msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:44Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2289-associated-type-bounds.md:1
msgid "Feature Name: `associated_type_bounds`"
msgstr ""

#: src/2289-associated-type-bounds.md:2
msgid "Start Date: 2018-01-13"
msgstr ""

#: src/2289-associated-type-bounds.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2289](https://github.com/rust-lang/rfcs/pull/2289)"
msgstr ""

#: src/2289-associated-type-bounds.md:4
msgid ""
"Rust Issue: [rust-lang/rust#52662](https://github.com/rust-lang/rust/"
"issues/52662)"
msgstr ""

#: src/2289-associated-type-bounds.md:6
msgid "Summary"
msgstr ""

#: src/2289-associated-type-bounds.md:9
msgid ""
"Introduce the bound form `MyTrait<AssociatedType: Bounds>`, permitted "
"anywhere a bound of the form `MyTrait<AssociatedType = T>` would be allowed. "
"The bound `T: Trait<AssociatedType: Bounds>` desugars to the bounds `T: "
"Trait` and `<T as Trait>::AssociatedType: Bounds`. See the [reference]"
"(#reference-level-explanation) and [rationale](#rationale-and-alternatives) "
"for exact details."
msgstr ""

#: src/2289-associated-type-bounds.md:16
msgid "Motivation"
msgstr ""

#: src/2289-associated-type-bounds.md:19
msgid ""
"Currently, when specifying a bound using a trait that has an associated "
"type, the developer can specify the precise type via the syntax "
"`MyTrait<AssociatedType = T>`. With the introduction of the `impl Trait` "
"syntax for static-dispatch existential types, this syntax also permits "
"`MyTrait<AssociatedType = impl Bounds>`, as a shorthand for introducing a "
"new type variable and specifying those bounds."
msgstr ""

#: src/2289-associated-type-bounds.md:26
msgid ""
"However, this introduces an unnecessary level of indirection that does not "
"match the developer's intuition and mental model as well as it could. In "
"particular, given the ability to write bounds on a type variable as `T: "
"Bounds`, it makes sense to permit writing bounds on an associated type "
"directly. This results in the simpler syntax `MyTrait<AssociatedType: "
"Bounds>`."
msgstr ""

#: src/2289-associated-type-bounds.md:32
msgid "Guide-level explanation"
msgstr ""

#: src/2289-associated-type-bounds.md:35
msgid ""
"Instead of specifying a concrete type for an associated type, we can specify "
"a bound on the associated type, to ensure that it implements specific "
"traits, as seen in the example below:"
msgstr ""

#: src/2289-associated-type-bounds.md:42
msgid "\"{}\""
msgstr ""

#: src/2289-associated-type-bounds.md:47
msgid "In anonymous existential types"
msgstr ""

#: src/2289-associated-type-bounds.md:51 src/2289-associated-type-bounds.md:65
#: src/2289-associated-type-bounds.md:76 src/2289-associated-type-bounds.md:84
msgid "// ..\n"
msgstr ""

#: src/2289-associated-type-bounds.md:55
msgid "Further examples"
msgstr ""

#: src/2289-associated-type-bounds.md:57
msgid "Instead of writing:"
msgstr ""

#: src/2289-associated-type-bounds.md:69
msgid "you may write:"
msgstr ""

#: src/2289-associated-type-bounds.md:80
msgid "or replace the `where` clause entirely:"
msgstr ""

#: src/2289-associated-type-bounds.md:88
msgid "Reference-level explanation"
msgstr ""

#: src/2289-associated-type-bounds.md:91
msgid ""
"The surface syntax `T: Trait<AssociatedType: Bounds>` should desugar to a "
"pair of bounds: `T: Trait` and `<T as Trait>::AssociatedType: Bounds`. Rust "
"currently allows both of those bounds anywhere a bound can currently appear; "
"the new syntax does not introduce any new semantics."
msgstr ""

#: src/2289-associated-type-bounds.md:96
msgid ""
"Additionally, the surface syntax `impl Trait<AssociatedType: Bounds>` turns "
"into a named type variable `T`, universal or existential depending on "
"context, with the usual bound `T: Trait` along with the added bound `<T as "
"Trait>::AssociatedType: Bounds`."
msgstr ""

#: src/2289-associated-type-bounds.md:101
msgid ""
"Meanwhile, the surface syntax `dyn Trait<AssociatedType: Bounds>` desugars "
"into `dyn Trait<AssociatedType = T>` where `T` is a named type variable `T` "
"with the bound `T: Bounds`."
msgstr ""

#: src/2289-associated-type-bounds.md:105
msgid "The desugaring for associated types"
msgstr ""

#: src/2289-associated-type-bounds.md:107
msgid "In the case of an associated type having a bound of the form:"
msgstr ""

#: src/2289-associated-type-bounds.md:115
msgid ""
"we desugar to an anonymous associated type for `AssocB`, which corresponds "
"to:"
msgstr ""

#: src/2289-associated-type-bounds.md:120
msgid "// Associated type is Unnamed!\n"
msgstr ""

#: src/2289-associated-type-bounds.md:124
msgid "Notes on the meaning of `impl Trait<Assoc: Bound>`"
msgstr ""

#: src/2289-associated-type-bounds.md:126
msgid ""
"Note that in the context `-> impl Trait<Assoc: Bound>`, since the Trait is "
"existentially quantified, the `Assoc` is as well. Semantically speaking, `fn "
"printables..` is equivalent to:"
msgstr ""

#: src/2289-associated-type-bounds.md:134
msgid ""
"For `arg: impl Trait<Assoc: Bound>`, it is semantically equivalent to: `arg: "
"impl Trait<Assoc = impl Bound>`."
msgstr ""

#: src/2289-associated-type-bounds.md:137
msgid "Meaning of `existential type Foo: Trait<Assoc: Bound>`"
msgstr ""

#: src/2289-associated-type-bounds.md:139
msgid "Given:"
msgstr ""

#: src/2289-associated-type-bounds.md:145
msgid "it can be seen as the same as:"
msgstr ""

#: src/2289-associated-type-bounds.md:154
msgid ""
"This syntax is specified in [RFC 2071](./2071-impl-trait-existential-types."
"md). As in that RFC, this documentation uses the non-final syntax for "
"existential type aliases."
msgstr ""

#: src/2289-associated-type-bounds.md:157
msgid "Drawbacks"
msgstr ""

#: src/2289-associated-type-bounds.md:160
msgid ""
"Rust code can already express this using the desugared form. This proposal "
"just introduces a simpler surface syntax that parallels other uses of "
"bounds. As always, when introducing new syntactic forms, an increased burden "
"is put on developers to know about and understand those forms, and this "
"proposal is no different. However, we believe that the parallel to the use "
"of bounds elsewhere makes this new syntax immediately recognizable and "
"understandable."
msgstr ""

#: src/2289-associated-type-bounds.md:167
msgid "Rationale and alternatives"
msgstr ""

#: src/2289-associated-type-bounds.md:170
msgid ""
"As with any new surface syntax, one alternative is simply not introducing "
"the syntax at all. That would still leave developers with the "
"`MyTrait<AssociatedType = impl Bounds>` form. However, allowing the more "
"direct bounds syntax provides a better parallel to the use of bounds "
"elsewhere. The introduced form in this RFC is comparatively both shorter and "
"clearer."
msgstr ""

#: src/2289-associated-type-bounds.md:176
msgid "An alternative desugaring of bounds on associated types"
msgstr ""

#: src/2289-associated-type-bounds.md:180
msgid "An alternative desugaring of the following definition:"
msgstr ""

#: src/2289-associated-type-bounds.md:188
msgid ""
"is to add the `where` clause, as specified above, to the trait, desugaring "
"to:"
msgstr ""

#: src/2289-associated-type-bounds.md:199
msgid ""
"However, at the time of this writing, a Rust compiler will treat this "
"differently than the desugaring proposed in the reference. The following "
"snippet illustrates the difference:"
msgstr ""

#: src/2289-associated-type-bounds.md:214
msgid ""
"// ^-- Remove this line and it will error with:\n"
"// error[E0277]: `<<X as Foo>::Bar as std::iter::Iterator>::Item` doesn't "
"implement `Copy`\n"
msgstr ""

#: src/2289-associated-type-bounds.md:226
msgid ""
"The desugaring with a `where` therefore becomes problematic from a "
"perspective of usability."
msgstr ""

#: src/2289-associated-type-bounds.md:229
msgid ""
"However, [RFC 2089, Implied Bounds](./2089-implied-bounds.md) specifies that "
"desugaring to the `where` clause in the trait will permit the `use_foo` "
"function to omit its `where` clause. This entails that both desugarings "
"become equivalent from the point of view of a user. The desugaring with "
"`where` therefore becomes viable in the presence of [RFC 2089](./2089-"
"implied-bounds.md)."
msgstr ""

#: src/2289-associated-type-bounds.md:235
msgid "Unresolved questions"
msgstr ""

#: src/2289-associated-type-bounds.md:238
msgid ""
"Does allowing this for `dyn` trait objects introduce any unforeseen issues? "
"This can be resolved during stabilization."
msgstr ""

#: src/2289-associated-type-bounds.md:241
msgid ""
"The exact desugaring in the context of putting bounds on an associated type "
"of a trait is left unresolved. The semantics should however be preserved. "
"This is also the case with other desugarings in this RFC."
msgstr ""
