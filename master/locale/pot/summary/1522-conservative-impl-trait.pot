msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:43Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1522-conservative-impl-trait.md:1
msgid "Feature Name: conservative_impl_trait"
msgstr ""

#: src/1522-conservative-impl-trait.md:2
msgid "Start Date: 2016-01-31"
msgstr ""

#: src/1522-conservative-impl-trait.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1522](https://github.com/rust-lang/rfcs/pull/1522)"
msgstr ""

#: src/1522-conservative-impl-trait.md:4
msgid ""
"Rust Issue: [rust-lang/rust#34511](https://github.com/rust-lang/rust/"
"issues/34511)"
msgstr ""

#: src/1522-conservative-impl-trait.md:6
msgid "Summary"
msgstr ""

#: src/1522-conservative-impl-trait.md:9
msgid ""
"Add a conservative form of abstract return types, also known as `impl "
"Trait`, that will be compatible with most possible future extensions by "
"initially being restricted to:"
msgstr ""

#: src/1522-conservative-impl-trait.md:13
msgid "Only free-standing or inherent functions."
msgstr ""

#: src/1522-conservative-impl-trait.md:14
msgid "Only return type position of a function."
msgstr ""

#: src/1522-conservative-impl-trait.md:16
msgid ""
"Abstract return types allow a function to hide a concrete return type behind "
"a trait interface similar to trait objects, while still generating the same "
"statically dispatched code as with concrete types."
msgstr ""

#: src/1522-conservative-impl-trait.md:20
msgid ""
"With the placeholder syntax used in discussions so far, abstract return "
"types would be used roughly like this:"
msgstr ""

#: src/1522-conservative-impl-trait.md:26
msgid ""
"// ^ behaves as if it had return type Map<Range<u32>, Closure>\n"
"// where Closure = type of the |x| x * 100 closure.\n"
msgstr ""

#: src/1522-conservative-impl-trait.md:31
msgid "// x = 0, 100, 200, ...\n"
msgstr ""

#: src/1522-conservative-impl-trait.md:35
msgid "Background"
msgstr ""

#: src/1522-conservative-impl-trait.md:37
msgid ""
"There has been much discussion around the `impl Trait` feature already, with "
"different proposals extending the core idea into different directions:"
msgstr ""

#: src/1522-conservative-impl-trait.md:40
msgid "The [original proposal](https://github.com/rust-lang/rfcs/pull/105)."
msgstr ""

#: src/1522-conservative-impl-trait.md:41
msgid ""
"A [blog post](http://aturon.github.io/blog/2015/09/28/impl-trait/) reviving "
"the proposal and further exploring the design space."
msgstr ""

#: src/1522-conservative-impl-trait.md:43
msgid ""
"A [more recent proposal](https://github.com/rust-lang/rfcs/pull/1305) with a "
"substantially more ambitious scope."
msgstr ""

#: src/1522-conservative-impl-trait.md:46
msgid ""
"This RFC is an attempt to make progress on the feature by proposing a "
"minimal subset that should be forwards-compatible with a whole range of "
"extensions that have been discussed (and will be reviewed in this RFC). "
"However, even this small step requires resolving some of the core questions "
"raised in [the blog post](http://aturon.github.io/blog/2015/09/28/impl-"
"trait/)."
msgstr ""

#: src/1522-conservative-impl-trait.md:52
msgid ""
"This RFC is closest in spirit to the [original RFC](https://github.com/rust-"
"lang/rfcs/pull/105), and we'll repeat its motivation and some other parts of "
"its text below."
msgstr ""

#: src/1522-conservative-impl-trait.md:56
msgid "Motivation"
msgstr ""

#: src/1522-conservative-impl-trait.md:59
msgid ""
"Why are we doing this? What use cases does it support? What is the expected "
"outcome?"
msgstr ""

#: src/1522-conservative-impl-trait.md:61
msgid "In today's Rust, you can write a function signature like"
msgstr ""

#: src/1522-conservative-impl-trait.md:68
msgid ""
"In both cases, the function does not depend on the exact type of the "
"argument. The type is held \"abstract\", and is assumed only to satisfy a "
"trait bound."
msgstr ""

#: src/1522-conservative-impl-trait.md:71
msgid ""
"In the `_static` version using generics, each use of the function is "
"specialized to a concrete, statically-known type, giving static dispatch, "
"inline layout, and other performance wins."
msgstr ""

#: src/1522-conservative-impl-trait.md:75
msgid ""
"In the `_dynamic` version using trait objects, the concrete argument type is "
"only known at runtime using a vtable."
msgstr ""

#: src/1522-conservative-impl-trait.md:78
msgid "On the other hand, while you can write"
msgstr ""

#: src/1522-conservative-impl-trait.md:84
msgid "you _cannot_ write something like"
msgstr ""

#: src/1522-conservative-impl-trait.md:90
msgid ""
"That is, in today's Rust, abstract return types can only be written using "
"trait objects, which can be a significant performance penalty. This RFC "
"proposes \"unboxed abstract types\" as a way of achieving signatures like "
"`produce_iter_static`. Like generics, unboxed abstract types guarantee "
"static dispatch and inline data layout."
msgstr ""

#: src/1522-conservative-impl-trait.md:96
msgid "Here are some problems that unboxed abstract types solve or mitigate:"
msgstr ""

#: src/1522-conservative-impl-trait.md:98
msgid ""
"_Returning unboxed closures_. Closure syntax generates an anonymous type "
"implementing a closure trait. Without unboxed abstract types, there is no "
"way to use this syntax while returning the resulting closure unboxed because "
"there is no way to write the name of the generated type."
msgstr ""

#: src/1522-conservative-impl-trait.md:103
msgid ""
"_Leaky APIs_. Functions can easily leak implementation details in their "
"return type, when the API should really only promise a trait bound. For "
"example, a function returning `Rev<Splits<'a, u8>>` is revealing exactly how "
"the iterator is constructed, when the function should only promise that it "
"returns _some_ type implementing `Iterator<Item = u8>`. Using newtypes/"
"structs with private fields helps, but is extra work. Unboxed abstract types "
"make it as easy to promise only a trait bound as it is to return a concrete "
"type."
msgstr ""

#: src/1522-conservative-impl-trait.md:111
msgid "_Complex types_. Use of iterators in particular can lead to huge types:"
msgstr ""

#: src/1522-conservative-impl-trait.md:117
msgid ""
"Even when using newtypes to hide the details, the type still has to be "
"written out, which can be very painful. Unboxed abstract types only require "
"writing the trait bound."
msgstr ""

#: src/1522-conservative-impl-trait.md:121
msgid ""
"_Documentation_. In today's Rust, reading the documentation for the "
"`Iterator` trait is needlessly difficult. Many of the methods return new "
"iterators, but currently each one returns a different type (`Chain`, `Zip`, "
"`Map`, `Filter`, etc), and it requires drilling down into each of these "
"types to determine what kind of iterator they produce."
msgstr ""

#: src/1522-conservative-impl-trait.md:127
msgid ""
"In short, unboxed abstract types make it easy for a function signature to "
"promise nothing more than a trait bound, and do not generally require the "
"function's author to write down the concrete type implementing the bound."
msgstr ""

#: src/1522-conservative-impl-trait.md:131
msgid "Detailed design"
msgstr ""

#: src/1522-conservative-impl-trait.md:134
msgid ""
"As explained at the start of the RFC, the focus here is a relatively narrow "
"introduction of abstract types limited to the return type of inherent "
"methods and free functions. While we still need to resolve some of the core "
"questions about what an \"abstract type\" means even in these cases, we "
"avoid some of the complexities that come along with allowing the feature in "
"other locations or with other extensions."
msgstr ""

#: src/1522-conservative-impl-trait.md:141
msgid "Syntax"
msgstr ""

#: src/1522-conservative-impl-trait.md:143
msgid ""
"Let's start with the bikeshed: The proposed syntax is `impl Trait` in return "
"type position, composing like trait objects to forms like `impl Foo + Send + "
"'a`."
msgstr ""

#: src/1522-conservative-impl-trait.md:146
msgid ""
"It can be explained as \"a type that implements `Trait`\", and has been used "
"in that form in most earlier discussions and proposals."
msgstr ""

#: src/1522-conservative-impl-trait.md:149
msgid ""
"Initial versions of this RFC proposed `@Trait` for brevity reasons, since "
"the feature is supposed to be used commonly once implemented, but due to "
"strong negative reactions by the community this has been changed back to the "
"current form."
msgstr ""

#: src/1522-conservative-impl-trait.md:154
msgid ""
"There are other possibilities, like `abstract Trait` or `~Trait`, with good "
"reasons for or against them, but since the concrete choice of syntax is not "
"a blocker for the implementation of this RFC, it is intended for a possible "
"follow-up RFC to address syntax changes if needed."
msgstr ""

#: src/1522-conservative-impl-trait.md:159
msgid "Semantics"
msgstr ""

#: src/1522-conservative-impl-trait.md:161
msgid "The core semantics of the feature is described below."
msgstr ""

#: src/1522-conservative-impl-trait.md:163
msgid ""
"Note that the sections after this one go into more detail on some of the "
"design decisions, and that **it is likely for many of the mentioned "
"limitations to be lifted at some point in the future**. For clarity, we'll "
"separately categorize the _core semantics_ of the feature (aspects that "
"would stay unchanged with future extensions) and the _initial limitations_ "
"(which are likely to be lifted later)."
msgstr ""

#: src/1522-conservative-impl-trait.md:169
msgid "**Core semantics**:"
msgstr ""

#: src/1522-conservative-impl-trait.md:171
msgid ""
"If a function returns `impl Trait`, its body can return values of any type "
"that implements `Trait`, but all return values need to be of the same type."
msgstr ""

#: src/1522-conservative-impl-trait.md:174
msgid ""
"As far as the typesystem and the compiler is concerned, the return type "
"outside of the function would not be a entirely \"new\" type, nor would it "
"be a simple type alias. Rather, its semantics would be very similar to that "
"of _generic type parameters_ inside a function, with small differences "
"caused by being an _output_ rather than an _input_ of the function."
msgstr ""

#: src/1522-conservative-impl-trait.md:180
msgid "The type would be known to implement the specified traits."
msgstr ""

#: src/1522-conservative-impl-trait.md:181
msgid ""
"The type would not be known to implement any other trait, with the exception "
"of OIBITS (aka \"auto traits\") and default traits like `Sized`."
msgstr ""

#: src/1522-conservative-impl-trait.md:183
msgid "The type would not be considered equal to the actual underlying type."
msgstr ""

#: src/1522-conservative-impl-trait.md:184
msgid ""
"The type would not be allowed to appear as the `Self` type for an `impl` "
"block."
msgstr ""

#: src/1522-conservative-impl-trait.md:186
msgid ""
"Because OIBITS like `Send` and `Sync` will leak through an abstract return "
"type, there will be some additional complexity in the compiler due to some "
"non-local type checking becoming necessary."
msgstr ""

#: src/1522-conservative-impl-trait.md:190
msgid ""
"The return type has an identity based on all generic parameters the function "
"body is parameterized by, and by the location of the function in the module "
"system. This means type equality behaves like this:"
msgstr ""

#: src/1522-conservative-impl-trait.md:205
#: src/1522-conservative-impl-trait.md:206
msgid "// OK\n"
msgstr ""

#: src/1522-conservative-impl-trait.md:207
msgid ""
"// ERROR, `impl Trait {bar}` is not the same type as `impl Trait {foo<i32>}"
"`\n"
msgstr ""

#: src/1522-conservative-impl-trait.md:208
msgid ""
"// ERROR, `impl Trait {foo<bool>}` is not the same type as `impl Trait "
"{foo<i32>}`\n"
msgstr ""

#: src/1522-conservative-impl-trait.md:211
msgid ""
"The code generation passes of the compiler would not draw a distinction "
"between the abstract return type and the underlying type, just like they "
"don't for generic parameters. This means:"
msgstr ""

#: src/1522-conservative-impl-trait.md:214
msgid ""
"The same trait code would be instantiated, for example, `-> impl Any` would "
"return the type id of the underlying type."
msgstr ""

#: src/1522-conservative-impl-trait.md:216
msgid "Specialization would specialize based on the underlying type."
msgstr ""

#: src/1522-conservative-impl-trait.md:218
msgid "**Initial limitations**:"
msgstr ""

#: src/1522-conservative-impl-trait.md:220
msgid ""
"`impl Trait` may only be written within the return type of a freestanding or "
"inherent-impl function, not in trait definitions or any non-return type "
"position. They may also not appear in the return type of closure traits or "
"function pointers, unless these are themselves part of a legal return type."
msgstr ""

#: src/1522-conservative-impl-trait.md:225
msgid ""
"Eventually, we will want to allow the feature to be used within traits, and "
"likely in argument position as well (as an ergonomic improvement over "
"today's generics)."
msgstr ""

#: src/1522-conservative-impl-trait.md:227
msgid ""
"Using `impl Trait` multiple times in the same return type would be valid, "
"like for example in `-> (impl Foo, impl Bar)`."
msgstr ""

#: src/1522-conservative-impl-trait.md:230
msgid ""
"The type produced when a function returns `impl Trait` would be effectively "
"unnameable, just like closures and function items."
msgstr ""

#: src/1522-conservative-impl-trait.md:233
msgid ""
"We will almost certainly want to lift this limitation in the long run, so "
"that abstract return types can be placed into structs and so on. There are a "
"few ways we could do so, all related to getting at the \"output type\" of a "
"function given all of its generic arguments."
msgstr ""

#: src/1522-conservative-impl-trait.md:238
msgid ""
"The function body cannot see through its own return type, so code like this "
"would be forbidden just like on the outside:"
msgstr ""

#: src/1522-conservative-impl-trait.md:251
msgid ""
"It's unclear whether we'll want to lift this limitation, but it should be "
"possible to do so."
msgstr ""

#: src/1522-conservative-impl-trait.md:253
msgid "Rationale"
msgstr ""

#: src/1522-conservative-impl-trait.md:255
msgid "Why these semantics for the return type?"
msgstr ""

#: src/1522-conservative-impl-trait.md:257
msgid ""
"There has been a lot of discussion about what the semantics of the return "
"type should be, with the theoretical extremes being \"full return type "
"inference\" and \"fully abstract type that behaves like a autogenerated "
"newtype wrapper\". (This was in fact the main focus of the [blog post]"
"(http://aturon.github.io/blog/2015/09/28/impl-trait/) on `impl Trait`.)"
msgstr ""

#: src/1522-conservative-impl-trait.md:264
msgid ""
"The design as chosen in this RFC lies somewhat in between those two, since "
"it allows OIBITs to leak through, and allows specialization to \"see\" the "
"full type being returned. That is, `impl Trait` does not attempt to be a "
"\"tightly sealed\" abstraction boundary. The rationale for this design is a "
"mixture of pragmatics and principles."
msgstr ""

#: src/1522-conservative-impl-trait.md:270
msgid "Specialization transparency"
msgstr ""

#: src/1522-conservative-impl-trait.md:272
msgid "**Principles for specialization transparency**:"
msgstr ""

#: src/1522-conservative-impl-trait.md:274
msgid ""
"The [specialization RFC](https://github.com/rust-lang/rfcs/pull/1210) has "
"given us a basic principle for how to understand bounds in function "
"generics: they represent a _minimum_ contract between the caller and the "
"callee, in that the caller must meet at least those bounds, and the callee "
"must be prepared to work with any type that meets at least those bounds. "
"However, with specialization, the callee may choose different behavior when "
"additional bounds hold."
msgstr ""

#: src/1522-conservative-impl-trait.md:281
msgid ""
"This RFC abides by a similar interpretation for return types: the signature "
"represents the minimum bound that the callee must satisfy, and the caller "
"must be prepared to work with any type that meets at least that bound. "
"Again, with specialization, the caller may dispatch on additional type "
"information beyond those bounds."
msgstr ""

#: src/1522-conservative-impl-trait.md:287
msgid ""
"In other words, to the extent that returning `impl Trait` is intended to be "
"symmetric with taking a generic `T: Trait`, transparency with respect to "
"specialization maintains that symmetry."
msgstr ""

#: src/1522-conservative-impl-trait.md:291
msgid "**Pragmatics for specialization transparency**:"
msgstr ""

#: src/1522-conservative-impl-trait.md:293
msgid ""
"The practical reason we want `impl Trait` to be transparent to "
"specialization is the same as the reason we want specialization in the first "
"place: to be able to break through abstractions with more efficient special-"
"case code."
msgstr ""

#: src/1522-conservative-impl-trait.md:297
msgid ""
"This is particularly important for one of the primary intended usecases: "
"returning `impl Iterator`. We are very likely to employ specialization for "
"various iterator types, and making the underlying return type invisible to "
"specialization would lose out on those efficiency wins."
msgstr ""

#: src/1522-conservative-impl-trait.md:302
msgid "OIBIT transparency"
msgstr ""

#: src/1522-conservative-impl-trait.md:304
msgid ""
"OIBITs leak through an abstract return type. This might be considered "
"controversial, since it effectively opens a channel where the result of "
"function-local type inference affects item-level API, but has been deemed "
"worth it for the following reasons:"
msgstr ""

#: src/1522-conservative-impl-trait.md:308
msgid ""
"Ergonomics: Trait objects already have the issue of explicitly needing to "
"declare `Send`/`Sync`\\-ability, and not extending this problem to abstract "
"return types is desirable. In practice, most uses of this feature would have "
"to add explicit bounds for OIBITS if they wanted to be maximally usable."
msgstr ""

#: src/1522-conservative-impl-trait.md:313
msgid ""
"Low real change, since the situation already somewhat exists on structs with "
"private fields:"
msgstr ""

#: src/1522-conservative-impl-trait.md:314
msgid ""
"In both cases, a change to the private implementation might change whether a "
"OIBIT is implemented or not."
msgstr ""

#: src/1522-conservative-impl-trait.md:316
msgid ""
"In both cases, the existence of OIBIT impls is not visible without "
"documentation tools"
msgstr ""

#: src/1522-conservative-impl-trait.md:317
msgid ""
"In both cases, you can only assert the existence of OIBIT impls by adding "
"explicit trait bounds either to the API or to the crate's test suite."
msgstr ""

#: src/1522-conservative-impl-trait.md:320
msgid ""
"In fact, a large part of the point of OIBITs in the first place was to cut "
"across abstraction barriers and provide information about a type without the "
"type's author having to explicitly opt in."
msgstr ""

#: src/1522-conservative-impl-trait.md:324
msgid ""
"This means, however, that it has to be considered a silent breaking change "
"to change a function with an abstract return type in a way that removes "
"OIBIT impls, which might be a problem. (As noted above, this is already the "
"case for `struct` definitions.)"
msgstr ""

#: src/1522-conservative-impl-trait.md:329
msgid ""
"But since the number of used OIBITs is relatively small, deducing the return "
"type in a function body and reasoning about whether such a breakage will "
"occur has been deemed as a manageable amount of work."
msgstr ""

#: src/1522-conservative-impl-trait.md:333
msgid "Wherefore type abstraction?"
msgstr ""

#: src/1522-conservative-impl-trait.md:335
msgid ""
"In the [most recent RFC](https://github.com/rust-lang/rfcs/pull/1305) "
"related to this feature, a more \"tightly sealed\" abstraction mechanism was "
"proposed. However, part of the discussion on specialization centered on "
"precisely the issue of what type abstraction provides and how to achieve "
"it.  A particular salient point there is that, in Rust, _privacy_ is already "
"our primary mechanism for hiding ([\"privacy is the new parametricity\"]"
"(https://github.com/rust-lang/rfcs/pull/1210#issuecomment-181992044)). In "
"practice, that means that if you want opacity against specialization, you "
"should use something like a newtype."
msgstr ""

#: src/1522-conservative-impl-trait.md:345
msgid "Anonymity"
msgstr ""

#: src/1522-conservative-impl-trait.md:347
msgid ""
"An abstract return type cannot be named in this proposal, which means that "
"it cannot be placed into `structs` and so on. This is not a fundamental "
"limitation in any sense; the limitation is there both to keep this RFC "
"simple, and because the precise way we might want to allow naming of such "
"types is still a bit unclear. Some possibilities include a `typeof` "
"operator, or explicit named abstract types."
msgstr ""

#: src/1522-conservative-impl-trait.md:354
msgid "Limitation to only return type position"
msgstr ""

#: src/1522-conservative-impl-trait.md:356
msgid ""
"There have been various proposed additional places where abstract types "
"might be usable. For example, `fn x(y: impl Trait)` as shorthand for `fn "
"x<T: Trait>(y: T)`."
msgstr ""

#: src/1522-conservative-impl-trait.md:360
msgid ""
"Since the exact semantics and user experience for these locations are yet "
"unclear (`impl Trait` would effectively behave completely different before "
"and after the `->`), this has also been excluded from this proposal."
msgstr ""

#: src/1522-conservative-impl-trait.md:364
msgid "Type transparency in recursive functions"
msgstr ""

#: src/1522-conservative-impl-trait.md:366
msgid ""
"Functions with abstract return types can not see through their own return "
"type, making code like this not compile:"
msgstr ""

#: src/1522-conservative-impl-trait.md:379
msgid ""
"This limitation exists because it is not clear how much a function body can "
"and should know about different instantiations of itself."
msgstr ""

#: src/1522-conservative-impl-trait.md:382
msgid ""
"It would be safe to allow recursive calls if the set of generic parameters "
"is identical, and it might even be safe if the generic parameters are "
"different, since you would still be inside the private body of the function, "
"just differently instantiated."
msgstr ""

#: src/1522-conservative-impl-trait.md:387
msgid ""
"But variance caused by lifetime parameters and the interaction with "
"specialization makes it uncertain whether this would be sound."
msgstr ""

#: src/1522-conservative-impl-trait.md:390
msgid ""
"In any case, it can be initially worked around by defining a local helper "
"function like this:"
msgstr ""

#: src/1522-conservative-impl-trait.md:405
msgid "Not legal in function pointers/closure traits"
msgstr ""

#: src/1522-conservative-impl-trait.md:407
msgid ""
"Because `impl Trait` defines a type tied to the concrete function body, it "
"does not make much sense to talk about it separately in a function "
"signature, so the syntax is forbidden there."
msgstr ""

#: src/1522-conservative-impl-trait.md:411
msgid "Compatibility with conditional trait bounds"
msgstr ""

#: src/1522-conservative-impl-trait.md:413
msgid ""
"One valid critique for the existing `impl Trait` proposal is that it does "
"not cover more complex scenarios where the return type would implement one "
"or more traits depending on whether a type parameter does so with another."
msgstr ""

#: src/1522-conservative-impl-trait.md:417
msgid ""
"For example, an iterator adapter might want to implement `Iterator` and "
"`DoubleEndedIterator`, depending on whether the adapted one does:"
msgstr ""

#: src/1522-conservative-impl-trait.md:427
msgid "Using just `-> impl Iterator`, this would not be possible to reproduce."
msgstr ""

#: src/1522-conservative-impl-trait.md:429
msgid ""
"Since there have been no proposals so far that would address this in a way "
"that would conflict with the fixed-trait-set case, this RFC punts on that "
"issue as well."
msgstr ""

#: src/1522-conservative-impl-trait.md:432
msgid "Limitation to free/inherent functions"
msgstr ""

#: src/1522-conservative-impl-trait.md:434
msgid ""
"One important usecase of abstract return types is to use them in trait "
"methods."
msgstr ""

#: src/1522-conservative-impl-trait.md:436
msgid ""
"However, there is an issue with this, namely that in combinations with "
"generic trait methods, they are effectively equivalent to higher kinded "
"types. Which is an issue because Rust's HKT story is not yet figured out, so "
"any \"accidental implementation\" might cause unintended fallout."
msgstr ""

#: src/1522-conservative-impl-trait.md:441
msgid ""
"HKT allows you to be generic over a type constructor, a.k.a. a \"thing with "
"type parameters\", and then instantiate them at some later point to get the "
"actual type. For example, given a HK type `T` that takes one type as "
"parameter, you could write code that uses `T<u32>` or `T<bool>` without "
"caring about whether `T = Vec`, `T = Box`, etc."
msgstr ""

#: src/1522-conservative-impl-trait.md:448
msgid "Now if we look at abstract return types, we have a similar situation:"
msgstr ""

#: src/1522-conservative-impl-trait.md:456
msgid ""
"Given a `T: Foo`, we could instantiate `T::bar::<u32>` or `T::bar::<bool>`, "
"and could get arbitrary different return types of `bar` instantiated with a "
"`u32` or `bool`, just like `T<u32>` and `T<bool>` might give us `Vec<u32>` "
"or `Box<bool>` in the example above."
msgstr ""

#: src/1522-conservative-impl-trait.md:462
msgid ""
"The problem does not exist with trait method return types today because they "
"are concrete:"
msgstr ""

#: src/1522-conservative-impl-trait.md:471
msgid ""
"Given the above code, there is no way for `bar` to choose a return type `X` "
"that could fundamentally differ between instantiations of `Self` while still "
"being instantiable with an arbitrary `U`."
msgstr ""

#: src/1522-conservative-impl-trait.md:475
msgid ""
"At most you could return a associated type, but then you'd lose the generics "
"from `bar`"
msgstr ""

#: src/1522-conservative-impl-trait.md:481
msgid "// No way to apply U\n"
msgstr ""

#: src/1522-conservative-impl-trait.md:485
msgid ""
"So, in conclusion, since Rust's HKT story is not yet fleshed out, and the "
"compatibility of the current compiler with it is unknown, it is not yet "
"possible to reach a concrete solution here."
msgstr ""

#: src/1522-conservative-impl-trait.md:489
msgid ""
"In addition to that, there are also different proposals as to whether an "
"abstract return type is its own thing or sugar for a associated type, how it "
"interacts with other associated items and so on, so forbidding them in "
"traits seems like the best initial course of action."
msgstr ""

#: src/1522-conservative-impl-trait.md:494
msgid "Drawbacks"
msgstr ""

#: src/1522-conservative-impl-trait.md:497
msgid "Why should we _not_ do this?"
msgstr ""

#: src/1522-conservative-impl-trait.md:499
msgid "Drawbacks due to the proposal's minimalism"
msgstr ""

#: src/1522-conservative-impl-trait.md:501
msgid ""
"As has been elaborated on above, there are various way this feature could be "
"extended and combined with the language, so implementing it might cause "
"issues down the road if limitations or incompatibilities become apparent. "
"However, variations of this RFC's proposal have been under discussion for "
"quite a long time at this point, and this proposal is carefully designed to "
"be future-compatible with them, while resolving the core issue around "
"transparency."
msgstr ""

#: src/1522-conservative-impl-trait.md:508
msgid ""
"A drawback of limiting the feature to return type position (and not "
"arguments) is that it creates a somewhat inconsistent mental model: it "
"forces you to understand the feature in a highly special-cased way, rather "
"than as a general way to talk about unknown-but-bounded types in function "
"signatures. This could be particularly bewildering to newcomers, who must "
"choose between `T: Trait`, `Box<Trait>`, and `impl Trait`, with the latter "
"only usable in one place."
msgstr ""

#: src/1522-conservative-impl-trait.md:515
msgid "Drawbacks due to partial transparency"
msgstr ""

#: src/1522-conservative-impl-trait.md:517
msgid ""
"The fact that specialization and OIBITs can \"see through\" `impl Trait` may "
"be surprising, to the extent that one wants to see `impl Trait` as an "
"abstraction mechanism. However, as the RFC argued in the rationale section, "
"this design is probably the most consistent with our existing post-"
"specialization abstraction mechanisms, and lead to the relatively simple "
"story that _privacy_ is the way to achieve hiding in Rust."
msgstr ""

#: src/1522-conservative-impl-trait.md:524
msgid "Alternatives"
msgstr ""

#: src/1522-conservative-impl-trait.md:527
msgid ""
"What other designs have been considered? What is the impact of not doing "
"this?"
msgstr ""

#: src/1522-conservative-impl-trait.md:529
msgid ""
"See the links in the motivation section for detailed analysis that we won't "
"repeat here."
msgstr ""

#: src/1522-conservative-impl-trait.md:532
msgid ""
"But basically, without this feature certain things remain hard or impossible "
"to do in Rust, like returning a efficiently usable type parameterized by "
"types private to a function body, for example an iterator adapter containing "
"a closure."
msgstr ""

#: src/1522-conservative-impl-trait.md:536
msgid "Unresolved questions"
msgstr ""

#: src/1522-conservative-impl-trait.md:539
msgid "What parts of the design are still to be determined?"
msgstr ""

#: src/1522-conservative-impl-trait.md:541
msgid ""
"The precise implementation details for OIBIT transparency are a bit unclear: "
"in general, it means that type checking may need to proceed in a particular "
"order, since you cannot get the full type information from the signature "
"alone (you have to typecheck the function body to determine which OIBITs "
"apply)."
msgstr ""
