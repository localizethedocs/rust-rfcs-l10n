msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:44Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2451-re-rebalancing-coherence.md:1
msgid "Feature Name: `re_rebalancing_coherence`"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:2
msgid "Start Date: 2018-05-30"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2451](https://github.com/rust-lang/rfcs/pull/2451)"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:4
msgid ""
"Rust Issue: [rust-lang/rust#55437](https://github.com/rust-lang/rust/"
"issues/55437)"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:6
msgid "Summary"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:9
msgid ""
"This RFC seeks to clarify some ambiguity from [RFC #1023](https://github.com/"
"rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md), and expands "
"it to allow type parameters to appear in the type for which the trait is "
"being implemented, regardless of whether a local type appears before them. "
"More concretely, it allows `impl<T> ForeignTrait<LocalType> for "
"ForeignType<T>` to be written."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:15
msgid "Motivation"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:18
msgid ""
"For better or worse, we allow implementing foreign traits for foreign types. "
"For example, `impl From<Foo> for Vec<i32>` is something any crate can write, "
"even though `From` is a foreign trait, and `Vec` is a foreign type. However, "
"under the current coherence rules, we do not allow `impl<T> From<Foo> for "
"Vec<T>`."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:23
msgid ""
"There's no good reason for this restriction. Fundamentally, allowing `for "
"Vec<ForeignType>` requires all the same restrictions as allowing `Vec<T>`. "
"Disallowing type parameters to appear in the target type restricts how "
"crates can be extended."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:28
msgid ""
"Consider an example from Diesel. Diesel constructs an AST which represents a "
"SQL query, and then provides a trait to construct the final SQL. Because "
"different databases have different syntax, this trait is generic over the "
"backend being used. Diesel wants to support third party crates which add new "
"AST nodes, as well as crates which add support for new backends. The current "
"rules make it impossible to support both."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:35
msgid ""
"The Oracle database requires special syntax for inserting multiple records "
"in a single query. However, the impl required for this is invalid today. "
"`impl<'a, T, U> QueryFragment<Oracle> for BatchInsert<'a, T, U>`. There is "
"no reason for this impl to be rejected. The only impl that Diesel could add "
"which would conflict with it would look like `impl<'a, T> QueryFragment<T> "
"for BatchInsert<'a, Type1, Type2>`. Adding such an impl is already "
"considered a major breaking change by [RFC #1023](https://github.com/rust-"
"lang/rfcs/blob/master/text/1023-rebalancing-coherence.md), which we'll "
"expand on below."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:43
msgid ""
"For some traits, this can be worked around by flipping the self type with "
"the type parameter to the trait. Diesel has done that in the past (e.g. `T: "
"NativeSqlType<DB>` became `DB: HasSqlType<T>`). However, that wouldn't work "
"for this case. A crate which adds a new AST node would no longer be able to "
"implement the required trait for all backends. For example, a crate which "
"added the `LOWER` function from SQL (which is supported by all databases) "
"would not be able to write `impl<T, DB> QueryFragment<Lower<T>> for DB`."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:51
msgid ""
"Unless we expand the orphan rules, use cases like this one will never be "
"possible, and a crate like Diesel will never be able to be designed in a "
"completely extensible fashion."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:55
msgid "Guide-level explanation"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:58
msgid "Definitions"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:60
msgid ""
"Local Trait: A trait which was defined in the current crate. Whether a trait "
"is local or not has nothing to do with type parameters. Given `trait Foo<T, "
"U>`, `Foo` is always local, regardless of the types used for `T` or `U`."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:64
msgid ""
"Local Type: A struct, enum, or union which was defined in the current crate. "
"This is not affected by type parameters. `struct Foo` is considered local, "
"but `Vec<Foo>` is not. `LocalType<ForeignType>` is local. Type aliases and "
"trait aliases do not affect locality."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:69
msgid ""
"Covered Type: A type which appears as a parameter to another type. For "
"example, `T` is uncovered, but the `T` in `Vec<T>` is covered. This is only "
"relevant for type parameters."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:73
msgid ""
"Blanket Impl: Any implementation where a type appears uncovered. `impl<T> "
"Foo for T`, `impl<T> Bar<T> for T`, `impl<T> Bar<Vec<T>> for T`, and "
"`impl<T> Bar<T> for Vec<T>` are considered blanket impls. However, `impl<T> "
"Bar<Vec<T>> for Vec<T>` is not a blanket impl, as all instances of `T` which "
"appear in this impl are covered by `Vec`."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:79
msgid ""
"Fundamental Type: A type for which you cannot add a blanket impl backwards "
"compatibly. This includes `&`, `&mut`, and `Box`. Any time a type `T` is "
"considered local, `&T`, `&mut T`, and `Box<T>` are also considered local. "
"Fundamental types cannot cover other types. Any time the term \"covered "
"type\" is used, `&T`, `&mut T`, and `Box<T>` are not considered covered."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:85
msgid "What is coherence and why do we care?"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:87
msgid ""
"Let's start with a quick refresher on coherence and the orphan rules. "
"Coherence means that for any given trait and type, there is one specific "
"implementation that applies. This is important for Rust to be easy to reason "
"about. When you write `<Foo as Bar>::trait_method`, the compiler needs to "
"know what actual implementation to use."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:93
msgid ""
"In languages without coherence, the compiler has to have some way to choose "
"which implementation to use when multiple implementations could apply. Scala "
"does this by having complex scope resolution rules for \"implicit\" "
"parameters. Haskell (when a discouraged flag is enabled) does this by "
"picking an impl arbitrarily."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:99
msgid ""
"Rust's solution is to enforce that there is only one impl to choose from at "
"all. While the rules required to enforce this are quite complex, the result "
"is easy to reason about, and is generally considered to be quite important "
"for Rust. New features like specialization allow more than one impl to "
"apply, but for any given type and trait, there will always be exactly one "
"which is most specific, and deterministically be chosen."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:106
msgid ""
"An important piece of enforcing coherence is restricting \"orphan impls\". "
"An impl is orphaned if it is implementing a trait you don't own for a type "
"you don't own. Rust's rules around this balance two separate, but related "
"goals:"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:110
msgid ""
"Ensuring that two crates can't write impls that would overlap (e.g. no crate "
"other than `std` can write `impl From<usize> for Vec<i32>`. If they could, "
"your program might stop compiling just by using two crates with an "
"overlapping impl)."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:114
msgid ""
"Restricting the impls that can be written so crates can add implementations "
"for traits/types they do own without worrying about breaking downstream "
"crates."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:118
msgid "Teaching users"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:120
msgid ""
"This change isn't something that would end up in a guide, and is mostly "
"communicated through error messages. The most common one seen is [E0210]"
"(https://doc.rust-lang.org/error-index.html#E0210). The text of that error "
"will be changed to approximate the following:"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:126
msgid ""
"Generally speaking, Rust only permits implementing a trait for a type if "
"either the trait or type were defined in your program. However, Rust allows "
"a limited number of impls that break this rule, if they follow certain "
"rules. This error indicates a violation of one of those rules."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:131
msgid ""
"A trait is considered local when {definition given above}. A type is "
"considered local when {definition given above}."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:134
msgid ""
"When implementing a foreign trait for a foreign type, the trait must have "
"one or more type parameters. A type local to your crate must appear before "
"any use of any type parameters. This means that `impl<T> "
"ForeignTrait<LocalType<T>, T> for ForeignType` is valid, but `impl<T> "
"ForeignTrait<T, LocalType<T>> for ForeignType` is not."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:140
msgid ""
"The reason that Rust considers order at all is to ensure that your "
"implementation does not conflict with one from another crate. Without this "
"rule, you could write `impl<T> ForeignTrait<T, LocalType> for ForeignType`, "
"and another crate could write `impl<T> ForeignTrait<TheirType, T> for "
"ForeignType`, which would overlap. For that reason, we require that your "
"local type come before the type parameter, since the only alternative would "
"be disallowing these implementations at all."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:148
msgid ""
"Additionally, the case of `impl<T> ForeignTrait<LocalType> for T` should be "
"special cased, and given its own error message, which approximates the "
"following:"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:152
msgid ""
"This error indicates an attempt to implement a trait from another crate for "
"a type parameter."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:155
msgid ""
"Rust requires that for any given trait and any given type, there is at most "
"one implementation of that trait. An important piece of this is that we "
"disallow implementing a trait from another crate for a type parameter."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:159
msgid ""
"Rust's orphan rule always permits an impl if either the trait or the type "
"being implemented are local to the current crate. Therefore, we can't allow "
"`impl<T> ForeignTrait<LocalTypeCrateA> for T`, because it might conflict "
"with another crate writing `impl<T> ForeignTrait<T> for LocalTypeCrateB`, "
"which we will always permit."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:165
msgid ""
"Finally, [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/text/1105-"
"api-evolution.md) states that implementing any non-fundamental trait for an "
"existing type is not a breaking change. This directly condradicts [RFC #1023]"
"(https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-"
"coherence.md), which is entirely based around \"blanket impls\" being "
"breaking changes. Regardless of whether the changes proposed to the orphan "
"rules in this proposal are accepted, a blanket impl being a breaking change "
"_must_ be true today. Given that the compiler currently accepts `impl "
"From<Foo> for Vec<Foo>`, adding `impl<T> From<T> for Vec<T>` must be "
"considered a major breaking change."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:173
msgid ""
"As such, [RFC #1105](https://github.com/rust-lang/rfcs/blob/master/text/1105-"
"api-evolution.md) is amended to remove the statement that implementing a non-"
"fundamental trait is a minor breaking change, and states that adding any "
"blanket impl for an existing trait is a major breaking change, using the "
"definition of blanket impl given above."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:178
msgid "Reference-level explanation"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:181
msgid "Concrete orphan rules"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:183
msgid "Assumes the same definitions [as above](#definitions)."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:185
msgid ""
"Given `impl<P1..=Pn> Trait<T1..=Tn> for T0`, an impl is valid only if at "
"least one of the following is true:"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:188
msgid "`Trait` is a local trait"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:189
msgid "All of"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:190
msgid ""
"At least one of the types `T0..=Tn` must be a local type. Let `Ti` be the "
"first such type."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:192
msgid ""
"No uncovered type parameters `P1..=Pn` may appear in `T0..Ti` (excluding "
"`Ti`)"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:195
msgid ""
"The primary change from the rules defined in [RFC #1023](https://github.com/"
"rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md) is that we "
"only restrict the appearance of _uncovered_ type parameters. Once again, it "
"is important to note that for the purposes of coherence, `#[fundamental]` "
"types are special. `Box<T>` is not considered covered, and `Box<LocalType>` "
"is considered local."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:201
msgid ""
"Under this proposal, the orphan rules continue to work generally as they did "
"before, with one notable exception; We will permit `impl<T> "
"ForeignTrait<LocalType> for ForeignType<T>`. This is completely valid under "
"the forward compatibility rules set in [RFC #1023](https://github.com/rust-"
"lang/rfcs/blob/master/text/1023-rebalancing-coherence.md). We can "
"demonstrate that this is the case with the following:"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:207
#: src/2451-re-rebalancing-coherence.md:219
msgid ""
"Any valid impl of `ForeignTrait` in a child crate must reference at least "
"one type that is local to the child crate."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:209
msgid ""
"The only way a parent crate can reference the type of a child crate is with "
"a type parameter."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:211
msgid ""
"For the impl in child crate to overlap with an impl in parent crate, the "
"type parameter must be uncovered."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:213
msgid ""
"Adding any impl with an uncovered type parameter is considered a major "
"breaking change."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:216
msgid ""
"We can also demonstrate that it is impossible for two sibling crates to "
"write conflicting impls, with or without this proposal."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:221
msgid ""
"The only way a local type of sibling crate A could overlap with a type used "
"in an impl from sibling crate B is if sibling crate B used a type parameter"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:223
msgid ""
"Any type parameter used by sibling crate B must be preceded by a local type"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:224
msgid ""
"Sibling crate A could not possibly name a type from sibling crate B, thus "
"that parameter can never overlap."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:227
msgid "Effects on parent crates"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:229
msgid ""
"[RFC #1023](https://github.com/rust-lang/rfcs/blob/master/text/1023-"
"rebalancing-coherence.md) is amended to state that adding a new impl to an "
"existing trait is considered a breaking change unless, given `impl<P1..=Pn> "
"Trait<T1..=Tn> for T0`:"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:233
msgid ""
"At least one of the types `T0..=Tn` must be a local type, added in this "
"revision. Let `Ti` be the first such type."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:235
msgid ""
"No uncovered type parameters `P1..=Pn` appear in `T0..Ti` (excluding `Ti`)"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:237
msgid ""
"The more general way to put this rule is: \"Adding an impl to an existing "
"trait is a breaking change if it could possibly conflict with a legal impl "
"in a downstream crate\"."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:241
msgid ""
"This clarification is true regardless of whether the changes in this "
"proposal are accepted or not. Given that the compiler currently accepts "
"`impl From<Foo> for Vec<Foo>`, adding the impl `impl<T> From<T> for Vec<T>` "
"_must_ be considered a major breaking change."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:246
msgid ""
"To be specific, the following adding any of the following impls would be "
"considered a breaking change:"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:249
msgid "`impl<T> OldTrait<T> for OldType`"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:250
msgid "`impl<T> OldTrait<AnyType> for T`"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:251
msgid "`impl<T> OldTrait<T> for ForeignType`"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:253
msgid "However, the following impls would not be considered a breaking change:"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:255
msgid "`impl NewTrait<AnyType> for AnyType`"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:256
msgid "`impl<T> OldTrait<T> for NewType`"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:257
msgid "`impl<T> OldTrait<NewType, T> for OldType`"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:259
msgid "Drawbacks"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:262
msgid ""
"The current rules around coherence are complex and hard to explain. While "
"this proposal feels like a natural extension of the current rules, and "
"something many expect to work, it does make them slightly more complex."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:266
msgid ""
"The orphan rules are often taught as \"for an impl `impl Trait for Type`, "
"either Trait or Type must be local to your crate\". While this has never "
"been actually true, it's a reasonable hand-wavy explanation, and this gets "
"us even further from it. Even though `impl From<Foo> for Vec<()>` has always "
"been accepted, `impl<T> From<Foo> for Vec<T>` _feels_ even less local. While "
"`Vec<()>` only applies to `std`, `Vec<T>` now applies to types from `std` "
"and any other crate."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:273
msgid "Rationale and alternatives"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:276
msgid ""
"Rework coherence even more deeply. The rules around the orphan rule are "
"complex and hard to explain. Even `--explain E0210` doesn't actually try to "
"give the rationale behind them, and just states the fairly arcane formula "
"from the original RFC. While this proposal is a natural extension of the "
"current rules, and something that many expect to \"just work\", it "
"ultimately makes them even more complex."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:283
msgid ""
"In particular, this keeps the \"ordering\" rule. It still serves _a_ purpose "
"with this proposal, but much less of one. By keeping it, we are able to "
"allow `impl<T> SomeTrait<LocalType, T> for ForeignType`, because no sibling "
"crate can write an overlapping impl. However, this is not something that the "
"majority of library authors are aware of, and requires API designers to "
"order their type parameters based on how likely they are to be overridden by "
"other crates."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:291
msgid ""
"We could instead provide a mechanism for traits to opt into a redesigned "
"coherence system, and potentially default to that in a future edition. "
"However, that would likely cause a lot of confusion in the community. This "
"proposal is a strict addition to the set of impls which are allowed with the "
"current rules, without an increase in risk or impls which are breaking "
"changes. It seems like a reasonably conservative move, even if we eventually "
"want to overhaul coherence."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:299
msgid ""
"Get rid of the orphan rule entirely. A long standing pain point for crates "
"like Diesel has been integration with other crates. Diesel doesn't want to "
"care about chrono, and chrono doesn't want to care about Diesel. A database "
"access library shouldn't dictate your choice of time libraries, vice versa."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:304
msgid ""
"However, due to the way Rust works today, one of them has to. Nobody can "
"create a `diesel-chrono` crate due to the orphan rule. Maybe if we just "
"allowed crates to have incompatible impls, and set a standard of \"don't "
"write orphan impls unless that's the entire point of your crate\", it "
"wouldn't actually be that bad."
msgstr ""

#: src/2451-re-rebalancing-coherence.md:310
msgid "Unresolved questions"
msgstr ""

#: src/2451-re-rebalancing-coherence.md:313
msgid ""
"Are there additional implementations which are clearly acceptable under the "
"current restrictions, which are disallowed with this extension? Should we "
"allow them if so?"
msgstr ""
