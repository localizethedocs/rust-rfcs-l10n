msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:42Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0100-partial-cmp.md:1
msgid "Start Date: 2014-06-01"
msgstr ""

#: src/0100-partial-cmp.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#100](https://github.com/rust-lang/rfcs/pull/100)"
msgstr ""

#: src/0100-partial-cmp.md:3
msgid ""
"Rust Issue: [rust-lang/rust#14987](https://github.com/rust-lang/rust/"
"issues/14987)"
msgstr ""

#: src/0100-partial-cmp.md:5
msgid "Summary"
msgstr ""

#: src/0100-partial-cmp.md:7
msgid ""
"Add a `partial_cmp` method to `PartialOrd`, analogous to `cmp` in `Ord`."
msgstr ""

#: src/0100-partial-cmp.md:9
msgid "Motivation"
msgstr ""

#: src/0100-partial-cmp.md:11
msgid ""
"The `Ord::cmp` method is useful when working with ordered values. When the "
"exact ordering relationship between two values is required, `cmp` is both "
"potentially more efficient than computing both `a > b` and then `a < b` and "
"makes the code clearer as well."
msgstr ""

#: src/0100-partial-cmp.md:16
msgid ""
"I feel that in the case of partial orderings, an equivalent to `cmp` is even "
"more important. I've found that it's very easy to accidentally make "
"assumptions that only hold true in the total order case (for example `!(a < "
"b) => a >= b`). Explicitly matching against the possible results of the "
"comparison helps keep these assumptions from creeping in."
msgstr ""

#: src/0100-partial-cmp.md:22
msgid ""
"In addition, the current default implementation setup is a bit strange, as "
"implementations in the _partial_ equality trait assume _total_ equality. "
"This currently makes it easier to incorrectly implement `PartialOrd` for "
"types that do not have a total ordering, and if `PartialOrd` is separated "
"from `Ord` in a way similar to [this](https://gist.github.com/"
"alexcrichton/10945968) proposal, the default implementations for "
"`PartialOrd` will need to be removed and an implementation of the trait will "
"require four repetitive implementations of the required methods."
msgstr ""

#: src/0100-partial-cmp.md:31
msgid "Detailed design"
msgstr ""

#: src/0100-partial-cmp.md:33
msgid ""
"Add a method to `PartialOrd`, changing the default implementations of the "
"other methods:"
msgstr ""

#: src/0100-partial-cmp.md:69
msgid ""
"Since almost all ordered types have a total ordering, the implementation of "
"`partial_cmp` is trivial in most cases:"
msgstr ""

#: src/0100-partial-cmp.md:78
msgid ""
"This can be done automatically if/when RFC #48 or something like it is "
"accepted and implemented."
msgstr ""

#: src/0100-partial-cmp.md:81
msgid "Drawbacks"
msgstr ""

#: src/0100-partial-cmp.md:83
msgid ""
"This does add some complexity to `PartialOrd`. In addition, the more "
"commonly used methods (`lt`, etc) may become more expensive than they would "
"normally be if their implementations call into `partial_ord`."
msgstr ""

#: src/0100-partial-cmp.md:87
msgid "Alternatives"
msgstr ""

#: src/0100-partial-cmp.md:89
msgid ""
"We could invert the default implementations and have a default "
"implementation of `partial_cmp` in terms of `lt` and `gt`. This may slightly "
"simplify things in current Rust, but it makes the default implementation "
"less efficient than it should be. It would also require more work to "
"implement `PartialOrd` once the currently planned `cmp` reform has finished "
"as noted above."
msgstr ""

#: src/0100-partial-cmp.md:95
msgid ""
"`partial_cmp` could just be called `cmp`, but it seems like UFCS would need "
"to be implemented first for that to be workable."
msgstr ""

#: src/0100-partial-cmp.md:98
msgid "Unresolved questions"
msgstr ""

#: src/0100-partial-cmp.md:100
msgid ""
"We may want to add something similar to `PartialEq` as well. I don't know "
"what it would be called, though (maybe `partial_eq`?):"
msgstr ""

#: src/0100-partial-cmp.md:103
msgid ""
"// I don't feel great about these variant names, but `Equal` is already "
"taken\n"
"// by `Ordering` which is in the same module.\n"
msgstr ""
