msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:46Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/3809-derive-from.md:1
msgid "Feature Name: `derive_from`"
msgstr ""

#: src/3809-derive-from.md:2
msgid "Start Date: 2025-05-06"
msgstr ""

#: src/3809-derive-from.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#3809](https://github.com/rust-lang/rfcs/pull/3809)"
msgstr ""

#: src/3809-derive-from.md:4
msgid ""
"Tracking Issue: [rust-lang/rust#144889](https://github.com/rust-lang/rust/"
"issues/144889)"
msgstr ""

#: src/3809-derive-from.md:6
msgid "Summary"
msgstr ""

#: src/3809-derive-from.md:9
msgid ""
"Allow deriving an implementation of the `From` trait using `#[derive(From)]` "
"on structs with a single field."
msgstr ""

#: src/3809-derive-from.md:14
msgid "// Generates:\n"
msgstr ""

#: src/3809-derive-from.md:23
msgid ""
"This would only be allowed for single-field structs for now, where we can "
"unambiguously determine the source type from which should the struct be "
"convertible."
msgstr ""

#: src/3809-derive-from.md:25
msgid "Motivation"
msgstr ""

#: src/3809-derive-from.md:28
msgid ""
"The primary motivation is to remove one of the gaps in the Rust language "
"which prohibit combining language features in intuitive ways. Both the "
"`#[derive(Trait)]` macro and the `From` trait are pervasively used across "
"the Rust ecosystem, but it is currently not possible to combine them, even "
"in situations where the resulting behavior seems _completely obvious_."
msgstr ""

#: src/3809-derive-from.md:30
msgid ""
"Concretely, when you have a struct with a single field and want to implement "
"the `From` trait to allow creating a value of the struct from a value of the "
"field, `#[derive(From)]` seems like the most intuitive way of achieving "
"that. `From` is a standard library trait, `#[derive(Trait)]` works with many "
"other such traits (such as `Hash`, `Eq`, `Clone`, etc.), and there is "
"essentially only one possible implementation that makes sense. However, when "
"users currently try to do that, they are met with a compiler error."
msgstr ""

#: src/3809-derive-from.md:32
msgid ""
"Enabling this would make one more intuitive use-case in the language \"just "
"work\", and would reduce boilerplate that Rust users either write over and "
"over again or for which they have to use macros or external crates."
msgstr ""

#: src/3809-derive-from.md:34
msgid "Newtype pattern"
msgstr ""

#: src/3809-derive-from.md:35
msgid ""
"As a concrete use-case, `#[derive(From)]` is particularly useful in "
"combination with the very popular [newtype pattern](https://doc.rust-lang."
"org/rust-by-example/generics/new_types.html). In this pattern, an inner type "
"is wrapped in a new type (hence the name), typically a tuple struct, to "
"semantically make it a separate concept in the type system and thus make it "
"harder to mix unrelated types by accident. For example, we can wrap a number "
"to represent things like `Priority(i32)`, `PullRequestNumber(u32)` or "
"`TcpPort(u16)`."
msgstr ""

#: src/3809-derive-from.md:37
msgid ""
"When using the newtype pattern, it is common to implement standard library "
"traits for it by delegating to the inner type. This is easily achievable "
"with `#[derive]`:"
msgstr ""

#: src/3809-derive-from.md:44
msgid ""
"However, not all standard library traits can be derived in this way, "
"including the `From` trait. Currently, users have to write the boilerplate "
"`From` implementation by hand. If there are many newtypes in a crate, this "
"might lead users to implement a macro, which unnecessarily obfuscates the "
"code, or use an external crate to derive the implementation, which increases "
"code size and compile times."
msgstr ""

#: src/3809-derive-from.md:46
msgid ""
"It should be noted that there are cases where the newtype should not be able "
"to store all possible values of the inner field, e.g. `struct "
"Email(String)`. In that case an implementation of `From` might not be "
"desirable, and the newtype will likely implement its own constructor "
"function that performs validation. For cases where the newtype can represent "
"all values of the inner field, implementing `From` for it is quite natural, "
"as it is the designated Rust trait for performing lossless conversions."
msgstr ""

#: src/3809-derive-from.md:48
msgid ""
"Is `From` really so useful for newtypes? There are two other common "
"alternatives for constructing a value of a newtype apart from using `From`:"
msgstr ""

#: src/3809-derive-from.md:49
msgid ""
"Using the struct literal syntax directly, such as `UserId(5)` or `UserId "
"{ id: 5 }`. This is explicit, but it does not work in generic code (unlike "
"`From`) and it can either only be used in the module of the struct, or the "
"struct field has to become publicly visible, which is usually not desirable."
msgstr ""

#: src/3809-derive-from.md:50
msgid ""
"Using a constructor function, often called `new`. This function cannot be "
"derived (without using custom proc macros) and has to be implemented using a "
"manual `impl` block. It is essentially boilerplate code if the newtype does "
"not need to perform any validation of the field value. If it was possible to "
"easily derive `From`, then it could be used instead of an explicit `new` "
"function, which could reduce the need to create any `impl` blocks for simple "
"newtypes."
msgstr ""

#: src/3809-derive-from.md:52
msgid ""
"To summarize, if `From` was `derive`\\-able, it could reduce the need for "
"using macros or external crates and increase the number of cases where "
"`#[derive]` takes care of all required `impl`s for a given newtype."
msgstr ""

#: src/3809-derive-from.md:54
msgid "Why does it make sense to derive `From`?"
msgstr ""

#: src/3809-derive-from.md:55
msgid ""
"There are various \"standard\" traits defined in the Rust standard library "
"that are pervasively used across the ecosystem. Currently, some of these "
"traits can already be automatically derived, for example `Hash` or `Debug`. "
"These traits can be derived automatically because they are composable; an "
"implementation of the trait for a struct can be composed of the trait "
"implementations of its fields."
msgstr ""

#: src/3809-derive-from.md:57
msgid ""
"One reason why we might not want to enable automatic derive for a specific "
"trait is when the implementation would not be _obvious_. For example, if we "
"allowed deriving `Display`, it is unclear how should the individual field "
"implementations be composed. Should they be separated with a newline? Or a "
"comma? That depends on the given type."
msgstr ""

#: src/3809-derive-from.md:59
msgid ""
"However, when deriving a `From` implementation for a struct with a single "
"field, the implementation seems straightforward and _obvious_ (simply wrap "
"the inner type in the struct). It should thus be possible to automatically "
"derive it."
msgstr ""

#: src/3809-derive-from.md:61
msgid ""
"That being said, the fact that the `From` trait is generic does present more "
"opportunities for alternative designs. These are discussed in [Rationale and "
"alternatives](#rationale-and-alternatives)."
msgstr ""

#: src/3809-derive-from.md:63
msgid "How common is implementing and deriving `From`?"
msgstr ""

#: src/3809-derive-from.md:64
msgid ""
"[This](https://github.com/search?type=code&q=lang%3ARust+"
"%2F%5C%5Bderive%5C%28.*%5CbFrom%5B%2C+%5C%29%5D%2F) GitHub Code Search query "
"shows tens of thousands of occurrences of the `From` trait being derived, "
"typically using the `derive_more` crate."
msgstr ""

#: src/3809-derive-from.md:66
msgid ""
"I have also scanned the top 100 crates from crates.io together with their "
"dependencies using a simple [script](https://github.com/Kobzol/scan-from-"
"impls), to find all instances of tuple structs with a single field where the "
"struct implements `From<FieldType>`."
msgstr ""

#: src/3809-derive-from.md:68
msgid ""
"In the analyzed 168 crates, 559 single-field tuple structs were found, and "
"49 out of them contained the `From` implementation from their field type."
msgstr ""

#: src/3809-derive-from.md:70
msgid "Guide-level explanation"
msgstr ""

#: src/3809-derive-from.md:73
msgid ""
"You can use `#[derive(From)]` to automatically generate an implementation of "
"the `From` trait for the given type, which will create a value of the struct "
"from a value of its field:"
msgstr ""

#: src/3809-derive-from.md:78 src/3809-derive-from.md:118
msgid "// Will generate:\n"
msgstr ""

#: src/3809-derive-from.md:87
msgid ""
"You can only use `#[derive(From)]` on structs that contain exactly one "
"field, otherwise the compiler would not know from which type should the "
"`From` implementation be generated. For example, the following code snippet "
"does not compile:"
msgstr ""

#: src/3809-derive-from.md:90
msgid "// <-- This DOES NOT compile\n"
msgstr ""

#: src/3809-derive-from.md:97
msgid ""
"In this case, the compiler wouldn't know if it should generate `From<u32> "
"for User` or `From<String> for User`, nor how it should figure out which "
"value to use for the other field when constructing `User`."
msgstr ""

#: src/3809-derive-from.md:99
msgid ""
"Note that the generated `From` implementation only allows converting the "
"value of the field into a value of the struct. It does not allow conversion "
"in the opposite direction:"
msgstr ""

#: src/3809-derive-from.md:106
msgid "// works\n"
msgstr ""

#: src/3809-derive-from.md:107
msgid "// does NOT work\n"
msgstr ""

#: src/3809-derive-from.md:111
msgid ""
"If you need to support conversion in the opposite direction, you will need "
"to implement `impl From<FieldType> for StructType` manually."
msgstr ""

#: src/3809-derive-from.md:113
msgid ""
"If the struct is generic over the type of the inner field, the `From` "
"implementation will be also generic:"
msgstr ""

#: src/3809-derive-from.md:127
msgid "Reference-level explanation"
msgstr ""

#: src/3809-derive-from.md:130
msgid ""
"Placing `#[derive(From)]` on a tuple struct or a struct with named fields "
"named `$s` is permissible if and only if the struct has exactly one field "
"that we will label as `$f`. We will use the name `$t` for the type of the "
"field `$f`. In that event, the compiler shall generate the following:"
msgstr ""

#: src/3809-derive-from.md:132
msgid "If `$s` is a tuple struct:"
msgstr ""

#: src/3809-derive-from.md:140
msgid "If `$s` is a struct with a named field `$f`:"
msgstr ""

#: src/3809-derive-from.md:151
msgid ""
"Using `#[derive(From)]` on unit structs, enums or tuple/named field structs "
"that do not have exactly one field produces a compiler error."
msgstr ""

#: src/3809-derive-from.md:153
msgid "Drawbacks"
msgstr ""

#: src/3809-derive-from.md:156
msgid ""
"While this does enable more Rust code to \"just work\", it also introduces a "
"special case that will have to be explained to the users. In this case it "
"seems quite easily understandable though (\"it only works for structs with a "
"single field\"), and we should be able to produce high-quality error "
"messages in the compiler, as it is trivial to detect how many fields a "
"struct has."
msgstr ""

#: src/3809-derive-from.md:158
msgid "Rationale and alternatives"
msgstr ""

#: src/3809-derive-from.md:161
msgid ""
"Based on the popularity of the `derive_more` crate (discussed in [Prior art]"
"(#prior-art)), which had more than 125 million downloads when this RFC was "
"proposed, it seems that there is a lot of appetite for extending the set of "
"use-cases where deriving standard traits is allowed. This feature was "
"discussed in the past [here](https://github.com/rust-lang/rfcs/issues/2026)."
msgstr ""

#: src/3809-derive-from.md:163
msgid ""
"The proposed change enables the usage of an existing feature (`#[derive]`) "
"in more situations. It makes code easier to read by using an intuitive built-"
"in feature instead of forcing users to write boilerplate code or use macros."
msgstr ""

#: src/3809-derive-from.md:165
msgid ""
"As always, an alternative is to just not do this, in that case users would "
"continue implementing `From` using boilerplate code, macros or external "
"crates."
msgstr ""

#: src/3809-derive-from.md:167
msgid ""
"Because the scope of the proposed change is quite minimal, it should be "
"forward-compatible with designs that would make it work in more situations "
"in the future (some ideas are discussed in [Future possibilities](#future-"
"possibilities)). There is one potential (although unlikely) incompatibility "
"discussed below."
msgstr ""

#: src/3809-derive-from.md:169
msgid "Alternative design using tuples"
msgstr ""

#: src/3809-derive-from.md:170
msgid ""
"There is one possible alternative design that comes to mind which could be "
"in theory incompatible with this proposal. We could enable `#[derive(From)]` "
"for tuple structs with an arbitrary number of fields by generating a `From` "
"implementation from a tuple containing the types of the struct fields:"
msgstr ""

#: src/3809-derive-from.md:179
msgid ""
"The question then becomes what would be generated under this design when the "
"struct has exactly one field."
msgstr ""

#: src/3809-derive-from.md:181
msgid ""
"We could either generate `From<T> for Type`, which would be compatible with "
"this RFC. It would also be slightly inconsistent though, as it would "
"generate something different only for the case with a single field."
msgstr ""

#: src/3809-derive-from.md:182
msgid "This is how the `derive_more::From` macro behaves."
msgstr ""

#: src/3809-derive-from.md:183
msgid ""
"Or, we could generate `From<(T, )> for Type`, which would be consistent with "
"the logic of generating `From<tuple>`. However, single-field tuples are not "
"idiomatic and it would be awkward having to write e.g. `(value, ).into()` to "
"make use of the impl."
msgstr ""

#: src/3809-derive-from.md:185
msgid ""
"I think that the second approach is not a good idea, and I find it unlikely "
"that we would want to use it."
msgstr ""

#: src/3809-derive-from.md:187
msgid "Generating `From` in the other direction"
msgstr ""

#: src/3809-derive-from.md:188
msgid ""
"This proposed change is useful to generate a `From` impl that turns the "
"inner field into the wrapper struct (`impl From<Inner>` for `Newtype`). "
"However, sometimes it is also useful to generate the other direction, i.e. "
"turning the newtype back into the inner type. This can be implemented using "
"`impl From<Newtype> for Innertype`."
msgstr ""

#: src/3809-derive-from.md:190
msgid ""
"We could make `#[derive(From)]` generate both directions, but that would "
"make it impossible to only ask for the \"basic\" `From` direction without "
"some additional syntax."
msgstr ""

#: src/3809-derive-from.md:192
msgid ""
"A better alternative might be to support generating the other direction in "
"the future through something like `#[derive(Into)]`."
msgstr ""

#: src/3809-derive-from.md:194
msgid "More general blanket implementation"
msgstr ""

#: src/3809-derive-from.md:195
msgid ""
"As an alternative to generating `From<Inner> for Newtype`, the compiler "
"could generate a more generic blanket implementation, such as `impl<T> "
"From<T> for Newtype where Inner: From<T>`[^blanket]."
msgstr ""

#: src/3809-derive-from.md:197
msgid "This would allow \"recursive conversions\", for example:"
msgstr ""

#: src/3809-derive-from.md:201
msgid "// Generated code:\n"
msgstr ""

#: src/3809-derive-from.md:215
msgid ""
"While this can be certainly useful in some scenarios, it feels too "
"\"magical\" to be the default; it does not seem like it is the most "
"straightforward implementation that users would expect to be generated. The "
"existing standard library traits are not derived in this way, as they are "
"not generic (unlike `From`)."
msgstr ""

#: src/3809-derive-from.md:217
msgid ""
"This generated implementation would also conflict with a `From` "
"implementation in the \"other direction\", from the newtype to the inner "
"field (`impl From<UserId> for u32`), which seems problematic."
msgstr ""

#: src/3809-derive-from.md:219
msgid ""
"The `derive_more` crate allows opting into the blanket implementation using "
"a custom attribute (`#[from(forward)]`)."
msgstr ""

#: src/3809-derive-from.md:221
msgid ""
"Noted [here](https://internals.rust-lang.org/t/pre-rfc-derive-from-for-"
"newtypes/22567/6)."
msgstr ""

#: src/3809-derive-from.md:223
msgid "Direction of the `From` impl"
msgstr ""

#: src/3809-derive-from.md:224
msgid "In theory, someone could be confused if this code:"
msgstr ""

#: src/3809-derive-from.md:229
msgid "generates this impl:"
msgstr ""

#: src/3809-derive-from.md:233
msgid "or this impl:"
msgstr ""

#: src/3809-derive-from.md:237
msgid ""
"However, `impl From<Inner> for Newtype` is consistent with all other "
"standard traits that can currently be derived, as they all generate code in "
"the form of `impl Trait for Type`. It should thus not be very surprising "
"that `#[derive(From)]` provides the impl for the outer type, not the inner "
"type. This will also be clearly documented."
msgstr ""

#: src/3809-derive-from.md:239
msgid ""
"Generating the other direction of the impl is best left as a separate "
"feature, which is briefly discussed in [Future possibilities](#future-"
"possibilities)."
msgstr ""

#: src/3809-derive-from.md:241
msgid "Prior art"
msgstr ""

#: src/3809-derive-from.md:244
msgid "Ecosystem crates"
msgstr ""

#: src/3809-derive-from.md:245
msgid ""
"There are several crates that offer deriving the `From` trait. The most "
"popular one is [derive_more](https://crates.io/crates/derive_more), which "
"allows deriving several standard traits that are normally not derivable, "
"including `From`, `Display` or `Add`."
msgstr ""

#: src/3809-derive-from.md:247
msgid ""
"[`#[derive(derive_more::From)`](https://docs.rs/derive_more/latest/"
"derive_more/derive.From.html) works in the same way as proposed in this RFC "
"for structs with a single field. However, it can also be used for other "
"kinds of structs and even enums and supports more complex use-cases. For "
"example:"
msgstr ""

#: src/3809-derive-from.md:248
msgid ""
"For structs with multiple fields, it generates an impl from a tuple "
"containing these fields:"
msgstr ""

#: src/3809-derive-from.md:255
msgid ""
"You can opt into additional types for which a `From` impl will be generated:"
msgstr ""

#: src/3809-derive-from.md:261
msgid "For enums, it generates a separate `From` impl for each enum variant:"
msgstr ""

#: src/3809-derive-from.md:268
msgid "// Generates\n"
msgstr ""

#: src/3809-derive-from.md:282
msgid ""
"The design proposed by this RFC should be forward compatible with all "
"features of `derive_more`[^enums], if we decided to adopt any of them in the "
"future."
msgstr ""

#: src/3809-derive-from.md:284
msgid ""
"If we only allow the `#[derive(From)]` on structs, and not enums, see "
"[Unresolved questions](#unresolved-questions)."
msgstr ""

#: src/3809-derive-from.md:286
msgid "Default trait"
msgstr ""

#: src/3809-derive-from.md:287
msgid ""
"There is a precedent for a trait that can only be automatically derived in "
"certain situations. The `Default` trait was originally only derivable on "
"structs, not on enums, because it was not clear which enum variant should be "
"selected as the default. This was later rectified by adding custom syntax "
"(`#[default]`) to select the default variant."
msgstr ""

#: src/3809-derive-from.md:289
msgid ""
"A similar solution could be used in the future to also extend "
"`#[derive(From)]` to more use-cases; this will be discussed in [Future "
"possibilities](#future-possibilities)."
msgstr ""

#: src/3809-derive-from.md:291
msgid ""
"The `Default` trait actually shares a similarity with `From`, in that they "
"are both \"constructor\" traits that create a new value of a given type, so "
"it feels natural that both should be automatically implementable, at least "
"in some cases."
msgstr ""

#: src/3809-derive-from.md:293
msgid "Unresolved questions"
msgstr ""

#: src/3809-derive-from.md:296 src/3809-derive-from.md:367
msgid "Enum support"
msgstr ""

#: src/3809-derive-from.md:297
msgid ""
"Should we also support enums? The design space there is more complex than "
"for structs. For example, `derive_more` generates a separate `From` impl for "
"each enum variant by default, which means that the individual variants must "
"not contain the same inner type, otherwise an impl conflict happens:"
msgstr ""

#: src/3809-derive-from.md:304
msgid "// Generates the following two impls:\n"
msgstr ""

#: src/3809-derive-from.md:311
msgid "// [ERROR] Conflicting impl\n"
msgstr ""

#: src/3809-derive-from.md:320
msgid "This could be difficult to explain."
msgstr ""

#: src/3809-derive-from.md:322
msgid ""
"As an alternative, we could use a simpler approach and only allow "
"`#[derive(From)]` for single-variant enums containing a single field. "
"However, these are likely not very common."
msgstr ""

#: src/3809-derive-from.md:324
msgid ""
"A better solution might be to use a custom attribute (such as `#[from]`) to "
"allow users to customize which variant of the enum should be created (see "
"[Future possibilities](#future-possibilities)), but this complicates the "
"design space."
msgstr ""

#: src/3809-derive-from.md:326
msgid ""
"For these reasons, this RFC only proposes to support structs as the first "
"step, similarly to the `Default` trait, which was originally also only "
"derivable on structs. We could support more use-cases with future extensions."
msgstr ""

#: src/3809-derive-from.md:328
msgid "Future possibilities"
msgstr ""

#: src/3809-derive-from.md:331
msgid "`#[from]` attribute"
msgstr ""

#: src/3809-derive-from.md:332
msgid ""
"In the future, we could extend the set of supported use-cases even to "
"structs with multiple fields. For example, we could allow it in cases where "
"the user marks a specific field with a `#[from]` attribute, and all other "
"fields implement `Default`:"
msgstr ""

#: src/3809-derive-from.md:349
msgid "which would generate this impl:"
msgstr ""

#: src/3809-derive-from.md:361
msgid ""
"This is similar to how [RFC#3107](https://rust-lang.github.io/rfcs/3107-"
"derive-default-enum.html) extended the deriving of the `Default` trait using "
"the `#[default]` attribute."
msgstr ""

#: src/3809-derive-from.md:363
msgid "Deriving From in the other direction"
msgstr ""

#: src/3809-derive-from.md:365
msgid ""
"It is also quite useful to generate `From<InnerType> for Struct`, i.e. "
"generating `From` in the other direction. This could be done in the future "
"using e.g. `#[derive(Into)]`."
msgstr ""

#: src/3809-derive-from.md:368
msgid ""
"We could add support for enums in a similar way, where users could mark the "
"variant that should be constructed using `#[from]`."
msgstr ""

#: src/3809-derive-from.md:370
msgid "Supporting other traits"
msgstr ""

#: src/3809-derive-from.md:371
msgid ""
"We could extend the same logic (only allowing deriving a standard trait for "
"structs with a single field) to more traits. For example, `AsRef`, `Deref` "
"or even things like `FromStr` or `Iterator` could be potentially derivable "
"in the same way, when used on a struct with a single field."
msgstr ""
