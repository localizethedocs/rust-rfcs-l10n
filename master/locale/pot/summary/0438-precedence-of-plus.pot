msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0438-precedence-of-plus.md:1
msgid "Start Date: 2014-11-18"
msgstr ""

#: src/0438-precedence-of-plus.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#438](https://github.com/rust-lang/rfcs/pull/438)"
msgstr ""

#: src/0438-precedence-of-plus.md:3
msgid ""
"Rust Issue: [rust-lang/rust#19092](https://github.com/rust-lang/rust/"
"issues/19092)"
msgstr ""

#: src/0438-precedence-of-plus.md:5
msgid "Summary"
msgstr ""

#: src/0438-precedence-of-plus.md:7
msgid ""
"Change the precedence of `+` (object bounds) in type grammar so that it is "
"similar to the precedence in the expression grammars."
msgstr ""

#: src/0438-precedence-of-plus.md:10
msgid "Motivation"
msgstr ""

#: src/0438-precedence-of-plus.md:12
msgid ""
"Currently `+` in types has a much higher precedence than it does in "
"expressions. This means that for example one can write a type like the "
"following:"
msgstr ""

#: src/0438-precedence-of-plus.md:19
msgid "Whereas if that were an expression, parentheses would be required:"
msgstr ""

#: src/0438-precedence-of-plus.md:25
msgid ""
"Besides being confusing in its own right, this loose approach with regard to "
"precedence yields ambiguities with unboxed closure bounds:"
msgstr ""

#: src/0438-precedence-of-plus.md:34
msgid ""
"In this example, it is unclear whether `F` returns an object which is "
"`Send`, or whether `F` itself is `Send`."
msgstr ""

#: src/0438-precedence-of-plus.md:37
msgid "Detailed design"
msgstr ""

#: src/0438-precedence-of-plus.md:39
msgid ""
"This RFC proposes that the precedence of `+` be made lower than unary type "
"operators. In addition, the grammar is segregated such that in \"open-"
"ended\" contexts (e.g., after `->`), parentheses are required to use a `+`, "
"whereas in others (e.g., inside `<>`), parentheses are not. Here are some "
"examples:"
msgstr ""

#: src/0438-precedence-of-plus.md:46
msgid ""
"// Before                             After                         Note\n"
"// ~~~~~~                             ~~~~~                         ~~~~\n"
msgstr ""

#: src/0438-precedence-of-plus.md:52
msgid "// (*)\n"
msgstr ""

#: src/0438-precedence-of-plus.md:54
msgid "// (*) Must yield a type error, as return type must be `Sized`.\n"
msgstr ""

#: src/0438-precedence-of-plus.md:58
msgid "More fully, the type grammar is as follows (EBNF notation):"
msgstr ""

#: src/0438-precedence-of-plus.md:72
msgid "Where clauses would use the following grammar:"
msgstr ""

#: src/0438-precedence-of-plus.md:76
msgid ""
"One property of this grammar is that the `TYPE` nonterminal does not require "
"a terminator as it has no \"open-ended\" expansions. `SUM`, in contrast, can "
"be extended any number of times via the `+` token. Hence is why `SUM` must "
"be enclosed in parens to make it into a `TYPE`."
msgstr ""

#: src/0438-precedence-of-plus.md:81
msgid "Drawbacks"
msgstr ""

#: src/0438-precedence-of-plus.md:83
msgid "Common types like `&'a Foo+'a` become slightly longer (`&'a (Foo+'a)`)."
msgstr ""

#: src/0438-precedence-of-plus.md:85
msgid "Alternatives"
msgstr ""

#: src/0438-precedence-of-plus.md:87
msgid ""
"We could live with the inconsistency between the type/expression grammars "
"and disambiguate where clauses in an ad-hoc way."
msgstr ""

#: src/0438-precedence-of-plus.md:90
msgid "Unresolved questions"
msgstr ""

#: src/0438-precedence-of-plus.md:92
msgid "None."
msgstr ""
