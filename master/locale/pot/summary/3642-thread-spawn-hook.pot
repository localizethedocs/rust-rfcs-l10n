msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:46Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/3642-thread-spawn-hook.md:1
msgid "Feature Name: `thread_spawn_hook`"
msgstr ""

#: src/3642-thread-spawn-hook.md:2
msgid "Start Date: 2024-05-22"
msgstr ""

#: src/3642-thread-spawn-hook.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#3642](https://github.com/rust-lang/rfcs/pull/3642)"
msgstr ""

#: src/3642-thread-spawn-hook.md:4
msgid ""
"Rust Issue: [rust-lang/rust#132951](https://github.com/rust-lang/rust/"
"issues/132951)"
msgstr ""

#: src/3642-thread-spawn-hook.md:6
msgid "Summary"
msgstr ""

#: src/3642-thread-spawn-hook.md:8
msgid ""
"Add `std::thread::add_spawn_hook` to register a hook that runs for newly "
"spawned threads. This will effectively provide us with \"inheriting thread "
"locals\", a much requested feature."
msgstr ""

#: src/3642-thread-spawn-hook.md:17
msgid "// Get the value of X in the spawning thread.\n"
msgstr ""

#: src/3642-thread-spawn-hook.md:20
msgid "// Set the value of X in the newly spawned thread.\n"
msgstr ""

#: src/3642-thread-spawn-hook.md:25
msgid "Motivation"
msgstr ""

#: src/3642-thread-spawn-hook.md:27
msgid ""
"Thread local variables are often used for scoped \"global\" state. For "
"example, a testing framework might store the status or name of the current "
"unit test in a thread local variable, such that multiple tests can be run in "
"parallel in the same process."
msgstr ""

#: src/3642-thread-spawn-hook.md:32
msgid ""
"However, this information will not be preserved across threads when a unit "
"test will spawn a new thread, which is problematic."
msgstr ""

#: src/3642-thread-spawn-hook.md:35
msgid ""
"The solution seems to be \"inheriting thread locals\": thread locals that "
"are automatically inherited by new threads."
msgstr ""

#: src/3642-thread-spawn-hook.md:38
msgid ""
"However, adding this property to thread local variables is not easily "
"possible. Thread locals are initialized lazily. And by the time they are "
"initialized, the parent thread might have already disappeared, such that "
"there is no value left to inherit from. Additionally, even if the parent "
"thread was still alive, there is no way to access the value in the parent "
"thread without causing race conditions."
msgstr ""

#: src/3642-thread-spawn-hook.md:45
msgid ""
"Allowing hooks to be run as part of spawning a thread allows precise control "
"over how thread locals are \"inherited\". One could simply `clone()` them, "
"but one could also add additional information to them, or even add relevant "
"information to some (global) data structure."
msgstr ""

#: src/3642-thread-spawn-hook.md:50
msgid ""
"For example, not only could a custom testing framework keep track of unit "
"test state even across spawned threads, but a logging/debugging/tracing "
"library could keeps track of which thread spawned which thread to provide "
"more useful information to the user."
msgstr ""

#: src/3642-thread-spawn-hook.md:55
msgid "Public Interface"
msgstr ""

#: src/3642-thread-spawn-hook.md:57
msgid "For adding a hook:"
msgstr ""

#: src/3642-thread-spawn-hook.md:60 src/3642-thread-spawn-hook.md:120
msgid "// In std::thread:\n"
msgstr ""

#: src/3642-thread-spawn-hook.md:61
msgid ""
"/// Registers a function to run for every newly thread spawned.\n"
"///\n"
"/// The hook is executed in the parent thread, and returns a function\n"
"/// that will be executed in the new thread.\n"
"///\n"
"/// The hook is called with the `Thread` handle for the new thread.\n"
"///\n"
"/// The hook will only be added for the current thread and is inherited by "
"the threads it spawns.\n"
"/// In other words, adding a hook has no effect on already running threads "
"(other than the current\n"
"/// thread) and the threads they might spawn in the future.\n"
"///\n"
"/// The hooks will run in order, starting with the most recently added.\n"
"///\n"
"/// # Usage\n"
"///\n"
"/// ```\n"
"/// std::thread::add_spawn_hook(|_| {\n"
"///     ..; // This will run in the parent (spawning) thread.\n"
"///     move || {\n"
"///         ..; // This will run it the child (spawned) thread.\n"
"///     }\n"
"/// });\n"
"/// ```\n"
"///\n"
"/// # Example\n"
"///\n"
"/// A spawn hook can be used to \"inherit\" a thread local from the parent "
"thread:\n"
"///\n"
"/// ```\n"
"/// use std::cell::Cell;\n"
"///\n"
"/// thread_local! {\n"
"///     static X: Cell<u32> = Cell::new(0);\n"
"/// }\n"
"///\n"
"/// // This needs to be done once in the main thread before spawning any "
"threads.\n"
"/// std::thread::add_spawn_hook(|_| {\n"
"///     // Get the value of X in the spawning thread.\n"
"///     let value = X.get();\n"
"///     // Set the value of X in the newly spawned thread.\n"
"///     move || X.set(value)\n"
"/// });\n"
"///\n"
"/// X.set(123);\n"
"///\n"
"/// std::thread::spawn(|| {\n"
"///     assert_eq!(X.get(), 123);\n"
"/// }).join().unwrap();\n"
"/// ```\n"
msgstr ""

#: src/3642-thread-spawn-hook.md:117
msgid "And for opting out when spawning a hook:"
msgstr ""

#: src/3642-thread-spawn-hook.md:123
msgid ""
"/// Disables running and inheriting [spawn hooks](add_spawn_hook).\n"
"    ///\n"
"    /// Use this if the parent thread is in no way relevant for the child "
"thread.\n"
"    /// For example, when lazily spawning threads for a thread pool.\n"
msgstr ""

#: src/3642-thread-spawn-hook.md:131
msgid "Implementation"
msgstr ""

#: src/3642-thread-spawn-hook.md:133
msgid ""
"The implementation is a _thread local_ linked list of hooks, which is "
"inherited by newly spawned threads. This means that adding a hook will only "
"affect the current thread and all (direct and indirect) future child threads "
"of the current thread. It will not globally affect all already running "
"threads."
msgstr ""

#: src/3642-thread-spawn-hook.md:137
msgid ""
"Functions that spawn a thread, such as `std::thread::spawn` will eventually "
"call `spawn_unchecked_`, which will call the hooks in the parent thread, "
"after the child `Thread` object has been created, but before the child "
"thread has been spawned. The resulting `FnOnce` objects are stored and "
"passed on to the child thread afterwards, which will execute them one by one "
"before continuing with its main function."
msgstr ""

#: src/3642-thread-spawn-hook.md:144
msgid "Downsides"
msgstr ""

#: src/3642-thread-spawn-hook.md:146
msgid ""
"The implementation requires allocation for each hook (to store them in the "
"list of hooks), and an allocation each time a hook is spawned (to store the "
"resulting closure)."
msgstr ""

#: src/3642-thread-spawn-hook.md:150
msgid ""
"A library that wants to make use of inheriting thread locals will have to "
"register a global hook (e.g. at the start of `main`), and will need to keep "
"track of whether its hook has already been added."
msgstr ""

#: src/3642-thread-spawn-hook.md:154
msgid ""
"The hooks will not run if threads are spawned through e.g. pthread directly, "
"bypassing the Rust standard library. (However, this is already the case for "
"output capturing in libtest: that does not work across threads when not "
"spawned by libstd.)"
msgstr ""

#: src/3642-thread-spawn-hook.md:159
msgid "Rationale and alternatives"
msgstr ""

#: src/3642-thread-spawn-hook.md:161
msgid "Global vs thread local effect"
msgstr ""

#: src/3642-thread-spawn-hook.md:163
msgid ""
"Unlike e.g. libc's `atexit()`, which has a global effect, `add_spawn_hook` "
"has a thread local effect."
msgstr ""

#: src/3642-thread-spawn-hook.md:165
msgid ""
"This means that adding a hook will only affect the current thread and all "
"(direct and indirect) future child threads of the current thread. In other "
"words, adding a hook has no effect on already running threads (other than "
"the current thread) and the threads they might spawn in the future."
msgstr ""

#: src/3642-thread-spawn-hook.md:168
msgid ""
"An alternative could be to have a global set of hooks that affects all newly "
"spawned threads, on any existing and future thread."
msgstr ""

#: src/3642-thread-spawn-hook.md:170
msgid ""
"Both are relatively easy and efficient to implement (as long as removing "
"hooks is not an option)."
msgstr ""

#: src/3642-thread-spawn-hook.md:173
msgid ""
"The global behavior was proposed in an earlier version of this RFC, but the "
"library-api team expressed a preference for exploring a \"more local\" "
"solution."
msgstr ""

#: src/3642-thread-spawn-hook.md:176
msgid ""
"Having a \"lexicographically local\" solution doesn't seem to be possible "
"other than for scoped threads, however, since threads can outlive their "
"parent thread and then spawn more threads."
msgstr ""

#: src/3642-thread-spawn-hook.md:179
msgid ""
"A thread local effect (affecting all future child threads) seems to be the "
"most \"local\" behavior we can achieve here."
msgstr ""

#: src/3642-thread-spawn-hook.md:181
msgid "Add but no remove"
msgstr ""

#: src/3642-thread-spawn-hook.md:183
msgid ""
"Having only an `add_spawn_hook` but not a `remove_spawn_hook` keeps things "
"simple, by not needing a way to identify a specific hook (through a handle "
"or a name)."
msgstr ""

#: src/3642-thread-spawn-hook.md:187
msgid ""
"If a hook only needs to execute conditionally, one can make use of an `if` "
"statement."
msgstr ""

#: src/3642-thread-spawn-hook.md:190
msgid ""
"If no hooks should be executed or inherited, one can use `Builder::no_hooks`."
msgstr ""

#: src/3642-thread-spawn-hook.md:192
msgid "Requiring storage on spawning"
msgstr ""

#: src/3642-thread-spawn-hook.md:194
msgid ""
"Because the hooks run on the parent thread first, before the child thread is "
"spawned, the results of those hooks (the functions to be executed in the "
"child) need to be stored. This will require heap allocations (although it "
"might be possible for an optimization to save small objects on the stack up "
"to a certain size)."
msgstr ""

#: src/3642-thread-spawn-hook.md:200
msgid ""
"An alternative interface that wouldn't require any store is possible, but "
"has downsides. Such an interface would spawn the child thread _before_ "
"running the hooks, and allow the hooks to execute a closure on the child "
"(before it moves on to its main function). That looks roughly like this:"
msgstr ""

#: src/3642-thread-spawn-hook.md:207
msgid "// Get the value on the parent thread.\n"
msgstr ""

#: src/3642-thread-spawn-hook.md:209
msgid "// Set the value on the child thread.\n"
msgstr ""

#: src/3642-thread-spawn-hook.md:214
msgid ""
"This could be implemented without allocations, as the function executed by "
"the child can now be borrowed from the parent thread."
msgstr ""

#: src/3642-thread-spawn-hook.md:217
msgid ""
"However, this means that the parent thread will have to block until the "
"child thread has been spawned, and block for each hook to be finished on "
"both threads, significantly slowing down thread creation."
msgstr ""

#: src/3642-thread-spawn-hook.md:221
msgid ""
"Considering that spawning a thread involves several allocations and "
"syscalls, it doesn't seem very useful to try to minimize an extra allocation "
"when that comes at a significant cost."
msgstr ""

#: src/3642-thread-spawn-hook.md:225
msgid "`impl` vs `dyn` in the signature"
msgstr ""

#: src/3642-thread-spawn-hook.md:227
msgid ""
"An alternative interface could use `dyn` instead of generics, as follows:"
msgstr ""

#: src/3642-thread-spawn-hook.md:235
msgid ""
"However, this mostly has downsides: it requires the user to write `Box::new` "
"in a few places, and it prevents us from ever implementing some optimization "
"tricks to, for example, use a single allocation for multiple hook results."
msgstr ""

#: src/3642-thread-spawn-hook.md:239
msgid "A regular function vs some lang feature"
msgstr ""

#: src/3642-thread-spawn-hook.md:241
msgid ""
"Just like `std::panic::set_hook`, `std::thread::add_spawn_hook` is just "
"regular function."
msgstr ""

#: src/3642-thread-spawn-hook.md:243
msgid ""
"An alternative would be to have some special attribute, like "
"`#[thread_spawn_hook]`, similar to `#[panic_handler]` in `no_std` programs, "
"or to make use of a potential future [global registration feature](https://"
"github.com/rust-lang/rust/issues/125119)."
msgstr ""

#: src/3642-thread-spawn-hook.md:247
msgid ""
"While such things might make sense in a `no_std` world, spawning threads "
"(like panic hooks) is an `std` only feature, where we can use global state "
"and allocations."
msgstr ""

#: src/3642-thread-spawn-hook.md:250
msgid ""
"The only potential advantage of such an approach might be a small reduction "
"in overhead, but this potential overhead is insignificant compared to the "
"overall cost of spwaning a thread."
msgstr ""

#: src/3642-thread-spawn-hook.md:253
msgid ""
"The downsides are plenty, including limitations on what your hook can do and "
"return, needing a macro or special syntax to register a hook, potential "
"issues with dynamic linking, additional implementation complexity, and "
"possibly having to block on a language feature."
msgstr ""

#: src/3642-thread-spawn-hook.md:257
msgid "Unresolved questions"
msgstr ""

#: src/3642-thread-spawn-hook.md:259
msgid ""
"Should the return value of the hook be an `Option`, for when the hook does "
"not require any code to be run in the child?"
msgstr ""

#: src/3642-thread-spawn-hook.md:262
msgid ""
"Should the hook be able to access/configure more information about the child "
"thread? E.g. set its stack size. (Note that settings that can be changed "
"afterwards by the child thread, such as the thread name, can already be set "
"by simply setting it as part of the code that runs on the child thread.)"
msgstr ""

#: src/3642-thread-spawn-hook.md:268
msgid "Future possibilities"
msgstr ""

#: src/3642-thread-spawn-hook.md:270
msgid ""
"Using this in libtest for output capturing (instead of today's "
"implementation that has special hardcoded support in libstd)."
msgstr ""

#: src/3642-thread-spawn-hook.md:273
msgid "Relevant history"
msgstr ""

#: src/3642-thread-spawn-hook.md:275
msgid ""
"The original reason I wrote [RFC 3184 \"Thread local Cell methods\"](https://"
"github.com/rust-lang/rfcs/pull/3184) was to simplify thread spawn hooks "
"(which I was experimenting with at the time). Without that RFC, thread spawn "
"hooks would look something like `let v = X.with(|x| x.get()); || X.with(|x| "
"x.set(v))`, instead of just `let v = X.get(); || X.set(v)`, which is far "
"less ergonomic (and behaves subtly differently). This is the reason I waited "
"with this RFC until that RFC was merged and stabilized."
msgstr ""
