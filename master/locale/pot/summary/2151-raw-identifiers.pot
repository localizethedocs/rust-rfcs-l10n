msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:44Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2151-raw-identifiers.md:1
msgid "Feature Name: `raw_identifiers`"
msgstr ""

#: src/2151-raw-identifiers.md:2
msgid "Start Date: 2017-09-14"
msgstr ""

#: src/2151-raw-identifiers.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2151](https://github.com/rust-lang/rfcs/pull/2151)"
msgstr ""

#: src/2151-raw-identifiers.md:4
msgid ""
"Rust Issue: [rust-lang/rust#48589](https://github.com/rust-lang/rust/"
"issues/48589)"
msgstr ""

#: src/2151-raw-identifiers.md:6
msgid "Summary"
msgstr ""

#: src/2151-raw-identifiers.md:9
msgid ""
"Add a raw identifier format `r#ident`, so crates written in future language "
"editions/versions can still use an older API that overlaps with new keywords."
msgstr ""

#: src/2151-raw-identifiers.md:12
msgid "Motivation"
msgstr ""

#: src/2151-raw-identifiers.md:15
msgid ""
"One of the primary examples of breaking changes in the edition RFC is to add "
"new keywords, and specifically `catch` is the first candidate. However, "
"since that's seeking crate compatibility across editions, this would leave a "
"crate in a newer edition unable to use `catch` identifiers in the API of a "
"crate in an older edition. [@matklad found](https://internals.rust-lang.org/"
"t/pre-rfc-raw-identifiers/5502/40) 28 crates using `catch` identifiers, some "
"public."
msgstr ""

#: src/2151-raw-identifiers.md:22
msgid ""
"A raw syntax that's _always_ an identifier would allow these to remain "
"compatible, so one can write `r#catch` where `catch`\\-as-identifier is "
"needed."
msgstr ""

#: src/2151-raw-identifiers.md:27
msgid "Guide-level explanation"
msgstr ""

#: src/2151-raw-identifiers.md:30
msgid ""
"Although some identifiers are reserved by the Rust language as keywords, it "
"is still possible to write them as raw identifiers using the `r#` prefix, "
"like `r#ident`.  When written this way, it will _always_ be treated as a "
"plain identifier equivalent to a bare `ident` name, never as a keyword."
msgstr ""

#: src/2151-raw-identifiers.md:35
msgid "For instance, the following is an erroneous use of the `match` keyword:"
msgstr ""

#: src/2151-raw-identifiers.md:51
msgid ""
"It can instead be written as `fn r#match(needle: &str, haystack: &str)`, "
"using the `r#match` raw identifier, and the compiler will accept this as a "
"true `match` function."
msgstr ""

#: src/2151-raw-identifiers.md:55
msgid ""
"Generally when defining items, you should just avoid keywords altogether and "
"choose a different name.  Raw identifiers require the `r#` prefix every time "
"they are mentioned, making them cumbersome to both the developer and users. "
"Usually an alternate is preferable: `crate` -> `krate`, `const` -> "
"`constant`, etc."
msgstr ""

#: src/2151-raw-identifiers.md:61
msgid ""
"However, new Rust editions may add to the list of reserved keywords, making "
"a formerly legal identifier now interpreted otherwise. Since compatibility "
"is maintained between crates of different editions, this could mean that "
"code written in a new edition might not be able to name an identifier in the "
"API of another crate. Using a raw identifier, it can still be named and used."
msgstr ""

#: src/2151-raw-identifiers.md:68
msgid "//! baseball.rs in edition 2015\n"
msgstr ""

#: src/2151-raw-identifiers.md:78
msgid "//! main.rs in edition 2018 -- `catch` is now a keyword!\n"
msgstr ""

#: src/2151-raw-identifiers.md:87
msgid "Reference-level explanation"
msgstr ""

#: src/2151-raw-identifiers.md:90
msgid ""
"The syntax for identifiers allows an optional `r#` prefix for a raw "
"identifier, otherwise following the normal identifier rules.  Raw "
"identifiers are always interpreted as plain identifiers and never as "
"keywords, regardless of context. They are also treated equivalent to an "
"identifier that wasn't raw -- for instance, it's perfectly legal to write:"
msgstr ""

#: src/2151-raw-identifiers.md:101
msgid "Drawbacks"
msgstr ""

#: src/2151-raw-identifiers.md:104
msgid "New syntax is always scary/noisy/etc."
msgstr ""

#: src/2151-raw-identifiers.md:105
msgid ""
"It might not be intuitively \"raw\" to a user coming upon this the first "
"time."
msgstr ""

#: src/2151-raw-identifiers.md:107
msgid "Rationale and Alternatives"
msgstr ""

#: src/2151-raw-identifiers.md:110
msgid ""
"If we don't have any way to refer to identifiers that were legal in prior "
"editions, but later became keywords, then this may hurt interoperability "
"between crates of different editions. The `r#ident` syntax enables "
"interoperability, and will hopefully invoke some intuition of being raw, "
"similar to raw strings."
msgstr ""

#: src/2151-raw-identifiers.md:116
msgid ""
"The `br#ident` syntax is also possible, but I see no advantage over "
"`r#ident`. Identifiers don't need the same kind of distinction as `str` and "
"`[u8]`."
msgstr ""

#: src/2151-raw-identifiers.md:119
msgid ""
"A small possible alternative is to also terminate it like `r#ident#`, which "
"could allow non-identifier characters to be part of a raw identifier.  This "
"could take a cue from raw strings and allow repetition for internal `#`, "
"like `r##my #1 ident##`.  That doesn't allow a leading `#` or `\"` though."
msgstr ""

#: src/2151-raw-identifiers.md:124
msgid ""
"A different possibility is to use backticks for a string-like `` `ident` ``, "
"like [Kotlin](https://kotlinlang.org/docs/reference/grammar.html), [Scala]"
"(https://www.scala-lang.org/files/archive/spec/2.13/01-lexical-syntax."
"html#identifiers), and [Swift](https://developer.apple.com/library/content/"
"documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure."
"html).  If it allows non-identifier chars, it could embrace escapes like "
"`\\u`, and have a raw-string-identifier `` r`slash\\ident` `` and even "
"``r#`tick`ident`#``.  However, backtick identifiers are annoying to write in "
"markdown. (e.g. ``` `` `ident` `` ```)"
msgstr ""

#: src/2151-raw-identifiers.md:130
msgid ""
"Backslashes could connote escaping identifiers, like `\\ident`, perhaps "
"surrounded like `\\ident\\`, `\\{ident}`, etc.  However, the infix RFC #1579 "
"currently seems to be leaning towards `\\op` syntax already."
msgstr ""

#: src/2151-raw-identifiers.md:134
msgid ""
"Alternatives which already start legal tokens, like [C#](https://msdn."
"microsoft.com/en-us/library/aa664670(v=vs.71).aspx)'s `@ident`, [Dart]"
"(https://www.dartlang.org/guides/language/language-tour#symbols)'s `#ident`, "
"or alternate prefixes like `identifier#catch`, all break Macros 1.0 as "
"[@kennytm demonstrated](https://internals.rust-lang.org/t/pre-rfc-raw-"
"identifiers/5502/28):"
msgstr ""

#: src/2151-raw-identifiers.md:151
msgid ""
"C# allows Unicode escapes directly in identifiers, which also separates them "
"from keywords, so both `@catch` and `cl\\u0061ss` are valid `class` "
"identifiers. Java also allows Unicode escapes, but they don't avoid keywords."
msgstr ""

#: src/2151-raw-identifiers.md:155
msgid ""
"For some new keywords, there may be contextual mitigations. In the case of "
"`catch`, it couldn't be a fully contextual keyword because `catch { ... }` "
"could be a struct literal. That context might be worked around with a path, "
"like `old_edition::catch { ... }` to use an identifier instead. Contexts "
"that don't make sense for a `catch` expression can just be identifiers, like "
"`foo.catch()`. However, this might not be possible for all future keywords."
msgstr ""

#: src/2151-raw-identifiers.md:162
msgid ""
"There might also be a need for raw keywords in the other direction, e.g. so "
"the older edition can still use the new `catch` functionality somehow. I "
"think this particular case is already served well enough by `do catch { ... }"
"`, if we choose to stabilize it that way.  Perhaps `br#keyword` could be "
"used for this, but that may not be a good intuitive relationship."
msgstr ""

#: src/2151-raw-identifiers.md:175
msgid "Unresolved questions"
msgstr ""

#: src/2151-raw-identifiers.md:178
msgid "Do macros need any special care with such identifier tokens?"
msgstr ""

#: src/2151-raw-identifiers.md:179
msgid ""
"Should diagnostics use the `r#` syntax when printing identifiers that "
"overlap keywords?"
msgstr ""

#: src/2151-raw-identifiers.md:180
msgid ""
"Does rustdoc need to use the `r#` syntax? e.g. to document `pub use "
"old_edition::*`"
msgstr ""
