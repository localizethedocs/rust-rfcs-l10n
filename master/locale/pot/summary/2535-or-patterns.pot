msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:05Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2535-or-patterns.md:1
msgid "Feature Name: `or_patterns`"
msgstr ""

#: src/2535-or-patterns.md:2
msgid "Start Date: 2018-08-29"
msgstr ""

#: src/2535-or-patterns.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2535](https://github.com/rust-lang/rfcs/pull/2535)"
msgstr ""

#: src/2535-or-patterns.md:4
msgid ""
"Rust Issue: [rust-lang/rust#54883](https://github.com/rust-lang/rust/"
"issues/54883)"
msgstr ""

#: src/2535-or-patterns.md:6
msgid "Summary"
msgstr ""

#: src/2535-or-patterns.md:9
msgid ""
"Allow `|` to be arbitrarily nested within a pattern such that `Some(A(0) | "
"B(1 | 2))` becomes a valid pattern."
msgstr ""

#: src/2535-or-patterns.md:12
msgid "Motivation"
msgstr ""

#: src/2535-or-patterns.md:15
msgid ""
"Nothing this RFC proposes adds anything with respect to expressive power. "
"Instead, the aim is to make the power we already have more easy to wield. "
"For example, we wish to improve ergonomics, readability, and the mental "
"model."
msgstr ""

#: src/2535-or-patterns.md:19
msgid "Don't repeat yourself"
msgstr ""

#: src/2535-or-patterns.md:21
msgid "Consider an example match arm such as (1):"
msgstr ""

#: src/2535-or-patterns.md:27
msgid "Here, we are repeating `Some($pat)` three times."
msgstr ""

#: src/2535-or-patterns.md:29
msgid "Compare (1) to how we could have written this with this RFC (2):"
msgstr ""

#: src/2535-or-patterns.md:35
msgid ""
"We can see that this is clearly shorter and that the amount of extra work we "
"have to do scales linearly with the number of inner variants we mention. The "
"ability to nest patterns in this way therefore results in improved writing "
"ergonomics."
msgstr ""

#: src/2535-or-patterns.md:40
msgid "Mental model"
msgstr ""

#: src/2535-or-patterns.md:42
msgid ""
"However, as we know, code is read more than it is written. So are we trading "
"readability for increased ergonomics? We believe this is not the case. "
"Instead, this RFC aims to improve the readability of code by reducing the "
"amount of redundant information that needs to be scanned."
msgstr ""

#: src/2535-or-patterns.md:47
msgid ""
"In addition, we aim to more closely align Rust with the mental model that "
"_humans_ have and how we usually speak and communicate."
msgstr ""

#: src/2535-or-patterns.md:50
msgid ""
"Consider that you wanted to ask someone what the _colour_ of their _car_ "
"was. Would you be more inclined to ask:"
msgstr ""

#: src/2535-or-patterns.md:53
msgid "Is your car red, white, or blue?"
msgstr ""

#: src/2535-or-patterns.md:55
msgid "Or would you instead ask:"
msgstr ""

#: src/2535-or-patterns.md:57
msgid "Is your car red, your car white, or your car blue?"
msgstr ""

#: src/2535-or-patterns.md:63
msgid ""
"When researching for this RFC; many people were asked and all of them "
"preferred the first alternative. This user testing was done on both "
"programmers and non-programmers alike and included speakers of: English, "
"German (2) Swedish (3), French (2), Portuguese (1), Spanish (2), Farsi (3), "
"Finnish (1), Esperanto (1), and Japanese (1)."
msgstr ""

#: src/2535-or-patterns.md:69
msgid ""
"Thus, we conjecture that it's more common for humans to not distribute and "
"to instead use something akin to _conjunctive normal form_ ([CNF](https://en."
"wikipedia.org/wiki/Conjunctive_normal_form)) when communicating. A likely "
"consequence of this is that a common way to understand snippet (1) "
"formulated in _disjunctive normal form_ ([DNF](https://en.wikipedia.org/wiki/"
"Disjunctive_normal_form)) is to first mentally reconstruct it into CNF and "
"then understand the implications of the pattern."
msgstr ""

#: src/2535-or-patterns.md:75
msgid ""
"By allowing users to encode their logic in the way they think instead of "
"going through more indirect routes, we can improve the understandability of "
"code."
msgstr ""

#: src/2535-or-patterns.md:78
msgid "Reducing complexity with uniformity"
msgstr ""

#: src/2535-or-patterns.md:80
msgid ""
"A principal way in which programming languages accumulate complexity is by "
"adding more and more rules that a programmer needs to keep in their head to "
"write or understand what a program does. A consequence of this is that often "
"times, caveats and corner cases make for a language that is harder to learn, "
"understand, and write in. To avoid such caveats, it is thus imperative that "
"we should try to keep the language more uniform rather than less. This is an "
"important means through which it becomes possible to give users more "
"expressiveness but at the same time limit the cost each feature takes from "
"our complexity budget."
msgstr ""

#: src/2535-or-patterns.md:90
msgid ""
"With this RFC, we try to reduce the complexity of the language by extending "
"a feature which already exists, and which many users already know about, to "
"another place. In a sense, giving the user more capabilities results in a "
"negative increase in complexity."
msgstr ""

#: src/2535-or-patterns.md:97
msgid ""
"In concrete terms, where before we only allowed a pattern of the form `pat | "
"pat` at the top level of `match` and [similar constructs](https://github.com/"
"rust-lang/rfcs/pull/2175), which special cased the language, we now allow "
"`pat | pat` anywhere a pattern may occur whereby we simplify the ruleset of "
"the language. In fact, there are already users that try this expecting it to "
"work but then find out that it does not."
msgstr ""

#: src/2535-or-patterns.md:104
msgid ""
"Furthermore, allowing `pat | pat` in the pattern grammar also allows macros "
"to produce disjunctions such as `$p | $q`."
msgstr ""

#: src/2535-or-patterns.md:107
msgid "Real world use cases"
msgstr ""

#: src/2535-or-patterns.md:109
msgid ""
"This RFC wouldn't be complete without concrete use cases which it would "
"facilitate. While there are not an overabundance of cases where `pat | pat` "
"would help, there are some where it would. Let's go through a few of them."
msgstr ""

#: src/2535-or-patterns.md:115
msgid ""
"One example which was raised in the [precursor](https://github.com/rust-lang/"
"rfcs/blob/de235887a80555427314c7eb25c6214523d50cce/text/0000-pipe-in-"
"patterns.md) to this RFC was building a state machine which is iterating "
"through `chars_indices`:"
msgstr ""

#: src/2535-or-patterns.md:120
msgid "' '"
msgstr ""

#: src/2535-or-patterns.md:120
msgid "'\\n'"
msgstr ""

#: src/2535-or-patterns.md:120
msgid "'\\r'"
msgstr ""

#: src/2535-or-patterns.md:120
msgid "'\\u{21A1}'"
msgstr ""

#: src/2535-or-patterns.md:121
msgid "// Change state\n"
msgstr ""

#: src/2535-or-patterns.md:124
msgid "// Look at char\n"
msgstr ""

#: src/2535-or-patterns.md:132
msgid ""
"Other examples are listed in the equivalent [GHC proposal](https://github."
"com/osa1/ghc-proposals/blob/77ee8e615aa28fbf2d0ef2be876a852c4e63c53b/"
"proposals/0000-or-patterns.rst#real-world-examples)."
msgstr ""

#: src/2535-or-patterns.md:134
msgid ""
"Another example which was provided in the [precursor](https://github.com/"
"rust-lang/rfcs/blob/de235887a80555427314c7eb25c6214523d50cce/text/0000-pipe-"
"in-patterns.md) RFC was:"
msgstr ""

#: src/2535-or-patterns.md:148
msgid "Other cases where this feature was requested include:"
msgstr ""

#: src/2535-or-patterns.md:149
msgid "<https://github.com/rust-lang/rust/issues/15219>"
msgstr ""

#: src/2535-or-patterns.md:150
msgid "<https://github.com/rust-lang/rust/issues/14516>"
msgstr ""

#: src/2535-or-patterns.md:154
msgid ""
"Another use case due to [@alercah](https://discordapp.com/"
"channels/442252698964721669/448237931136679936/483325957130813440) is:"
msgstr ""

#: src/2535-or-patterns.md:166
msgid "Some further examples found with sourcegraph include:"
msgstr ""

#: src/2535-or-patterns.md:168
msgid ""
"From [cc-rs](https://github.com/alexcrichton/cc-rs/"
"blob/74ce606aa227a30a97d7c1990c1e8d322e01c6d8/src/lib.rs#L1307-L1319):"
msgstr ""

#: src/2535-or-patterns.md:174
msgid "\"-stdlib=lib{}\""
msgstr ""

#: src/2535-or-patterns.md:182
msgid ""
"From [capnproto](https://github.com/capnproto/capnproto-rust/"
"blob/35027494bb6e741aa478597358bac8ac92108a30/capnp/src/private/layout."
"rs#L1979-L2002):"
msgstr ""

#: src/2535-or-patterns.md:185
msgid "// Check whether the size is compatible.\n"
msgstr ""

#: src/2535-or-patterns.md:194
msgid ""
"From [chrono](https://github.com/chronotope/chrono/"
"blob/94b43fa2e8bd43e7f42bb5b67afd1c3415b27683/src/format/parsed.rs#L271-"
"L308):"
msgstr ""

#: src/2535-or-patterns.md:207
msgid ""
"From maidsafe's [routing](https://github.com/maidsafe/routing/"
"blob/0081a48d59e4fe3fb86b20da1fceb8f757855112/src/states/node.rs#L2138-"
"L2180):"
msgstr ""

#: src/2535-or-patterns.md:217
msgid ""
"Also from [routing](https://github.com/maidsafe/routing/"
"blob/0081a48d59e4fe3fb86b20da1fceb8f757855112/src/states/node.rs#L2215-"
"L2245):"
msgstr ""

#: src/2535-or-patterns.md:228
msgid ""
"From [termion](https://github.com/redox-os/termion/blob/"
"d2945cd36c452824aeabd5d7c13980d9567eb8a2/src/input.rs#L143-L153):"
msgstr ""

#: src/2535-or-patterns.md:236
msgid "b'\\n'"
msgstr ""

#: src/2535-or-patterns.md:236
msgid "b'\\r'"
msgstr ""

#: src/2535-or-patterns.md:242
msgid "Some other use cases are:"
msgstr ""

#: src/2535-or-patterns.md:244
msgid "In code using git2-rs:"
msgstr ""

#: src/2535-or-patterns.md:254
msgid ""
"From [debcargo](https://salsa.debian.org/rust-team/debcargo/"
"blob/4355097810264644cb08ddaa8f7464d5887275f1/src/debian/dependency."
"rs#L234-291):"
msgstr ""

#: src/2535-or-patterns.md:259
msgid "\"Unrepresentable dependency version predicate: {} {:?}\""
msgstr ""

#: src/2535-or-patterns.md:279
msgid "From rustc, we have:"
msgstr ""

#: src/2535-or-patterns.md:281
msgid "In `src/librustc_mir/interpret/eval_context.rs`:"
msgstr ""

#: src/2535-or-patterns.md:286
msgid "In `src/librustc_mir/util/borrowck_errors.rs`:"
msgstr ""

#: src/2535-or-patterns.md:288
msgid "\"array\""
msgstr ""

#: src/2535-or-patterns.md:291
msgid "In `src/librustc/middle/reachable.rs`:"
msgstr ""

#: src/2535-or-patterns.md:296
msgid "In `src/librustc/infer/error_reporting/mod.rs`:"
msgstr ""

#: src/2535-or-patterns.md:298
msgid "\"body\""
msgstr ""

#: src/2535-or-patterns.md:301
msgid "In `src/libfmt_macros/lib.rs`:"
msgstr ""

#: src/2535-or-patterns.md:303
msgid "'>'"
msgstr ""

#: src/2535-or-patterns.md:303
msgid "'<'"
msgstr ""

#: src/2535-or-patterns.md:303
msgid "'^'"
msgstr ""

#: src/2535-or-patterns.md:306
msgid "In `src/librustc/traits/select.rs`:"
msgstr ""

#: src/2535-or-patterns.md:311
msgid "In `src/librustc_typeck/check/mod.rs`:"
msgstr ""

#: src/2535-or-patterns.md:320
msgid "In `src/tools/cargo/src/cargo/sources/path.rs`:"
msgstr ""

#: src/2535-or-patterns.md:322
msgid "\"Cargo.lock\""
msgstr ""

#: src/2535-or-patterns.md:322
msgid "\"target\""
msgstr ""

#: src/2535-or-patterns.md:325
msgid "In `src/libsyntax_ext/format_foreign.rs`:"
msgstr ""

#: src/2535-or-patterns.md:327
msgid "'h'"
msgstr ""

#: src/2535-or-patterns.md:327
msgid "'l'"
msgstr ""

#: src/2535-or-patterns.md:327
msgid "'L'"
msgstr ""

#: src/2535-or-patterns.md:327
msgid "'z'"
msgstr ""

#: src/2535-or-patterns.md:327
msgid "'j'"
msgstr ""

#: src/2535-or-patterns.md:327
msgid "'t'"
msgstr ""

#: src/2535-or-patterns.md:327
msgid "'q'"
msgstr ""

#: src/2535-or-patterns.md:337
msgid "// NOTE: Rust doesn't support this.\n"
msgstr ""

#: src/2535-or-patterns.md:345
msgid "In `src/libsyntax/parse/token.rs`:"
msgstr ""

#: src/2535-or-patterns.md:351
msgid "Guide-level explanation"
msgstr ""

#: src/2535-or-patterns.md:354
msgid ""
"Simply put, `$p | $q` where `$p` and `$q` are some patterns is now itself a "
"legal pattern."
msgstr ""

#: src/2535-or-patterns.md:357
msgid "This means that you may for example write:"
msgstr ""

#: src/2535-or-patterns.md:374
msgid ""
"Because `$p | $q` is itself a pattern, this means that you can nest "
"arbitrarily:"
msgstr ""

#: src/2535-or-patterns.md:385
msgid ""
"Note that the operator `|` has a low precedence. This means that if you want "
"the same outcome as `foo @ 1 | foo @ 2 | foo @ 3`, you have to write `foo @ "
"(1 | 2 | 3)` instead of writing `foo @ 1 | 2 | 3`. This is discussed in the "
"[rationale](#rationale-and-alternatives)."
msgstr ""

#: src/2535-or-patterns.md:390
msgid "You can also use `p | q` in:"
msgstr ""

#: src/2535-or-patterns.md:392
msgid "`if let` expressions:"
msgstr ""

#: src/2535-or-patterns.md:400
msgid "`while let` expressions:"
msgstr ""

#: src/2535-or-patterns.md:408
msgid "`let` statements:"
msgstr ""

#: src/2535-or-patterns.md:414
msgid "In this case, the pattern must be irrefutable as `Ok(x) | Err(x)` is."
msgstr ""

#: src/2535-or-patterns.md:416
msgid "`fn` arguments:"
msgstr ""

#: src/2535-or-patterns.md:424
msgid "Here too, the pattern must be irrefutable."
msgstr ""

#: src/2535-or-patterns.md:426
msgid "closure arguments:"
msgstr ""

#: src/2535-or-patterns.md:432
msgid ""
"Notice that in this case, we have to wrap the pattern in parenthesis. This "
"restriction is currently enforced to avoid backtracking but may possibly be "
"lifted in the future based on other developments in the grammar."
msgstr ""

#: src/2535-or-patterns.md:436
msgid "macros by example:"
msgstr ""

#: src/2535-or-patterns.md:446
msgid ""
"Here we must wrap the pattern in parenthesis since `$p:pat | $q:pat` is "
"already legal in patterns."
msgstr ""

#: src/2535-or-patterns.md:449
msgid "Reference-level explanation"
msgstr ""

#: src/2535-or-patterns.md:452
msgid "Grammar"
msgstr ""

#: src/2535-or-patterns.md:454
msgid ""
"We parameterize the `pat` grammar by the choice whether to allow top level "
"`pat | pat`. We then change the pattern grammar to:"
msgstr ""

#: src/2535-or-patterns.md:459 src/2535-or-patterns.md:479
msgid "'|'"
msgstr ""

#: src/2535-or-patterns.md:464 src/2535-or-patterns.md:770
msgid "\"(\""
msgstr ""

#: src/2535-or-patterns.md:464 src/2535-or-patterns.md:770
msgid "\")\""
msgstr ""

#: src/2535-or-patterns.md:469
msgid ""
"Here `|` has the lowest precedence. In particular, the operator `@` binds "
"more tightly than `|` does. Thus, `i @ p | q` associates as `(i @ p) | q` as "
"opposed to `i @ (p | q)`."
msgstr ""

#: src/2535-or-patterns.md:473
msgid ""
"Note: `pat<T>` does not entail that the grammar of Rust is context sensitive "
"because we \"monomorphize\" the parameterization below."
msgstr ""

#: src/2535-or-patterns.md:476
msgid "We then introduce a production:"
msgstr ""

#: src/2535-or-patterns.md:482
msgid ""
"We then change the grammar of `let` statements to (as compared to [RFC 2175]"
"(https://github.com/rust-lang/rfcs/pull/2175)):"
msgstr ""

#: src/2535-or-patterns.md:485
msgid "';'"
msgstr ""

#: src/2535-or-patterns.md:488
msgid "We change the grammar of `if let` expressions to:"
msgstr ""

#: src/2535-or-patterns.md:491 src/2535-or-patterns.md:497
msgid "'='"
msgstr ""

#: src/2535-or-patterns.md:494
msgid "And for `while let` expressions:"
msgstr ""

#: src/2535-or-patterns.md:500
msgid "For `for` loop expressions we now have:"
msgstr ""

#: src/2535-or-patterns.md:506
msgid "For `match` expressions we now have:"
msgstr ""

#: src/2535-or-patterns.md:509
msgid "'{'"
msgstr ""

#: src/2535-or-patterns.md:509
msgid "'}'"
msgstr ""

#: src/2535-or-patterns.md:510
msgid "','"
msgstr ""

#: src/2535-or-patterns.md:517
msgid ""
"In other words, in all of the contexts where a pattern is currently "
"accepted, the compiler will now accept pattern alternations of form `p | q` "
"where `p` and `q` are arbitrary patterns."
msgstr ""

#: src/2535-or-patterns.md:521
msgid "For the patterns of `fn` arguments we now have:"
msgstr ""

#: src/2535-or-patterns.md:524
msgid "':'"
msgstr ""

#: src/2535-or-patterns.md:527
msgid "For closures we now have:"
msgstr ""

#: src/2535-or-patterns.md:533
msgid ""
"Finally, `pat` macro fragment specifiers will also match the "
"`pat<no_top_alt>` production as opposed to `pat<allow_top_alt>`."
msgstr ""

#: src/2535-or-patterns.md:536
msgid "Error messages"
msgstr ""

#: src/2535-or-patterns.md:538
msgid ""
"As previously noted, the precedence of the operator `|` is lower than that "
"of the operator `@`. This results in `i @ p | q` being interpreted as `(i @ "
"p) | q`. In turn, this would result in an error because `i` is not defined "
"in all alternations. An example:"
msgstr ""

#: src/2535-or-patterns.md:551
msgid "This would result in:"
msgstr ""

#: src/2535-or-patterns.md:563
msgid ""
"However, it is quite likely that a user who wrote `i @ p | q` wanted the "
"semantics of `i @ (p | q)` because it would be the only thing that would be "
"a well formed pattern. To guide the user on the way, we recommend special "
"casing the error message for such circumstances with for example:"
msgstr ""

#: src/2535-or-patterns.md:583
msgid ""
"The particular design of such an error message is left open to "
"implementations."
msgstr ""

#: src/2535-or-patterns.md:585
msgid "Static semantics"
msgstr ""

#: src/2535-or-patterns.md:587
msgid ""
"Given a pattern `p | q` at some depth for some arbitrary patterns `p` and "
"`q`, the pattern is considered ill-formed if:"
msgstr ""

#: src/2535-or-patterns.md:590
msgid ""
"the type inferred for `p` does not unify with the type inferred for `q`, or"
msgstr ""

#: src/2535-or-patterns.md:591
msgid "the same set of bindings are not introduced in `p` and `q`, or"
msgstr ""

#: src/2535-or-patterns.md:592
msgid ""
"the type of any two bindings with the same name in `p` and `q` do not unify "
"with respect to types or binding modes."
msgstr ""

#: src/2535-or-patterns.md:597
msgid ""
"Unification of types is in all instances aforementioned exact and implicit "
"[type coercions](https://doc.rust-lang.org/reference/type-coercions.html) do "
"not apply."
msgstr ""

#: src/2535-or-patterns.md:600
msgid ""
"When type checking an expression `match e_s { a_1 => e_1, ... a_n => e_n }`, "
"for each match arm `a_i` which contains a pattern of form `p_i | q_i`, the "
"pattern `p_i | q_i` is considered ill formed if, at the depth `d` where it "
"exists the fragment of `e_s` at depth `d`, the type of the expression "
"fragment does not unify with `p_i | q_i`."
msgstr ""

#: src/2535-or-patterns.md:606
msgid ""
"With respect to exhaustiveness checking, a pattern `p | q` is considered to "
"cover `p` as well as `q`. For some constructor `c(x, ..)` the distributive "
"law applies such that `c(p | q, ..rest)` covers the same set of value as "
"`c(p, ..rest) | c(q, ..rest)` does. This can be applied recursively until "
"there are no more nested patterns of form `p | q` other than those that "
"exist at the top level."
msgstr ""

#: src/2535-or-patterns.md:613
msgid ""
"Note that by _\"constructor\"_ we do not refer to tuple struct patterns, but "
"rather we refer to a pattern for any product type. This includes enum "
"variants, tuple structs, structs with named fields, arrays, tuples, and "
"slices."
msgstr ""

#: src/2535-or-patterns.md:618
msgid "Dynamic semantics"
msgstr ""

#: src/2535-or-patterns.md:620
msgid ""
"The dynamic semantics of pattern matching a scrutinee expression `e_s` "
"against a pattern `c(p | q, ..rest)` at depth `d` where `c` is some "
"constructor, `p` and `q` are arbitrary patterns, and `rest` is optionally "
"any remaining potential factors in `c`, is defined as being the same as that "
"of `c(p, ..rest) | c(q, ..rest)`."
msgstr ""

#: src/2535-or-patterns.md:626
msgid "Implementation notes"
msgstr ""

#: src/2535-or-patterns.md:628
msgid ""
"With respect to both static and dynamic semantics, it is always valid to "
"first desugar a pattern `c(p | q)` in CNF to its equivalent form in DNF, i."
"e. `c(p) | c(q)`."
msgstr ""

#: src/2535-or-patterns.md:632
msgid ""
"However, implementing `c(p | q)` in terms of a pure desugaring to `c(p) | "
"c(q)` may not be optimal as the desugaring can result in multiplicative blow-"
"up of patterns. An example of such blow up can be seen with:"
msgstr ""

#: src/2535-or-patterns.md:642
msgid "If we expanded this naively to DNF we would get:"
msgstr ""

#: src/2535-or-patterns.md:666
msgid ""
"Instead, it is more likely that a one-step case analysis will be more "
"efficient."
msgstr ""

#: src/2535-or-patterns.md:668
msgid ""
"Which implementation technique to use is left open to each Rust compiler."
msgstr ""

#: src/2535-or-patterns.md:670
msgid "Drawbacks"
msgstr ""

#: src/2535-or-patterns.md:673
msgid ""
"Some parsers will have to be rewritten by a tiny bit; We do this with any "
"syntactic change in the language so there should not be any problem."
msgstr ""

#: src/2535-or-patterns.md:677
msgid "Rationale and alternatives"
msgstr ""

#: src/2535-or-patterns.md:680
msgid ""
"As for why the change as proposed in this RFC should be done, it is "
"discussed in the [motivation](#motivation)."
msgstr ""

#: src/2535-or-patterns.md:683
msgid "Syntax"
msgstr ""

#: src/2535-or-patterns.md:685
msgid ""
"Since we already use `|` for alternation at the top level, the only "
"consistent operator syntax for alternations in nested patterns would be `|`. "
"Therefore, there are not many design choices to make with respect to _how_ "
"this change should be done rather than _if_."
msgstr ""

#: src/2535-or-patterns.md:690
msgid "Precedence"
msgstr ""

#: src/2535-or-patterns.md:692
msgid ""
"With respect to the precedence of `|`, we cannot interpret `i @ p | q` as `i "
"@ (p | q)` because it is already legal to write `i @ p | j @ q` at the top "
"level of a pattern. Therefore, if we say that `|` binds more tightly, then "
"`i @ p | j @ q` will associate as `i @ (p | j @ q)` which as a different "
"meaning than what we currently have, thus causing a breaking change."
msgstr ""

#: src/2535-or-patterns.md:698
msgid ""
"And even if we could associate `i @ p | q` as `i @ (p | q)` there is a good "
"reason why we should not. Simply put, we should understand `@` as a "
"pattern / set intersection operator and the operator `|` as the union "
"operator. This is analogous to multiplication and addition as well as "
"conjunction and disjunction in logic. In these fields, it is customary for "
"multiplication and conjunction to bind more tightly. That is, we interpret "
"`a * b + c` as `(a * b) + c` and not `a * (b + c)`. Similarly, we interpret "
"`p ∧ q ∨ r` as `(p ∧ q) ∨ r` and not `p ∧ (q ∨ r)`."
msgstr ""

#: src/2535-or-patterns.md:707
msgid "Leading `|`"
msgstr ""

#: src/2535-or-patterns.md:709
msgid ""
"The only real choice that we do have to make is whether the new addition to "
"the pattern grammar should be `pat : .. | pat \"|\" pat ;` or if it instead "
"should be `pat : .. | \"|\"? pat \"|\" pat ;`. We have chosen the former for "
"4 reasons:"
msgstr ""

#: src/2535-or-patterns.md:713
msgid ""
"If we chose the former we can later change to the latter but not vice versa. "
"This is thus the conservative choice."
msgstr ""

#: src/2535-or-patterns.md:716
msgid "There is precedent for such a decision due to [OCaml](#ocaml)."
msgstr ""

#: src/2535-or-patterns.md:718
msgid ""
"The benefit to macros is dubious as they don't have to produce leading "
"alternations."
msgstr ""

#: src/2535-or-patterns.md:721
msgid "Leading alternations inside patterns is considered poor style."
msgstr ""

#: src/2535-or-patterns.md:723
msgid ""
"However, there is one notable advantage to permitting leading `|` in nested "
"pattern:"
msgstr ""

#: src/2535-or-patterns.md:726
msgid ""
"Libraries or tools such as `syn` will have _slightly_ easier time parsing "
"the grammar of Rust."
msgstr ""

#: src/2535-or-patterns.md:729
msgid "`fn` arguments"
msgstr ""

#: src/2535-or-patterns.md:731
msgid ""
"In this RFC, we allow `p | q` inside patterns of `fn` arguments. The "
"rationale for this is simply consistency with `let` which also permit these "
"and did so before this RFC at the top level with [RFC 2175](https://github."
"com/rust-lang/rfcs/pull/2175)."
msgstr ""

#: src/2535-or-patterns.md:735
msgid "Macros and closures"
msgstr ""

#: src/2535-or-patterns.md:737
msgid ""
"See the section on [unresolved](#unresolved-questions) questions for a brief "
"discussion."
msgstr ""

#: src/2535-or-patterns.md:739
msgid "Prior art"
msgstr ""

#: src/2535-or-patterns.md:742
msgid "CSS4 selectors"
msgstr ""

#: src/2535-or-patterns.md:746
msgid ""
"In [CSS4](https://drafts.csswg.org/selectors/#matches) (draft proposal), it "
"is possible to write a selector `div > *:matches(ul, ol)` which is "
"equivalent to `div > ul, div > ol`. The moral equivalent of this in Rust "
"would be: `Div(Ul | Ol)`."
msgstr ""

#: src/2535-or-patterns.md:750
msgid "Regular expressions"
msgstr ""

#: src/2535-or-patterns.md:754
msgid ""
"Most [regular expression](https://en.wikipedia.org/wiki/Regular_expression) "
"formalisms support at least the following operations (where `a`, `b`, and "
"`c` are arbitrary regexes):"
msgstr ""

#: src/2535-or-patterns.md:757
msgid ""
"Concatenation: _\"`a` followed by `b`\"_. Commonly written by just saying "
"`ab`."
msgstr ""

#: src/2535-or-patterns.md:760
msgid ""
"Alternation: _\"first match `a` or otherwise match `b`\"_ Commonly written "
"as `a | b`. `|` binds more loosely than concatenation."
msgstr ""

#: src/2535-or-patterns.md:764
msgid ""
"Grouping: used to define the scope of what operators apply to. Commonly "
"written as `(a)`."
msgstr ""

#: src/2535-or-patterns.md:767
msgid "Formally, the minimal formalism we need is:"
msgstr ""

#: src/2535-or-patterns.md:770
msgid "\"|\""
msgstr ""

#: src/2535-or-patterns.md:773
msgid "Given this formalism, it is then possible to encode a regex:"
msgstr ""

#: src/2535-or-patterns.md:779
msgid "By the law of distributivity, we can rewrite this as:"
msgstr ""

#: src/2535-or-patterns.md:785
msgid "OCaml"
msgstr ""

#: src/2535-or-patterns.md:790
msgid ""
"[This is supported](https://caml.inria.fr/pub/docs/manual-ocaml/patterns."
"html#sec108) in OCaml. An example from \"Real World OCaml\" is:"
msgstr ""

#: src/2535-or-patterns.md:796
msgid "\"ml\""
msgstr ""

#: src/2535-or-patterns.md:796
msgid "\"mli\""
msgstr ""

#: src/2535-or-patterns.md:800
msgid "While OCaml will permit the following:"
msgstr ""

#: src/2535-or-patterns.md:809
msgid "the OCaml compiler will reject:"
msgstr ""

#: src/2535-or-patterns.md:814
msgid "(* Note in particular the leading | in Some(..). *)"
msgstr ""

#: src/2535-or-patterns.md:818
msgid ""
"We have chosen to impose the same restriction as OCaml here with respect to "
"not allowing leading `|` in nested pattern alternations."
msgstr ""

#: src/2535-or-patterns.md:821
msgid "F\\#"
msgstr ""

#: src/2535-or-patterns.md:825
msgid ""
"A language which is quite similar to OCaml is F#. With respect to [pattern "
"matching](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/"
"pattern-matching), we may write:"
msgstr ""

#: src/2535-or-patterns.md:828
msgid ""
"```fsharp\n"
"let detectZeroOR point =\n"
"    match point with\n"
"    | (0, 0) | (0, _) | (_, 0) -> printfn \"Zero found.\"\n"
"    | _ -> printfn \"Both nonzero.\"\n"
"```"
msgstr ""

#: src/2535-or-patterns.md:835
msgid ""
"F# calls these \"OR pattern\"s and includes `pattern1 | pattern2` in the "
"pattern grammar."
msgstr ""

#: src/2535-or-patterns.md:838
msgid "Haskell"
msgstr ""

#: src/2535-or-patterns.md:842
msgid ""
"The [equivalent proposal](https://github.com/ghc-proposals/ghc-proposals/"
"pull/43) is currently being discussed for inclusion in Haskell."
msgstr ""

#: src/2535-or-patterns.md:845
msgid "Lisp"
msgstr ""

#: src/2535-or-patterns.md:849
msgid ""
"There is support for or-patterns in [various lisp libraries](https://"
"stackoverflow.com/a/3798659/1063961)."
msgstr ""

#: src/2535-or-patterns.md:851
msgid "Unresolved questions"
msgstr ""

#: src/2535-or-patterns.md:854
msgid ""
"Should we allow `top_pat` or `pat<allow_top_alt>` in `inferable_param` such "
"that closures permit `|Ok(x) | Err(x)|` without first wrapping in "
"parenthesis?"
msgstr ""

#: src/2535-or-patterns.md:857
msgid ""
"We defer this decision to stabilization as it may depend on experimentation. "
"Our current inclination is to keep the RFC as-is because the ambiguity is "
"not just for the compiler; for humans, it is likely also ambiguous and thus "
"harder to read."
msgstr ""

#: src/2535-or-patterns.md:862
msgid ""
"This also applies to functions which, although do not look as ambiguous, "
"benefit from better consistency with closures. With respect to function "
"arguments there's also the issue that not disambiguating with parenthesis "
"makes it less clear whether the type ascription applies to the or-pattern as "
"a whole or just the last alternative."
msgstr ""

#: src/2535-or-patterns.md:868
msgid ""
"Should the `pat` macro fragment specifier match `top_pat` in different Rust "
"editions or should it match `pat<no_top_alt>` as currently specified? We "
"defer such decisions to stabilization because it depends on the outcome of "
"crater runs to see what the extent of the breakage would be."
msgstr ""

#: src/2535-or-patterns.md:873
msgid ""
"The benefit of avoiding `pat<no_top_alt>` in as many places as possible "
"would both be grammatical consistency and fewer surprises for uses. The "
"drawbacks would be possible ambiguity or backtracking for closures and "
"breakage for macros."
msgstr ""
