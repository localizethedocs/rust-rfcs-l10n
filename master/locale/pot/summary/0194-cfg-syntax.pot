msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0194-cfg-syntax.md:1
msgid "Start Date: 2014-08-09"
msgstr ""

#: src/0194-cfg-syntax.md:2
msgid ""
"RFC PR #: [rust-lang/rfcs#194](https://github.com/rust-lang/rfcs/pull/194)"
msgstr ""

#: src/0194-cfg-syntax.md:3
msgid ""
"Rust Issue: [rust-lang/rust#17490](https://github.com/rust-lang/rust/"
"issues/17490)"
msgstr ""

#: src/0194-cfg-syntax.md:5
msgid "Summary"
msgstr ""

#: src/0194-cfg-syntax.md:7
msgid ""
"The `#[cfg(...)]` attribute provides a mechanism for conditional compilation "
"of items in a Rust crate. This RFC proposes to change the syntax of `#[cfg]` "
"to make more sense as well as enable expansion of the conditional "
"compilation system to attributes while maintaining a single syntax."
msgstr ""

#: src/0194-cfg-syntax.md:12
msgid "Motivation"
msgstr ""

#: src/0194-cfg-syntax.md:14
msgid ""
"In the current implementation, `#[cfg(...)]` takes a comma separated list of "
"`key`, `key = \"value\"`, `not(key)`, or `not(key = \"value\")`. An "
"individual `#[cfg(...)]` attribute \"matches\" if _all_ of the contained cfg "
"patterns match the compilation environment, and an item preserved if it "
"_either_ has no `#[cfg(...)]` attributes or _any_ of the `#[cfg(...)]` "
"attributes present match."
msgstr ""

#: src/0194-cfg-syntax.md:21
msgid "This is problematic for several reasons:"
msgstr ""

#: src/0194-cfg-syntax.md:23
msgid ""
"It is excessively verbose in certain situations. For example, implementing "
"the equivalent of `(a AND (b OR c OR d))` requires three separate attributes "
"and `a` to be duplicated in each."
msgstr ""

#: src/0194-cfg-syntax.md:26
msgid ""
"It differs from all other attributes in that all `#[cfg(...)]` attributes on "
"an item must be processed together instead of in isolation. This change will "
"move `#[cfg(...)]` closer to implementation as a normal syntax extension."
msgstr ""

#: src/0194-cfg-syntax.md:31
msgid "Detailed design"
msgstr ""

#: src/0194-cfg-syntax.md:33
msgid ""
"The `<p>` inside of `#[cfg(<p>)]` will be called a _cfg pattern_ and have a "
"simple recursive syntax:"
msgstr ""

#: src/0194-cfg-syntax.md:36
msgid ""
"`key` is a cfg pattern and will match if `key` is present in the compilation "
"environment."
msgstr ""

#: src/0194-cfg-syntax.md:38
msgid ""
"`key = \"value\"` is a cfg pattern and will match if a mapping from `key` to "
"`value` is present in the compilation environment. At present, key-value "
"pairs only exist for compiler defined keys such as `target_os` and `endian`."
msgstr ""

#: src/0194-cfg-syntax.md:42
msgid ""
"`not(<p>)` is a cfg pattern if `<p>` is and matches if `<p>` does not match."
msgstr ""

#: src/0194-cfg-syntax.md:43
msgid ""
"`all(<p>, ...)` is a cfg pattern if all of the comma-separated `<p>`s are "
"cfg patterns and all of them match."
msgstr ""

#: src/0194-cfg-syntax.md:45
msgid ""
"`any(<p>, ...)` is a cfg pattern if all of the comma-separated `<p>`s are "
"cfg patterns and any of them match."
msgstr ""

#: src/0194-cfg-syntax.md:48
msgid ""
"If an item is tagged with `#[cfg(<p>)]`, that item will be stripped from the "
"AST if the cfg pattern `<p>` does not match."
msgstr ""

#: src/0194-cfg-syntax.md:51
msgid "One implementation hazard is that the semantics of"
msgstr ""

#: src/0194-cfg-syntax.md:57
msgid ""
"will change from \"include `foo` if _either of_ `a` and `b` are present in "
"the compilation environment\" to \"include `foo` if _both of_ `a` and `b` "
"are present in the compilation environment\". To ease the transition, the "
"old semantics of multiple `#[cfg(...)]` attributes will be maintained as a "
"special case, with a warning. After some reasonable period of time, the "
"special case will be removed."
msgstr ""

#: src/0194-cfg-syntax.md:64
msgid ""
"In addition, `#[cfg(a, b, c)]` will be accepted with a warning and be "
"equivalent to `#[cfg(all(a, b, c))]`. Again, after some reasonable period of "
"time, this behavior will be removed as well."
msgstr ""

#: src/0194-cfg-syntax.md:68
msgid ""
"The `cfg!()` syntax extension will be modified to accept cfg patterns as "
"well. A `#[cfg_attr(<p>, <attr>)]` syntax extension will be added ([PR 16230]"
"(https://github.com/rust-lang/rust/pull/16230)) which will expand to "
"`#[<attr>]` if the cfg pattern `<p>` matches.  The test harness's "
"`#[ignore]` attribute will have its built-in cfg filtering functionality "
"stripped in favor of `#[cfg_attr(<p>, ignore)]`."
msgstr ""

#: src/0194-cfg-syntax.md:75
msgid "Drawbacks"
msgstr ""

#: src/0194-cfg-syntax.md:77
msgid ""
"While the implementation of this change in the compiler will be "
"straightforward, the effects on downstream code will be significant, "
"especially in the standard library."
msgstr ""

#: src/0194-cfg-syntax.md:81
msgid "Alternatives"
msgstr ""

#: src/0194-cfg-syntax.md:83
msgid ""
"`all` and `any` could be renamed to `and` and `or`, though I feel that the "
"proposed names read better with the function-like syntax and are consistent "
"with `Iterator::all` and `Iterator::any`."
msgstr ""

#: src/0194-cfg-syntax.md:87
msgid ""
"Issue [\\#2119](https://github.com/rust-lang/rust/issues/2119) proposed the "
"addition of `||` and `&&` operators and parentheses to the attribute syntax "
"to result in something like `#[cfg(a || (b && c)]`. I don't favor this "
"proposal since it would result in a major change to the attribute syntax for "
"relatively little readability gain."
msgstr ""

#: src/0194-cfg-syntax.md:93
msgid "Unresolved questions"
msgstr ""

#: src/0194-cfg-syntax.md:95
msgid ""
"How long should multiple `#[cfg(...)]` attributes on a single item be "
"forbidden? It should probably be at least until after 0.12 releases."
msgstr ""

#: src/0194-cfg-syntax.md:98
msgid ""
"Should we permanently keep the behavior of treating `#[cfg(a, b)]` as "
"`#[cfg(all(a, b))]`? It is the common case, and adding this interpretation "
"can reduce the noise level a bit. On the other hand, it may be a bit "
"confusing to read as it's not immediately clear if it will be processed as "
"`and(..)` or `all(..)`."
msgstr ""
