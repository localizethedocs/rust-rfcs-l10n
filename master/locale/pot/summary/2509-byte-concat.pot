msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:45Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2509-byte-concat.md:1
msgid "Feature Name: concat_bytes"
msgstr ""

#: src/2509-byte-concat.md:2
msgid "Start Date: 2018-07-31"
msgstr ""

#: src/2509-byte-concat.md:3
msgid "RFC PR: [\\#2509](https://github.com/rust-lang/rfcs/pull/2509)"
msgstr ""

#: src/2509-byte-concat.md:4
msgid "Rust Issue: [\\#87555](https://github.com/rust-lang/rust/issues/87555)"
msgstr ""

#: src/2509-byte-concat.md:6
msgid "Summary"
msgstr ""

#: src/2509-byte-concat.md:9
msgid ""
"Add a macro `concat_bytes!()` to join byte sequences onto an `u8` array, the "
"same way `concat!()` currently supports for `str` literals."
msgstr ""

#: src/2509-byte-concat.md:12
msgid "Motivation"
msgstr ""

#: src/2509-byte-concat.md:15
msgid ""
"`concat!()` is convenient and useful to create compile time `str` literals "
"from `str`, `bool`, numeric and `char` literals in the code. This RFC adds "
"an equivalent capability for `[u8]` instead of `str`."
msgstr ""

#: src/2509-byte-concat.md:19
msgid "Guide-level explanation"
msgstr ""

#: src/2509-byte-concat.md:22
msgid ""
"The `concat_bytes!()` macro concatenates literals into a byte string literal "
"(an expression of the type `&[u8; N]`). The following literal types are "
"supported as inputs:"
msgstr ""

#: src/2509-byte-concat.md:26
msgid "byte string literals (`b\"...\"`)"
msgstr ""

#: src/2509-byte-concat.md:27
msgid "byte literals (`b'b'`)"
msgstr ""

#: src/2509-byte-concat.md:28
msgid ""
"numeric array literals – if any literal is outside of `u8` range, it will "
"cause a compile time error:"
msgstr ""

#: src/2509-byte-concat.md:31
msgid ""
"```\n"
"error: cannot concatenate a non-`u8` literal in a byte string literal\n"
"  --> $FILE:XX:YY\n"
"   |\n"
"XX |     concat_bytes!([300, 1, 2, 256], b\"val\");\n"
"   |                    ^^^        ^^^ this value is larger than `255`\n"
"   |                    |\n"
"   |                    this value is larger than `255`\n"
"```"
msgstr ""

#: src/2509-byte-concat.md:41
msgid ""
"For example, `concat_bytes!(42, b\"va\", b'l', [1, 2])` evaluates to `[42, "
"118, 97, 108, 1, 2]`."
msgstr ""

#: src/2509-byte-concat.md:44
msgid "Drawbacks"
msgstr ""

#: src/2509-byte-concat.md:47
msgid "None known."
msgstr ""

#: src/2509-byte-concat.md:49
msgid "Rationale and alternatives"
msgstr ""

#: src/2509-byte-concat.md:52
msgid ""
"`concat!` could instead be changed to sometimes produce byte literals "
"instead of string literals, like a previous revision of this RFC proposed. "
"This would make it hard to ensure the right output type is produced – users "
"would have to use hacks like adding a dummy `b\"\"` argument to force a byte "
"literal output."
msgstr ""

#: src/2509-byte-concat.md:57
msgid ""
"An earlier version of this RFC proposed to support integer literals outside "
"of arrays, but that was rejected since it would make the output of "
"`byte_concat!(123, b\"\\n\")` inconsistent with the equivalent `concat!` "
"invocation."
msgstr ""

#: src/2509-byte-concat.md:62
msgid "Unresolved questions"
msgstr ""

#: src/2509-byte-concat.md:65
msgid ""
"Should additional literal types be supported? Byte string literals are "
"basically the same thing as byte slice references, so it might make sense to "
"support those as well (support `&[0, 1, 2]` in addition to `[0, 1, 2]`)."
msgstr ""

#: src/2509-byte-concat.md:68
msgid ""
"What to do with string and character literals? They could either be "
"supported with their underlying UTF-8 representation being concatenated, or "
"rejected."
msgstr ""
