msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:42Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0241-deref-conversions.md:1
msgid "Start Date: 2014-09-16"
msgstr ""

#: src/0241-deref-conversions.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#241](https://github.com/rust-lang/rfcs/pull/241)"
msgstr ""

#: src/0241-deref-conversions.md:3
msgid ""
"Rust Issue: [rust-lang/rust#21432](https://github.com/rust-lang/rust/"
"issues/21432)"
msgstr ""

#: src/0241-deref-conversions.md:5
msgid "Summary"
msgstr ""

#: src/0241-deref-conversions.md:7
msgid "Add the following coercions:"
msgstr ""

#: src/0241-deref-conversions.md:9 src/0241-deref-conversions.md:139
msgid "From `&T` to `&U` when `T: Deref<U>`."
msgstr ""

#: src/0241-deref-conversions.md:10 src/0241-deref-conversions.md:140
msgid "From `&mut T` to `&U` when `T: Deref<U>`."
msgstr ""

#: src/0241-deref-conversions.md:11 src/0241-deref-conversions.md:141
msgid "From `&mut T` to `&mut U` when `T: DerefMut<U>`"
msgstr ""

#: src/0241-deref-conversions.md:13
msgid ""
"These coercions eliminate the need for \"cross-borrowing\" (things like "
"`&**v`) and calls to `as_slice`."
msgstr ""

#: src/0241-deref-conversions.md:16
msgid "Motivation"
msgstr ""

#: src/0241-deref-conversions.md:18
msgid ""
"Rust currently supports a conservative set of _implicit coercions_ that are "
"used when matching the types of arguments against those given for a "
"function's parameters. For example, if `T: Trait` then `&T` is implicitly "
"coerced to `&Trait` when used as a function argument:"
msgstr ""

#: src/0241-deref-conversions.md:30
msgid "// automatically coerced from &MyStruct to &MyTrait\n"
msgstr ""

#: src/0241-deref-conversions.md:34
msgid ""
"In older incarnations of Rust, in which types like vectors were built in to "
"the language, coercions included things like auto-borrowing (taking `T` to "
"`&T`), auto-slicing (taking `Vec<T>` to `&[T]`) and \"cross-"
"borrowing\" (taking `Box<T>` to `&T`).  As built-in types migrated to the "
"library, these coercions have disappeared: none of them apply today. That "
"means that you have to write code like `&**v` to convert `&Box<T>` or "
"`Rc<RefCell<T>>` to `&T` and `v.as_slice()` to convert `Vec<T>` to `&T`."
msgstr ""

#: src/0241-deref-conversions.md:42
msgid ""
"The ergonomic regression was coupled with a promise that we'd improve things "
"in a more general way later on."
msgstr ""

#: src/0241-deref-conversions.md:45
msgid ""
"\"Later on\" has come! The premise of this RFC is that (1) we have learned "
"some valuable lessons in the interim and (2) there is a quite conservative "
"kind of coercion we can add that dramatically improves today's ergonomic "
"state of affairs."
msgstr ""

#: src/0241-deref-conversions.md:50
msgid "Detailed design"
msgstr ""

#: src/0241-deref-conversions.md:52
msgid "Design principles"
msgstr ""

#: src/0241-deref-conversions.md:54
msgid "The centrality of ownership and borrowing"
msgstr ""

#: src/0241-deref-conversions.md:56
msgid ""
"As Rust has evolved, [a theme has emerged](http://blog.rust-lang."
"org/2014/09/15/Rust-1.0.html): _ownership_ and _borrowing_ are the focal "
"point of Rust's design, and the key enablers of much of Rust's achievements."
msgstr ""

#: src/0241-deref-conversions.md:61
msgid ""
"As such, reasoning about ownership/borrowing is a central aspect of "
"programming in Rust."
msgstr ""

#: src/0241-deref-conversions.md:64
msgid ""
"In the old coercion model, borrowing could be done completely implicitly, so "
"an invocation like:"
msgstr ""

#: src/0241-deref-conversions.md:71
msgid ""
"might move `bar`, immutably borrow `baz`, and mutably borrow `quux`. To "
"understand the flow of ownership, then, one has to be aware of the details "
"of all function signatures involved -- it is not possible to see ownership "
"at a glance."
msgstr ""

#: src/0241-deref-conversions.md:76
msgid ""
"When [auto-borrowing was removed](https://mail.mozilla.org/pipermail/rust-"
"dev/2013-November/006849.html), this reasoning difficulty was cited as a "
"major motivator:"
msgstr ""

#: src/0241-deref-conversions.md:80
msgid ""
"Code readability does not necessarily benefit from autoref on arguments:"
msgstr ""

#: src/0241-deref-conversions.md:84
msgid "// reading this code looks like it moves `a`\n"
msgstr ""

#: src/0241-deref-conversions.md:85
msgid "// ah, nevermind, it doesn't move `a`!\n"
msgstr ""

#: src/0241-deref-conversions.md:88
msgid "// not only does this not move `a`, but it mutates it!\n"
msgstr ""

#: src/0241-deref-conversions.md:91
msgid ""
"Having to include an extra `&` or `&mut` for arguments is a slight "
"inconvenience, but it makes it much easier to track ownership at a glance. "
"(Note that ownership is not _entirely_ explicit, due to `self` and macros; "
"see the [appendix](#appendix-ownership-in-rust-today).)"
msgstr ""

#: src/0241-deref-conversions.md:96
msgid ""
"This RFC takes as a basic principle: **Coercions should never implicitly "
"borrow from owned data**."
msgstr ""

#: src/0241-deref-conversions.md:98
msgid ""
"This is a key difference from the [cross-borrowing RFC](https://github.com/"
"rust-lang/rfcs/pull/226)."
msgstr ""

#: src/0241-deref-conversions.md:101
msgid "Limit implicit execution of arbitrary code"
msgstr ""

#: src/0241-deref-conversions.md:103
msgid ""
"Another positive aspect of Rust's current design is that a function call "
"like `foo(bar, baz)` does not invoke arbitrary code (general implicit "
"coercions, as found in e.g. Scala). It simply executes `foo`."
msgstr ""

#: src/0241-deref-conversions.md:107
msgid ""
"The tradeoff here is similar to the ownership tradeoff: allowing arbitrary "
"implicit coercions means that a programmer must understand the types of the "
"arguments given, the types of the parameters, and _all_ applicable coercion "
"code in order to understand what code will be executed. While arbitrary "
"coercions are convenient, they come at a substantial cost in local reasoning "
"about code."
msgstr ""

#: src/0241-deref-conversions.md:113
msgid ""
"Of course, method dispatch can implicitly execute code via `Deref`. But "
"`Deref` is a pretty specialized tool:"
msgstr ""

#: src/0241-deref-conversions.md:116
msgid "Each type `T` can only deref to _one_ other type."
msgstr ""

#: src/0241-deref-conversions.md:118
msgid ""
"(Note: this restriction is not currently enforced, but will be enforceable "
"once [associated types](https://github.com/rust-lang/rfcs/pull/195) land.)"
msgstr ""

#: src/0241-deref-conversions.md:121
msgid ""
"Deref makes all the methods of the target type visible on the source type."
msgstr ""

#: src/0241-deref-conversions.md:122
msgid ""
"The source and target types are both references, limiting what the `deref` "
"code can do."
msgstr ""

#: src/0241-deref-conversions.md:125
msgid ""
"These characteristics combined make `Deref` suitable for smart pointer-like "
"types and little else. They make `Deref` implementations relatively rare. "
"And as a consequence, you generally know when you're working with a type "
"implementing `Deref`."
msgstr ""

#: src/0241-deref-conversions.md:130
msgid ""
"This RFC takes as a basic principle: **Coercions should narrowly limit the "
"code they execute**."
msgstr ""

#: src/0241-deref-conversions.md:132
msgid "Coercions through `Deref` are considered narrow enough."
msgstr ""

#: src/0241-deref-conversions.md:134
msgid "The proposal"
msgstr ""

#: src/0241-deref-conversions.md:136
msgid ""
"The idea is to introduce a coercion corresponding to `Deref`/`DerefMut`, but "
"_only_ for already-borrowed values:"
msgstr ""

#: src/0241-deref-conversions.md:143
msgid ""
"These coercions are applied _recursively_, similarly to auto-deref for "
"method dispatch."
msgstr ""

#: src/0241-deref-conversions.md:146
msgid ""
"Here is a simple pseudocode algorithm for determining the applicability of "
"coercions.  Let `HasBasicCoercion(T, U)` be a procedure for determining "
"whether `T` can be coerced to `U` using today's coercion rules (i.e. without "
"deref). The general `HasCoercion(T, U)` procedure would work as follows:"
msgstr ""

#: src/0241-deref-conversions.md:166
msgid ""
"Essentially, the procedure looks for applicable \"basic\" coercions at "
"increasing levels of deref from the given argument, just as method "
"resolution searches for applicable methods at increasing levels of deref."
msgstr ""

#: src/0241-deref-conversions.md:170
msgid ""
"Unlike method resolution, however, this coercion does _not_ automatically "
"borrow."
msgstr ""

#: src/0241-deref-conversions.md:172
msgid "Benefits of the design"
msgstr ""

#: src/0241-deref-conversions.md:174
msgid ""
"Under this coercion design, we'd see the following ergonomic improvements "
"for \"cross-borrowing\":"
msgstr ""

#: src/0241-deref-conversions.md:182 src/0241-deref-conversions.md:187
#: src/0241-deref-conversions.md:190 src/0241-deref-conversions.md:195
#: src/0241-deref-conversions.md:207 src/0241-deref-conversions.md:212
msgid "// what you have to write today\n"
msgstr ""

#: src/0241-deref-conversions.md:183 src/0241-deref-conversions.md:188
#: src/0241-deref-conversions.md:191 src/0241-deref-conversions.md:208
#: src/0241-deref-conversions.md:213
msgid "// what you'd be able to write\n"
msgstr ""

#: src/0241-deref-conversions.md:196
msgid "// what you'd be able to write (note: recursive deref)\n"
msgstr ""

#: src/0241-deref-conversions.md:200
msgid ""
"In addition, if `Vec<T>: Deref<[T]>` (as proposed [here](https://github.com/"
"rust-lang/rfcs/pull/235)), slicing would be automatic:"
msgstr ""

#: src/0241-deref-conversions.md:217
msgid "Characteristics of the design"
msgstr ""

#: src/0241-deref-conversions.md:219
msgid "The design satisfies both of the principles laid out in the Motivation:"
msgstr ""

#: src/0241-deref-conversions.md:221
msgid ""
"It does not introduce implicit borrows of owned data, since it only applies "
"to already-borrowed data."
msgstr ""

#: src/0241-deref-conversions.md:224
msgid ""
"It only applies to `Deref` types, which means there is only limited "
"potential for implicitly running unknown code; together with the expectation "
"that programmers are generally aware when they are using `Deref` types, this "
"should retain the kind of local reasoning Rust programmers can do about "
"function/method invocations today."
msgstr ""

#: src/0241-deref-conversions.md:230
msgid ""
"There is a _conceptual model_ implicit in the design here: `&` is a "
"\"borrow\" operator, and richer coercions are available between borrowed "
"types. This perspective is in opposition to viewing `&` primarily as adding "
"a layer of indirection -- a view that, given compiler optimizations, is "
"often inaccurate anyway."
msgstr ""

#: src/0241-deref-conversions.md:236
msgid "Drawbacks"
msgstr ""

#: src/0241-deref-conversions.md:238
msgid ""
"As with any mechanism that implicitly invokes code, deref coercions make it "
"more complex to fully understand what a given piece of code is doing. The "
"RFC argued inline that the design conserves local reasoning in practice."
msgstr ""

#: src/0241-deref-conversions.md:242
msgid ""
"As mentioned above, this coercion design also changes the mental model "
"surrounding `&`, and in particular somewhat muddies the idea that it creates "
"a pointer. This change could make Rust more difficult to learn (though note "
"that it puts _more_ attention on ownership), though it would make it more "
"convenient to use in the long run."
msgstr ""

#: src/0241-deref-conversions.md:248
msgid "Alternatives"
msgstr ""

#: src/0241-deref-conversions.md:250
msgid ""
"The main alternative that addresses the same goals as this RFC is the [cross-"
"borrowing RFC](https://github.com/rust-lang/rfcs/pull/226), which proposes a "
"more aggressive form of deref coercion: it would allow converting e.g. "
"`Box<T>` to `&T` and `Vec<T>` to `&[T]` directly. The advantage is even "
"greater convenience: in many cases, even `&` is not necessary. The "
"disadvantage is the change to local reasoning about ownership:"
msgstr ""

#: src/0241-deref-conversions.md:259
msgid "// is v moved here?\n"
msgstr ""

#: src/0241-deref-conversions.md:260
msgid "// is v still available?\n"
msgstr ""

#: src/0241-deref-conversions.md:263
msgid ""
"Knowing whether `v` is moved in the call to `foo` requires knowing `foo`'s "
"signature, since the coercion would _implicitly borrow_ from the vector."
msgstr ""

#: src/0241-deref-conversions.md:266
msgid "Appendix: ownership in Rust today"
msgstr ""

#: src/0241-deref-conversions.md:268
msgid ""
"In today's Rust, ownership transfer/borrowing is explicit for all function/"
"method arguments. It is implicit only for:"
msgstr ""

#: src/0241-deref-conversions.md:271
msgid ""
"_`self` on method invocations._ In practice, the name and context of a "
"method invocation is almost always sufficient to infer its move/borrow "
"semantics."
msgstr ""

#: src/0241-deref-conversions.md:274
msgid ""
"_Macro invocations._ Since macros can expand into arbitrary code, macro "
"invocations can appear to move when they actually borrow."
msgstr ""
