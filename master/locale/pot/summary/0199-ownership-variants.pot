msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:42Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0199-ownership-variants.md:1
msgid "Start Date: 2014-08-28"
msgstr ""

#: src/0199-ownership-variants.md:2
msgid ""
"RFC PR #: [rust-lang/rfcs#199](https://github.com/rust-lang/rfcs/pull/199)"
msgstr ""

#: src/0199-ownership-variants.md:3
msgid ""
"Rust Issue #: [rust-lang/rust#16810](https://github.com/rust-lang/rust/"
"issues/16810)"
msgstr ""

#: src/0199-ownership-variants.md:5
msgid "Summary"
msgstr ""

#: src/0199-ownership-variants.md:7
msgid ""
"This is a _conventions RFC_ for settling naming conventions when there are "
"by value, by reference, and by mutable reference variants of an operation."
msgstr ""

#: src/0199-ownership-variants.md:11
msgid "Motivation"
msgstr ""

#: src/0199-ownership-variants.md:13
msgid ""
"Currently the libraries are not terribly consistent about how to signal mut "
"variants of functions; sometimes it is by a `mut_` prefix, sometimes a "
"`_mut` suffix, and occasionally with `_mut_` appearing in the middle. These "
"inconsistencies make APIs difficult to remember."
msgstr ""

#: src/0199-ownership-variants.md:18
msgid ""
"While there are arguments in favor of each of the positions, we stand to "
"gain a lot by standardizing, and to some degree we just need to make a "
"choice."
msgstr ""

#: src/0199-ownership-variants.md:22
msgid "Detailed design"
msgstr ""

#: src/0199-ownership-variants.md:24
msgid ""
"Functions often come in multiple variants: immutably borrowed, mutably "
"borrowed, and owned."
msgstr ""

#: src/0199-ownership-variants.md:27
msgid "The canonical example is iterator methods:"
msgstr ""

#: src/0199-ownership-variants.md:29
msgid "`iter` works with immutably borrowed data"
msgstr ""

#: src/0199-ownership-variants.md:30
msgid "`mut_iter` works with mutably borrowed data"
msgstr ""

#: src/0199-ownership-variants.md:31
msgid "`move_iter` works with owned data"
msgstr ""

#: src/0199-ownership-variants.md:33
msgid ""
"For iterators, the \"default\" (unmarked) variant is immutably borrowed. In "
"other cases, the default is owned."
msgstr ""

#: src/0199-ownership-variants.md:36
msgid ""
"The proposed rules depend on which variant is the default, but use "
"_suffixes_ to mark variants in all cases."
msgstr ""

#: src/0199-ownership-variants.md:39
msgid "The rules"
msgstr ""

#: src/0199-ownership-variants.md:41
msgid "Immutably borrowed by default"
msgstr ""

#: src/0199-ownership-variants.md:43
msgid "If `foo` uses/produces an immutable borrow by default, use:"
msgstr ""

#: src/0199-ownership-variants.md:45 src/0199-ownership-variants.md:62
msgid "The `_mut` suffix (e.g. `foo_mut`) for the mutably borrowed variant."
msgstr ""

#: src/0199-ownership-variants.md:46
msgid "The `_move` suffix (e.g. `foo_move`) for the owned variant."
msgstr ""

#: src/0199-ownership-variants.md:48
msgid ""
"However, in the case of iterators, the moving variant can also be understood "
"as an `into` conversion, `into_iter`, and `for x in v.into_iter()` reads "
"arguably better than `for x in v.iter_move()`, so the convention is "
"`into_iter`."
msgstr ""

#: src/0199-ownership-variants.md:53
msgid ""
"**NOTE**: This convention covers only the _method_ names for iterators, not "
"the names of the iterator types. That will be the subject of a follow up RFC."
msgstr ""

#: src/0199-ownership-variants.md:57
msgid "Owned by default"
msgstr ""

#: src/0199-ownership-variants.md:59
msgid "If `foo` uses/produces owned data by default, use:"
msgstr ""

#: src/0199-ownership-variants.md:61
msgid "The `_ref` suffix (e.g. `foo_ref`) for the immutably borrowed variant."
msgstr ""

#: src/0199-ownership-variants.md:64
msgid "Exceptions"
msgstr ""

#: src/0199-ownership-variants.md:66
msgid ""
"For mutably borrowed variants, if the `mut` qualifier is part of a type name "
"(e.g. `as_mut_slice`), it should appear as it would appear in the type."
msgstr ""

#: src/0199-ownership-variants.md:70
msgid "References to type names"
msgstr ""

#: src/0199-ownership-variants.md:72
msgid ""
"Some places in the current libraries, we say things like `as_ref` and "
"`as_mut`, and others we say `get_ref` and `get_mut_ref`."
msgstr ""

#: src/0199-ownership-variants.md:75
msgid "Proposal: generally standardize on `mut` as a shortening of `mut_ref`."
msgstr ""

#: src/0199-ownership-variants.md:78
msgid "The rationale"
msgstr ""

#: src/0199-ownership-variants.md:80
msgid "Why suffixes?"
msgstr ""

#: src/0199-ownership-variants.md:82
msgid ""
"Using a suffix makes it easier to visually group variants together, "
"especially when sorted alphabetically. It puts the emphasis on the "
"functionality, rather than the qualifier."
msgstr ""

#: src/0199-ownership-variants.md:86
msgid "Why `move`?"
msgstr ""

#: src/0199-ownership-variants.md:88
msgid ""
"Historically, Rust has used `move` as a way to signal ownership transfer and "
"to connect to C++ terminology. The main disadvantage is that it does not "
"emphasize ownership, which is our current narrative. On the other hand, in "
"Rust all data is owned, so using `_owned` as a qualifier is a bit strange."
msgstr ""

#: src/0199-ownership-variants.md:94
msgid ""
"The `Copy` trait poses a problem for any terminology about ownership "
"transfer. The proposed mental model is that with `Copy` data you are "
"\"moving a copy\"."
msgstr ""

#: src/0199-ownership-variants.md:98
msgid "See Alternatives for more discussion."
msgstr ""

#: src/0199-ownership-variants.md:100
msgid "Why `mut` rather then `mut_ref`?"
msgstr ""

#: src/0199-ownership-variants.md:102
msgid ""
"It's shorter, and pairs like `as_ref` and `as_mut` have a pleasant harmony "
"that doesn't place emphasis on one kind of reference over the other."
msgstr ""

#: src/0199-ownership-variants.md:105
msgid "Alternatives"
msgstr ""

#: src/0199-ownership-variants.md:107
msgid "Prefix or mixed qualifiers"
msgstr ""

#: src/0199-ownership-variants.md:109
msgid ""
"Using prefixes for variants is another possibility, but there seems to be "
"little upside."
msgstr ""

#: src/0199-ownership-variants.md:112
msgid ""
"It's possible to rationalize our current mix of prefixes and suffixes via "
"[grammatical distinctions](https://github.com/rust-lang/rust/"
"issues/13660#issuecomment-43576378), but this seems overly subtle and "
"complex, and requires a strong command of English grammar to work well."
msgstr ""

#: src/0199-ownership-variants.md:118
msgid "No suffix exception"
msgstr ""

#: src/0199-ownership-variants.md:120
msgid ""
"The rules here make an exception when `mut` is part of a type name, as in "
"`as_mut_slice`, but we could instead _always_ place the qualifier as a "
"suffix: `as_slice_mut`. This would make APIs more consistent in some ways, "
"less in others: conversion functions would no longer consistently use a "
"transcription of their type name."
msgstr ""

#: src/0199-ownership-variants.md:126
msgid ""
"This is perhaps not so bad, though, because as it is we often abbreviate "
"type names. In any case, we need a convention (separate RFC) for how to "
"refer to type names in methods."
msgstr ""

#: src/0199-ownership-variants.md:130
msgid "`owned` instead of `move`"
msgstr ""

#: src/0199-ownership-variants.md:132
msgid ""
"The overall narrative about Rust has been evolving to focus on _ownership_ "
"as the essential concept, with borrowing giving various lesser forms of "
"ownership, so `_owned` would be a reasonable alternative to `_move`."
msgstr ""

#: src/0199-ownership-variants.md:137
msgid ""
"On the other hand, the `ref` variants do not say \"borrowed\", so in some "
"sense this choice is inconsistent. In addition, the terminology is less "
"familiar to those coming from C++."
msgstr ""

#: src/0199-ownership-variants.md:141
msgid "`val` instead of `owned`"
msgstr ""

#: src/0199-ownership-variants.md:143
msgid ""
"Another option would be `val` or `value` instead of `owned`. This suggestion "
"plays into the \"by reference\" and \"by value\" distinction, and so is even "
"more congruent with `ref` than `move` is. On the other hand, it's less clear/"
"evocative than either `move` or `owned`."
msgstr ""
