msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:44Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2388-try-expr.md:1
msgid "Feature Name: `try_expr`"
msgstr ""

#: src/2388-try-expr.md:2
msgid "Start Date: 2018-04-04"
msgstr ""

#: src/2388-try-expr.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2388](https://github.com/rust-lang/rfcs/pull/2388)"
msgstr ""

#: src/2388-try-expr.md:4
msgid ""
"Rust Issue: [rust-lang/rust#50412](https://github.com/rust-lang/rust/"
"issues/50412)"
msgstr ""

#: src/2388-try-expr.md:6
msgid "Summary"
msgstr ""

#: src/2388-try-expr.md:11
msgid ""
"[RFC 243](https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-"
"based-exception-handling.md#choice-of-keywords) left the choice of keyword "
"for `catch { .. }` expressions unresolved. This RFC settles the choice of "
"keyword. Namely, it:"
msgstr ""

#: src/2388-try-expr.md:14
msgid "reserves `try` as a keyword in edition 2018."
msgstr ""

#: src/2388-try-expr.md:15
msgid "replaces `do catch { .. }` with `try { .. }`"
msgstr ""

#: src/2388-try-expr.md:16
msgid "does **not** reserve `catch` as a keyword."
msgstr ""

#: src/2388-try-expr.md:18
msgid "Motivation"
msgstr ""

#: src/2388-try-expr.md:25
msgid ""
"This RFC does not motivate `catch { .. }` or `try { .. }` expressions. To "
"read the motivation for that, please consult [the original `catch` RFC]"
"(https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-based-"
"exception-handling.md#catch-expressions)."
msgstr ""

#: src/2388-try-expr.md:28
msgid "For reserving a keyword"
msgstr ""

#: src/2388-try-expr.md:30
msgid "Whatever keyword is chosen, it can't be contextual."
msgstr ""

#: src/2388-try-expr.md:32
msgid ""
"As with `catch { .. }`, the syntactic form `<word> { .. }` where `<word>` is "
"replaced with any possible keyword would conflict with a struct named "
"`<word>` as seen in this perfectly legal snippet in Rust 2015, where "
"`<word>` has been substituted for `try`:"
msgstr ""

#: src/2388-try-expr.md:45
msgid "Aside note:"
msgstr ""

#: src/2388-try-expr.md:47
msgid "The snippet above emits the following warning:"
msgstr ""

#: src/2388-try-expr.md:53
msgid ""
"which is also the case for `catch`. This warning decreases the risk that "
"someone has defined a type named `try` anywhere in the ecosystem which "
"happens to be beneficial to us."
msgstr ""

#: src/2388-try-expr.md:57
msgid "For reserving `try` specifically"
msgstr ""

#: src/2388-try-expr.md:59
msgid "This is discussed in the [rationale for `try`](#rationale-for-try)."
msgstr ""

#: src/2388-try-expr.md:61
msgid "Guide-level explanation"
msgstr ""

#: src/2388-try-expr.md:64
msgid ""
"The keyword `try` will be reserved. This will allow you to write expressions "
"such as:"
msgstr ""

#: src/2388-try-expr.md:71
msgid ""
"// Note: OK-wrapping is assumed here, but it is not the goal of this RFC\n"
"    // to decide either in favor or against OK-wrapping.\n"
msgstr ""

#: src/2388-try-expr.md:77
msgid "Reference-level explanation"
msgstr ""

#: src/2388-try-expr.md:82
msgid ""
"The word `try` is reserved as a keyword in the [list of keywords](https://"
"doc.rust-lang.org/book/second-edition/appendix-01-keywords.html#keywords-"
"currently-in-use) in Rust edition 2018 and later editions."
msgstr ""

#: src/2388-try-expr.md:85
msgid ""
"The keyword `try` is used in \"try expressions\" of the form `try { .. }`."
msgstr ""

#: src/2388-try-expr.md:87
msgid "Drawbacks"
msgstr ""

#: src/2388-try-expr.md:90
msgid "There are two main drawbacks to the `try` keyword."
msgstr ""

#: src/2388-try-expr.md:92
msgid "Association with exception handling - Both a pro and con"
msgstr ""

#: src/2388-try-expr.md:94
msgid ""
"I think that there is a belief – one that I have shared from time to time – "
"that it is not helpful to use familiar keywords unless the semantics are a "
"perfect match, the concern being that they will setup an intuition that will "
"lead people astray. I think that is a danger, but it works both ways: those "
"intuitions also help people to understand, particularly in the early days. "
"So it’s a question of “how far along will you get before the differences "
"start to matter” and “how damaging is it if you misunderstand for a while”."
msgstr ""

#: src/2388-try-expr.md:96
msgid "\\[..\\]"
msgstr ""

#: src/2388-try-expr.md:98
msgid ""
"Rust has a lot of concepts to learn. If we are going to succeed, it’s "
"essential that people can learn them a bit at a time, and that we not throw "
"everything at you at once. I think we should always be on the lookout for "
"places where we can build on intuitions from other languages; it doesn’t "
"have to be a 100% match to be useful."
msgstr ""

#: src/2388-try-expr.md:100
msgid ""
"\\- [Niko Matsakis](https://internals.rust-lang.org/t/bikeshed-rename-catch-"
"blocks-to-fallible-blocks/7121/4)"
msgstr ""

#: src/2388-try-expr.md:102
msgid ""
"For some people, the association to `try { .. } catch { .. }` in languages "
"such as Java, and others in the [prior-art](#prior-art) section, is "
"unhelpful wrt. teachability because they see the explicit, reified, and "
"manually propagated exceptions in Rust as something very different than the "
"much more implicit exception handling stories in Java et al."
msgstr ""

#: src/2388-try-expr.md:110
msgid ""
"However, we make the case that other languages which do have these explicit "
"and reified exceptions as in Rust also use an exception vocabulary. Notably, "
"Haskell calls the monad-transformer for adding exceptions [`ExceptT`]"
"(https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except."
"html#t:ExceptT)."
msgstr ""

#: src/2388-try-expr.md:114
msgid ""
"We also argue that even tho we are propagating exceptions manually, we are "
"following tradition in that other languages have very different formulations "
"of the exception idea."
msgstr ""

#: src/2388-try-expr.md:118
msgid ""
"The benefit of familiarity, even if not a perfect match, as Niko puts it, "
"helps in learning, particularly because Rust is not a language in lack of "
"concepts to learn."
msgstr ""

#: src/2388-try-expr.md:124
msgid ""
"Breakage of the [`try!`](https://doc.rust-lang.org/nightly/std/macro.try."
"html) macro"
msgstr ""

#: src/2388-try-expr.md:126
msgid ""
"One possible result of introducing `try` as a keyword be that the old `try!` "
"macro would break. This could potentially be avoided but with great "
"technical challenges."
msgstr ""

#: src/2388-try-expr.md:130
msgid ""
"With the prospect of breaking [`try!`](https://doc.rust-lang.org/nightly/std/"
"macro.try.html), a few notes are in order:"
msgstr ""

#: src/2388-try-expr.md:132
msgid ""
"`?` was stabilized in 1.13, November 2016, which is roughly 1.4 years since "
"the date this RFC was started."
msgstr ""

#: src/2388-try-expr.md:134
msgid "`try!` has been \"deprecated\" since then since:"
msgstr ""

#: src/2388-try-expr.md:135
msgid ""
"The `?` operator was added to replace `try!` and should be used instead."
msgstr ""

#: src/2388-try-expr.md:136
msgid ""
"`try!(expr)` can in virtually all instances be automatically `rustfix`ed "
"automatically to `expr?`."
msgstr ""

#: src/2388-try-expr.md:138
msgid "There are very few questions on Stack Overflow that mention `try!`."
msgstr ""

#: src/2388-try-expr.md:139
msgid ""
"[\"The Rust Programming Language\", 2nd edition](https://doc.rust-lang.org/"
"book/second-edition/) (book) and \"Rust by Example\" have both already "
"removed all mentions of `try!`."
msgstr ""

#: src/2388-try-expr.md:142
msgid ""
"So overall I think it’s feasible to reduce the `try!` macro to a historical "
"curiosity to the point it won’t be actively confusing to newbies coming to "
"Rust."
msgstr ""

#: src/2388-try-expr.md:144
msgid ""
"\\- [kornel](https://internals.rust-lang.org/t/bikeshed-rename-catch-blocks-"
"to-fallible-blocks/7121/49)"
msgstr ""

#: src/2388-try-expr.md:146
msgid "However,"
msgstr ""

#: src/2388-try-expr.md:148
msgid "There are still plenty of materials out there which mention `try!`."
msgstr ""

#: src/2388-try-expr.md:149
msgid "`try!` is essentially the inverse of `try { .. }`."
msgstr ""

#: src/2388-try-expr.md:151
msgid ""
"Purging from the “collective memories of Rustaceans and Rust materials” is "
"not something that easy."
msgstr ""

#: src/2388-try-expr.md:153
msgid ""
"\\- [Manish Goregaokar](https://internals.rust-lang.org/t/bikeshed-rename-"
"catch-blocks-to-fallible-blocks/7121/50)"
msgstr ""

#: src/2388-try-expr.md:155
msgid ""
"In the RFC author's opinion however, the sum total benefits of `try { .. }` "
"seem to outweigh the drawbacks of the difficulty with purging [`try!`]"
"(https://doc.rust-lang.org/nightly/std/macro.try.html) from our collective "
"memory."
msgstr ""

#: src/2388-try-expr.md:159
msgid "Inverse semantics of `?`"
msgstr ""

#: src/2388-try-expr.md:161
msgid ""
"The `?` postfix operator is sometimes referred to as the \"try operator\", "
"and can be seen as having the inverse semantics as `try { .. }`."
msgstr ""

#: src/2388-try-expr.md:164
msgid ""
"To many, this is a drawback. To others, this makes the `?` and `try { .. }` "
"expression forms more closely related and therefore makes them more findable "
"in relation to each other."
msgstr ""

#: src/2388-try-expr.md:168
msgid ""
"There is currently some ongoing debate about renaming the `?` operator to "
"something other than the \"try operator\". This could help in mitigating the "
"effects of picking `try` as the keyword."
msgstr ""

#: src/2388-try-expr.md:172
msgid "Rationale and alternatives"
msgstr ""

#: src/2388-try-expr.md:175
msgid "Review considerations"
msgstr ""

#: src/2388-try-expr.md:177
msgid ""
"Among the considerations when picking a keyword are, ordered by importance:"
msgstr ""

#: src/2388-try-expr.md:179
msgid "Fidelity to the construct's actual behavior."
msgstr ""

#: src/2388-try-expr.md:181
msgid "Precedent from existing languages"
msgstr ""

#: src/2388-try-expr.md:182
msgid "Popularity of the languages."
msgstr ""

#: src/2388-try-expr.md:183
msgid "Fidelity to behavior in those languages."
msgstr ""

#: src/2388-try-expr.md:184
msgid "Familiarity with respect to their analogous constructs."
msgstr ""

#: src/2388-try-expr.md:186
msgid ""
"See the [prior art](#prior-art) the [rationale for try](#rationale-for-try) "
"for more discussion on precedent."
msgstr ""

#: src/2388-try-expr.md:189
msgid "Brevity."
msgstr ""

#: src/2388-try-expr.md:193
msgid "Consistency with related standard library function conventions."
msgstr ""

#: src/2388-try-expr.md:195
msgid ""
"Consistency with the naming of the trait used for `?` (the [`Try`](https://"
"doc.rust-lang.org/nightly/std/ops/trait.Try.html) trait). Since the `Try` "
"trait is unstable and the naming of the `?` operator in communication is "
"still unsettled, this is not regarded as very important."
msgstr ""

#: src/2388-try-expr.md:199
msgid "Degree / Risk of breakage."
msgstr ""

#: src/2388-try-expr.md:201
msgid "Consistency with old learning material."
msgstr ""

#: src/2388-try-expr.md:203
msgid "Inversely: The extent of the old learning material"
msgstr ""

#: src/2388-try-expr.md:205
msgid ""
"That is, (in)consistency with `?` and the `try!()` macro. If the first "
"clause is called `try`, then `try { }` and `try!()` would have essentially "
"inverse meanings."
msgstr ""

#: src/2388-try-expr.md:209
msgid "Rationale for `try`"
msgstr ""

#: src/2388-try-expr.md:212
msgid "**Fidelity to the construct's actual behavior:** Very high"
msgstr ""

#: src/2388-try-expr.md:213
msgid ""
"**Precedent from existing languages:** A lot, see [prior-art](#prior-art)"
msgstr ""

#: src/2388-try-expr.md:214 src/2388-try-expr.md:306
msgid "**Popularity of the languages:** Massive accumulated dominance"
msgstr ""

#: src/2388-try-expr.md:215
msgid "**Fidelity to behavior in those languages:** Very high"
msgstr ""

#: src/2388-try-expr.md:216
msgid "**Familiarity with respect to their analogous constructs:** Very high"
msgstr ""

#: src/2388-try-expr.md:217
msgid "**Brevity / Length:** 3"
msgstr ""

#: src/2388-try-expr.md:218
msgid "**Consistency with related libstd fn conventions:** Consistent"
msgstr ""

#: src/2388-try-expr.md:219
msgid "**Consistency with the naming of the trait used for `?`:** Consistent"
msgstr ""

#: src/2388-try-expr.md:220
msgid ""
"**Risk of breakage:** High (if we assume `try!` will break, otherwise: Low)"
msgstr ""

#: src/2388-try-expr.md:221
msgid ""
"**Used in std:** [_No_](https://doc.rust-lang.org/nightly/std/?search=try), "
"`std::try!`, but it is technically possible to not break this macro. "
"(unstable: `std::intrinsics::try` so irrelevant)"
msgstr ""

#: src/2388-try-expr.md:222
msgid ""
"**Used as crate?** [_Yes_](https://crates.io/crates/try). No reverse "
"dependencies. Described as: _\"Deprecation warning resistant try macro\"_"
msgstr ""

#: src/2388-try-expr.md:223
msgid "**Usage (sourcegraph):** **27** regex:"
msgstr ""

#: src/2388-try-expr.md:228
msgid ""
"**Consistency with old learning material:** Inconsistent ([`try!`](https://"
"doc.rust-lang.org/nightly/std/macro.try.html))"
msgstr ""

#: src/2388-try-expr.md:230 src/2388-try-expr.md:262 src/2388-try-expr.md:318
#: src/2388-try-expr.md:357 src/2388-try-expr.md:487 src/2388-try-expr.md:516
#: src/2388-try-expr.md:542 src/2388-try-expr.md:684 src/2388-try-expr.md:847
msgid "Review"
msgstr ""

#: src/2388-try-expr.md:232
msgid "This is our choice of keyword, because it:"
msgstr ""

#: src/2388-try-expr.md:234
msgid ""
"has a massive dominance in both popular and less known languages and is "
"sufficiently semantically faithful to what `try` means in those languages. "
"Thus, we can leverage people's intuitions and not spend too much of our "
"complexity budget."
msgstr ""

#: src/2388-try-expr.md:238
msgid ""
"is consistent with the standard library wrt. `Try` and `try_` prefixed "
"methods."
msgstr ""

#: src/2388-try-expr.md:239
msgid "it is brief."
msgstr ""

#: src/2388-try-expr.md:240
msgid ""
"it has high fidelity wrt. the concepts it attempts to communicate (exception "
"boundary for `?`). This high fidelity is from the perspective of a "
"programmers intent, i.e: \"I want to try a bunch of stuff in this block\"."
msgstr ""

#: src/2388-try-expr.md:243
msgid "it can be further extended with `catch { .. }` handlers if we wish."
msgstr ""

#: src/2388-try-expr.md:245
msgid "Alternative: reserving `catch`"
msgstr ""

#: src/2388-try-expr.md:247 src/2388-try-expr.md:302
msgid "**Fidelity to the construct's actual behavior:** High"
msgstr ""

#: src/2388-try-expr.md:248
msgid ""
"**Precedent from existing languages:** Erlang and Tcl, see [prior-art]"
"(#prior-art)"
msgstr ""

#: src/2388-try-expr.md:249 src/2388-try-expr.md:529 src/2388-try-expr.md:586
#: src/2388-try-expr.md:749
msgid "**Brevity / Length:** 6"
msgstr ""

#: src/2388-try-expr.md:250
msgid "**Consistency with related libstd fn conventions:** Somewhat consistent"
msgstr ""

#: src/2388-try-expr.md:251 src/2388-try-expr.md:289 src/2388-try-expr.md:353
#: src/2388-try-expr.md:476 src/2388-try-expr.md:505 src/2388-try-expr.md:531
#: src/2388-try-expr.md:571 src/2388-try-expr.md:588 src/2388-try-expr.md:605
#: src/2388-try-expr.md:622 src/2388-try-expr.md:639 src/2388-try-expr.md:656
#: src/2388-try-expr.md:673 src/2388-try-expr.md:700 src/2388-try-expr.md:717
#: src/2388-try-expr.md:734 src/2388-try-expr.md:751 src/2388-try-expr.md:768
#: src/2388-try-expr.md:785 src/2388-try-expr.md:802 src/2388-try-expr.md:819
#: src/2388-try-expr.md:836
msgid "**Consistency with the naming of the trait used for `?`:** Inconsistent"
msgstr ""

#: src/2388-try-expr.md:252 src/2388-try-expr.md:606
msgid "**Risk of breakage:** Low"
msgstr ""

#: src/2388-try-expr.md:253
msgid ""
"**Used in std:** [_No_](https://doc.rust-lang.org/nightly/std/?search=catch)"
msgstr ""

#: src/2388-try-expr.md:254
msgid "**Used as crate?** [_No_](https://crates.io/crates/catch)."
msgstr ""

#: src/2388-try-expr.md:255
msgid "**Usage (sourcegraph):** **21** regex:"
msgstr ""

#: src/2388-try-expr.md:260 src/2388-try-expr.md:294 src/2388-try-expr.md:316
#: src/2388-try-expr.md:355 src/2388-try-expr.md:485 src/2388-try-expr.md:514
#: src/2388-try-expr.md:540 src/2388-try-expr.md:576 src/2388-try-expr.md:597
#: src/2388-try-expr.md:614 src/2388-try-expr.md:631 src/2388-try-expr.md:648
#: src/2388-try-expr.md:665 src/2388-try-expr.md:682 src/2388-try-expr.md:709
#: src/2388-try-expr.md:726 src/2388-try-expr.md:743 src/2388-try-expr.md:760
#: src/2388-try-expr.md:777 src/2388-try-expr.md:794 src/2388-try-expr.md:811
#: src/2388-try-expr.md:828 src/2388-try-expr.md:845
msgid "**Consistency with old learning material:** Untaught"
msgstr ""

#: src/2388-try-expr.md:264
msgid "We believe `catch` to be a poor choice of keyword, because it:"
msgstr ""

#: src/2388-try-expr.md:266
msgid ""
"is used in few in other languages to demarcate the body which can result in "
"an exceptional path. Instead, it is almost exclusively used for exception "
"handlers of the form: `catch(pat) { recover_expr }`."
msgstr ""

#: src/2388-try-expr.md:269
msgid ""
"extending `catch` with handlers will require a different word such as "
"`handler` to get `catch { .. } handler(e) { .. }` semantics if we want. This "
"inversion compared to a lot of other languages will only harm teachability "
"of the language and steal a lot of our strangeness budget."
msgstr ""

#: src/2388-try-expr.md:273
msgid "it is less brief than `try`."
msgstr ""

#: src/2388-try-expr.md:274
msgid ""
"the consistency wrt. methods in the standard library is low - there's only "
"`catch_unwind`, but that has to do with panics, not `Try` style exceptions."
msgstr ""

#: src/2388-try-expr.md:278
msgid ""
"However, `catch` has high fidelity wrt. the operational semantics of "
"\"catching\" any exceptions in the `try { .. }` block."
msgstr ""

#: src/2388-try-expr.md:281
msgid "Alternative: keeping `do catch { .. }`"
msgstr ""

#: src/2388-try-expr.md:283
msgid "**Fidelity to the construct's actual behavior:** Middle"
msgstr ""

#: src/2388-try-expr.md:284 src/2388-try-expr.md:303
msgid "**Precedent from existing languages:**"
msgstr ""

#: src/2388-try-expr.md:285 src/2388-try-expr.md:304
msgid "`do`: Haskell, Idris"
msgstr ""

#: src/2388-try-expr.md:286
msgid "`catch`: Erlang and Tcl, see [prior-art](#prior-art)"
msgstr ""

#: src/2388-try-expr.md:287 src/2388-try-expr.md:569 src/2388-try-expr.md:698
#: src/2388-try-expr.md:817 src/2388-try-expr.md:834
msgid "**Brevity / Length:** 8"
msgstr ""

#: src/2388-try-expr.md:288
msgid "**Consistency with related libstd fn conventions:** Tiny bit consistent"
msgstr ""

#: src/2388-try-expr.md:290 src/2388-try-expr.md:312 src/2388-try-expr.md:354
msgid "**Risk of breakage:** Impossible (already reserved keyword)"
msgstr ""

#: src/2388-try-expr.md:291 src/2388-try-expr.md:313
msgid ""
"**Used in std:** _No_, the form `$ident $ident` is not a legal identifier."
msgstr ""

#: src/2388-try-expr.md:292 src/2388-try-expr.md:314
msgid "**Used as crate?** _No_, as above."
msgstr ""

#: src/2388-try-expr.md:293 src/2388-try-expr.md:315
msgid "**Usage (sourcegraph):** **0** regex: N/A"
msgstr ""

#: src/2388-try-expr.md:296
msgid ""
"An alternative would be to simply use the `do catch { ... }` syntax we have "
"in the nightly compiler. However, this syntax was not in the accepted "
"`catch` RFC and was only a temporary fix around `catch { .. }` not working."
msgstr ""

#: src/2388-try-expr.md:300
msgid "Alternative: `do try { .. }`"
msgstr ""

#: src/2388-try-expr.md:305
msgid "`try`: A lot, see [prior-art](#prior-art)"
msgstr ""

#: src/2388-try-expr.md:307
msgid "**Fidelity to behavior in those languages:** High"
msgstr ""

#: src/2388-try-expr.md:308
msgid "**Familiarity with respect to their analogous constructs:** High"
msgstr ""

#: src/2388-try-expr.md:309
msgid "**Brevity / Length:** 6 (including space)"
msgstr ""

#: src/2388-try-expr.md:310
msgid ""
"**Consistency with related libstd fn conventions:** Moderately consistent"
msgstr ""

#: src/2388-try-expr.md:311
msgid ""
"**Consistency with the naming of the trait used for `?`:** Moderately "
"consistent"
msgstr ""

#: src/2388-try-expr.md:320
msgid ""
"We could in fact decide to keep the `do`\\-prefix but change the suffix to "
"`try`. The benefit here would be two-fold:"
msgstr ""

#: src/2388-try-expr.md:323
msgid ""
"No keyword `try` would need to be introduced as `do` already is a keyword. "
"Therefore, the `try!` macro would not break."
msgstr ""

#: src/2388-try-expr.md:326
msgid ""
"An association with monads due to `do`. This can be considered a benfit "
"since `try` can be seen as sugar for the family of error monads (modulo "
"kinks wrt. imperative flow), and thus, the `do` prefix leads to a path of "
"generality if more monads are introduced."
msgstr ""

#: src/2388-try-expr.md:331
msgid "The drawbacks would be:"
msgstr ""

#: src/2388-try-expr.md:333
msgid ""
"The wider association with monads can be seen as a drawback for those not "
"familiar with monads."
msgstr ""

#: src/2388-try-expr.md:336
msgid ""
"`do try { .. }` over `try { .. }` adds a small degree of ergonomics overhead "
"but not much (3 characters including the space). However, the frequency with "
"which the `try { .. }` construct might be used can make the small overhead "
"accumulate to a significant overhead when a large codebase is considered."
msgstr ""

#: src/2388-try-expr.md:341
msgid ""
"Other than this, the argument for `do try` over `do catch` boils down to an "
"argument of `try` over `catch`."
msgstr ""

#: src/2388-try-expr.md:344
msgid "Alternative: using `do { .. }`"
msgstr ""

#: src/2388-try-expr.md:346 src/2388-try-expr.md:584 src/2388-try-expr.md:652
#: src/2388-try-expr.md:669 src/2388-try-expr.md:696 src/2388-try-expr.md:713
#: src/2388-try-expr.md:730 src/2388-try-expr.md:747 src/2388-try-expr.md:764
#: src/2388-try-expr.md:781 src/2388-try-expr.md:798 src/2388-try-expr.md:832
msgid "**Fidelity to the construct's actual behavior:**  Not at all."
msgstr ""

#: src/2388-try-expr.md:347
msgid "**Precedent from existing languages:** Haskell, Idris"
msgstr ""

#: src/2388-try-expr.md:348
msgid "**Popularity of the languages:** Haskell: Tiobe #42, PYPL #22"
msgstr ""

#: src/2388-try-expr.md:349
msgid "**Fidelity to behavior in those languages:** Good"
msgstr ""

#: src/2388-try-expr.md:350
msgid "**Familiarity with respect to their analogous constructs:** Poor"
msgstr ""

#: src/2388-try-expr.md:351
msgid "**Brevity / Length:** 2"
msgstr ""

#: src/2388-try-expr.md:352 src/2388-try-expr.md:475 src/2388-try-expr.md:504
#: src/2388-try-expr.md:530 src/2388-try-expr.md:587 src/2388-try-expr.md:604
#: src/2388-try-expr.md:621 src/2388-try-expr.md:638 src/2388-try-expr.md:655
#: src/2388-try-expr.md:672 src/2388-try-expr.md:699 src/2388-try-expr.md:716
#: src/2388-try-expr.md:733 src/2388-try-expr.md:750 src/2388-try-expr.md:767
#: src/2388-try-expr.md:784 src/2388-try-expr.md:801
msgid "**Consistency with related libstd fn conventions:** Inconsistent"
msgstr ""

#: src/2388-try-expr.md:359
msgid "The keyword `do` was probably originally reserved for two use cases:"
msgstr ""

#: src/2388-try-expr.md:361
msgid "`do while { .. }`"
msgstr ""

#: src/2388-try-expr.md:363
msgid "Monadic `do`\\-notation a la Haskell:"
msgstr ""

#: src/2388-try-expr.md:374
msgid "The which would be translated into the following pseudo-Rust:"
msgstr ""

#: src/2388-try-expr.md:386
msgid "Or particularly for the `try { .. }` case:"
msgstr ""

#: src/2388-try-expr.md:398
msgid "The Haskell version is syntactic sugar for:"
msgstr ""

#: src/2388-try-expr.md:408
msgid "or in Rust:"
msgstr ""

#: src/2388-try-expr.md:412
msgid "// or .and_then(..)\n"
msgstr ""

#: src/2388-try-expr.md:423
msgid ""
"In the Haskell version, `>>=` is defined in the `Monad` typeclass (trait):"
msgstr ""

#: src/2388-try-expr.md:436
msgid "And some instances (impls) of `Monad` are:"
msgstr ""

#: src/2388-try-expr.md:439
msgid "-- | Same as Option<T>\n"
msgstr ""

#: src/2388-try-expr.md:447
msgid "-- | `struct Norm<T> { value: T, normalized: bool }`\n"
msgstr ""

#: src/2388-try-expr.md:457
msgid ""
"Considering the latter case of do-notation, we saw how `try { .. }` and `do "
"{ .. }` relate. In fact, `try { .. }` is special to the [`Try`](https://doc."
"rust-lang.org/nightly/std/ops/trait.Try.html) ([`MonadError`](http://hackage."
"haskell.org/package/mtl-2.2.2/docs/Control-Monad-Error-Class.html#t:"
"MonadError)) monads. There are also more forms of monads which you might "
"want to use `do { .. }` for. Among these are: Futures, Iterators Due to "
"having more monads than [`Try`](https://doc.rust-lang.org/nightly/std/ops/"
"trait.Try.html)\\-based ones, using the `do { .. }` syntax directly as a "
"replacement for `try { .. }` becomes problematic as it:"
msgstr ""

#: src/2388-try-expr.md:466
msgid "confuses everyone familiar with do-notation and monads."
msgstr ""

#: src/2388-try-expr.md:467
msgid "is in the way of use for monads in general."
msgstr ""

#: src/2388-try-expr.md:468
msgid "`do` is generic and unclear wrt. semantics."
msgstr ""

#: src/2388-try-expr.md:470
msgid "Alternative: reserving `trap`"
msgstr ""

#: src/2388-try-expr.md:472 src/2388-try-expr.md:635
msgid "**Fidelity to the construct's actual behavior:** Good"
msgstr ""

#: src/2388-try-expr.md:473 src/2388-try-expr.md:502 src/2388-try-expr.md:528
#: src/2388-try-expr.md:568 src/2388-try-expr.md:585 src/2388-try-expr.md:602
#: src/2388-try-expr.md:619 src/2388-try-expr.md:636 src/2388-try-expr.md:653
#: src/2388-try-expr.md:670 src/2388-try-expr.md:697 src/2388-try-expr.md:714
#: src/2388-try-expr.md:731 src/2388-try-expr.md:748 src/2388-try-expr.md:765
#: src/2388-try-expr.md:782 src/2388-try-expr.md:799 src/2388-try-expr.md:816
#: src/2388-try-expr.md:833
msgid "**Precedent from existing languages:** None"
msgstr ""

#: src/2388-try-expr.md:474 src/2388-try-expr.md:503 src/2388-try-expr.md:671
#: src/2388-try-expr.md:715
msgid "**Brevity / Length:** 4"
msgstr ""

#: src/2388-try-expr.md:477 src/2388-try-expr.md:506 src/2388-try-expr.md:572
#: src/2388-try-expr.md:640 src/2388-try-expr.md:735 src/2388-try-expr.md:752
#: src/2388-try-expr.md:769 src/2388-try-expr.md:786 src/2388-try-expr.md:820
msgid "**Risk of breakage:** Very low"
msgstr ""

#: src/2388-try-expr.md:478
msgid ""
"**Used in std:** [_No_](https://doc.rust-lang.org/nightly/std/?search=trap)"
msgstr ""

#: src/2388-try-expr.md:479
msgid "**Used as crate?** [_No_](https://crates.io/crates/trap)."
msgstr ""

#: src/2388-try-expr.md:480
msgid "**Usage (sourcegraph):** **4** regex:"
msgstr ""

#: src/2388-try-expr.md:489
msgid "Arguably, this candidate keyword is a somewhat a good choice."
msgstr ""

#: src/2388-try-expr.md:491
msgid ""
"To `trap` an error is sufficiently clear on the \"exception boundary\" "
"semantics we wish to communicate."
msgstr ""

#: src/2388-try-expr.md:494
msgid "However, `trap` is used as an error handler in at least one language."
msgstr ""

#: src/2388-try-expr.md:496
msgid ""
"It also does not have the familiarity that `try` does have and is entirely "
"inconsistent wrt. naming in the standard library."
msgstr ""

#: src/2388-try-expr.md:499
msgid "Alternative: reserving `wrap`"
msgstr ""

#: src/2388-try-expr.md:501 src/2388-try-expr.md:527
msgid "**Fidelity to the construct's actual behavior:** Somewhat good"
msgstr ""

#: src/2388-try-expr.md:507
msgid ""
"**Used in std:** [_No_](https://doc.rust-lang.org/nightly/std/?search=wrap)"
msgstr ""

#: src/2388-try-expr.md:508
msgid ""
"**Used as crate?** [_Yes_](https://crates.io/crates/wrap), no reverse "
"dependencies."
msgstr ""

#: src/2388-try-expr.md:509
msgid "**Usage (sourcegraph):** **37+** regex:"
msgstr ""

#: src/2388-try-expr.md:518
msgid ""
"With `wrap { .. }` we can say that it \"wraps\" the result of the block as a "
"`Result` / `Option`, etc. and it is logically related to `.unwrap()`, which "
"is however a partial function, wherefore the connotation might be bad."
msgstr ""

#: src/2388-try-expr.md:522
msgid ""
"Also, `wrap` could be considered too generic as with `do` in that it could "
"fit for any monad."
msgstr ""

#: src/2388-try-expr.md:525
msgid "Alternative: reserving `result`"
msgstr ""

#: src/2388-try-expr.md:532 src/2388-try-expr.md:623
msgid "**Risk of breakage:** Very high"
msgstr ""

#: src/2388-try-expr.md:533
msgid ""
"**Used in std:** [_Yes_](https://doc.rust-lang.org/nightly/std/?"
"search=result) for the `{std, core}::result` modules."
msgstr ""

#: src/2388-try-expr.md:534
msgid ""
"**Used as crate?** [_Yes_](https://crates.io/crates/result). 6 reverse "
"dependencies (transitive closure)."
msgstr ""

#: src/2388-try-expr.md:535
msgid "**Usage (sourcegraph):** **43+** regex:"
msgstr ""

#: src/2388-try-expr.md:546
msgid ""
"The fidelity of `result` is somewhat good due to the association with the "
"`Result` type as well as `Try` being a [final encoding](http://okmij.org/ftp/"
"tagless-final/course/lecture.pdf) of `Result`."
msgstr ""

#: src/2388-try-expr.md:549
msgid ""
"However, when you consider `Option`, the association is less direct, and "
"thus it does not fit `Option` and other types well."
msgstr ""

#: src/2388-try-expr.md:552
msgid ""
"The breakage of the `result` module is however quite problematic, making "
"this particular choice of keyword more or less a non-starter."
msgstr ""

#: src/2388-try-expr.md:555
msgid "Alternative: a smattering of other possible keywords"
msgstr ""

#: src/2388-try-expr.md:557
msgid "There are a host of other keywords which have been suggested."
msgstr ""

#: src/2388-try-expr.md:559
msgid "`fallible`"
msgstr ""

#: src/2388-try-expr.md:561
msgid ""
"On an [internals thread](https://internals.rust-lang.org/t/bikeshed-rename-"
"catch-blocks-to-fallible-blocks/7121/), `fallible` was suggested. However, "
"this keyword lacks the verb-form that is the convention in Rust. Breaking "
"with this convention should only be done if there are significant reasons to "
"do so, which do not seem to exist in this case. It is also considerably "
"longer than `try` (+5 character) which matters for constructions which are "
"oft used."
msgstr ""

#: src/2388-try-expr.md:567
msgid "**Fidelity to the construct's actual behavior:**  High"
msgstr ""

#: src/2388-try-expr.md:570
msgid "**Consistency with related libstd fn conventions:** Highly inconsistent"
msgstr ""

#: src/2388-try-expr.md:573
msgid ""
"**Used in std:** [_No_](https://doc.rust-lang.org/nightly/std/?"
"search=fallible)"
msgstr ""

#: src/2388-try-expr.md:574
msgid ""
"**Used as crate?** [_Yes_](https://crates.io/crates/fallible), some reverse "
"dependencies (all by the same author)."
msgstr ""

#: src/2388-try-expr.md:575
msgid ""
"**Usage (sourcegraph)** [_None_](https://sourcegraph.com/search?q=repogroup:"
"crates+case:yes++"
"%5Cb%28%28let%7Cconst%7Ctype%7C%29%5Cs%2Bfallible%5Cs%2B%3D%7C%28fn%7Cimpl%7Cmod%7Cstruct%7Cenum%7Cunion%7Ctrait%29%5Cs%2Bfallible%29%5Cb+max:400)"
msgstr ""

#: src/2388-try-expr.md:578
msgid "Synonyms of `catch`:"
msgstr ""

#: src/2388-try-expr.md:580
msgid ""
"Some synonyms of `catch` [have been suggested](https://internals.rust-lang."
"org/t/bikeshed-rename-catch-blocks-to-fallible-blocks/7121/2):"
msgstr ""

#: src/2388-try-expr.md:582
msgid "`accept`"
msgstr ""

#: src/2388-try-expr.md:589 src/2388-try-expr.md:803
msgid "**Risk of breakage:** Medium"
msgstr ""

#: src/2388-try-expr.md:590
msgid ""
"**Used in std:** [_Yes_](https://doc.rust-lang.org/nightly/std/?"
"search=accept)"
msgstr ""

#: src/2388-try-expr.md:591
msgid "**Used as crate?** [_No_](https://crates.io/crates/accept)."
msgstr ""

#: src/2388-try-expr.md:592
msgid "**Usage (sourcegraph):** **79+** regex:"
msgstr ""

#: src/2388-try-expr.md:599
msgid "`capture`"
msgstr ""

#: src/2388-try-expr.md:601
msgid "**Fidelity to the construct's actual behavior:** Good."
msgstr ""

#: src/2388-try-expr.md:603 src/2388-try-expr.md:620 src/2388-try-expr.md:637
#: src/2388-try-expr.md:654 src/2388-try-expr.md:800
msgid "**Brevity / Length:** 7"
msgstr ""

#: src/2388-try-expr.md:607
msgid ""
"**Used in std:** [_No_](https://doc.rust-lang.org/nightly/std/?"
"search=capture)"
msgstr ""

#: src/2388-try-expr.md:608
msgid ""
"**Used as crate?** [_Yes_](https://crates.io/crates/capture), no reverse "
"dependencies."
msgstr ""

#: src/2388-try-expr.md:609 src/2388-try-expr.md:806
msgid "**Usage (sourcegraph):** **6+** regex:"
msgstr ""

#: src/2388-try-expr.md:616
msgid "`collect`"
msgstr ""

#: src/2388-try-expr.md:618
msgid "**Fidelity to the construct's actual behavior:** Very much not at all."
msgstr ""

#: src/2388-try-expr.md:624
msgid ""
"**Used in std:** [_Yes_](https://doc.rust-lang.org/nightly/std/?"
"search=collect) (`Iterator::collect`)"
msgstr ""

#: src/2388-try-expr.md:625
msgid ""
"**Used as crate?** [_Yes_](https://crates.io/crates/collect), no reverse "
"dependencies."
msgstr ""

#: src/2388-try-expr.md:626
msgid "**Usage (sourcegraph):** **35+** regex:"
msgstr ""

#: src/2388-try-expr.md:633
msgid "`recover`"
msgstr ""

#: src/2388-try-expr.md:641
msgid ""
"**Used in std:** [_No_](https://doc.rust-lang.org/nightly/std/?"
"search=recover)"
msgstr ""

#: src/2388-try-expr.md:642
msgid "**Used as crate?** [_No_](https://crates.io/crates/recover)"
msgstr ""

#: src/2388-try-expr.md:643
msgid "**Usage (sourcegraph):** **4+** regex:"
msgstr ""

#: src/2388-try-expr.md:650
msgid "`resolve`"
msgstr ""

#: src/2388-try-expr.md:657
msgid "**Risk of breakage:** Low to medium"
msgstr ""

#: src/2388-try-expr.md:658
msgid ""
"**Used in std:** [_No_](https://doc.rust-lang.org/nightly/std/?"
"search=resolve)"
msgstr ""

#: src/2388-try-expr.md:659
msgid ""
"**Used as crate?** [_Yes_](https://crates.io/crates/resolve), 3 reverse "
"dependencies"
msgstr ""

#: src/2388-try-expr.md:660
msgid "**Usage (sourcegraph):** **50+** regex:"
msgstr ""

#: src/2388-try-expr.md:667
msgid "`take`"
msgstr ""

#: src/2388-try-expr.md:674
msgid "**Risk of breakage:** Huge"
msgstr ""

#: src/2388-try-expr.md:675
msgid ""
"**Used in std:** [_Yes_](https://doc.rust-lang.org/nightly/std/?"
"search=take), `{Cell, HashSet, Read, Iterator, Option}::take`."
msgstr ""

#: src/2388-try-expr.md:676
msgid ""
"**Used as crate?** [_Yes_](https://crates.io/crates/resolve), a lot of "
"reverse dependency (transitive closure)."
msgstr ""

#: src/2388-try-expr.md:677
msgid "**Usage (sourcegraph):** **62+** regex:"
msgstr ""

#: src/2388-try-expr.md:686
msgid ""
"Of these, only `recover` and `capture` seem reasonable semantically. But "
"`recover` is even more problematic than `catch` because it enhances the "
"feeling of exception-handling instead of exception-boundaries. However, "
"`capture` is reasonable as a substitute for `try`, but it seems obscure and "
"lacks familiarity, which is counted as a strong downside."
msgstr ""

#: src/2388-try-expr.md:692
msgid ""
"[and some other keywords:](https://internals.rust-lang.org/t/bikeshed-rename-"
"catch-blocks-to-fallible-blocks/7121/13)"
msgstr ""

#: src/2388-try-expr.md:694
msgid "`coalesce`"
msgstr ""

#: src/2388-try-expr.md:701
msgid "**Risk of breakage:** Medium (itertools)"
msgstr ""

#: src/2388-try-expr.md:702
msgid ""
"**Used in std:** [_No_](https://doc.rust-lang.org/nightly/std/?"
"search=coalesce)."
msgstr ""

#: src/2388-try-expr.md:703
msgid ""
"**Used as crate?** [_Yes_](https://crates.io/crates/coalesce), one reverse "
"dependency."
msgstr ""

#: src/2388-try-expr.md:704
msgid "**Usage (sourcegraph):** **3+** regex:"
msgstr ""

#: src/2388-try-expr.md:711
msgid "`fuse`"
msgstr ""

#: src/2388-try-expr.md:718
msgid "**Risk of breakage:** Medium (libstd)"
msgstr ""

#: src/2388-try-expr.md:719
msgid ""
"**Used in std:** [_Yes_](https://doc.rust-lang.org/nightly/std/?"
"search=fuse), `Iterator::fuse`."
msgstr ""

#: src/2388-try-expr.md:720
msgid ""
"**Used as crate?** [_Yes_](https://crates.io/crates/fuse), 8 reverse "
"dependencies (transitive closure)."
msgstr ""

#: src/2388-try-expr.md:721
msgid "**Usage (sourcegraph):** **8+** regex:"
msgstr ""

#: src/2388-try-expr.md:728
msgid "`unite`"
msgstr ""

#: src/2388-try-expr.md:732 src/2388-try-expr.md:783
msgid "**Brevity / Length:** 5"
msgstr ""

#: src/2388-try-expr.md:736
msgid ""
"**Used in std:** [_No_](https://doc.rust-lang.org/nightly/std/?search=unite)."
msgstr ""

#: src/2388-try-expr.md:737
msgid "**Used as crate?** [_No_](https://crates.io/crates/unite)."
msgstr ""

#: src/2388-try-expr.md:738 src/2388-try-expr.md:755 src/2388-try-expr.md:772
#: src/2388-try-expr.md:823 src/2388-try-expr.md:840
msgid "**Usage (sourcegraph):** **0+** regex:"
msgstr ""

#: src/2388-try-expr.md:745
msgid "`cohere`"
msgstr ""

#: src/2388-try-expr.md:753
msgid ""
"**Used in std:** [_No_](https://doc.rust-lang.org/nightly/std/?"
"search=cohere)."
msgstr ""

#: src/2388-try-expr.md:754
msgid "**Used as crate?** [_No_](https://crates.io/crates/cohere)."
msgstr ""

#: src/2388-try-expr.md:762
msgid "`consolidate`"
msgstr ""

#: src/2388-try-expr.md:766
msgid "**Brevity / Length:** 11"
msgstr ""

#: src/2388-try-expr.md:770
msgid ""
"**Used in std:** [_No_](https://doc.rust-lang.org/nightly/std/?"
"search=consolidate)."
msgstr ""

#: src/2388-try-expr.md:771
msgid "**Used as crate?** [_No_](https://crates.io/crates/consolidate)."
msgstr ""

#: src/2388-try-expr.md:779
msgid "`unify`"
msgstr ""

#: src/2388-try-expr.md:787
msgid ""
"**Used in std:** [_No_](https://doc.rust-lang.org/nightly/std/?search=unify)."
msgstr ""

#: src/2388-try-expr.md:788
msgid ""
"**Used as crate?** [_Yes_](https://crates.io/crates/unify), no dependencies"
msgstr ""

#: src/2388-try-expr.md:789
msgid "**Usage (sourcegraph):** **1** regex:"
msgstr ""

#: src/2388-try-expr.md:796
msgid "`combine`"
msgstr ""

#: src/2388-try-expr.md:804
msgid ""
"**Used in std:** [_No_](https://doc.rust-lang.org/nightly/std/?"
"search=combine)."
msgstr ""

#: src/2388-try-expr.md:805
msgid ""
"**Used as crate?** [_Yes_](https://crates.io/crates/combine), 17 (direct "
"dependencies)"
msgstr ""

#: src/2388-try-expr.md:813
msgid "`resultof`"
msgstr ""

#: src/2388-try-expr.md:815
msgid "**Fidelity to the construct's actual behavior:** Somewhat"
msgstr ""

#: src/2388-try-expr.md:818
msgid ""
"**Consistency with related libstd fn conventions:** Very inconsistent (not "
"verb)"
msgstr ""

#: src/2388-try-expr.md:821
msgid ""
"**Used in std:** [_No_](https://doc.rust-lang.org/nightly/std/?"
"search=resultof)."
msgstr ""

#: src/2388-try-expr.md:822
msgid "**Used as crate?** [_No_](https://crates.io/crates/resultof)."
msgstr ""

#: src/2388-try-expr.md:830
msgid "`returned`"
msgstr ""

#: src/2388-try-expr.md:835
msgid "**Consistency with related libstd fn conventions:** Very inconsistent"
msgstr ""

#: src/2388-try-expr.md:837
msgid "**Risk of breakage:**"
msgstr ""

#: src/2388-try-expr.md:838
msgid ""
"**Used in std:** [_No_](https://doc.rust-lang.org/nightly/std/?"
"search=returned)."
msgstr ""

#: src/2388-try-expr.md:839
msgid "**Used as crate?** [_No_](https://crates.io/crates/returned)."
msgstr ""

#: src/2388-try-expr.md:849
msgid ""
"Of these, only `resultof` seems to be semantically descriptive and has some "
"support. However, it has three major drawbacks:"
msgstr ""

#: src/2388-try-expr.md:851
msgid ""
"Length: Compared to `try`, it is 5 characters longer (see reasoning for "
"`fallible`)."
msgstr ""

#: src/2388-try-expr.md:853
msgid ""
"Not a word: `resultof` is in fact a concatenation of `result` and `of`. This "
"does not feel like a natural fit for Rust, as we tend to use a `_` "
"separator. Furthermore, there are no current keywords in use that are "
"concatenations of two word."
msgstr ""

#: src/2388-try-expr.md:857
msgid ""
"`Result<T, E>` oriented: `resultof` is too tied to `Result<T, E>` and fits "
"poorly with `Option<T>` or other types that implement `Try`."
msgstr ""

#: src/2388-try-expr.md:859
msgid "Prior art"
msgstr ""

#: src/2388-try-expr.md:862
msgid ""
"All of the languages listed below have a `try { .. } <handler_kw> { .. }` "
"concept (modulo layout syntax / braces) where `<handler_kw>` is one of: "
"`catch`, `with`, `except`, `trap`, `rescue`."
msgstr ""

#: src/2388-try-expr.md:866
msgid ""
"In total, these are 29 languages and they have massive ~80% dominance "
"according to the [TIOBE index](https://www.tiobe.com/tiobe-index/) and "
"roughly the same with the [PYPL index](http://pypl.github.io/PYPL.html)."
msgstr ""

#: src/2388-try-expr.md:870
msgid "[C++](http://en.cppreference.com/w/cpp/language/try_catch)"
msgstr ""

#: src/2388-try-expr.md:871
msgid "[D](https://tour.dlang.org/tour/en/basics/exceptions)"
msgstr ""

#: src/2388-try-expr.md:872
msgid ""
"[C#](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/"
"keywords/try-catch)"
msgstr ""

#: src/2388-try-expr.md:873
msgid ""
"[Java](https://docs.oracle.com/javase/tutorial/essential/exceptions/try.html)"
msgstr ""

#: src/2388-try-expr.md:874
msgid ""
"[Scala](https://stackoverflow.com/questions/18685573/try-catch-finally-"
"return-value)"
msgstr ""

#: src/2388-try-expr.md:875
msgid "[Kotlin](https://kotlinlang.org/docs/reference/exceptions.html)"
msgstr ""

#: src/2388-try-expr.md:876
msgid ""
"[JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/"
"Reference/Statements/try...catch)"
msgstr ""

#: src/2388-try-expr.md:877
msgid ""
"[TypeScript](https://www.typescriptlang.org/docs/handbook/release-notes/"
"typescript-2-5.html)"
msgstr ""

#: src/2388-try-expr.md:878
msgid ""
"[ActionScript](https://help.adobe.com/en_US/ActionScript/3.0_ProgrammingAS3/"
"WS5b3ccc516d4fbf351e63e3d118a9b90204-7ed1."
"html#WS5b3ccc516d4fbf351e63e3d118a9b90204-7ec5)"
msgstr ""

#: src/2388-try-expr.md:879
msgid "[Dart](https://www.dartlang.org/resources/dart-tips/dart-tips-ep-9)"
msgstr ""

#: src/2388-try-expr.md:880
msgid "[Python](https://docs.python.org/3/tutorial/errors.html)"
msgstr ""

#: src/2388-try-expr.md:881
msgid "[PHP](http://php.net/manual/en/language.exceptions.php)"
msgstr ""

#: src/2388-try-expr.md:882
msgid "[Matlab](https://se.mathworks.com/help/matlab/ref/try.html)"
msgstr ""

#: src/2388-try-expr.md:883
msgid ""
"[Visual Basic](https://docs.microsoft.com/en-us/dotnet/visual-basic/language-"
"reference/statements/try-catch-finally-statement)"
msgstr ""

#: src/2388-try-expr.md:884
msgid "[OCaml](https://ocaml.org/learn/tutorials/error_handling.html)"
msgstr ""

#: src/2388-try-expr.md:885
msgid ""
"[F#](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/"
"exception-handling/the-try-with-expression)"
msgstr ""

#: src/2388-try-expr.md:886
msgid ""
"[Objective C](https://developer.apple.com/library/content/documentation/"
"Cocoa/Conceptual/ProgrammingWithObjectiveC/ErrorHandling/ErrorHandling."
"html#//apple_ref/doc/uid/TP40011210-CH9-SW3)"
msgstr ""

#: src/2388-try-expr.md:887
msgid ""
"[Swift](https://developer.apple.com/library/content/documentation/Swift/"
"Conceptual/Swift_Programming_Language/ErrorHandling.html)"
msgstr ""

#: src/2388-try-expr.md:888
msgid ""
"[Delphi](https://stackoverflow.com/questions/6601147/how-to-correctly-write-"
"try-finally-except-statements)"
msgstr ""

#: src/2388-try-expr.md:889
msgid ""
"[Julia](https://docs.julialang.org/en/stable/manual/control-flow/#The-try/"
"catch-statement-1)"
msgstr ""

#: src/2388-try-expr.md:890
msgid ""
"[Elixir](https://elixir-lang.org/getting-started/try-catch-and-rescue.html)"
msgstr ""

#: src/2388-try-expr.md:891
msgid "[Erlang](http://erlang.org/doc/reference_manual/expressions.html#try)"
msgstr ""

#: src/2388-try-expr.md:892
msgid "[Clojure](https://clojuredocs.org/clojure.core/try)"
msgstr ""

#: src/2388-try-expr.md:893
msgid ""
"[R](https://www.rdocumentation.org/packages/base/versions/3.0.3/topics/"
"conditions), modulo minor syntactic difference."
msgstr ""

#: src/2388-try-expr.md:894
msgid ""
"[Powershell](https://docs.microsoft.com/en-us/powershell/module/microsoft."
"powershell.core/about/about_try_catch_finally?view=powershell-6)"
msgstr ""

#: src/2388-try-expr.md:895
msgid "[Tcl](http://wiki.tcl.tk/8293)"
msgstr ""

#: src/2388-try-expr.md:896
msgid ""
"[Apex](https://developer.salesforce.com/page/"
"An_Introduction_to_Exception_Handling)"
msgstr ""

#: src/2388-try-expr.md:897
msgid ""
"[RPG](http://devnet.asna.com/documentation/Help102/AVR/_HTML/TRYCATCHFINALLY."
"htm)"
msgstr ""

#: src/2388-try-expr.md:898
msgid ""
"[ABAP](https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-US/abaptry."
"htm)"
msgstr ""

#: src/2388-try-expr.md:900
msgid ""
"The syntactic form `catch { .. }` seems quite rare and is, together with "
"`trap`, `rescue`, `except`, only used for handlers. However, the `<kw> { .. }"
"` expression we want to introduce is not a handler, but rather the body of "
"expression we wish to `try`."
msgstr ""

#: src/2388-try-expr.md:905
msgid ""
"There are however a few languages where `catch { .. }` is used for the "
"fallible part and not for the handler, these languages are:"
msgstr ""

#: src/2388-try-expr.md:907
msgid "[Erlang](http://erlang.org/doc/reference_manual/expressions.html#catch)"
msgstr ""

#: src/2388-try-expr.md:908
msgid "[Tcl](https://www.tcl.tk/man/tcl/TclCmd/catch.htm)"
msgstr ""

#: src/2388-try-expr.md:910
msgid ""
"However, the combined popularity of these languages are not significant as "
"compared to that for `try { .. }`."
msgstr ""

#: src/2388-try-expr.md:913
msgid "Unresolved questions"
msgstr ""

#: src/2388-try-expr.md:916
msgid "None as of yet."
msgstr ""
