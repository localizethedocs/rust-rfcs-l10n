msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:05Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2570-linked-list-cursors.md:1
msgid "Feature Name: `linked_list_cursors`"
msgstr ""

#: src/2570-linked-list-cursors.md:2
msgid "Start Date: 2018-10-14"
msgstr ""

#: src/2570-linked-list-cursors.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2570](https://github.com/rust-lang/rfcs/pull/2570)"
msgstr ""

#: src/2570-linked-list-cursors.md:4
msgid ""
"Rust Issue: [rust-lang/rust#58533](https://github.com/rust-lang/rust/"
"issues/58533)"
msgstr ""

#: src/2570-linked-list-cursors.md:6
msgid "Summary"
msgstr ""

#: src/2570-linked-list-cursors.md:9
msgid ""
"Many of the benefits of linked lists rely on the fact that most operations "
"(insert, remove, split, splice etc.) can be performed in constant time once "
"one reaches the desired element. To take advantage of this, a `Cursor` "
"interface can be created to efficiently edit linked lists. Furthermore, "
"unstable extensions like the `IterMut` changes will be removed."
msgstr ""

#: src/2570-linked-list-cursors.md:15
msgid "Motivation"
msgstr ""

#: src/2570-linked-list-cursors.md:18
msgid "From Programming Rust:"
msgstr ""

#: src/2570-linked-list-cursors.md:19
msgid ""
"As of Rust 1.12, Rustâ€™s LinkedList type has no methods for removing a range "
"of elements from a list or inserting elements at specific locations in a "
"list. The API seems incomplete."
msgstr ""

#: src/2570-linked-list-cursors.md:23
msgid ""
"Both of these issues have been fixed, but in different and incompatible "
"ways. Removing a range of elements is possible though the unstable "
"`drain_filter` API, and inserting elements in at specific locations in a "
"list is possible through the `linked_list_extras` extensions to `IterMut`."
msgstr ""

#: src/2570-linked-list-cursors.md:28
msgid ""
"This motivates the need for a standard interface for insertion and deletion "
"of elements in a linked list. An efficient way to implement this is through "
"the use of \"cursors\". A cursor represents a position in a collection that "
"can be moved back and forth, somewhat like a `DoubleEndedIterator`. However, "
"mutable cursors can also edit the collection at their position."
msgstr ""

#: src/2570-linked-list-cursors.md:34
msgid ""
"A mutable cursor would allow for constant time insertion and deletion of "
"elements and insertion and splitting of lists at its position. This would "
"allow for simplification of the `IterMut` API and a complete LinkedList "
"implementation."
msgstr ""

#: src/2570-linked-list-cursors.md:39
msgid "Guide-level explanation"
msgstr ""

#: src/2570-linked-list-cursors.md:42
msgid ""
"The cursor interface would provides two new types: `Cursor` and `CursorMut`. "
"These are created in the same way as iterators."
msgstr ""

#: src/2570-linked-list-cursors.md:45
msgid ""
"With a `Cursor` one can seek back and forth through a list and get the "
"current element. With a `CursorMut` One can seek back and forth and get "
"mutable references to elements, and it can insert and delete elements before "
"and behind the current element (along with performing several list "
"operations such as splitting and splicing)."
msgstr ""

#: src/2570-linked-list-cursors.md:51
msgid "Lets look at where these might be useful."
msgstr ""

#: src/2570-linked-list-cursors.md:53
msgid "Examples"
msgstr ""

#: src/2570-linked-list-cursors.md:55
msgid ""
"This interface is helpful most times insertion and deletion are used "
"together."
msgstr ""

#: src/2570-linked-list-cursors.md:57
msgid ""
"For example, consider you had a linked list and wanted to remove all "
"elements which satisfy a certain predicate, and replace them with another "
"element. With the old interface, one would have to insert and delete "
"separately, or split the list many times. With the cursor interface, one can "
"do the following:"
msgstr ""

#: src/2570-linked-list-cursors.md:67
msgid "// move to the first element, if it exists\n"
msgstr ""

#: src/2570-linked-list-cursors.md:82
msgid ""
"This could also be done using iterators. One could transform the list into "
"an iterator, perform operations on it and collect. This is easier, however "
"it still requires much needless allocation."
msgstr ""

#: src/2570-linked-list-cursors.md:86
msgid ""
"For another example, consider code that was previously using `IterMut` "
"extensions."
msgstr ""

#: src/2570-linked-list-cursors.md:100
msgid "This can be changed almost verbatim to `CursorMut`:"
msgstr ""

#: src/2570-linked-list-cursors.md:114
msgid ""
"In general, the cursor interface is not the easiest way to do something. "
"However, it provides a basic API that can be built on to perform more "
"complicated tasks."
msgstr ""

#: src/2570-linked-list-cursors.md:118
msgid "Reference-level explanation"
msgstr ""

#: src/2570-linked-list-cursors.md:121
msgid ""
"One gets a cursor the exact same way as one would get an iterator. The "
"returned cursor would point to the \"empty\" element, i.e. if you got an "
"element and called `current` you would receive `None`."
msgstr ""

#: src/2570-linked-list-cursors.md:125
msgid "/// Provides a cursor to the first element of the list.\n"
msgstr ""

#: src/2570-linked-list-cursors.md:127
msgid "/// Provides a mutable cursor to the first element of the list.\n"
msgstr ""

#: src/2570-linked-list-cursors.md:130
msgid "/// Provides a cursor to the last element of the list.\n"
msgstr ""

#: src/2570-linked-list-cursors.md:133
msgid "/// Provides a mutable cursor to the last element of the list.\n"
msgstr ""

#: src/2570-linked-list-cursors.md:138
msgid "These would provide the following interface:"
msgstr ""

#: src/2570-linked-list-cursors.md:142 src/2570-linked-list-cursors.md:160
msgid "/// Returns the cursor position index within the `LinkedList`.\n"
msgstr ""

#: src/2570-linked-list-cursors.md:145 src/2570-linked-list-cursors.md:163
msgid ""
"/// Move to the subsequent element of the list if it exists or the empty\n"
"    /// element\n"
msgstr ""

#: src/2570-linked-list-cursors.md:148 src/2570-linked-list-cursors.md:166
msgid "/// Move to the previous element of the list\n"
msgstr ""

#: src/2570-linked-list-cursors.md:151 src/2570-linked-list-cursors.md:169
msgid "/// Get the current element\n"
msgstr ""

#: src/2570-linked-list-cursors.md:153
msgid "/// Get the following element\n"
msgstr ""

#: src/2570-linked-list-cursors.md:155 src/2570-linked-list-cursors.md:173
msgid "/// Get the previous element\n"
msgstr ""

#: src/2570-linked-list-cursors.md:171
msgid "/// Get the next element\n"
msgstr ""

#: src/2570-linked-list-cursors.md:176
msgid "/// Get an immutable cursor at the current element\n"
msgstr ""

#: src/2570-linked-list-cursors.md:179
msgid "// Now the list editing operations\n"
msgstr ""

#: src/2570-linked-list-cursors.md:181
msgid "/// Insert `item` after the cursor\n"
msgstr ""

#: src/2570-linked-list-cursors.md:183
msgid "/// Insert `item` before the cursor\n"
msgstr ""

#: src/2570-linked-list-cursors.md:186
msgid ""
"/// Remove the current item. The new current item is the item following the\n"
"    /// removed one.\n"
msgstr ""

#: src/2570-linked-list-cursors.md:190
msgid "/// Insert `list` between the current element and the next\n"
msgstr ""

#: src/2570-linked-list-cursors.md:192
msgid "/// Insert `list` between the previous element and current\n"
msgstr ""

#: src/2570-linked-list-cursors.md:195
msgid ""
"/// Split the list in two after the current element\n"
"    /// The returned list consists of all elements following the current "
"one.\n"
msgstr ""

#: src/2570-linked-list-cursors.md:198
msgid "/// Split the list in two before the current element\n"
msgstr ""

#: src/2570-linked-list-cursors.md:202
msgid ""
"One should closely consider the lifetimes in this interface. Both `Cursor` "
"and `CursorMut` operate on data in their `LinkedList`. This is why, they "
"both hold the annotation of `'list`."
msgstr ""

#: src/2570-linked-list-cursors.md:206
msgid "The lifetime elision for their constructors is correct as"
msgstr ""

#: src/2570-linked-list-cursors.md:210
msgid "becomes"
msgstr ""

#: src/2570-linked-list-cursors.md:214
msgid "which is what we would expect. (the same goes for `CursorMut`)."
msgstr ""

#: src/2570-linked-list-cursors.md:216
msgid ""
"Since `Cursor` cannot mutate its list, `current`, `peek_next` and "
"`peek_prev` all live as long as `'list`. However, in `CursorMut` we must be "
"careful to make these methods borrow. Otherwise, one could produce multiple "
"mutable references to the same element."
msgstr ""

#: src/2570-linked-list-cursors.md:221
msgid ""
"The only other lifetime annotation is with `as_cursor`. In this case, the "
"returned `Cursor` must borrow its generating `CursorMut`. Otherwise, it "
"would be possible to achieve a mutable and immutable reference to the same "
"element at once."
msgstr ""

#: src/2570-linked-list-cursors.md:226
msgid ""
"One question that arises from this interface is what happens if `move_next` "
"is called when a cursor is on the last element of the list, or is empty (or "
"`move_prev` and the beginning). A simple way to solve this is to make "
"cursors wrap around this list back to the empty element. One could "
"complicate the interface by having move return a `bool`, however this is "
"unnecessary since `current` is sufficient to know whether the iterator is at "
"the end of the list."
msgstr ""

#: src/2570-linked-list-cursors.md:233
msgid ""
"A large consequence of this new interface is that it is a complete superset "
"of the already existing `Iter` and `IterMut` API. Therefore, the following "
"two methods added to `IterMut` in the `linked_list_extras` features should "
"be removed or depreciated:"
msgstr ""

#: src/2570-linked-list-cursors.md:237
msgid "`IterMut::insert_next`"
msgstr ""

#: src/2570-linked-list-cursors.md:238
msgid ""
"`IterMut::peek_next` The rest of the iterator methods are stable and should "
"probably stay untouched (but see below for comments)."
msgstr ""

#: src/2570-linked-list-cursors.md:242
msgid "Drawbacks"
msgstr ""

#: src/2570-linked-list-cursors.md:245
msgid ""
"The cursor interface is rather clunky, and while it allows for efficient "
"code, it is probably not useful outside of many use-cases."
msgstr ""

#: src/2570-linked-list-cursors.md:248
msgid ""
"One of the largest issues with the cursor interface is that it exposes the "
"exact same interface of iterators (and more), which leads to unnecessary "
"code duplication. However, the purpose of iterators seems to be simple, "
"abstract and easy to use rather than efficient mutation, so cursors and "
"iterators should be used in different places."
msgstr ""

#: src/2570-linked-list-cursors.md:255
msgid "Rationale and alternatives"
msgstr ""

#: src/2570-linked-list-cursors.md:258
msgid "There are several alternatives to this:"
msgstr ""

#: src/2570-linked-list-cursors.md:260
msgid ""
"Implement cursors as a trait extending `Iterator` (see the cursors pseudo-"
"rfc below)"
msgstr ""

#: src/2570-linked-list-cursors.md:263
msgid ""
"Since the cursors are just an extension of iterators, it makes some sense to "
"create them as a trait. However, I see several reasons why this is not the "
"best."
msgstr ""

#: src/2570-linked-list-cursors.md:266
msgid ""
"First, cursors work differently than the existing `Iterator` extensions like "
"`DoubleEndedIterator`. In a `DoubleEndedIterator`, if one calls `next_back` "
"and then `next`, it should not return the same value, so unlike a cursor, a "
"`DoubleEndedIterator` does not move back and forth throughout a collection."
msgstr ""

#: src/2570-linked-list-cursors.md:271
msgid ""
"Furthermore, while `Iterator` is a general interface for many collections, "
"`Cursor` is very much specific to linked lists. In other collections such as "
"`Vec` a cursor does not make sense. So it makes little sense to make a trait "
"when it will only be used in one place."
msgstr ""

#: src/2570-linked-list-cursors.md:276
msgid "Using the `IterMut` linked list extensions"
msgstr ""

#: src/2570-linked-list-cursors.md:278
msgid ""
"Insertion was added to `IterMut` in the `linked_list_extras` feature. Many "
"of these features could be added to it just as well. But, this overcrowds "
"`IterMut` with many methods that have nothing to do with iteration (such as "
"deletion, splitting etc.) It makes sense to put these explicitly in their "
"own type, and this can be `CursorMut`."
msgstr ""

#: src/2570-linked-list-cursors.md:285
msgid "Do not create cursors at all"
msgstr ""

#: src/2570-linked-list-cursors.md:287
msgid ""
"Everything that cursors do can already be done, albeit in sometimes a less "
"efficient way. Efficient code can be written by splitting linked lists "
"often, and while this is a complicated way to do things, the rarity of the "
"use case may justify keeping things how they are."
msgstr ""

#: src/2570-linked-list-cursors.md:292
msgid "Prior art"
msgstr ""

#: src/2570-linked-list-cursors.md:295
msgid ""
"[cursors pseudo-rfc](https://internals.rust-lang.org/t/pseudo-rfc-cursors-"
"reversible-iterators/386/18)"
msgstr ""

#: src/2570-linked-list-cursors.md:297
msgid ""
"This rust internals post describes an early attempt at making cursors. The "
"language was in a different state when it was written (pre-1.0), so details "
"have changed since then. But this describes several different approaches to "
"making cursors and where they led."
msgstr ""

#: src/2570-linked-list-cursors.md:302
msgid "Java-style iterators"
msgstr ""

#: src/2570-linked-list-cursors.md:304
msgid ""
"Java (and other languages) tried to fix this by adding a `remove` function "
"to their iterators. However, I feel this method would not be the best choice "
"for Rust (even for specific `IterMut`s like those in LinkedList) since it "
"diverges from the expected behaviour of iterators."
msgstr ""

#: src/2570-linked-list-cursors.md:309
msgid ""
"[linked list extras issue](https://github.com/rust-lang/rust/issues/27794)"
msgstr ""

#: src/2570-linked-list-cursors.md:311
msgid ""
"Discussion on the issue tracker about how this is currently managed with "
"modifications to `IterMut`. The consensus seems to be that it is incomplete, "
"and it is suggested to create a new `Cursor` and `CursorMut` types."
msgstr ""

#: src/2570-linked-list-cursors.md:315
msgid "Unresolved questions"
msgstr ""

#: src/2570-linked-list-cursors.md:318
msgid "How will this interface interact with iterators?"
msgstr ""

#: src/2570-linked-list-cursors.md:320
msgid ""
"Will we keep both `Iter` and `Cursor` types? Implement one with another? I "
"feel like they should be different things, but there is reason to "
"consolidate them."
msgstr ""

#: src/2570-linked-list-cursors.md:323
msgid "Only for linked lists?"
msgstr ""

#: src/2570-linked-list-cursors.md:325
msgid ""
"Should we implement this for more collections? It could make sense for other "
"collections, such as trees and arrays, but the design would have to be "
"reworked."
msgstr ""
