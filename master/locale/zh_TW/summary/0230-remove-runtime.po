msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:42Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0230-remove-runtime.md:1
msgid "Start Date: 2014-09-16"
msgstr ""

#: src/0230-remove-runtime.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#230](https://github.com/rust-lang/rfcs/pull/230)"
msgstr ""

#: src/0230-remove-runtime.md:3
msgid ""
"Rust Issue: [rust-lang/rust#17325](https://github.com/rust-lang/rust/"
"issues/17325)"
msgstr ""

#: src/0230-remove-runtime.md:5
msgid "Summary"
msgstr "摘要"

#: src/0230-remove-runtime.md:7
msgid ""
"This RFC proposes to remove the _runtime system_ that is currently part of "
"the standard library, which currently allows the standard library to support "
"both native and green threading. In particular:"
msgstr ""

#: src/0230-remove-runtime.md:11
msgid ""
"The `libgreen` crate and associated support will be moved out of tree, into "
"a separate Cargo package."
msgstr ""

#: src/0230-remove-runtime.md:14
msgid "The `librustrt` (the runtime) crate will be removed entirely."
msgstr ""

#: src/0230-remove-runtime.md:16
msgid ""
"The `std::io` implementation will be directly welded to native threads and "
"system calls."
msgstr ""

#: src/0230-remove-runtime.md:19
msgid ""
"The `std::io` module will remain completely cross-platform, though "
"_separate_ platform-specific modules may be added at a later time."
msgstr ""

#: src/0230-remove-runtime.md:22
msgid "Motivation"
msgstr "動機"

#: src/0230-remove-runtime.md:24
msgid "Background: thread/task models and I/O"
msgstr ""

#: src/0230-remove-runtime.md:26
msgid ""
"Many languages/libraries offer some notion of \"task\" as a unit of "
"concurrent execution, possibly distinct from native OS threads. The "
"characteristics of tasks vary along several important dimensions:"
msgstr ""

#: src/0230-remove-runtime.md:30
msgid ""
"_1:1 vs M:N_. The most fundamental question is whether a \"task\" always "
"corresponds to an OS-level thread (the 1:1 model), or whether there is some "
"userspace scheduler that maps tasks onto worker threads (the M:N model).  "
"Some kernels -- notably, Windows -- support a 1:1 model where the scheduling "
"is performed in userspace, which combines some of the advantages of the two "
"models."
msgstr ""

#: src/0230-remove-runtime.md:37
msgid ""
"In the M:N model, there are various choices about whether and when blocked "
"tasks can migrate between worker threads. One basic downside of the model, "
"however, is that if a task takes a page fault, the entire worker thread is "
"essentially blocked until the fault is serviced. Choosing the optimal number "
"of worker threads is difficult, and some frameworks attempt to do so "
"dynamically, which has costs of its own."
msgstr ""

#: src/0230-remove-runtime.md:44
msgid ""
"_Stack management_. In the 1:1 model, tasks are threads and therefore must "
"be equipped with their own stacks. In M:N models, tasks may or may not need "
"their own stack, but there are important tradeoffs:"
msgstr ""

#: src/0230-remove-runtime.md:48
msgid ""
"Techniques like _segmented stacks_ allow stack size to grow over time, "
"meaning that tasks can be equipped with their own stack but still be "
"lightweight. Unfortunately, segmented stacks come with [a significant "
"performance and complexity cost](https://mail.mozilla.org/pipermail/rust-"
"dev/2013-November/006314.html)."
msgstr ""

#: src/0230-remove-runtime.md:53
msgid ""
"On the other hand, if tasks are not equipped with their own stack, they "
"either cannot be migrated between underlying worker threads (the case for "
"frameworks like Java's [fork/join](http://gee.cs.oswego.edu/dl/papers/fj."
"pdf)), or else must be implemented using _continuation-passing style (CPS)_, "
"where each blocking operation takes a closure representing the work left to "
"do. (CPS essentially moves the needed parts of the stack into the "
"continuation closure.) The upside is that such tasks can be extremely "
"lightweight -- essentially just the size of a closure."
msgstr ""

#: src/0230-remove-runtime.md:63
msgid ""
"_Blocking and I/O support_. In the 1:1 model, a task can block freely "
"without any risk for other tasks, since each task is an OS thread. In the M:"
"N model, however, blocking in the OS sense means blocking the worker thread. "
"(The same applies to long-running loops or page faults.)"
msgstr ""

#: src/0230-remove-runtime.md:68
msgid ""
"M:N models can deal with blocking in a couple of ways. The approach taken in "
"Java's [fork/join](http://gee.cs.oswego.edu/dl/papers/fj.pdf) framework, for "
"example, is to dynamically spin up/down worker threads. Alternatively, "
"special task-aware blocking operations (including I/O) can be provided, "
"which are mapped under the hood to nonblocking operations, allowing the "
"worker thread to continue. Unfortunately, this latter approach helps only "
"with explicit blocking; it does nothing for loops, page faults and the like."
msgstr ""

#: src/0230-remove-runtime.md:76
msgid "Where Rust is now"
msgstr ""

#: src/0230-remove-runtime.md:78
msgid ""
"Rust has gradually migrated from a \"green\" threading model toward a native "
"threading model:"
msgstr ""

#: src/0230-remove-runtime.md:81
msgid ""
"In Rust's green threading, tasks are scheduled M:N and are equipped with "
"their own stack. Initially, Rust used segmented stacks to allow growth over "
"time, but that [was removed](https://mail.mozilla.org/pipermail/rust-"
"dev/2013-November/006314.html) in favor of pre-allocated stacks, which means "
"Rust's green threads are not \"lightweight\". The treatment of blocking is "
"described below."
msgstr ""

#: src/0230-remove-runtime.md:88
msgid "In Rust's native threading model, tasks are 1:1 with OS threads."
msgstr ""

#: src/0230-remove-runtime.md:90
msgid ""
"Initially, Rust supported only the green threading model. Later, native "
"threading was added and ultimately became the default."
msgstr ""

#: src/0230-remove-runtime.md:93
msgid ""
"In today's Rust, there is a single I/O API -- `std::io` -- that provides "
"blocking operations only and works with both threading models. Rust is "
"somewhat unusual in allowing programs to mix native and green threading, and "
"furthermore allowing _some_ degree of interoperation between the two. This "
"feat is achieved through the runtime system -- `librustrt` -- which exposes:"
msgstr ""

#: src/0230-remove-runtime.md:99
msgid ""
"The `Runtime` trait, which abstracts over the scheduler (via methods like "
"`deschedule` and `spawn_sibling`) as well as the entire I/O API (via "
"`local_io`)."
msgstr ""

#: src/0230-remove-runtime.md:103
msgid ""
"The `rtio` module, which provides a number of traits that define the "
"standard I/O abstraction."
msgstr ""

#: src/0230-remove-runtime.md:106
msgid ""
"The `Task` struct, which includes a `Runtime` trait object as the dynamic "
"entry point into the runtime."
msgstr ""

#: src/0230-remove-runtime.md:109
msgid ""
"In this setup, `libstd` works directly against the runtime interface. When "
"invoking an I/O or scheduling operation, it first finds the current `Task`, "
"and then extracts the `Runtime` trait object to actually perform the "
"operation."
msgstr ""

#: src/0230-remove-runtime.md:113
msgid ""
"On native tasks, blocking operations simply block. On green tasks, blocking "
"operations are routed through the green scheduler and/or underlying event "
"loop and nonblocking I/O."
msgstr ""

#: src/0230-remove-runtime.md:117
msgid ""
"The actual scheduler and I/O implementations -- `libgreen` and `libnative` "
"-- then live as crates \"above\" `libstd`."
msgstr ""

#: src/0230-remove-runtime.md:120
msgid "The problems"
msgstr ""

#: src/0230-remove-runtime.md:122
msgid ""
"While the situation described above may sound good in principle, there are "
"several problems in practice."
msgstr ""

#: src/0230-remove-runtime.md:125
msgid ""
"**Forced co-evolution.** With today's design, the green and native threading "
"models must provide the same I/O API at all times. But there is "
"functionality that is only appropriate or efficient in one of the threading "
"models."
msgstr ""

#: src/0230-remove-runtime.md:130
msgid ""
"For example, the lightest-weight M:N task models are essentially just "
"collections of closures, and do not provide any special I/O support. This "
"style of lightweight tasks is used in Servo, but also shows up in [java.util."
"concurrent's exectors](http://docs.oracle.com/javase/7/docs/api/java/util/"
"concurrent/Executors.html) and [Haskell's par monad](https://hackage.haskell."
"org/package/monad-par), among many others. These lighter weight models do "
"not fit into the current runtime system."
msgstr ""

#: src/0230-remove-runtime.md:138
msgid ""
"On the other hand, green threading systems designed explicitly to support I/"
"O may also want to provide low-level access to the underlying event loop -- "
"an API surface that doesn't make sense for the native threading model."
msgstr ""

#: src/0230-remove-runtime.md:142
msgid ""
"Under the native model we want to provide direct non-blocking and/or "
"asynchronous I/O support -- as a systems language, Rust should be able to "
"work directly with what the OS provides without imposing global abstraction "
"costs. These APIs may involve some platform-specific abstractions (`epoll`, "
"`kqueue`, IOCP) for maximal performance. But integrating them cleanly with a "
"green threading model may be difficult or impossible -- and at the very "
"least, makes it difficult to add them quickly and seamlessly to the current "
"I/O system."
msgstr ""

#: src/0230-remove-runtime.md:151
msgid ""
"In short, the current design couples threading and I/O models together, and "
"thus forces the green and native models to supply a common I/O interface -- "
"despite the fact that they are pulling in different directions."
msgstr ""

#: src/0230-remove-runtime.md:155
msgid ""
"**Overhead.** The current Rust model allows runtime mixtures of the green "
"and native models. The implementation achieves this flexibility by using "
"trait objects to model the entire I/O API. Unfortunately, this flexibility "
"has several downsides:"
msgstr ""

#: src/0230-remove-runtime.md:160
msgid ""
"_Binary sizes_. A significant overhead caused by the trait object design is "
"that the entire I/O system is included in any binary that statically links "
"to `libstd`. See [this comment](https://github.com/rust-lang/rust/"
"issues/10740#issuecomment-31475987) for more details."
msgstr ""

#: src/0230-remove-runtime.md:166
msgid ""
"_Task-local storage_. The current implementation of task-local storage is "
"designed to work seamlessly across native and green threads, and its "
"performs substantially suffers as a result. While it is feasible to provide "
"a more efficient form of \"hybrid\" TLS that works across models, doing so "
"is _far_ more difficult than simply using native thread-local storage."
msgstr ""

#: src/0230-remove-runtime.md:172
msgid ""
"_Allocation and dynamic dispatch_. With the current design, any invocation "
"of I/O involves at least dynamic dispatch, and in many cases allocation, due "
"to the use of trait objects. However, in most cases these costs are trivial "
"when compared to the cost of actually doing the I/O (or even simply making a "
"syscall), so they are not strong arguments against the current design."
msgstr ""

#: src/0230-remove-runtime.md:178
msgid ""
"**Problematic I/O interactions.** As the [documentation for libgreen](http://"
"doc.rust-lang.org/green/#considerations-when-using-libgreen) explains, only "
"some I/O and synchronization methods work seamlessly across native and green "
"tasks. For example, any invocation of native code that calls blocking I/O "
"has the potential to block the worker thread running the green scheduler. In "
"particular, `std::io` objects created on a native task cannot safely be used "
"within a green task. Thus, even though `std::io` presents a unified I/O API "
"for green and native tasks, it is not fully interoperable."
msgstr ""

#: src/0230-remove-runtime.md:187
msgid ""
"**Embedding Rust.** When embedding Rust code into other contexts -- whether "
"calling from C code or embedding in high-level languages -- there is a fair "
"amount of setup needed to provide the \"runtime\" infrastructure that "
"`libstd` relies on. If `libstd` was instead bound to the native threading "
"and I/O system, the embedding setup would be much simpler."
msgstr ""

#: src/0230-remove-runtime.md:193
msgid ""
"**Maintenance burden.** Finally, `libstd` is made somewhat more complex by "
"providing such a flexible threading model. As this RFC will explain, moving "
"to a strictly native threading model will allow substantial simplification "
"and reorganization of the structure of Rust's libraries."
msgstr ""

#: src/0230-remove-runtime.md:198
msgid "Detailed design"
msgstr "詳細設計"

#: src/0230-remove-runtime.md:200
msgid ""
"To mitigate the above problems, this RFC proposes to tie `std::io` directly "
"to the native threading model, while moving `libgreen` and its supporting "
"infrastructure into an external Cargo package with its own I/O API."
msgstr ""

#: src/0230-remove-runtime.md:204
msgid "The near-term plan"
msgstr ""

#: src/0230-remove-runtime.md:205
msgid "`std::io` and native threading"
msgstr ""

#: src/0230-remove-runtime.md:207
msgid ""
"The plan is to entirely remove `librustrt`, including all of the traits. The "
"abstraction layers will then become:"
msgstr ""

#: src/0230-remove-runtime.md:210
msgid ""
"Highest level: `libstd`, providing cross-platform, high-level I/O and "
"scheduling abstractions.  The crate will depend on `libnative` (the opposite "
"of today's situation)."
msgstr ""

#: src/0230-remove-runtime.md:214
msgid ""
"Mid-level: `libnative`, providing a cross-platform Rust interface for I/O "
"and scheduling. The API will be relatively low-level, compared to `libstd`. "
"The crate will depend on `libsys`."
msgstr ""

#: src/0230-remove-runtime.md:218
msgid ""
"Low-level: `libsys` (renamed from `liblibc`), providing platform-specific "
"Rust bindings to system C APIs."
msgstr ""

#: src/0230-remove-runtime.md:221
msgid ""
"In this scheme, the actual API of `libstd` will not change significantly. "
"But its implementation will invoke functions in `libnative` directly, rather "
"than going through a trait object."
msgstr ""

#: src/0230-remove-runtime.md:225
msgid ""
"A goal of this work is to minimize the complexity of embedding Rust code in "
"other contexts. It is not yet clear what the final embedding API will look "
"like."
msgstr ""

#: src/0230-remove-runtime.md:228
msgid "Green threading"
msgstr ""

#: src/0230-remove-runtime.md:230
msgid ""
"Despite tying `libstd` to native threading, however, `libgreen` will still "
"be supported -- at least initially. The infrastructure in `libgreen` and "
"friends will move into its own Cargo package."
msgstr ""

#: src/0230-remove-runtime.md:234
msgid ""
"Initially, the green threading package will support essentially the same "
"interface it does today; there are no immediate plans to change its API, "
"since the focus will be on first improving the native threading API. Note, "
"however, that the I/O API will be exposed separately within `libgreen`, as "
"opposed to the current exposure through `std::io`."
msgstr ""

#: src/0230-remove-runtime.md:240
msgid "The long-term plan"
msgstr ""

#: src/0230-remove-runtime.md:242
msgid ""
"Ultimately, a large motivation for the proposed refactoring is to allow the "
"APIs for native I/O to grow."
msgstr ""

#: src/0230-remove-runtime.md:245
msgid ""
"In particular, over time we should expose more of the underlying system "
"capabilities under the native threading model. Whenever possible, these "
"capabilities should be provided at the `libstd` level -- the highest level "
"of cross-platform abstraction. However, an important goal is also to provide "
"nonblocking and/or asynchronous I/O, for which system APIs differ greatly. "
"It may be necessary to provide additional, platform-specific crates to "
"expose this functionality. Ideally, these crates would interoperate smoothly "
"with `libstd`, so that for example a `libposix` crate would allow using an "
"`poll` operation directly against a `std::io::fs::File` value, for example."
msgstr ""

#: src/0230-remove-runtime.md:255
msgid ""
"We also wish to expose \"lowering\" operations in `libstd` -- APIs that "
"allow you to get at the file descriptor underlying a `std::io::fs::File`, "
"for example."
msgstr ""

#: src/0230-remove-runtime.md:258
msgid ""
"On the other hand, we very much want to explore and support truly "
"lightweight M:N task models (that do not require per-task stacks) -- "
"supporting efficient data parallelism with work stealing for CPU-bound "
"computations. These lightweight models will not provide any special support "
"for I/O. But they may benefit from a notion of \"task-local storage\" and "
"interfacing with the task scheduler when explicitly synchronizing between "
"tasks (via channels, for example)."
msgstr ""

#: src/0230-remove-runtime.md:266
msgid ""
"All of the above long-term plans will require substantial new design and "
"implementation work, and the specifics are out of scope for this RFC. The "
"main point, though, is that the refactoring proposed by this RFC will make "
"it much more plausible to carry out such work."
msgstr ""

#: src/0230-remove-runtime.md:271
msgid ""
"Finally, a guiding principle for the above work is _uncompromising support_ "
"for native system APIs, in terms of both functionality and performance. For "
"example, it must be possible to use thread-local storage without significant "
"overhead, which is very much not the case today. Any abstractions to support "
"M:N threading models -- including the now-external `libgreen` package -- "
"must respect this constraint."
msgstr ""

#: src/0230-remove-runtime.md:278
msgid "Drawbacks"
msgstr ""

#: src/0230-remove-runtime.md:280
msgid ""
"The main drawback of this proposal is that green I/O will be provided by a "
"forked interface of `std::io`. This change makes green threading \"second "
"class\", and means there's more to learn when using both models together."
msgstr ""

#: src/0230-remove-runtime.md:285
msgid ""
"This setup also somewhat increases the risk of invoking native blocking I/O "
"on a green thread -- though of course that risk is very much present today. "
"One way of mitigating this risk in general is the Java executor approach, "
"where the native \"worker\" threads that are executing the green thread "
"scheduler are monitored for blocking, and new worker threads are spun up as "
"needed."
msgstr ""

#: src/0230-remove-runtime.md:291
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/0230-remove-runtime.md:293
msgid ""
"There are may unresolved questions about the exact details of the "
"refactoring, but these are considered implementation details since the "
"`libstd` interface itself will not substantially change as part of this RFC."
msgstr ""
