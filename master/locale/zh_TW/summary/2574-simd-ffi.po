msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:05Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2574-simd-ffi.md:1
msgid "Feature Name: `simd_ffi`"
msgstr ""

#: src/2574-simd-ffi.md:2
msgid "Start Date: 2018-10-12"
msgstr ""

#: src/2574-simd-ffi.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2574](https://github.com/rust-lang/rfcs/pull/2574)"
msgstr ""

#: src/2574-simd-ffi.md:4
msgid ""
"Rust Issue: [rust-lang/rust#63068](https://github.com/rust-lang/rust/"
"issues/63068)"
msgstr ""

#: src/2574-simd-ffi.md:6
msgid "Summary"
msgstr "摘要"

#: src/2574-simd-ffi.md:9
msgid "This RFC allows using SIMD types in C FFI."
msgstr ""

#: src/2574-simd-ffi.md:11
msgid "Motivation"
msgstr "動機"

#: src/2574-simd-ffi.md:14
msgid ""
"The architecture-specific SIMD types provided in [`core::arch`](https://doc."
"rust-lang.org/stable/core/arch/index.html) cannot currently be used in C "
"FFI. That is, Rust programs cannot interface with C libraries that use these "
"in their APIs."
msgstr ""

#: src/2574-simd-ffi.md:18
msgid ""
"One notable example would be calling into vectorized [`libm`](https://"
"sourceware.org/glibc/wiki/libm) implementations like [`sleef`](https://sleef."
"org/), [`libmvec`](https://sourceware.org/glibc/wiki/libm), or Intel's "
"[`SVML`](https://software.intel.com/en-us/node/524289). The [`packed_simd`]"
"(https://github.com/rust-lang-nursery/packed_simd) crate relies on C FFI "
"with these fundamental libraries to offer competitive performance."
msgstr ""

#: src/2574-simd-ffi.md:30
msgid "Why is using SIMD vectors in C FFI currently disallowed?"
msgstr ""

#: src/2574-simd-ffi.md:32
msgid ""
"Consider the following example ([playground](https://play.rust-lang.org/?"
"gist=b8cfb63bb4e7fb00bb293f6e27061c52&version=nightly&mode=debug&edition=2015)):"
msgstr ""

#: src/2574-simd-ffi.md:36 src/2574-simd-ffi.md:130
msgid "\"C\""
msgstr ""

#: src/2574-simd-ffi.md:46
msgid ""
"In this example, a 256-bit wide vector type, `__m256`, is passed to an "
"`extern \"C\"` function via C FFI. Is the behavior of passing `__m256` to "
"the C function defined?"
msgstr ""

#: src/2574-simd-ffi.md:50
msgid ""
"That depends on both the platform and how the Rust program was compiled!"
msgstr ""

#: src/2574-simd-ffi.md:52
msgid ""
"First, let's make the platform concrete and assume that it follows the [x64 "
"SysV ABI](https://www.uclibc.org/docs/psABI-x86_64.pdf) which states:"
msgstr ""

#: src/2574-simd-ffi.md:55
msgid "**3.2.1 Registers and the Stack Frame**"
msgstr ""

#: src/2574-simd-ffi.md:57
msgid ""
"Intel AVX (Advanced Vector Extensions) provides 16 256-bit wide AVX "
"registers (`%ymm0` - `%ymm15`). The lower 128-bits of `%ymm0` - `%ymm15` are "
"aliased to the respective 128b-bit SSE registers (`%xmm0` - `%xmm15`). For "
"purposes of parameter passing and function return, `%xmmN` and `%ymmN` refer "
"to the same register. Only one of them can be used at the same time."
msgstr ""

#: src/2574-simd-ffi.md:63
msgid "**3.2.3 Parameter Passing**"
msgstr ""

#: src/2574-simd-ffi.md:65
msgid "**SSE** The class consists of types that fit into a vector register."
msgstr ""

#: src/2574-simd-ffi.md:67
msgid ""
"**SSEUP** The class consists of types that fit into a vector register and "
"can be passed and returned in the upper bytes of it."
msgstr ""

#: src/2574-simd-ffi.md:72
msgid ""
"Second, in `C`, the `__m256` type is only available if the current "
"translation unit is being compiled with `AVX` enabled."
msgstr ""

#: src/2574-simd-ffi.md:75
msgid ""
"Back to the example: `__m256` is a 256-bit wide vector type, that is, wider "
"than 128-bit, but it can be passed through a vector register using the lower "
"and upper 128-bits of a 256-bit wide register, and in C, if `__m256` can be "
"used, these registers are always available."
msgstr ""

#: src/2574-simd-ffi.md:80
msgid "That is, the C ABI requires two things:"
msgstr ""

#: src/2574-simd-ffi.md:82
msgid "that Rust passes `__m256` via a 256-bit wide register"
msgstr ""

#: src/2574-simd-ffi.md:83
msgid "that `foo` has the `#[target_feature(enable = \"avx\")]` attribute !"
msgstr ""

#: src/2574-simd-ffi.md:85
msgid ""
"And this is where things went wrong: in Rust, `__m256` is always available "
"independently of whether `AVX` is available or not<sup>[1]"
"(#layout_unspecified)</sup>, but we haven't specified how we are actually "
"compiling our Rust program above:"
msgstr ""

#: src/2574-simd-ffi.md:89
msgid ""
"if we compile it with `AVX` globally enabled, e.g., via `-C target-"
"feature=+avx`, then the behavior of calling `foo` is defined because "
"`__m256` will be passed to C in a single 256-bit wide register, which is "
"what the C ABI requires."
msgstr ""

#: src/2574-simd-ffi.md:94
msgid ""
"if we compile our program without `AVX` enabled, then the Rust program "
"cannot use 256-bit wide registers because they are not available, so "
"independently of how `__m256` will be passed to C, it won't be passed in a "
"256-bit wide register, and the behavior is undefined because of an ABI "
"mismatch."
msgstr ""

#: src/2574-simd-ffi.md:99
msgid ""
"<a name=\"layout_unspecified\">1</a>: its layout is currently unspecified "
"but that is not relevant for this issue - what matters is that 256-bit "
"registers are not available and therefore they cannot be used."
msgstr ""

#: src/2574-simd-ffi.md:103
msgid ""
"You might be wondering: why is `__m256` available even if `AVX` is not "
"available? The reason is that we want to use `__m256` in some parts of "
"Rust's programs even if `AVX` is not globally enabled, and currently we "
"don't have great infrastructure for conditionally allowing it in some parts "
"of the program and not others."
msgstr ""

#: src/2574-simd-ffi.md:109
msgid ""
"Ideally, one should only be able to use `__m256` and operations on it if "
"`AVX` is available, and this is exactly what this RFC proposes for using "
"vector types in C FFI: to always require `#[target_feature(enable = X)]` in "
"C FFI functions using SIMD types, where \"unblocking\" the use of each type "
"requires some particular feature to be enabled, e.g., `avx` or `avx2` in the "
"case of `__m256`."
msgstr ""

#: src/2574-simd-ffi.md:115
msgid "That is, the compiler would reject the example above with an error:"
msgstr ""

#: src/2574-simd-ffi.md:117
msgid ""
"```\n"
"error[E1337]: `__m256` on C FFI requires `#[target_feature(enable = "
"\"avx\")]`\n"
" --> src/main.rs:7:15\n"
"  |\n"
"7 |     fn foo(x: __m256) -> __m256;\n"
"  |               ^^^^^^\n"
"```"
msgstr ""

#: src/2574-simd-ffi.md:125
msgid ""
"And the following program would always have defined behavior ([playground]"
"(https://play.rust-lang.org/?"
"gist=db651d09441fd16172a5c94711b2ab97&version=nightly&mode=debug&edition=2015)):"
msgstr ""

#: src/2574-simd-ffi.md:129 src/2574-simd-ffi.md:135
msgid "\"avx\""
msgstr ""

#: src/2574-simd-ffi.md:136
msgid ""
"// note: this operation is used here for readability\n"
"            // but its behavior is currently unspecified (see note above).\n"
msgstr ""

#: src/2574-simd-ffi.md:145
msgid ""
"independently of the `-C target-feature`s used globally to compile the whole "
"binary. Note that:"
msgstr ""

#: src/2574-simd-ffi.md:148
msgid ""
"`extern \"C\" foo` is compiled with `AVX` enabled, so `foo` takes an "
"`__m256` like the C ABI expects"
msgstr ""

#: src/2574-simd-ffi.md:150
msgid ""
"the call to `foo` is guarded with an `is_x86_feature_detected`, that is, "
"`foo` will only be called if `AVX` is available at run-time"
msgstr ""

#: src/2574-simd-ffi.md:152
msgid ""
"if the Rust calling convention differs from the calling convention of the "
"`extern` function, Rust has to adapt these."
msgstr ""

#: src/2574-simd-ffi.md:155
msgid "Guide-level and reference-level explanation"
msgstr ""

#: src/2574-simd-ffi.md:158
msgid ""
"Architecture-specific vector types require `#[target_feature]`s to be FFI "
"safe. That is, they are only safely usable as part of the signature of "
"`extern` functions if the function has certain `#[target_feature]`s enabled."
msgstr ""

#: src/2574-simd-ffi.md:162
msgid ""
"Which `#[target_feature]`s must be enabled depends on the vector types being "
"used."
msgstr ""

#: src/2574-simd-ffi.md:165
msgid ""
"For the stable architecture-specific vector types the following target "
"features must be enabled:"
msgstr ""

#: src/2574-simd-ffi.md:168 src/2574-simd-ffi.md:191
msgid "`x86`/`x86_64`:"
msgstr ""

#: src/2574-simd-ffi.md:169
msgid "`__m128`, `__m128i`, `__m128d`: `\"sse\"`"
msgstr ""

#: src/2574-simd-ffi.md:170
msgid "`__m256`, `__m256i`, `__m256d`: `\"avx\"`"
msgstr ""

#: src/2574-simd-ffi.md:173
msgid ""
"Future stabilizations of architecture-specific vector types must specify the "
"target features required to use them in `extern` functions."
msgstr ""

#: src/2574-simd-ffi.md:176
msgid "Drawbacks"
msgstr ""

#: src/2574-simd-ffi.md:179
msgid "None."
msgstr ""

#: src/2574-simd-ffi.md:181
msgid "Rationale and alternatives"
msgstr ""

#: src/2574-simd-ffi.md:184
msgid ""
"This is an adhoc solution to the problem, but sufficient for FFI purposes."
msgstr ""

#: src/2574-simd-ffi.md:186
msgid "Future architecture-specific vector types"
msgstr ""

#: src/2574-simd-ffi.md:188
msgid ""
"In the future, we might want to stabilize some of the following vector "
"types. This section explores which target features would they require:"
msgstr ""

#: src/2574-simd-ffi.md:192
msgid "`__m64`: `mmx`"
msgstr ""

#: src/2574-simd-ffi.md:193
msgid "`__m512`, `__m512i`, `__m512f`: \"avx512f\""
msgstr ""

#: src/2574-simd-ffi.md:194
msgid "`arm`: `neon`"
msgstr ""

#: src/2574-simd-ffi.md:195
msgid "`aarch64`: `neon`"
msgstr ""

#: src/2574-simd-ffi.md:196
msgid "`ppc64`: `altivec` / `vsx`"
msgstr ""

#: src/2574-simd-ffi.md:197
msgid "`wasm32`: `simd128`"
msgstr ""

#: src/2574-simd-ffi.md:199
msgid "Require the feature to be enabled globally for the binary"
msgstr ""

#: src/2574-simd-ffi.md:201
msgid ""
"Instead of using `#[target_feature]` we could allow vector types on C FFI "
"only behind `#[cfg(target_feature)]`, e.g., via something like the "
"portability check."
msgstr ""

#: src/2574-simd-ffi.md:204
msgid ""
"This would not allow calling C FFI functions with vector types conditionally "
"on, e.g., run-time feature detection."
msgstr ""

#: src/2574-simd-ffi.md:207
msgid "Prior art"
msgstr ""

#: src/2574-simd-ffi.md:210
msgid ""
"In C, the architecture specific vector types are only available if the "
"required target features are enabled at compile-time."
msgstr ""

#: src/2574-simd-ffi.md:213
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/2574-simd-ffi.md:216
msgid ""
"Should it be possible to use, e.g., `__m128` on C FFI when the `avx` feature "
"is enabled? Does that change the calling convention and make doing so "
"unsafe ? We could extend this RFC to also require that to use certain types "
"certain features must be disabled."
msgstr ""
