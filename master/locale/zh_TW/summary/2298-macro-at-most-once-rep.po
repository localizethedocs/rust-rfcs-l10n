msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:04Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2298-macro-at-most-once-rep.md:1
msgid "Feature Name: `macro-at-most-once-rep`"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:2
msgid "Start Date: 2018-01-17"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2298](https://github.com/rust-lang/rfcs/pull/2298)"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:4
msgid ""
"Rust Issue: [rust-lang/rust#48075](https://github.com/rust-lang/rust/"
"issues/48075)"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:7
msgid "Summary"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:9
msgid ""
"Add a repetition specifier to macros to repeat a pattern at most once: "
"`$(pat)?`. Here, `?` behaves like `+` or `*` but represents at most one "
"repetition of `pat`."
msgstr ""

#: src/2298-macro-at-most-once-rep.md:11
msgid "Motivation"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:13
msgid "There are two specific use cases in mind."
msgstr ""

#: src/2298-macro-at-most-once-rep.md:15
msgid "Macro rules with optional parts"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:17
msgid ""
"Currently, you just have to write two rules and possibly have one "
"\"desugar\" to the other."
msgstr ""

#: src/2298-macro-at-most-once-rep.md:31
msgid "Under this RFC, one would simply write:"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:42
msgid "Trailing commas"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:44
msgid ""
"Currently, the best way to make a rule tolerate trailing commas is to create "
"another identical rule that has a comma at the end:"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:50 src/2298-macro-at-most-once-rep.md:60
msgid "// do stuff\n"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:55
msgid "or to allow multiple trailing commas:"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:65
msgid ""
"This is unergonomic and clutters up macro definitions needlessly. Under this "
"RFC, one would simply write:"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:75
msgid "Guide-level explanation"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:77
msgid ""
"In Rust macros, you specify some \"rules\" which define how the macro is "
"used and what it transforms to. For each rule, there is a pattern and a body:"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:85
msgid ""
"The pattern portion is composed of zero or more subpatterns concatenated "
"together. One possible subpattern is to repeat another subpattern some "
"number of times. This is useful when writing variadic macros (e.g. "
"`println`):"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:89
msgid "// Takes a variable number of arguments after the template\n"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:93
msgid "which can be invoked like so:"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:95 src/2298-macro-at-most-once-rep.md:96
#: src/2298-macro-at-most-once-rep.md:97
msgid "\"\""
msgstr ""

#: src/2298-macro-at-most-once-rep.md:95
msgid "// 0 args\n"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:96
msgid "// 1 args\n"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:97
msgid "// 2 args\n"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:101
msgid ""
"The `*` in the pattern of this example indicates \"0 or more repetitions\". "
"One can also use `+` for \"at _least_ one repetition\" or `?` for \"at "
"_most_ one repetition\"."
msgstr ""

#: src/2298-macro-at-most-once-rep.md:103
msgid ""
"In the body of a rule, one can specify to repeat some code for every "
"occurrence of the pattern in the invocation:"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:109
#: src/2298-macro-at-most-once-rep.md:147
msgid "\"{}\""
msgstr ""

#: src/2298-macro-at-most-once-rep.md:110
#: src/2298-macro-at-most-once-rep.md:148
msgid "// Repeat for each `expr` passed to the macro\n"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:115
msgid "The same can be done for `+` and `?`."
msgstr ""

#: src/2298-macro-at-most-once-rep.md:117
msgid ""
"The `?` operator is particularly useful for making macro rules with optional "
"components in the invocation or for making macros tolerate trailing commas."
msgstr ""

#: src/2298-macro-at-most-once-rep.md:119
msgid "Reference-level explanation"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:121
msgid ""
"`?` is identical to `+` and `*` in use except that it represents \"at most "
"once\" repetition."
msgstr ""

#: src/2298-macro-at-most-once-rep.md:123
msgid ""
"Introducing `?` into the grammar for macro repetition introduces an easily "
"fixable ambiguity, as noted by @kennytm [here](https://internals.rust-lang."
"org/t/pre-rfc-at-most-one-repetition-macro-patterns/6557/2?u=mark-i-m):"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:125
msgid ""
"There is ambiguity: $($x:ident)?+ today matches a?b?c and not a+. "
"Fortunately this is easy to resolve: you just look one more token ahead and "
"always treat ?\\* and ?+ to mean separate by the question mark token."
msgstr ""

#: src/2298-macro-at-most-once-rep.md:127
msgid "Drawbacks"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:128
msgid "While there are grammar ambiguities, they can be easily fixed."
msgstr ""

#: src/2298-macro-at-most-once-rep.md:130
msgid ""
"Also, for patterns that use `*`, `?` is not a perfect solution: `$(pat),* "
"$(,)?` still allows `,` which is a bit weird. However, this is still an "
"improvement over `$(pat),* $(,)*` which allows `,,,,,`."
msgstr ""

#: src/2298-macro-at-most-once-rep.md:132
msgid "Rationale and Alternatives"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:134
msgid ""
"The implementation of `?` ought to be very similar to `+` and `*`. Only the "
"parser needs to change; to the author's knowledge, it would not be "
"technically difficult to implement, nor would it add much complexity to the "
"compiler."
msgstr ""

#: src/2298-macro-at-most-once-rep.md:136
msgid "The `?` character is chosen because"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:137
msgid ""
"As noted above, there are grammar ambiguities, but they can be easily fixed"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:138
msgid "It is consistent with common regex syntax, as are `+` and `*`"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:139
msgid "It intuitively expresses \"this pattern is optional\""
msgstr ""

#: src/2298-macro-at-most-once-rep.md:141
msgid ""
"One alternative to alleviate the trailing comma paper cut is to allow "
"trailing commas automatically for any pattern repetitions. This would be a "
"breaking change. Also, it would allow trailing commas in potentially "
"unwanted places. For example:"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:152
msgid "would allow"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:159
msgid ""
"Also, rather than have `?` be a repetition operator, we could have the "
"compiler do a \"copy/paste\" of the rule and insert the optional pattern. "
"Implementation-wise, this might reuse less code than the proposal. Also, "
"it's probably less easy to teach; this RFC is very easy to teach because `?` "
"is another operator like `+` or `*`."
msgstr ""

#: src/2298-macro-at-most-once-rep.md:161
msgid ""
"We could use another symbol other than `?`, but it's not clear what other "
"options might be better. `?` has the advantage of already being known in "
"common regex syntax as \"optional\"."
msgstr ""

#: src/2298-macro-at-most-once-rep.md:163
msgid ""
"It has also been suggested to add `{M, N}` (at least `M` but no more than "
"`N`) either in addition to or as an alternative to `?`. Like `?`, `{M, N}` "
"is common regex syntax and has the same implementation difficulty level. "
"However, it's not clear how useful such a pattern would be. In particular, "
"we can't think of any other language to include this sort of \"partially-"
"variadic\" argument list. It is also questionable why one would want to "
"_syntactically_ repeat some piece of code between `M` and `N` times. Thus, "
"this RFC does not propose to add `{M, N}` at this time (though we note that "
"it is forward-compatible)."
msgstr ""

#: src/2298-macro-at-most-once-rep.md:165
msgid ""
"Finally, we could do nothing and wait for macros 2.0. However, it will be a "
"while (possibly years) before that lands in stable rust. The current "
"implementation and proposals are not very well-defined yet. Having something "
"until that time would be nice to fix this paper cut. This proposal does not "
"add a lot of complexity, but does nicely fill the gap."
msgstr ""

#: src/2298-macro-at-most-once-rep.md:167
msgid "Unresolved Questions"
msgstr ""

#: src/2298-macro-at-most-once-rep.md:169
msgid ""
"Should the `?` Kleene operator accept a separator? Adding a separator is "
"completely meaningless (since we don't accept trailing separators, and `?` "
"can accept \"at most one\" repetition), but allowing it is consistent with "
"`+` and `*`. Currently, we allow a separator. We could also make it an error "
"or lint."
msgstr ""
