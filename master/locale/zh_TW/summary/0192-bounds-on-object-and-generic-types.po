msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0192-bounds-on-object-and-generic-types.md:1
msgid "Start Date: 2014-08-06"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#192](https://github.com/rust-lang/rfcs/pull/192)"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:3
msgid ""
"Rust Issue: [rust-lang/rust#16462](https://github.com/rust-lang/rust/"
"issues/16462)"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:5
msgid "Summary"
msgstr "摘要"

#: src/0192-bounds-on-object-and-generic-types.md:7
msgid ""
"Remove the special-case bound `'static` and replace with a generalized "
"_lifetime bound_ that can be used on objects and type parameters."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:9
msgid ""
"Remove the rules that aim to prevent references from being stored into "
"objects and replace with a simple lifetime check."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:11
msgid ""
"Tighten up type rules pertaining to reference lifetimes and well-formed "
"types containing references."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:13
msgid ""
"Introduce explicit lifetime bounds (`'a:'b`), with the meaning that the "
"lifetime `'a` outlives the lifetime `'b`. These exist today but are always "
"inferred; this RFC adds the ability to specify them explicitly, which is "
"sometimes needed in more complex cases."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:18
msgid "Motivation"
msgstr "動機"

#: src/0192-bounds-on-object-and-generic-types.md:20
msgid ""
"Currently, the type system is not supposed to allow references to escape "
"into object types. However, there are various bugs where it fails to prevent "
"this from happening. Moreover, it is very useful (and frequently necessary) "
"to store a reference into an object. Moreover, the current treatment of "
"generic types is in some cases naive and not obviously sound."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:27
msgid "Detailed design"
msgstr "詳細設計"

#: src/0192-bounds-on-object-and-generic-types.md:29
msgid "Lifetime bounds on parameters"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:31
msgid ""
"The heart of the new design is the concept of a _lifetime bound_. In fact, "
"this (sort of) exists today in the form of the `'static` bound:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:36
msgid ""
"Here, the notation `'static` means \"all borrowed content within `A` "
"outlives the lifetime `'static`\". (Note that when we say that something "
"outlives a lifetime, we mean that it lives _at least that long_. In other "
"words, for any lifetime `'a`, `'a` outlives `'a`. This is similar to how we "
"say that every type `T` is a subtype of itself.)"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:42
msgid ""
"In the newer design, it is possible to use an arbitrary lifetime as a bound, "
"and not just `'static`:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:47
msgid ""
"Explicit lifetime bounds are in fact only rarely necessary, for two reasons:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:50
msgid ""
"The compiler is often able to infer this relationship from the argument and "
"return types. More on this below."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:52
msgid ""
"It is only important to bound the lifetime of a generic type like `A` when "
"one of two things is happening (and both of these are cases where the "
"inference generally is sufficient):"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:55
msgid ""
"A borrowed pointer to an `A` instance (i.e., value of type `&A`) is being "
"consumed or returned."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:57
msgid ""
"A value of type `A` is being closed over into an object reference (or "
"closure, which per the unboxed closures RFC is really the same thing)."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:61
msgid ""
"Note that, per RFC 11, these lifetime bounds may appear in types as well "
"(this is important later on). For example, an iterator might be declared:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:69
msgid ""
"Here, the constraint `T:'a` indicates that the data being iterated over must "
"live at least as long as the collection (logically enough)."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:72
msgid "Lifetime bounds on object types"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:74
msgid ""
"Like parameters, all object types have a lifetime bound. Unlike parameter "
"types, however, object types are _required_ to have exactly one bound. This "
"bound can be either specified explicitly or derived from the traits that "
"appear in the object type. In general, the rule is as follows:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:80
msgid "If an explicit bound is specified, use that."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:81
msgid "Otherwise, let S be the set of lifetime bounds we can derive."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:82
msgid "Otherwise, if S contains 'static, use 'static."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:83
msgid "Otherwise, if S is a singleton set, use that."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:84
msgid "Otherwise, error."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:86
msgid "Here are some examples:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:88
msgid ""
"    trait IsStatic : 'static { }\n"
"    trait Is<'a> : 'a { }\n"
"    \n"
"    // Type               Bounds\n"
"    // IsStatic           'static\n"
"    // Is<'a>             'a\n"
"    // IsStatic+Is<'a>    'static+'a\n"
"    // IsStatic+'a        'static+'a\n"
"    // IsStatic+Is<'a>+'b 'static,'a,'b\n"
"    "
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:98
msgid ""
"Object types must have exactly one bound -- zero bounds is not acceptable. "
"Therefore, if an object type with no derivable bounds appears, we will "
"supply a default lifetime using the normal rules:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:102
msgid ""
"    trait Writer { /* no derivable bounds */ }\n"
"    struct Foo<'a> {\n"
"        Box<Writer>,      // Error: try Box<Writer+'static> or "
"Box<Writer+'a>\n"
"        Box<Writer+Send>, // OK: Send implies 'static\n"
"        &'a Writer,       // Error: try &'a (Writer+'a)\n"
"    }\n"
"    \n"
"    fn foo(a: Box<Writer>, // OK: Sugar for Box<Writer+'a> where 'a fresh\n"
"           b: &Writer)     // OK: Sugar for &'b (Writer+'c) where 'b, 'c "
"fresh\n"
"    { ... }\n"
"    "
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:113
msgid ""
"This kind of annotation can seem a bit tedious when using object types "
"extensively, though type aliases can help quite a bit:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:119
msgid ""
"The unresolved questions section discussed possibles ways to lighten the "
"burden."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:122
msgid ""
"See Appendix B for the motivation on why object types are permitted to have "
"exactly one lifetime bound."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:125
msgid "Specifying relations between lifetimes"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:127
msgid ""
"Currently, when a type or fn has multiple lifetime parameters, there is no "
"facility to explicitly specify a relationship between them. For example, in "
"a function like this:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:133
msgid ""
"the lifetimes `'a` and `'b` are declared as independent. In some cases, "
"though, it can be important that there be a relation between them. In most "
"cases, these relationships can be inferred (and in fact are inferred today, "
"see below), but it is useful to be able to state them explicitly (and "
"necessary in some cases, see below)."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:139
msgid ""
"A _lifetime bound_ is written `'a:'b` and it means that \"`'a` outlives "
"`'b`\". For example, if `foo` were declared like so:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:144
msgid ""
"that would indicate that the lifetime '`x` was shorter than (or equal to) "
"`'y`."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:147
msgid "The \"type must outlive\" and well-formedness relation"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:149
msgid ""
"Many of the rules to come make use of a \"type must outlive\" relation, "
"written `T outlives 'a`. This relation means primarily that all borrowed "
"data in `T` is known to have a lifetime of at least '`a` (hence the name). "
"However, the relation also guarantees various basic lifetime constraints are "
"met. For example, for every reference type `&'b U` that is found within `T`, "
"it would be required that `U outlives 'b` (and that `'b` outlives `'a`)."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:157
msgid ""
"In fact, `T outlives 'a` is defined on another function `WF(T:'a)`, which "
"yields up a list of lifetime relations that must hold for `T` to be well-"
"formed and to outlive `'a`. It is not necessary to understand the details of "
"this relation in order to follow the rest of the RFC, I will defer its "
"precise specification to an appendix below."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:163
msgid "For this section, it suffices to give some examples:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:165
msgid ""
"    // int always outlives any region\n"
"    WF(int : 'a) = []\n"
"    \n"
"    // a reference with lifetime 'a outlives 'b if 'a outlives 'b\n"
"    WF(&'a int : 'b) = ['a : 'b]\n"
"    \n"
"    // the outer reference must outlive 'c, and the inner reference\n"
"    // must outlive the outer reference\n"
"    WF(&'a &'b int : 'c) = ['a : 'c, 'b : 'a]\n"
"    \n"
"    // Object type with bound 'static\n"
"    WF(SomeTrait+'static : 'a) = ['static : 'a]\n"
"    \n"
"    // Object type with bound 'a \n"
"    WF(SomeTrait+'a : 'b) = ['a : 'b]\n"
"    "
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:181
msgid "Rules for when object closure is legal"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:183
msgid ""
"Whenever data of type `T` is closed over to form an object, the type checker "
"will require that `T outlives 'a` where `'a` is the primary lifetime bound "
"of the object type."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:187
msgid "Rules for types to be well-formed"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:189
msgid ""
"Currently we do not apply any tests to the types that appear in type "
"declarations. Per RFC 11, however, this should change, as we intend to "
"enforce trait bounds on types, wherever those types appear. Similarly, we "
"should be requiring that types are well-formed with respect to the `WF` "
"function. This means that a type like the following would be illegal without "
"a lifetime bound on the type parameter `T`:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:198
msgid ""
"This is illegal because the field `c` has type `&'a T`, which is only well-"
"formed if `T:'a`. Per usual practice, this RFC does not propose any form of "
"inference on struct declarations and instead requires all conditions to be "
"spelled out (this is in contrast to fns and methods, see below)."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:204
msgid "Rules for expression type validity"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:206
msgid ""
"We should add the condition that for every expression with lifetime `'e` and "
"type `T`, then `T outlives 'e`. We already enforce this in many special "
"cases but not uniformly."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:210
msgid "Inference"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:212
msgid ""
"The compiler will infer lifetime bounds on both type parameters and region "
"parameters as follows. Within a function or method, we apply the "
"wellformedness function `WF` to each function or parameter type. This yields "
"up a set of relations that must hold. The idea here is that the caller could "
"not have type checked unless the types of the arguments were well-formed, so "
"that implies that the callee can assume that those well-formedness "
"constraints hold."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:220
msgid "As an example, in the following function:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:224
msgid ""
"the callee here can assume that the type parameter `A` outlives the lifetime "
"`'a`, even though that was not explicitly declared."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:227
msgid ""
"Note that the inference also pulls in constraints that were declared on the "
"types of arguments. So, for example, if there is a type `Items` declared as "
"follows:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:233
msgid "And a function that takes an argument of type `Items`:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:237
msgid ""
"The inference rules will conclude that `T:'a` because the `Items` type was "
"declared with that bound."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:240
msgid ""
"In practice, these inference rules largely remove the need to manually "
"declare lifetime relations on types. When porting the existing library and "
"rustc over to these rules, I had to add explicit lifetime bounds to exactly "
"one function (but several types, almost exclusively iterators)."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:246
msgid ""
"Note that this sort of inference is already done. This RFC simply proposes a "
"more extensive version that also includes bounds of the form `X:'a`, where "
"`X` is a type parameter."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:250
msgid "What does all this mean in practice?"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:252
msgid "This RFC has a lot of details. The main implications for end users are:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:254
msgid ""
"Object types must specify a lifetime bound when they appear in a type. This "
"most commonly means changing `Box<Trait>` to `Box<Trait+'static>` and `&'a "
"Trait` to `&'a Trait+'a`."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:257
msgid ""
"For types that contain references to generic types, lifetime bounds are "
"needed in the type definition. This comes up most often in iterators:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:264
msgid ""
"Here, the presence of `&'a [T]` within the type definition requires that the "
"type checker can show that `T outlives 'a` which in turn requires the bound "
"`T:'a` on the type definition. These bounds are rarely outside of type "
"definitions, because they are almost always implied by the types of the "
"arguments."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:269
msgid ""
"It is sometimes, but rarely, necessary to use lifetime bounds, specifically "
"around double indirections (references to references, often the second "
"reference is contained within a struct). For example:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:282
msgid ""
"Here, we must know that the lifetime `'global` outlives `'local` in order "
"for this type to be well-formed."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:285
msgid "Phasing"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:287
msgid ""
"Some parts of this RFC require new syntax and thus must be phased in. The "
"current plan is to divide the implementation three parts:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:290
msgid ""
"Implement support for everything in this RFC except for region bounds and "
"requiring that every expression type be well-formed. Enforcing the latter "
"constraint leads to type errors that require lifetime bounds to resolve."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:294
msgid ""
"Implement support for `'a:'b` notation to be parsed under a feature gate "
"`issue_5723_bootstrap`."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:296
msgid "Implement the final bits of the RFC:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:297
msgid "Bounds on lifetime parameters"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:298
msgid "Wellformedness checks on every expression"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:299
msgid "Wellformedness checks in type definitions"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:301
msgid ""
"Parts 1 and 2 can be landed simultaneously, but part 3 requires a snapshot. "
"Parts 1 and 2 have largely been written. Depending on precisely how the "
"timing works out, it might make sense to just merge parts 1 and 3."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:306
msgid "Drawbacks / Alternatives"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:308
msgid ""
"If we do not implement some solution, we could continue with the current "
"approach (but patched to be sound) of banning references from being closed "
"over in object types. I consider this a non-starter."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:312
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/0192-bounds-on-object-and-generic-types.md:314
msgid "Inferring wellformedness bounds"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:316
msgid ""
"Under this RFC, it is required to write bounds on struct types which are in "
"principle inferable from their contents. For example, iterators tend to "
"follow a pattern like:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:324
msgid ""
"Note that `T` is bounded by `'a`. It would be possible to infer these "
"bounds, but I've stuck to our current principle that type definitions are "
"always fully spelled out. The danger of inference is that it becomes unclear "
"_why_ a particular constraint exists if one must traverse the type hierarchy "
"deeply to find its origin. This could potentially be addressed with better "
"error messages, though our track record for lifetime error messages is not "
"very good so far."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:332
msgid ""
"Also, there is a potential interaction between this sort of inference and "
"the description of default trait bounds below."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:335
msgid "Default trait bounds"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:337
msgid ""
"When referencing a trait object, it is almost _always_ the case that one "
"follows certain fixed patterns:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:340
msgid "`Box<Trait+'static>`"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:341
msgid "`Rc<Trait+'static>` (once DST works)"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:342
msgid "`&'a (Trait+'a)`"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:343
msgid "and so on."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:345
msgid ""
"You might think that we should simply provide some kind of defaults that are "
"sensitive to where the `Trait` appears. The same is probably true of struct "
"type parameters (in other words, `&'a SomeStruct<'a>` is a very common "
"pattern)."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:350
msgid "However, there are complications:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:352
msgid ""
"What about a type like `struct Ref<'a, T:'a> { x: &'a T }`? `Ref<'a, Trait>` "
"should really work the same way as `&'a Trait`. One way that I can see to do "
"this is to drive the defaulting based on the default trait bounds of the `T` "
"type parameter -- but if we do that, it is both a non-local default (you "
"have to consult the definition of `Ref`) and interacts with the potential "
"inference described in the previous section."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:359
msgid ""
"There _are_ reasons to want a type like `Box<Trait+'a>`. For example, the "
"macro parser includes a function like:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:364
msgid ""
"In other words, this function returns an object that closes over the macro "
"context. In such a case, if `Box<MacroExt>` implies a static bound, then "
"taking ownership of this macro object would require a signature like:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:371
msgid ""
"Note that the `'cx` variable is only used in one place. It's purpose is just "
"to disable the `'static` default that would otherwise be inserted."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:375
msgid "Appendix: Definition of the outlives relation and well-formedness"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:377
msgid ""
"To make this more specific, we can \"formally\" model the Rust type system "
"as:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:380
msgid ""
"    T = scalar (int, uint, fn(...))   // Boring stuff\n"
"      | *const T                      // Unsafe pointer\n"
"      | *mut T                        // Unsafe pointer\n"
"      | Id<P>                         // Nominal type (struct, enum)\n"
"      | &'x T                         // Reference\n"
"      | &'x mut T                     // Mutable reference\n"
"      | {TraitReference<P>}+'x        // Object type\n"
"      | X                             // Type variable\n"
"    P = {'x} + {T}\n"
"    "
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:390
msgid ""
"We can define a function `WF(T : 'a)` which, given a type `T` and lifetime "
"`'a` yields a list of `'b:'c` or `X:'d` pairs. For each pair `'b:'c`, the "
"lifetime `'b` must outlive the lifetime `'c` for the type `T` to be well-"
"formed in a location with lifetime `'a`. For each pair `X:'d`, the type "
"parameter `X` must outlive the lifetime `'d`."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:396
msgid "`WF(int : 'a)` yields an empty list"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:397
msgid "`WF(X:'a)` where `X` is a type parameter yields `(X:'a)`."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:398
msgid "`WF(Foo<P>:'a)` where `Foo<P>` is an enum or struct type yields:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:399
msgid ""
"For each lifetime parameter `'b` that is contravariant or invariant, `'b : "
"'a`."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:401
msgid ""
"For each type parameter `T` that is covariant or invariant, the results of "
"`WF(T : 'a)`."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:403
msgid "The lifetime bounds declared on `Foo`'s lifetime or type parameters."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:404
msgid ""
"The reasoning here is that if we can reach borrowed data with lifetime `'a` "
"through `Foo<'a>`, then `'a` must be contra- or invariant.  Covariant "
"lifetimes only occur in \"setter\" situations. Analogous reasoning applies "
"to the type case."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:408
msgid "`WF(T:'a)` where `T` is an object type:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:409
msgid "For the primary bound `'b`, `'b : 'a`."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:410
msgid "For each derived bound `'c` of `T`, `'b : 'c`"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:411
msgid ""
"Motivation: The primary bound of an object type implies that all other "
"bounds are met. This simplifies some of the other formulations and does not "
"represent a loss of expressiveness."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:415
msgid ""
"We can then say that `T outlives 'a` if all lifetime relations returned by "
"`WF(T:'a)` hold."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:418
msgid "Appendix B: Why object types must have exactly one bound"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:420
msgid ""
"The motivation is that handling multiple bounds is overwhelmingly "
"complicated to reason about and implement. In various places, constraints "
"arise of the form `all i. exists j. R[i] <= R[j]`, where `R` is a list of "
"lifetimes. This is challenging for lifetime inference, since there are many "
"options for it to choose from, and thus inference is no longer a fixed-point "
"iteration. Moreover, it doesn't seem to add any particular expressiveness."
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:428
msgid "The places where this becomes important\tare:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:430
msgid "Checking lifetime bounds when data is closed over into an object type"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:431
msgid ""
"Subtyping between object types, which would most naturally be contravariant "
"in the lifetime bound"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:434
msgid ""
"Similarly, requiring that the \"master\" bound on object lifetimes outlives "
"all other bounds also aids inference. Now, given a type like the following:"
msgstr ""

#: src/0192-bounds-on-object-and-generic-types.md:445
msgid ""
"the inference engine can create a fresh lifetime variable `'0` for the "
"master bound and then say that `'0:'a` and `'0:'b`. Without the requirement "
"that `'0` be a master bound, it would be somewhat unclear how `'0` relates "
"to `'a` and `'b` (in fact, there would be no necessary relation). But if "
"there is no necessary relation, then when closing over data, one would have "
"to ensure that the closed over data outlives _all_ derivable lifetime "
"bounds, which again creates a constraint of the form `all i. exists j.`."
msgstr ""
