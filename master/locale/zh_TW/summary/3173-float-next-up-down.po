msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:05Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/3173-float-next-up-down.md:1
msgid "Feature Name: `float_next_up_down`"
msgstr ""

#: src/3173-float-next-up-down.md:2
msgid "Start Date: 2021-09-06"
msgstr ""

#: src/3173-float-next-up-down.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#3173](https://github.com/rust-lang/rfcs/pull/3173)"
msgstr ""

#: src/3173-float-next-up-down.md:4
msgid ""
"Rust Issue: [rust-lang/rust#91399](https://github.com/rust-lang/rust/"
"issues/91399)"
msgstr ""

#: src/3173-float-next-up-down.md:6
msgid "Summary"
msgstr ""

#: src/3173-float-next-up-down.md:9
msgid ""
"This RFC adds two argumentless methods to `f32`/`f64`, `next_up` and "
"`next_down`. These functions are specified in the IEEE 754 standard, and "
"provide the capability to enumerate floating point values in order."
msgstr ""

#: src/3173-float-next-up-down.md:14
msgid "Motivation"
msgstr ""

#: src/3173-float-next-up-down.md:17
msgid ""
"Currently it is not possible to answer the question 'which floating point "
"value comes after `x`' in Rust without intimate knowledge of the IEEE 754 "
"standard. Answering this question has multiple uses:"
msgstr ""

#: src/3173-float-next-up-down.md:21
msgid ""
"Simply exploratory or educational purposes. Being able to enumerate values "
"is critical for understanding how floating point numbers work, and how they "
"have varying precision at different sizes. E.g. one might wonder what sort "
"of precision `f32` has at numbers around 10,000. With this feature one could "
"simply print `10_000f32.next_up() - 10_000f32` to find out it is "
"`0.0009765625`."
msgstr ""

#: src/3173-float-next-up-down.md:28
msgid ""
"Testing. If you wish to ensure a property holds for all values in a certain "
"range, you need to be able to enumerate them. One might also want to check "
"if and how your function fails just outside its supported range."
msgstr ""

#: src/3173-float-next-up-down.md:32
msgid ""
"Exclusive ranges. If you want to ensure a variable lies within an exclusive "
"range, these functions can help. E.g. to ensure that `x` lies within \\[0, "
"1) one can write `x.clamp(0.0, 1.0.next_down())`."
msgstr ""

#: src/3173-float-next-up-down.md:37
msgid "Guide-level explanation"
msgstr ""

#: src/3173-float-next-up-down.md:40
msgid ""
"Because floating point numbers have finite precision sometimes you might "
"want to know which floating point number is _right_ below or above a number "
"you already have. For this you can use the methods `next_down` or `next_up` "
"respectively. Using them repeatedly allows you to iterate over all the "
"values within a range."
msgstr ""

#: src/3173-float-next-up-down.md:45
msgid ""
"The method `x.next_up()` defined on both `f32` and `f64` returns the "
"smallest number greater than `x`. Similarly, `x.next_down()` returns the "
"greatest number less than `x`."
msgstr ""

#: src/3173-float-next-up-down.md:49
msgid ""
"If you wanted to test a function for all `f32` floating point values between "
"1 and 2, you could for example write:"
msgstr ""

#: src/3173-float-next-up-down.md:59
msgid ""
"On another occasion might be interested in how much `f32` and `f64` differ "
"in their precision for numbers around one million. This is easy to figure "
"out:"
msgstr ""

#: src/3173-float-next-up-down.md:66
msgid "The answer is:"
msgstr ""

#: src/3173-float-next-up-down.md:72
msgid ""
"If you want to ensure that a value `s` lies within -1 to 1, excluding the "
"endpoints, this is easy to do:"
msgstr ""

#: src/3173-float-next-up-down.md:79
msgid "Reference-level explanation"
msgstr ""

#: src/3173-float-next-up-down.md:82
msgid ""
"The functions `nextUp` and `nextDown` are defined precisely (and "
"identically) in the standards IEEE 754-2008 and IEEE 754-2019. This RFC "
"proposes the methods `f32::next_up`, `f32::next_down`, `f64::next_up`, and "
"`f64::next_down` with the behavior exactly as specified in those standards."
msgstr ""

#: src/3173-float-next-up-down.md:87
msgid ""
"To be precise, let `tiny` be the smallest representable positive value and "
"`max` be the largest representable finite positive value of the floating "
"point type. Then if `x` is an arbitrary value `x.next_up()` is specified as:"
msgstr ""

#: src/3173-float-next-up-down.md:91
msgid "`x` if `x.is_nan()`,"
msgstr ""

#: src/3173-float-next-up-down.md:92
msgid "`-max` if `x` is negative infinity,"
msgstr ""

#: src/3173-float-next-up-down.md:93
msgid "`-0.0` if `x` is `-tiny`,"
msgstr ""

#: src/3173-float-next-up-down.md:94
msgid "`tiny` if `x` is `0.0` or `-0.0`,"
msgstr ""

#: src/3173-float-next-up-down.md:95
msgid "positive infinity if `x` is `max` or positive infinity, and"
msgstr ""

#: src/3173-float-next-up-down.md:96
msgid ""
"the unambiguous and unique minimal finite value `y` such that `x < y` in all "
"other cases."
msgstr ""

#: src/3173-float-next-up-down.md:99
msgid "`x.next_down()` is specified as `-(-x).next_up()`."
msgstr ""

#: src/3173-float-next-up-down.md:101
msgid ""
"A reference implementation for `f32` follows, using exclusively integer "
"arithmetic. The implementation for `f64` is entirely analogous, with the "
"exception that the constants `0x7fff_ffff` and `0x8000_0001` are replaced by "
"respectively `0x7fff_ffff_ffff_ffff` and `0x8000_0000_0000_0001`. Using "
"exclusively integer arithmetic aids stabilization as a `const fn`, reduces "
"transfers between floating point and integer registers or execution units "
"(which incur penalties on some processors), and avoids issues with denormal "
"values potentially flushing to zero during floating point arithmetic "
"operations on some platforms."
msgstr ""

#: src/3173-float-next-up-down.md:112
msgid ""
"/// Returns the least number greater than `self`.\n"
"///\n"
"/// Let `TINY` be the smallest representable positive `f32`. Then,\n"
"///  - if `self.is_nan()`, this returns `self`;\n"
"///  - if `self` is `NEG_INFINITY`, this returns `-MAX`;\n"
"///  - if `self` is `-TINY`, this returns -0.0;\n"
"///  - if `self` is -0.0 or +0.0, this returns `TINY`;\n"
"///  - if `self` is `MAX` or `INFINITY`, this returns `INFINITY`;\n"
"///  - otherwise the unique least value greater than `self` is returned.\n"
"///\n"
"/// The identity `x.next_up() == -(-x).next_down()` holds for all `x`. When "
"`x`\n"
"/// is finite `x == x.next_up().next_down()` also holds.\n"
msgstr ""

#: src/3173-float-next-up-down.md:125
msgid "// Smallest positive f32.\n"
msgstr ""

#: src/3173-float-next-up-down.md:143
msgid ""
"/// Returns the greatest number less than `self`.\n"
"///\n"
"/// Let `TINY` be the smallest representable positive `f32`. Then,\n"
"///  - if `self.is_nan()`, this returns `self`;\n"
"///  - if `self` is `INFINITY`, this returns `MAX`;\n"
"///  - if `self` is `TINY`, this returns 0.0;\n"
"///  - if `self` is -0.0 or +0.0, this returns `-TINY`;\n"
"///  - if `self` is `-MAX` or `NEG_INFINITY`, this returns `NEG_INFINITY`;\n"
"///  - otherwise the unique greatest value less than `self` is returned.\n"
"///\n"
"/// The identity `x.next_down() == -(-x).next_up()` holds for all `x`. When "
"`x`\n"
"/// is finite `x == x.next_down().next_up()` also holds.\n"
msgstr ""

#: src/3173-float-next-up-down.md:157
msgid "// Smallest (in magnitude) negative f32.\n"
msgstr ""

#: src/3173-float-next-up-down.md:177
msgid "Drawbacks"
msgstr ""

#: src/3173-float-next-up-down.md:180
msgid ""
"Two more functions get added to `f32` and `f64`, which may be considered "
"already cluttered by some."
msgstr ""

#: src/3173-float-next-up-down.md:183
msgid ""
"Additionally, there is a minor pitfall regarding signed zero. Repeatedly "
"calling `next_up` on a negative number will iterate over all values above "
"it, with the exception of +0.0, only -0.0 will be visited. Similarly "
"starting at positive number and iterating downwards will only visit +0.0, "
"not -0.0."
msgstr ""

#: src/3173-float-next-up-down.md:188
msgid ""
"However, if we were to define `(-0.0).next_up() == 0.0` we would lose "
"compliance with the IEEE 754 standard, and lose the property that `x."
"next_up() > x` for all finite `x`. It would also lead to the pitfall that "
"`(0.0).next_down()` would not be the smallest negative number, but -0.0 "
"instead."
msgstr ""

#: src/3173-float-next-up-down.md:193
msgid ""
"Finally, there is a minor risk of confusion regarding precedence with unary "
"minus. A user might inadvertently write `-1.0.next_up()` instead of `(-1.0)."
"next_up()`, giving a value on the wrong side of -1. However, this potential "
"confusion holds for most methods on `f32`/`f64`, and can be avoided by the "
"cautious by writing `f32::next_up(-1.0)`."
msgstr ""

#: src/3173-float-next-up-down.md:200
msgid "Rationale and alternatives"
msgstr ""

#: src/3173-float-next-up-down.md:203
msgid ""
"To implement the features described in the motivation the user essentially "
"_needs_ the `next_up`/`next_down` methods, or the alternative mentioned just "
"below. If these are not available the user must either install a third party "
"library for what is essentially one elementary function, or implement it "
"themselves using `to_bits` and `from_bits`. This has several issues or "
"pitfalls:"
msgstr ""

#: src/3173-float-next-up-down.md:209
msgid ""
"The user might not even be aware that a third party library exists, "
"searching the standard library in vain. If they find a third party library "
"they might not be able to judge if it is of sufficient quality and with the "
"exact semantics they expect."
msgstr ""

#: src/3173-float-next-up-down.md:214
msgid ""
"Even if the user is aware of IEEE 754 representation and chooses to "
"implement it themselves, they might not get the edge cases correct. It is "
"also a wasted duplicate effort."
msgstr ""

#: src/3173-float-next-up-down.md:218
msgid ""
"The user might misunderstand the meaning of `f32::EPSILON`, thinking that "
"adding this to a number results in the next floating point number. "
"Alternatively they might misunderstand `f32::MIN_POSITIVE` to be the "
"smallest positive `f32`, or believe that `x + f32::MIN_POSITIVE` is a "
"correct implementation of `x.next_up()`."
msgstr ""

#: src/3173-float-next-up-down.md:224
msgid ""
"The user might give up entirely and simply choose an arbitrary offset, e.g. "
"instead of `x.clamp(0, 1.0.next_down())` they end up writing `x.clamp(0, 1.0 "
"- 1e-9)`."
msgstr ""

#: src/3173-float-next-up-down.md:228
msgid ""
"The main alternative to these two functions is `nextafter(x, y)` (sometimes "
"called `nexttoward`). This function was specified in IEEE 754-1985 to "
"\"return the next representable neighbor of `x` in the direction toward "
"`y`\". If `x == y` then `x` is supposed to be returned. Besides error "
"signaling and NaNs, that is the complete specification."
msgstr ""

#: src/3173-float-next-up-down.md:234
msgid "We did not choose this function for three reasons:"
msgstr ""

#: src/3173-float-next-up-down.md:236
msgid ""
"The IEEE specification is lacking, and deprecated. Unfortunately IEEE "
"754-1985 does not specify how to handle signed zeros at all, and some "
"implementations (such as the one in the ISO C standard) deviate from the "
"IEEE 754 standard by defining `nextafter(x, y)` as `y` when `x == y`. "
"Specifications IEEE 754-2008 and IEEE 754-2019 do not mention `nextafter` at "
"all."
msgstr ""

#: src/3173-float-next-up-down.md:243
msgid ""
"From an informal study by searching for code using `nextafter` or "
"`nexttoward` across a variety of languages we found that essentially every "
"use case in the wild consisted of `nextafter(x, c)` where `c` is a constant "
"effectively equal to negative or positive infinity. That is, the users would "
"have been better suited by `x.next_up()` or `x.next_down()`."
msgstr ""

#: src/3173-float-next-up-down.md:249
msgid ""
"Worse still, we also saw a lot of scenarios where `c` was somewhat "
"arbitrarily chosen to be bigger/smaller than `x`, which might cause bugs "
"when `x` is carelessly changed without updating `c`."
msgstr ""

#: src/3173-float-next-up-down.md:253
msgid ""
"The function `next_after` has been deprecated by the libs team in the past "
"(see [Prior art](#prior-art))."
msgstr ""

#: src/3173-float-next-up-down.md:256
msgid ""
"The advantage of a potential `x.next_toward(y)` method would be that only a "
"single method would need to be added to `f32`/`f64`, however we argue that "
"this simply shifts the burden from documentation bloat to code bloat. Other "
"advantages are that it might considered more readable by some, and that it "
"is more familiar to those used to `nextafter` in other languages."
msgstr ""

#: src/3173-float-next-up-down.md:262
msgid ""
"Finally, if we were to take inspiration from Julia and Ruby these two "
"functions could be called `next_float` and `prev_float`, which are arguably "
"more readable, albeit slightly more ambiguous as to which direction 'next' "
"is."
msgstr ""

#: src/3173-float-next-up-down.md:267
msgid "Prior art"
msgstr ""

#: src/3173-float-next-up-down.md:270
msgid ""
"First we must mention that Rust used to have the `next_after` function, "
"which got deprecated in https://github.com/rust-lang/rust/issues/27752. We "
"quote @alexcrichton:"
msgstr ""

#: src/3173-float-next-up-down.md:274
msgid ""
"We were somewhat ambivalent if I remember correctly on whether to stabilize "
"or deprecate these functions. The functionality is likely needed by someone, "
"but the names are unfortunately sub-par wrt the rest of the module. \\[..."
"\\] We realize that the FCP for this issue was pretty short, however, so "
"please comment with any objections you might have! We're very willing to "
"backport an un-deprecate for the few APIs we have this cycle."
msgstr ""

#: src/3173-float-next-up-down.md:282
msgid ""
"One might consider this a formal un-deprecation request, albeit with a "
"different name and slightly different API."
msgstr ""

#: src/3173-float-next-up-down.md:285
msgid ""
"Within the Rust ecosystem the crate `float_next_after` solely provides the "
"`x.next_after(y)` method, and has 30,000 all-time downloads at the moment of "
"writing. The crate `ieee754` provides the `next` and `prev` methods among a "
"few others and sits at 244,000 all-time downloads."
msgstr ""

#: src/3173-float-next-up-down.md:290
msgid ""
"As for other languages supporting this feature, the list of prior art is "
"extensive:"
msgstr ""

#: src/3173-float-next-up-down.md:293
msgid ""
"C has `nextafter` and `nexttoward`, essentially identical:  \n"
"https://en.cppreference.com/w/c/numeric/math/nextafter"
msgstr ""

#: src/3173-float-next-up-down.md:296
msgid ""
"C++ follows in C's footsteps:  \n"
"https://en.cppreference.com/w/cpp/numeric/math/nextafter"
msgstr ""

#: src/3173-float-next-up-down.md:299
msgid ""
"Python has `nextafter`:  \n"
"https://docs.python.org/3/library/math.html#math.nextafter"
msgstr ""

#: src/3173-float-next-up-down.md:302
msgid ""
"Java has `nextUp`, `nextDown` and `nextAfter`:  \n"
"https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#nextUp-double-"
msgstr ""

#: src/3173-float-next-up-down.md:305
msgid ""
"Swift has `nextUp` and `nextDown`:  \n"
"https://developer.apple.com/documentation/swift/double/1847593-nextup"
msgstr ""

#: src/3173-float-next-up-down.md:308
msgid ""
"Go has `Nextafter`:  \n"
"https://pkg.go.dev/math#Nextafter"
msgstr ""

#: src/3173-float-next-up-down.md:311
msgid ""
"Julia has `nextfloat` and `prevfloat`:  \n"
"https://docs.julialang.org/en/v1/base/numbers/#Base.nextfloat"
msgstr ""

#: src/3173-float-next-up-down.md:314
msgid ""
"Ruby has `next_float` and `prev_float`:  \n"
"https://ruby-doc.org/core-3.0.2/Float.html#next_float-method"
msgstr ""

#: src/3173-float-next-up-down.md:318
msgid "Unresolved questions"
msgstr ""

#: src/3173-float-next-up-down.md:321
msgid ""
"Which is the better pair of names, `next_up` and `next_down` or `next_float` "
"and `prev_float`?"
msgstr ""

#: src/3173-float-next-up-down.md:324
msgid "Future possibilities"
msgstr ""

#: src/3173-float-next-up-down.md:327
msgid ""
"In the future Rust might consider having an iterator for `f32` / `f64` "
"ranges that uses `next_up` or `next_down` internally."
msgstr ""

#: src/3173-float-next-up-down.md:330
msgid ""
"The method `ulp` might also be considered, being a more precise "
"implementation of what is approximated as `x.next_up() - x` in this "
"document. Its implementation would directly compute the correct [ULP]"
"(https://en.wikipedia.org/wiki/Unit_in_the_last_place) by inspecting the "
"exponent field of the IEEE 754 number."
msgstr ""
