msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:03Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1135-raw-pointer-comparisons.md:1
msgid "Feature Name: raw-pointer-comparisons"
msgstr ""

#: src/1135-raw-pointer-comparisons.md:2
msgid "Start Date: 2015-05-27"
msgstr ""

#: src/1135-raw-pointer-comparisons.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1135](https://github.com/rust-lang/rfcs/pull/1135)"
msgstr ""

#: src/1135-raw-pointer-comparisons.md:4
msgid ""
"Rust Issue: [rust-lang/rust#28235](https://github.com/rust-lang/rust/"
"issues/28236)"
msgstr ""

#: src/1135-raw-pointer-comparisons.md:6
msgid "Summary"
msgstr ""

#: src/1135-raw-pointer-comparisons.md:8
msgid ""
"Allow equality, but not order, comparisons between fat raw pointers of the "
"same type."
msgstr ""

#: src/1135-raw-pointer-comparisons.md:11
msgid "Motivation"
msgstr ""

#: src/1135-raw-pointer-comparisons.md:13
msgid ""
"Currently, fat raw pointers can't be compared via either PartialEq or "
"PartialOrd (currently this causes an ICE). It seems to me that a primitive "
"type like a fat raw pointer should implement equality in some way."
msgstr ""

#: src/1135-raw-pointer-comparisons.md:17
msgid ""
"However, there doesn't seem to be a sensible way to order raw fat pointers "
"unless we take vtable addresses into account, which is relatively weird."
msgstr ""

#: src/1135-raw-pointer-comparisons.md:20
msgid "Detailed design"
msgstr ""

#: src/1135-raw-pointer-comparisons.md:22
msgid ""
"Implement PartialEq/Eq for fat raw pointers, defined as comparing both the "
"unsize-info and the address. This means that these are true:"
msgstr ""

#: src/1135-raw-pointer-comparisons.md:26
msgid "// of course\n"
msgstr ""

#: src/1135-raw-pointer-comparisons.md:28
msgid ""
"// these are *different* (one\n"
"\t                                 // prints only the first field,\n"
"\t\t\t\t\t // the other prints all fields).\n"
msgstr ""

#: src/1135-raw-pointer-comparisons.md:33
msgid "But"
msgstr ""

#: src/1135-raw-pointer-comparisons.md:36
msgid "// addresses are equal\n"
msgstr ""

#: src/1135-raw-pointer-comparisons.md:39
msgid "Drawbacks"
msgstr ""

#: src/1135-raw-pointer-comparisons.md:41
msgid ""
"Order comparisons may be useful for putting fat raw pointers into ordering-"
"based data structures (e.g. BinaryTree)."
msgstr ""

#: src/1135-raw-pointer-comparisons.md:44
msgid "Alternatives"
msgstr ""

#: src/1135-raw-pointer-comparisons.md:46
msgid ""
"@nrc suggested to implement heterogeneous comparisons between all thin raw "
"pointers and all fat raw pointers. I don't like this because equality "
"between fat raw pointers of different traits is false most of the time "
"(unless one of the traits is a supertrait of the other and/or the only "
"difference is in free lifetimes), and anyway you can always compare by "
"casting both pointers to a common type."
msgstr ""

#: src/1135-raw-pointer-comparisons.md:53
msgid ""
"It is also possible to implement ordering too, either in unsize -> addr "
"lexicographic order or addr -> unsize lexicographic order."
msgstr ""

#: src/1135-raw-pointer-comparisons.md:56
msgid "Unresolved questions"
msgstr ""

#: src/1135-raw-pointer-comparisons.md:58
msgid "What form of ordering should be adopted, if any?"
msgstr ""
