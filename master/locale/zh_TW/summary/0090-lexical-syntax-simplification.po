msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0090-lexical-syntax-simplification.md:1
msgid "Start Date: 2014-05-23"
msgstr ""

#: src/0090-lexical-syntax-simplification.md:2
msgid "RFC PR: [rust-lang/rfcs#90](https://github.com/rust-lang/rfcs/pull/90)"
msgstr ""

#: src/0090-lexical-syntax-simplification.md:3
msgid ""
"Rust Issue: [rust-lang/rust#14504](https://github.com/rust-lang/rust/"
"issues/14504)"
msgstr ""

#: src/0090-lexical-syntax-simplification.md:5
msgid "Summary"
msgstr "摘要"

#: src/0090-lexical-syntax-simplification.md:7
msgid ""
"Simplify Rust's lexical syntax to make tooling easier to use and easier to "
"define."
msgstr ""

#: src/0090-lexical-syntax-simplification.md:10
msgid "Motivation"
msgstr "動機"

#: src/0090-lexical-syntax-simplification.md:12
msgid ""
"Rust's lexer does a lot of work. It un-escapes escape sequences in string "
"and character literals, and parses numeric literals of 4 different bases. It "
"also strips comments, which is sensible, but can be undesirable for pretty "
"printing or syntax highlighting without hacks. Since many characters are "
"allowed in strings both escaped and raw (tabs, newlines, and unicode "
"characters come to mind), after lexing it is impossible to tell if a given "
"character was escaped or unescaped in the source, making the lexer difficult "
"to test against a model."
msgstr ""

#: src/0090-lexical-syntax-simplification.md:21
msgid "Detailed design"
msgstr "詳細設計"

#: src/0090-lexical-syntax-simplification.md:23
msgid ""
"The following (antlr4) grammar completely describes the proposed lexical "
"syntax:"
msgstr ""

#: src/0090-lexical-syntax-simplification.md:26
msgid ""
"    lexer grammar RustLexer;\n"
"    \n"
"    /* import Xidstart, Xidcont; */\n"
"    \n"
"    /* Expression-operator symbols */\n"
"    \n"
"    EQ      : '=' ;\n"
"    LT      : '<' ;\n"
"    LE      : '<=' ;\n"
"    EQEQ    : '==' ;\n"
"    NE      : '!=' ;\n"
"    GE      : '>=' ;\n"
"    GT      : '>' ;\n"
"    ANDAND  : '&&' ;\n"
"    OROR    : '||' ;\n"
"    NOT     : '!' ;\n"
"    TILDE   : '~' ;\n"
"    PLUS    : '+' ;\n"
"    MINUS   : '-' ;\n"
"    STAR    : '*' ;\n"
"    SLASH   : '/' ;\n"
"    PERCENT : '%' ;\n"
"    CARET   : '^' ;\n"
"    AND     : '&' ;\n"
"    OR      : '|' ;\n"
"    SHL     : '<<' ;\n"
"    SHR     : '>>' ;\n"
"    \n"
"    BINOP\n"
"        : PLUS\n"
"        | MINUS\n"
"        | STAR\n"
"        | PERCENT\n"
"        | CARET\n"
"        | AND\n"
"        | OR\n"
"        | SHL\n"
"        | SHR\n"
"        ;\n"
"    \n"
"    BINOPEQ : BINOP EQ ;\n"
"    \n"
"    /* \"Structural symbols\" */\n"
"    \n"
"    AT         : '@' ;\n"
"    DOT        : '.' ;\n"
"    DOTDOT     : '..' ;\n"
"    DOTDOTDOT  : '...' ;\n"
"    COMMA      : ',' ;\n"
"    SEMI       : ';' ;\n"
"    COLON      : ':' ;\n"
"    MOD_SEP    : '::' ;\n"
"    LARROW     : '->' ;\n"
"    FAT_ARROW  : '=>' ;\n"
"    LPAREN     : '(' ;\n"
"    RPAREN     : ')' ;\n"
"    LBRACKET   : '[' ;\n"
"    RBRACKET   : ']' ;\n"
"    LBRACE     : '{' ;\n"
"    RBRACE     : '}' ;\n"
"    POUND      : '#';\n"
"    DOLLAR     : '$' ;\n"
"    UNDERSCORE : '_' ;\n"
"    \n"
"    KEYWORD : STRICT_KEYWORD | RESERVED_KEYWORD ;\n"
"    \n"
"    fragment STRICT_KEYWORD\n"
"      : 'as'\n"
"      | 'box'\n"
"      | 'break'\n"
"      | 'continue'\n"
"      | 'crate'\n"
"      | 'else'\n"
"      | 'enum'\n"
"      | 'extern'\n"
"      | 'fn'\n"
"      | 'for'\n"
"      | 'if'\n"
"      | 'impl'\n"
"      | 'in'\n"
"      | 'let'\n"
"      | 'loop'\n"
"      | 'match'\n"
"      | 'mod'\n"
"      | 'mut'\n"
"      | 'once'\n"
"      | 'proc'\n"
"      | 'pub'\n"
"      | 'ref'\n"
"      | 'return'\n"
"      | 'self'\n"
"      | 'static'\n"
"      | 'struct'\n"
"      | 'super'\n"
"      | 'trait'\n"
"      | 'true'\n"
"      | 'type'\n"
"      | 'unsafe'\n"
"      | 'use'\n"
"      | 'virtual'\n"
"      | 'while'\n"
"      ;\n"
"    \n"
"    fragment RESERVED_KEYWORD\n"
"      : 'alignof'\n"
"      | 'be'\n"
"      | 'const'\n"
"      | 'do'\n"
"      | 'offsetof'\n"
"      | 'priv'\n"
"      | 'pure'\n"
"      | 'sizeof'\n"
"      | 'typeof'\n"
"      | 'unsized'\n"
"      | 'yield'\n"
"      ;\n"
"    \n"
"    // Literals\n"
"    \n"
"    fragment HEXIT\n"
"      : [0-9a-fA-F]\n"
"      ;\n"
"    \n"
"    fragment CHAR_ESCAPE\n"
"      : [nrt\\\\'\"0]\n"
"      | [xX] HEXIT HEXIT\n"
"      | 'u' HEXIT HEXIT HEXIT HEXIT\n"
"      | 'U' HEXIT HEXIT HEXIT HEXIT HEXIT HEXIT HEXIT HEXIT\n"
"      ;\n"
"    \n"
"    LIT_CHAR\n"
"      : '\\'' ( '\\\\' CHAR_ESCAPE | ~[\\\\'\\n\\t\\r] ) '\\''\n"
"      ;\n"
"    \n"
"    INT_SUFFIX\n"
"      : 'i'\n"
"      | 'i8'\n"
"      | 'i16'\n"
"      | 'i32'\n"
"      | 'i64'\n"
"      | 'u'\n"
"      | 'u8'\n"
"      | 'u16'\n"
"      | 'u32'\n"
"      | 'u64'\n"
"      ;\n"
"    \n"
"    LIT_INTEGER\n"
"      : [0-9][0-9_]* INT_SUFFIX?\n"
"      | '0b' [01][01_]* INT_SUFFIX?\n"
"      | '0o' [0-7][0-7_]* INT_SUFFIX?\n"
"      | '0x' [0-9a-fA-F][0-9a-fA-F_]* INT_SUFFIX?\n"
"      ;\n"
"    \n"
"    FLOAT_SUFFIX\n"
"      : 'f32'\n"
"      | 'f64'\n"
"      | 'f128'\n"
"      ;\n"
"    \n"
"    LIT_FLOAT\n"
"      : [0-9][0-9_]* ('.' | ('.' [0-9][0-9_]*)? ([eE] [-+]? [0-9][0-9_]*)? "
"FLOAT_SUFFIX?)\n"
"      ;\n"
"    \n"
"    LIT_STR\n"
"      : '\"' ('\\\\\\n' | '\\\\\\r\\n' | '\\\\' CHAR_ESCAPE | .)*? '\"'\n"
"      ;\n"
"    \n"
"    /* this is a bit messy */\n"
"    \n"
"    fragment LIT_STR_RAW_INNER\n"
"      : '\"' .*? '\"'\n"
"      | LIT_STR_RAW_INNER2\n"
"      ;\n"
"    \n"
"    fragment LIT_STR_RAW_INNER2\n"
"      : POUND LIT_STR_RAW_INNER POUND\n"
"      ;\n"
"    \n"
"    LIT_STR_RAW\n"
"      : 'r' LIT_STR_RAW_INNER\n"
"      ;\n"
"    \n"
"    fragment BLOCK_COMMENT\n"
"      : '/*' (BLOCK_COMMENT | .)*? '*/'\n"
"      ;\n"
"    \n"
"    COMMENT\n"
"      : '//' ~[\\r\\n]*\n"
"      | BLOCK_COMMENT\n"
"      ;\n"
"    \n"
"    IDENT : XID_start XID_continue* ;\n"
"    \n"
"    LIFETIME : '\\'' IDENT ;\n"
"    \n"
"    WHITESPACE : [ \\r\\n\\t]+ ;\n"
"    "
msgstr ""

#: src/0090-lexical-syntax-simplification.md:225
msgid "There are a few notable changes from today's lexical syntax:"
msgstr ""

#: src/0090-lexical-syntax-simplification.md:227
msgid ""
"Non-doc comments are not stripped. To compensate, when encountering a "
"COMMENT token the parser can check itself whether or not it's a doc comment. "
"This can be done with a simple regex: `(//(/[^/]|!)|/\\*(\\*[^*]|!))`."
msgstr ""

#: src/0090-lexical-syntax-simplification.md:230
msgid ""
"Numeric literals are not differentiated based on presence of type suffix, "
"nor are they converted from binary/octal/hexadecimal to decimal, nor are "
"underscores stripped. This can be done trivially in the parser."
msgstr ""

#: src/0090-lexical-syntax-simplification.md:233
msgid ""
"Character escapes are not unescaped. That is, if you write '\\x20', this "
"lexer will give you `LIT_CHAR('\\x20')` rather than `LIT_CHAR(' ')`. The "
"same applies to string literals."
msgstr ""

#: src/0090-lexical-syntax-simplification.md:237
msgid ""
"The output of the lexer then becomes annotated spans -- which part of the "
"document corresponds to which token type. Even whitespace is categorized."
msgstr ""

#: src/0090-lexical-syntax-simplification.md:240
msgid "Drawbacks"
msgstr ""

#: src/0090-lexical-syntax-simplification.md:242
msgid ""
"Including comments and whitespace in the token stream is very non-"
"traditional and not strictly necessary."
msgstr ""
