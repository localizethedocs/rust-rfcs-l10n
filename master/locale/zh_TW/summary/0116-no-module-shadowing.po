msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0116-no-module-shadowing.md:1
msgid "Start Date: 2014-06-12"
msgstr ""

#: src/0116-no-module-shadowing.md:2
msgid "RFC PR #: https://github.com/rust-lang/rfcs/pull/116"
msgstr ""

#: src/0116-no-module-shadowing.md:3
msgid "Rust Issue #: https://github.com/rust-lang/rust/issues/16464"
msgstr ""

#: src/0116-no-module-shadowing.md:5
msgid "Summary"
msgstr "摘要"

#: src/0116-no-module-shadowing.md:7
msgid ""
"Remove or feature gate the shadowing of view items on the same scope level, "
"in order to have less complicated semantic and be more future proof for "
"module system changes or experiments."
msgstr ""

#: src/0116-no-module-shadowing.md:10
msgid ""
"This means the names brought in scope by `extern crate` and `use` may never "
"collide with each other, nor with any other item (unless they live in "
"different namespaces). Eg, this will no longer work:"
msgstr ""

#: src/0116-no-module-shadowing.md:16
msgid "// ERROR: There is already a module `foo` in scope\n"
msgstr ""

#: src/0116-no-module-shadowing.md:19
msgid ""
"Shadowing would still be allowed in case of lexical scoping, so this "
"continues to work:"
msgstr ""

#: src/0116-no-module-shadowing.md:25
msgid "// Shadows the outer foo\n"
msgstr ""

#: src/0116-no-module-shadowing.md:31
msgid "Definitions"
msgstr ""

#: src/0116-no-module-shadowing.md:32
msgid ""
"Due to a certain lack of official, clearly defined semantics and "
"terminology, a list of relevant definitions is included:"
msgstr ""

#: src/0116-no-module-shadowing.md:35
msgid ""
"**Scope** A _scope_ in Rust is basically defined by a block, following the "
"rules of lexical scoping:"
msgstr ""

#: src/0116-no-module-shadowing.md:55
msgid ""
"Blocks include block expressions, `fn` items and `mod` items, but not things "
"like `extern`, `enum` or `struct`. Additionally, `mod` is special in that it "
"isolates itself from parent scopes."
msgstr ""

#: src/0116-no-module-shadowing.md:58
msgid ""
"**Scope Level** Anything with the same name in the example above is on the "
"same scope level. In a scope level, all names defined in parent scopes are "
"visible, but can be shadowed by a new definition with the same name, which "
"will be in scope for that scope itself and all its child scopes."
msgstr ""

#: src/0116-no-module-shadowing.md:63
msgid ""
"**Namespace** Rust has different namespaces, and the scoping rules apply to "
"each one separately. The exact number of different namespaces is not well "
"defined, but they are roughly"
msgstr ""

#: src/0116-no-module-shadowing.md:66
msgid "types (`enum Foo {}`)"
msgstr ""

#: src/0116-no-module-shadowing.md:67
msgid "modules (`mod foo {}`)"
msgstr ""

#: src/0116-no-module-shadowing.md:68
msgid "item values (`static FOO: uint = 0;`)"
msgstr ""

#: src/0116-no-module-shadowing.md:69
msgid "local values (`let foo = 0;`)"
msgstr ""

#: src/0116-no-module-shadowing.md:70
msgid "lifetimes (`impl<'a> ...`)"
msgstr ""

#: src/0116-no-module-shadowing.md:71
msgid "macros (`macro_rules! foo {...}`)"
msgstr ""

#: src/0116-no-module-shadowing.md:72
msgid ""
"**Definition Item** Declarations that create new entities in a crate are "
"called (by the author) definition items. They include `struct`, `enum`, "
"`mod`, `fn`, etc. Each of them creates a name in the type, module, item "
"value or macro namespace in the same scope level they are written in."
msgstr ""

#: src/0116-no-module-shadowing.md:77
msgid ""
"**View Item** Declarations that just create aliases to existing declarations "
"in a crate are called view items. They include `use` and `extern crate`, and "
"also create a name in the type, module, item value or macro namespace in the "
"same scope level they are written in."
msgstr ""

#: src/0116-no-module-shadowing.md:81
msgid ""
"**Item** Both definition items and view items together are collectively "
"called items."
msgstr ""

#: src/0116-no-module-shadowing.md:83
msgid ""
"**Shadowing** While the principle of shadowing exists in all namespaces, "
"there are different forms of it:"
msgstr ""

#: src/0116-no-module-shadowing.md:85
msgid ""
"item-style: Declarations shadow names from outer scopes, and are visible "
"everywhere in their own, including lexically before their own definition. "
"This requires there to be only one definition with the same name and "
"namespace per scope level. Types, modules, item values and lifetimes fall "
"under these rules."
msgstr ""

#: src/0116-no-module-shadowing.md:89
msgid ""
"sequentially: Declarations shadow names that are lexically before them, both "
"in parent scopes and their own. This means you can reuse the same name in "
"the same scope, but a definition will not be visibly before itself. This is "
"how local values and macros work. (Due to sequential code execution and "
"parsing, respectively)"
msgstr ""

#: src/0116-no-module-shadowing.md:93
msgid ""
"_view item_: A special case exists with view items; In the same scope level, "
"`extern crate` creates entries in the module namespace, which are shadowable "
"by names created with `use`, which are shadowable with any definition item. "
"**The singular goal of this RFC is to remove this shadowing behavior of view "
"items**"
msgstr ""

#: src/0116-no-module-shadowing.md:99
msgid "Motivation"
msgstr "動機"

#: src/0116-no-module-shadowing.md:101
msgid ""
"As explained above, what is currently visible under which namespace in a "
"given scope is determined by a somewhat complicated three step process:"
msgstr ""

#: src/0116-no-module-shadowing.md:104
msgid ""
"First, every `extern crate` item creates a name in the module namespace."
msgstr ""

#: src/0116-no-module-shadowing.md:105
msgid ""
"Then, every `use` can create a name in any namespace, shadowing the `extern "
"crate` ones."
msgstr ""

#: src/0116-no-module-shadowing.md:107
msgid ""
"Lastly, any definition item can shadow any name brought in scope by both "
"`extern crate` and `use`."
msgstr ""

#: src/0116-no-module-shadowing.md:109
msgid ""
"These rules have developed mostly in response to the older, more complicated "
"import system, and the existence of wildcard imports (`use foo::*`). In the "
"case of wildcard imports, this shadowing behavior prevents local code from "
"breaking if the source module gets updated to include new names that happen "
"to be defined locally."
msgstr ""

#: src/0116-no-module-shadowing.md:114
msgid ""
"However, wildcard imports are now feature gated, and name conflicts in "
"general can be resolved by using the renaming feature of `extern crate` and "
"`use`, so in the current non-gated state of the language there is no need "
"for this shadowing behavior."
msgstr ""

#: src/0116-no-module-shadowing.md:118
msgid ""
"Gating it off opens the door to remove it altogether in a backwards "
"compatible way, or to re-enable it in case wildcard imports are officially "
"supported again."
msgstr ""

#: src/0116-no-module-shadowing.md:121
msgid ""
"It also makes the mental model around items simpler: Any shadowing of items "
"happens through lexical scoping only, and every item can be considered "
"unordered and mutually recursive."
msgstr ""

#: src/0116-no-module-shadowing.md:124
msgid ""
"If this RFC gets accepted, a possible next step would be a RFC to lift the "
"ordering restriction between `extern crate`, `use` and definition items, "
"which would make them truly behave the same in regard to shadowing and the "
"ability to be reordered. It would also lift the weirdness of `use foo::bar; "
"mod foo;`."
msgstr ""

#: src/0116-no-module-shadowing.md:129
msgid ""
"Implementing this RFC would also not change anything about how name "
"resolution works, as its just a tightening of the existing rules."
msgstr ""

#: src/0116-no-module-shadowing.md:132
msgid "Drawbacks"
msgstr ""

#: src/0116-no-module-shadowing.md:134
msgid ""
"Feature gating import shadowing might break some code using "
"`#[feature(globs)]`."
msgstr ""

#: src/0116-no-module-shadowing.md:135
msgid ""
"The behavior of `libstd`s prelude becomes more magical if it still allows "
"shadowing, but this could be de-magified again by a new feature, see below "
"in unresolved questions."
msgstr ""

#: src/0116-no-module-shadowing.md:137
msgid ""
"Or the utility of `libstd`s prelude becomes more restricted if it doesn't "
"allow shadowing."
msgstr ""

#: src/0116-no-module-shadowing.md:139
msgid "Detailed design"
msgstr "詳細設計"

#: src/0116-no-module-shadowing.md:141
msgid "A new feature gate `import_shadowing` gets created."
msgstr ""

#: src/0116-no-module-shadowing.md:143
msgid ""
"During the name resolution phase of compilation, every time the compiler "
"detects a shadowing between `extern crate`, `use` and definition items in "
"the same scope level, it bails out unless the feature gate got enabled. This "
"amounts to two rules:"
msgstr ""

#: src/0116-no-module-shadowing.md:147
msgid ""
"Items in the same scope level and either the type, module, item value or "
"lifetime namespace may not shadow each other in the respective namespace."
msgstr ""

#: src/0116-no-module-shadowing.md:149
msgid "Items may shadow names from outer scopes in any namespace."
msgstr ""

#: src/0116-no-module-shadowing.md:151
msgid ""
"Just like for the `globs` feature, the `libstd` prelude import would be "
"preempt from this, and still be allowed to be shadowed."
msgstr ""

#: src/0116-no-module-shadowing.md:154
msgid "Alternatives"
msgstr ""

#: src/0116-no-module-shadowing.md:156
msgid ""
"The alternative is to do nothing, and risk running into a backwards "
"compatibility hazard, or committing to make a final design decision around "
"the whole module system before 1.0 gets released."
msgstr ""

#: src/0116-no-module-shadowing.md:160
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/0116-no-module-shadowing.md:162
msgid "It is unclear how the `libstd` preludes fits into this."
msgstr ""

#: src/0116-no-module-shadowing.md:164
msgid ""
"On the one hand, it basically acts like a hidden `use std::prelude::*;` "
"import which ignores the `globs` feature, so it could simply also ignore the "
"`import_shadowing` feature as well, and the rule becomes that the prelude is "
"a magic compiler feature that injects imports into every module but doesn't "
"prevent the user from taking the same names."
msgstr ""

#: src/0116-no-module-shadowing.md:170
msgid ""
"On the other hand, it is also thinkable to simply forbid shadowing of "
"prelude items as well, as defining things with the same name as std exports "
"is not recommended anyway, and this would nicely enforce that. It would "
"however mean that the prelude can not change without breaking backwards "
"compatibility, which might be too restricting."
msgstr ""

#: src/0116-no-module-shadowing.md:175
msgid ""
"A compromise would be to specialize wildcard imports into a new `prelude "
"use` feature, which has the explicit properties of being shadow-able and "
"using a wildcard import. `libstd`s prelude could then simply use that, and "
"users could define and use their own preludes as well. But that's a somewhat "
"orthogonal feature, and should be discussed in its own RFC."
msgstr ""

#: src/0116-no-module-shadowing.md:180
msgid "Interaction with overlapping imports."
msgstr ""

#: src/0116-no-module-shadowing.md:182
msgid "Right now its legal to write this:"
msgstr ""

#: src/0116-no-module-shadowing.md:190
msgid ""
"where the latter `use` shadows the former. This would have to be forbidden "
"as well, however the current semantic seems like a accident anyway."
msgstr ""
