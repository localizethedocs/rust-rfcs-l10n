msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:05Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/3101-reserved_prefixes.md:2
msgid "Feature Name: reserved_prefixes"
msgstr ""

#: src/3101-reserved_prefixes.md:3
msgid "Start Date: 2021-03-31"
msgstr ""

#: src/3101-reserved_prefixes.md:4
msgid ""
"RFC PR: [rust-lang/rfcs#3101](https://github.com/rust-lang/rfcs/pull/3101)"
msgstr ""

#: src/3101-reserved_prefixes.md:5
msgid ""
"Rust Issue: [rust-lang/rust#84978](https://github.com/rust-lang/rust/"
"issues/84978)"
msgstr ""

#: src/3101-reserved_prefixes.md:7
msgid "Summary"
msgstr "摘要"

#: src/3101-reserved_prefixes.md:10
msgid ""
"Beginning with the 2021 edition, reserve the syntax `ident#foo`, "
"`ident\"foo\"`, `ident'f'`, and `ident#123`, as a way of future-proofing "
"against future language changes."
msgstr ""

#: src/3101-reserved_prefixes.md:12
msgid "Motivation"
msgstr "動機"

#: src/3101-reserved_prefixes.md:15
msgid ""
"In [RFC 2151](https://rust-lang.github.io/rfcs/2151-raw-identifiers.html), "
"the language syntax was expanded to allow identifiers to optionally be "
"prefixed with `r#`, to ease migrating code when new keywords are introduced. "
"Conversely, [RFC 3098](https://github.com/rust-lang/rfcs/pull/3098) (still "
"under discussion as of this writing) is proposing to allow keywords to be "
"prefixed with `k#`, as an unobtrusive way to introduce new keywords without "
"requiring any migration effort or edition-level coordination."
msgstr ""

#: src/3101-reserved_prefixes.md:17
msgid ""
"In almost all circumstances these are frictionless additions; there is no "
"place in the basic Rust grammar that would conflict with productions of the "
"form `foo#bar`. However, there is a minor wrinkle with regard to macros. "
"Consider the following code:"
msgstr ""

#: src/3101-reserved_prefixes.md:20 src/3101-reserved_prefixes.md:81
msgid "\"one token\""
msgstr ""

#: src/3101-reserved_prefixes.md:21
msgid "\"three tokens\""
msgstr ""

#: src/3101-reserved_prefixes.md:29
msgid ""
"Prior to Rust 1.30 and the stabilization of raw identifiers (RFC 2151), the "
"above code would have produced the following compiler error:"
msgstr ""

#: src/3101-reserved_prefixes.md:38
msgid ""
"The `r#` prefix for raw identifiers was originally chosen because it "
"exploited a quirk of the parser, which prevented any code containing `r#foo` "
"from compiling due to the parser believing that it was processing a raw "
"string literal."
msgstr ""

#: src/3101-reserved_prefixes.md:40
msgid "After Rust 1.30 , it prints the following:"
msgstr ""

#: src/3101-reserved_prefixes.md:47
msgid "If RFC 3098 were accepted, it would print the following:"
msgstr ""

#: src/3101-reserved_prefixes.md:54
msgid ""
"This would be a breaking change, which is why RFC 3098 is currently aiming "
"to be implemented across an edition. However, the time-sensitivity of that "
"RFC could be obviated if the language merely guaranteed that such space was "
"syntactically available. Therefore this RFC proposes reserving such "
"syntactic space, without attaching any semantic meaning to it, to "
"accommodate both the \"raw keywords\" proposal or any other future language "
"changes that would benefit."
msgstr ""

#: src/3101-reserved_prefixes.md:56
msgid ""
"The notion of reserving \"syntactic space\" as an aid to backwards-"
"compatibility is an idea that has precedence from other languages. [C "
"reserves large swathes of the identifier space](https://www.gnu.org/software/"
"libc/manual/html_node/Reserved-Names.html) for its own use, most notably "
"identifiers that begin with `_` or `__`. Likewise, Python reserves all "
"identifiers of the form `__foo__` for special use by the language."
msgstr ""

#: src/3101-reserved_prefixes.md:58
msgid ""
"In contrast to Python or C, reserving syntax via `#` rather than `_` is much "
"less of an imposition on ordinary users, because `#` is not a valid "
"character in Rust identifiers. The only contexts in which this change would "
"be observable is within macros: `foo!(bar#qux)` would now fail to lex (a.k."
"a. tokenize). As such, the above code would produce the following "
"compilation error (wording TBD) when upgrading to the 2021 edition:"
msgstr ""

#: src/3101-reserved_prefixes.md:69
msgid ""
"Note that this syntactic reservation is whitespace-sensitive: any whitespace "
"to either side of the intervening `#` will allow this code to compile. This "
"provides a simple migration path for anyone who would be impacted by this "
"change; they would need only change their macro invocations from `foo!"
"(bar#qux)` to any of `foo!(bar # qux)`, `foo!(bar# qux)`, or `foo!(bar "
"#qux)`. It is possible to automate this mechanical migration via rustfix."
msgstr ""

#: src/3101-reserved_prefixes.md:71
msgid ""
"Rather than try to guess what prefixes it might be useful to reserve, this "
"RFC reserves _all_ [identifiers](https://doc.rust-lang.org/reference/"
"identifiers.html) directly preceding a `#`. This has the following benefits:"
msgstr ""

#: src/3101-reserved_prefixes.md:73
msgid ""
"It increases the amount of leeway for future language changes that might "
"wish to use this space (e.g. a hypothetical mechanism for edition-specific "
"keywords might be written as `edition2015#use`)."
msgstr ""

#: src/3101-reserved_prefixes.md:74
msgid ""
"It has symmetry with the existing notion of [literal suffixes](https://doc."
"rust-lang.org/reference/tokens.html#suffixes)."
msgstr ""

#: src/3101-reserved_prefixes.md:75
msgid "It avoids complicating the grammar and parser with bespoke concepts."
msgstr ""

#: src/3101-reserved_prefixes.md:77
msgid ""
"Finally, this RFC also proposes that this same syntax be reserved for string "
"literals (`ident\"foo\"`), char literals (`ident'f'`), and numeric literals "
"(`ident#123`). Once again, this reservation would be mostly unobservable by "
"end-users and would only manifest in code using macros like so:"
msgstr ""

#: src/3101-reserved_prefixes.md:82
msgid "\"two tokens\""
msgstr ""

#: src/3101-reserved_prefixes.md:83
msgid "\"four tokens\""
msgstr ""

#: src/3101-reserved_prefixes.md:86
msgid "br\"foo\""
msgstr ""

#: src/3101-reserved_prefixes.md:87
msgid "r\"foo\""
msgstr ""

#: src/3101-reserved_prefixes.md:88
msgid "r#\"foo\"#"
msgstr ""

#: src/3101-reserved_prefixes.md:91
msgid "Prior to the 2021 edition, this produces:"
msgstr ""

#: src/3101-reserved_prefixes.md:98
msgid ""
"Following the 2021 edition, these would become compiler errors. Once again, "
"whitespace could be (automatically) inserted to mitigate any breakage."
msgstr ""

#: src/3101-reserved_prefixes.md:100
msgid ""
"The motivation here, aside from the symmetry with prefixed identifiers and "
"[literal suffixes](https://doc.rust-lang.org/reference/tokens."
"html#suffixes), would be to leave open the design space for new literal "
"prefixes along the lines of the existing `b\"` and `r\"` prefixes. Some "
"hypothetical examples (not necessarily planned features or planned syntax): "
"format string literals `f\"`, `String` literals `s\"`, `CString` literals "
"`c\"`,  `OsString` literals `o\"`, UTF-16 literals `w\"`, user-overloadable "
"string literals `x\"`, etc."
msgstr ""

#: src/3101-reserved_prefixes.md:102
msgid ""
"There is one subtle note to this reservation: because raw string literals "
"and string literals tokenize differently, any prefix ending in `r` will "
"tokenize as a raw string literal would tokenize, and any prefix not ending "
"in `r` will tokenize as a non-raw string literal would tokenize. This is "
"considered acceptable in that it is assumed that new prefixes on these "
"literals will be \"compositional\" in nature, in the same sense that `b` and "
"`r` on string literals compose today, and thus it will be natural and "
"intentional to compose any such prefix with `r` in order to achieve raw "
"string semantics when desired. However, any hypothetical _non_\\-"
"compositional prefix would need to be chosen carefully in order to achieve "
"its desired tokenization"
msgstr ""

#: src/3101-reserved_prefixes.md:104
msgid "Guide-level explanation"
msgstr ""

#: src/3101-reserved_prefixes.md:105
msgid ""
"When designing DSLs via macros that take token trees as inputs, be aware "
"that certain syntactic productions which have no meaning in Rust are "
"nonetheless forbidden by the grammar, as they represent \"reserved space\" "
"for future language development. In particular, anything of the form "
"`<identifier>#<identifier>`, `<identifier>\"<string contents>\"`, "
"`<identifier>'<char contents>'`, and `<identifier>#<numeric literal>` is "
"reserved for exclusive use by the language; these are called _reserved "
"prefixes_."
msgstr ""

#: src/3101-reserved_prefixes.md:107
msgid ""
"Unless a prefix has been assigned a specific meaning by the language (e.g. "
"`r#async`, `b\"foo\"`), Rust will fail to tokenize when encountering any "
"code that attempts to make use of such prefixes. Note that these prefixes "
"rely on the absence of whitespace, so a macro invocation can use "
"`<identifier> # <identifier>` (note the spaces) as a way to consume "
"individual tokens adjacent to a `#`."
msgstr ""

#: src/3101-reserved_prefixes.md:109
msgid ""
"Putting it all together, this means that the following are valid macro "
"invocations:"
msgstr ""

#: src/3101-reserved_prefixes.md:111
msgid "`foo!(r#async)`,"
msgstr ""

#: src/3101-reserved_prefixes.md:112
msgid "`foo!(b'x')`"
msgstr ""

#: src/3101-reserved_prefixes.md:113
msgid "`foo!(bar # qux)`,"
msgstr ""

#: src/3101-reserved_prefixes.md:114
msgid "`foo!(bar #123)`"
msgstr ""

#: src/3101-reserved_prefixes.md:115
msgid "`foo!(bar# \"qux\")`"
msgstr ""

#: src/3101-reserved_prefixes.md:117
msgid "...but the following are invalid macro invocations:"
msgstr ""

#: src/3101-reserved_prefixes.md:119
msgid "`foo!(bar#async)`"
msgstr ""

#: src/3101-reserved_prefixes.md:120
msgid "`foo!(bar#123)`"
msgstr ""

#: src/3101-reserved_prefixes.md:121
msgid "`foo!(bar\"qux\")`"
msgstr ""

#: src/3101-reserved_prefixes.md:123
msgid "Reference-level explanation"
msgstr ""

#: src/3101-reserved_prefixes.md:126
msgid "New tokenizing rules are introduced:"
msgstr ""

#: src/3101-reserved_prefixes.md:128
msgid ""
"RESERVED_IDENTIFIER : IDENTIFIER_OR_KEYWORD<sub>Except `r`</sub> `#` "
"IDENTIFIER_OR_KEYWORD"
msgstr ""

#: src/3101-reserved_prefixes.md:130
msgid "RESERVED_BYTE_LITERAL : IDENTIFIER_OR_KEYWORD BYTE_LITERAL"
msgstr ""

#: src/3101-reserved_prefixes.md:132
msgid ""
"RESERVED_CHAR_LITERAL : IDENTIFIER_OR_KEYWORD<sub>Except `b`</sub> "
"CHAR_LITERAL"
msgstr ""

#: src/3101-reserved_prefixes.md:134
msgid ""
"RESERVED_RAW_BYTE_STRING_LITERAL : IDENTIFIER_OR_KEYWORD "
"RAW_BYTE_STRING_LITERAL"
msgstr ""

#: src/3101-reserved_prefixes.md:136
msgid ""
"RESERVED_BYTE_STRING_LITERAL : IDENTIFIER_OR_KEYWORD BYTE_STRING_LITERAL"
msgstr ""

#: src/3101-reserved_prefixes.md:138
msgid ""
"RESERVED_RAW_STRING_LITERAL : IDENTIFIER_OR_KEYWORD<sub>Except`b`</sub> "
"RAW_STRING_LITERAL"
msgstr ""

#: src/3101-reserved_prefixes.md:140
msgid ""
"RESERVED_STRING_LITERAL : IDENTIFIER_OR_KEYWORD<sub>Except `b`, `r`, `br`</"
"sub> STRING_LITERAL"
msgstr ""

#: src/3101-reserved_prefixes.md:142
msgid ""
"RESERVED_NUMERIC_LITERAL : IDENTIFIER_OR_KEYWORD `#` (INTEGER_LITERAL | "
"FLOAT_LITERAL)"
msgstr ""

#: src/3101-reserved_prefixes.md:144
msgid ""
"When compiling under the Rust 2021 edition (as determined by the edition of "
"the current crate), any instance of the above produces a tokenization error."
msgstr ""

#: src/3101-reserved_prefixes.md:146
msgid ""
"The use of \"identifier\" in this document proactively refers to whatever "
"definition of \"identifier\" is in use by Rust as of the 2021 edition. At "
"the time of this writing, the `non_ascii_idents` feature is not yet "
"stabilized, but is on track to be. If `non_ascii_idents` is stabilized "
"before the 2021 edition, then the syntactic reservations that take place in "
"the 2021 edition will include things like `über#foo`. However, if "
"`non_ascii_idents` is _not_ stabilized before the 2021 edition, then any "
"subsequent stabilization of `non_ascii_idents` would need to take care to "
"_not_ expand the reservations in this RFC, and instead defer that task to "
"the next edition."
msgstr ""

#: src/3101-reserved_prefixes.md:148
msgid ""
"An edition migration may be implemented that looks for `ident#ident`, "
"`ident\"string\"`, etc. within macro calls and inserts whitespace to force "
"proper tokenization."
msgstr ""

#: src/3101-reserved_prefixes.md:150
msgid "What follows are some examples of suggested error message templates:"
msgstr ""

#: src/3101-reserved_prefixes.md:168
msgid ""
"```\n"
"error: unknown prefix on string literal: bar\n"
" --> file.rs:x:y\n"
"  |\n"
"1 | foo!(bar\"qux\");\n"
"  |      ^^^ help: try using whitespace here: `bar \"qux\"`\n"
"  |\n"
"  = note: prefixed string literals are reserved for future use\n"
"```"
msgstr ""

#: src/3101-reserved_prefixes.md:178
msgid "Drawbacks"
msgstr ""

#: src/3101-reserved_prefixes.md:181
msgid "Complicates macro tokenizing rules."
msgstr ""

#: src/3101-reserved_prefixes.md:183
msgid "Rationale and alternatives"
msgstr ""

#: src/3101-reserved_prefixes.md:186
msgid ""
"Reserve only prefixed identifiers, and not prefixed literals. The former has "
"a concrete RFC that would benefit from this, but the latter is currently "
"just aspirational."
msgstr ""

#: src/3101-reserved_prefixes.md:187
msgid ""
"Instead of `ident`, reserve only `[a-z]+` or `[a-z]`. However, reserving "
"only `[a-z]` would force future language extensions to use exclusively pithy "
"single-letter syntax, even for features that may not be common enough to "
"warrant such abbreviated syntax. Reserving identifiers in this space "
"provides more flexibility for future language design, without impacting Rust "
"programs."
msgstr ""

#: src/3101-reserved_prefixes.md:188
msgid ""
"Instead of `ident`, reserve only `[a-zA-Z_][a-zA-Z0-9_]*`, the set of ASCII-"
"only identifiers. This would cover the space future Rust language design "
"extensions are likely to use. However, the explanation of the reserved space "
"would require presenting a distinct concept separate from the definition of "
"identifiers. In addition, reserving only ASCII identifiers seems unlikely to "
"provide a benefit to future Rust programs."
msgstr ""

#: src/3101-reserved_prefixes.md:189
msgid ""
"Instead of `ident`, reserve prefixes that permit any sequence of identifier "
"continuation characters. This would allow things like preceding digits, e.g. "
"`4#foo`."
msgstr ""

#: src/3101-reserved_prefixes.md:191
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/3101-reserved_prefixes.md:194
msgid ""
"How to manage the API `proc_macro::TokenStream::from_str`, which does not "
"take any edition information? ([raised here](https://github.com/rust-lang/"
"rfcs/pull/3101#issuecomment-832686934))"
msgstr ""

#: src/3101-reserved_prefixes.md:196
msgid "Prior art"
msgstr ""

#: src/3101-reserved_prefixes.md:199
msgid ""
"[C: Reserved names](https://www.gnu.org/software/libc/manual/html_node/"
"Reserved-Names.html)"
msgstr ""

#: src/3101-reserved_prefixes.md:200
msgid ""
"[Python: Reserved classes of identifiers](https://docs.python.org/3/"
"reference/lexical_analysis.html#reserved-classes-of-identifiers)"
msgstr ""

#: src/3101-reserved_prefixes.md:201
msgid ""
"[Ada: Based literals](archive.adaic.com/standards/83lrm/html/lrm-02-04."
"html#2.4.2)"
msgstr ""

#: src/3101-reserved_prefixes.md:202
msgid ""
"[Emacs Calc: Integers](https://www.gnu.org/software/emacs/manual/html_mono/"
"calc.html#Integers)"
msgstr ""
