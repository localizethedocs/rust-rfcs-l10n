msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0130-box-not-special.md:1
msgid "Start Date: 2014-07-29"
msgstr ""

#: src/0130-box-not-special.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#130](https://github.com/rust-lang/rfcs/pull/130)"
msgstr ""

#: src/0130-box-not-special.md:3
msgid ""
"Rust Issue: [rust-lang/rust#16094](https://github.com/rust-lang/rust/"
"issues/16094)"
msgstr ""

#: src/0130-box-not-special.md:5
msgid "Summary"
msgstr ""

#: src/0130-box-not-special.md:7
msgid "Remove special treatment of `Box<T>` from the borrow checker."
msgstr ""

#: src/0130-box-not-special.md:9
msgid "Motivation"
msgstr ""

#: src/0130-box-not-special.md:11
msgid ""
"Currently the `Box<T>` type is special-cased and converted to the old `~T` "
"internally. This is mostly invisible to the user, but it shows up in some "
"places that give special treatment to `Box<T>`. This RFC is specifically "
"concerned with the fact that the borrow checker has greater precision when "
"dereferencing `Box<T>` vs other smart pointers that rely on the `Deref` "
"traits. Unlike the other kinds of special treatment, we do not currently "
"have a plan for how to extend this behavior to all smart pointer types, and "
"hence we would like to remove it."
msgstr ""

#: src/0130-box-not-special.md:21
msgid ""
"Here is an example that illustrates the extra precision afforded to `Box<T>` "
"vs other types that implement the `Deref` traits. The following program, "
"written using the `Box` type, compiles successfully:"
msgstr ""

#: src/0130-box-not-special.md:37
msgid ""
"This program compiles because the type checker can see that `(*smaht).a` and "
"`(*smaht).b` are always distinct paths. In contrast, if I use a smart "
"pointer, I get compilation errors:"
msgstr ""

#: src/0130-box-not-special.md:41
msgid ""
"    fn example2(cell: RefCell<Pair>) {\n"
"        let mut smaht: RefMut<Pair> = cell.borrow_mut();\n"
"        let a = &mut smaht.a;\n"
"        \n"
"        // Error: cannot borrow `smaht` as mutable more than once at a time\n"
"        let b = &mut smaht.b;\n"
"    }\n"
"    "
msgstr ""

#: src/0130-box-not-special.md:49
msgid "To see why this, consider the desugaring:"
msgstr ""

#: src/0130-box-not-special.md:51
msgid ""
"    fn example2(smaht: RefCell<Pair>) {\n"
"        let mut smaht = smaht.borrow_mut();\n"
"        \n"
"        let tmp1: &mut Pair = smaht.deref_mut(); // borrows `smaht`\n"
"        let a = &mut tmp1.a;\n"
"        \n"
"        let tmp2: &mut Pair = smaht.deref_mut(); // borrows `smaht` again!\n"
"        let b = &mut tmp2.b;\n"
"    }\n"
"    "
msgstr ""

#: src/0130-box-not-special.md:61
msgid ""
"It is a violation of the Rust type system to invoke `deref_mut` when the "
"reference to `a` is valid and usable, since `deref_mut` requires `&mut "
"self`, which in turn implies no alias to `self` or anything owned by `self`."
msgstr ""

#: src/0130-box-not-special.md:66
msgid ""
"This desugaring suggests how the problem can be worked around in user code. "
"The idea is to pull the result of the deref into a new temporary:"
msgstr ""

#: src/0130-box-not-special.md:76
msgid "Detailed design"
msgstr ""

#: src/0130-box-not-special.md:78
msgid ""
"Removing this treatment from the borrow checker basically means changing the "
"construction of loan paths for unique pointers."
msgstr ""

#: src/0130-box-not-special.md:81
msgid ""
"I don't actually know how best to implement this in the borrow checker, "
"particularly concerning the desire to keep the ability to move out of boxes "
"and use them in patterns. This requires some investigation. The easiest and "
"best way may be to \"do it right\" and is probably to handle derefs of "
"`Box<T>` in a similar way to how overloaded derefs are handled, but somewhat "
"differently to account for the possibility of moving out of them. Some "
"investigation is needed."
msgstr ""

#: src/0130-box-not-special.md:89
msgid "Drawbacks"
msgstr ""

#: src/0130-box-not-special.md:91
msgid "The borrow checker rules are that much more restrictive."
msgstr ""

#: src/0130-box-not-special.md:93
msgid "Alternatives"
msgstr ""

#: src/0130-box-not-special.md:95
msgid ""
"We have ruled out inconsistent behavior between `Box` and other smart "
"pointer types. We considered a number of ways to extend the current "
"treatment of box to other smart pointer types:"
msgstr ""

#: src/0130-box-not-special.md:99
msgid ""
"_Require_ compiler to introduce deref temporaries automatically where "
"possible. This is plausible as a future extension but requires some thought "
"to work through all cases. It may be surprising. Note that this would be a "
"required optimization because if the optimization is not performed it "
"affects what programs can successfully type check. (Naturally it is also "
"observable.)"
msgstr ""

#: src/0130-box-not-special.md:106
msgid ""
"Some sort of unsafe deref trait that acknowledges possibility of other "
"pointers into the referent. Unappealing because the problem is not that bad "
"as to require unsafety."
msgstr ""

#: src/0130-box-not-special.md:110
msgid ""
"Determining conditions (perhaps based on parametricity?) where it is "
"provably safe to call deref. It is dubious and unknown if such conditions "
"exist or what that even means. Rust also does not really enjoy parametricity "
"properties due to presence of reflection and unsafe code."
msgstr ""

#: src/0130-box-not-special.md:116
msgid "Unresolved questions"
msgstr ""

#: src/0130-box-not-special.md:118
msgid "Best implementation strategy."
msgstr ""
