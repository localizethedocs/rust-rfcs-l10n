msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0019-opt-in-builtin-traits.md:1
msgid "Start Date: 2014-09-18"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:2
msgid ""
"RFC PR #: [rust-lang/rfcs#19](https://github.com/rust-lang/rfcs/pull/19), "
"[rust-lang/rfcs#127](https://github.com/rust-lang/rfcs/pull/127)"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:3
msgid ""
"Rust Issue #: [rust-lang/rust#13231](https://github.com/rust-lang/rust/"
"issues/13231)"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:5
msgid ""
"**Note:** The `Share` trait described in this RFC was later [renamed to "
"`Sync`](0123-share-to-threadsafe.md)."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:8
msgid "Summary"
msgstr "摘要"

#: src/0019-opt-in-builtin-traits.md:10
msgid ""
"The high-level idea is to add language features that simultaneously achieve "
"three goals:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:13
msgid ""
"move `Send` and `Share` out of the language entirely and into the standard "
"library, providing mechanisms for end users to easily implement and use "
"similar \"marker\" traits of their own devising;"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:16
msgid ""
"make \"normal\" Rust types sendable and sharable by default, without the "
"need for explicit opt-in; and,"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:18
msgid ""
"continue to require \"unsafe\" Rust types (those that manipulate unsafe "
"pointers or implement special abstractions) to \"opt-in\" to sendability and "
"sharability with an unsafe declaration."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:22
msgid "These goals are achieved by two changes:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:24
msgid ""
"**Unsafe traits:** An _unsafe trait_ is a trait that is unsafe to implement, "
"because it represents some kind of trusted assertion. Note that unsafe "
"traits are perfectly safe to _use_. `Send` and `Share` are examples of "
"unsafe traits: implementing these traits is effectively an assertion that "
"your type is safe for threading."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:30
msgid ""
"**Default and negative impls:** A _default impl_ is one that applies to all "
"types, except for those types that explicitly _opt out_. For example, there "
"would be a default impl for `Send`, indicating that all types are `Send` "
"\"by default\"."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:35
msgid ""
"To counteract a default impl, one uses a _negative impl_ that explicitly "
"opts out for a given type `T` and any type that contains `T`. For example, "
"this RFC proposes that unsafe pointers `*T` will opt out of `Send` and "
"`Share`. This implies that unsafe pointers cannot be sent or shared between "
"threads by default. It also implies that any structs which contain an unsafe "
"pointer cannot be sent. In all examples encountered thus far, the set of "
"negative impls is fixed and can easily be declared along with the trait "
"itself."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:45
msgid ""
"Safe wrappers like `Arc`, `Atomic`, or `Mutex` can opt to implement `Send` "
"and `Share` explicitly. This will then make them be considered sendable (or "
"sharable) even though they contain unsafe pointers etc."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:50
msgid ""
"Based on these two mechanisms, we can remove the notion of `Send` and "
"`Share` as builtin concepts. Instead, these would become unsafe traits with "
"default impls (defined purely in the library). The library would explicitly "
"_opt out_ of `Send`/`Share` for certain types, like unsafe pointers (`*T`) "
"or interior mutability (`Unsafe<T>`). Any type, therefore, which contains an "
"unsafe pointer would be confined (by default) to a single thread. Safe "
"wrappers around those types, like `Arc`, `Atomic`, or `Mutex`, can then opt "
"back in by explicitly implementing `Send` (these impls would have to be "
"designed as unsafe)."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:60
msgid "Motivation"
msgstr "動機"

#: src/0019-opt-in-builtin-traits.md:62
msgid ""
"Since proposing opt-in builtin traits, I have become increasingly concerned "
"about the notion of having `Send` and `Share` be strictly opt-in. There are "
"two main reasons for my concern:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:66
msgid ""
"Rust is very close to being a language where computations can be "
"parallelized by default. Making `Send`, and _especially_ `Share`, opt-in "
"makes that harder to achieve."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:69
msgid ""
"The model followed by `Send`/`Share` cannot easily be extended to other "
"traits in the future nor can it be extended by end-users with their own "
"similar traits. It is worrisome that I have come across several use cases "
"already which might require such extension (described below)."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:75
msgid ""
"To elaborate on those two points: With respect to parallelization: for the "
"most part, Rust types are threadsafe \"by default\". To make something non-"
"threadsafe, you must employ unsynchronized interior mutability (e.g., "
"`Cell`, `RefCell`) or unsynchronized shared ownership (`Rc`). In both cases, "
"there are also synchronized variants available (`Mutex`, `Arc`, etc). This "
"implies that we can make APIs to enable intra-task parallelism and they will "
"work ubiquitously, so long as people avoid `Cell` and `Rc` when not needed. "
"Explicit opt-in threatens that future, however, because fewer types will "
"implement `Share`, even if they are in fact threadsafe."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:86
msgid ""
"With respect to extensibility, it is particularly worrisome that if a "
"library forgets to implement `Send` or `Share`, downstream clients are "
"stuck. They cannot, for example, use a newtype wrapper, because it would be "
"illegal to implement `Send` on the newtype. This implies that all libraries "
"must be vigilant about implementing `Send` and `Share` (even more so than "
"with other pervasive traits like `Eq` or `Ord`). The current plan is to "
"address this via lints and perhaps some convenient deriving syntax, which "
"may be adequate for `Send` and `Share`. But if we wish to add new "
"\"classification\" traits in the future, these new traits won't have been "
"around from the start, and hence won't be implemented by all existing code."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:98
msgid ""
"Another concern of mine is that end users cannot define classification "
"traits of their own. For example, one might like to define a trait for "
"\"tainted\" data, and then test to ensure that tainted data doesn't pass "
"through some generic routine. There is no particular way to do this today."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:104
msgid ""
"More examples of classification traits that have come up recently in various "
"discussions:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:107
msgid ""
"`Snapshot` (nee `Freeze`), which defines _logical_ immutability rather than "
"_physical_ immutability. `Rc<int>`, for example, would be considered "
"`Snapshot`. `Snapshot` could be useful because `Snapshot+Clone` indicates a "
"type whose value can be safely \"preserved\" by cloning it."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:112
msgid ""
"`NoManaged`, a type which does not contain managed data. This might be "
"useful for integrating garbage collection with custom allocators which do "
"not wish to serve as potential roots."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:115
msgid ""
"`NoDrop`, a type which does not contain an explicit destructor. This can be "
"used to avoid nasty GC quandries."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:118
msgid ""
"All three of these (`Snapshot`, `NoManaged`, `NoDrop`) can be easily defined "
"using traits with default impls."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:121
msgid ""
"A final, somewhat weaker, motivator is aesthetics. Ownership has allowed us "
"to move threading almost entirely into libraries. The one exception is that "
"the `Send` and `Share` types remain built-in. Opt-in traits makes them "
"_less_ built-in, but still requires custom logic in the \"impl matching\" "
"code as well as special safety checks when `Safe` or `Share` are implemented."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:128
msgid ""
"After the changes I propose, the only traits which would be specifically "
"understood by the compiler are `Copy` and `Sized`. I consider this "
"acceptable, since those two traits are intimately tied to the core Rust type "
"system, unlike `Send` and `Share`."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:133
msgid "Detailed design"
msgstr "詳細設計"

#: src/0019-opt-in-builtin-traits.md:135
msgid "Unsafe traits"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:137
msgid ""
"Certain traits like `Send` and `Share` are critical to memory safety. "
"Nonetheless, it is not feasible to check the thread-safety of all types that "
"implement `Send` and `Share`. Therefore, we introduce a notion of an _unsafe "
"trait_ -- this is a trait that is unsafe to implement, because implementing "
"it carries semantic guarantees that, if compromised, threaten memory safety "
"in a deep way."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:144
msgid "An unsafe trait is declared like so:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:148
msgid "To implement an unsafe trait, one must mark the impl as unsafe:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:152
msgid ""
"Designating an impl as unsafe does not automatically mean that the body of "
"the methods is an unsafe block. Each method in the trait must also be "
"declared as unsafe if it to be considered unsafe."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:156
msgid ""
"Unsafe traits are only unsafe to _implement_. It is always safe to reference "
"an unsafe trait. For example, the following function is safe:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:162
msgid ""
"It is also safe to _opt out_ of an unsafe trait (as discussed in the next "
"section)."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:165
msgid "Default and negative impls"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:167
msgid "We add a notion of a _default impl_, written:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:171
msgid "Default impls are subject to various limitations:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:173
msgid ""
"The default impl must appear in the same module as `Trait` (or a submodule)."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:174
msgid "`Trait` must not define any methods."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:176
msgid "We further add the notion of a _negative impl_, written:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:180
msgid ""
"Negative impls are only permitted if `Trait` has a default impl. Negative "
"impls are subject to the usual orphan rules, but they are permitting to be "
"overlapping. This makes sense because negative impls are not providing an "
"implementation and hence we are not forced to select between them. For "
"similar reasons, negative impls never need to be marked unsafe, even if they "
"reference an unsafe trait."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:187
msgid ""
"Intuitively, to check whether a trait `Foo` that contains a default impl is "
"implemented for some type `T`, we first check for explicit (positive) impls "
"that apply to `T`. If any are found, then `T` implements `Foo`. Otherwise, "
"we check for negative impls. If any are found, then `T` does not implement "
"`Foo`. If neither positive nor negative impls were found, we proceed to "
"check the component types of `T` (i.e., the types of a struct's fields) to "
"determine whether all of them implement `Foo`. If so, then `Foo` is "
"considered implemented by `T`."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:197
msgid ""
"Oe non-obvious part of the procedure is that, as we recursively examine the "
"component types of `T`, we add to our list of assumptions that `T` "
"implements `Foo`. This allows recursive types like"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:203
msgid ""
"to be checked successfully. Otherwise, we would recursive infinitely. (This "
"procedure is directly analogous to what the existing `TypeContents` code "
"does.)"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:207
msgid ""
"Note that there exist types that expand to an infinite tree of types. Such "
"types cannot be successfully checked with a recursive impl; they will simply "
"overflow the builtin depth checking. However, such types also break code "
"generation under monomorphization (we cannot create a finite set of LLVM "
"types that correspond to them) and are in general not supported. Here is an "
"example of such a type:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:218
msgid ""
"The difference between `Foo` and `List` above is that `Foo<A>` references "
"`Foo<Vec<A>>`, which will then in turn reference `Foo<Vec<Vec<A>>>` and so "
"on."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:222
msgid "Modeling Send and Share using default traits"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:224
msgid ""
"The `Send` and `Share` traits will be modeled entirely in the library as "
"follows. First, we declare the two traits as follows:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:233
msgid ""
"Both traits are declared as unsafe because declaring that a type if `Send` "
"and `Share` has ramifications for memory safety (and data-race freedom) that "
"the compiler cannot, itself, check."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:237
msgid ""
"Next, we will add _opt out_ impls of `Send` and `Share` for the various "
"unsafe types:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:248
msgid ""
"Note that it is not necessary to write unsafe to _opt out_ of an unsafe "
"trait, as that is the default state."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:251
msgid ""
"Finally, we will add _opt in_ impls of `Send` and `Share` for the various "
"safe wrapper types as needed. Here I give one example, which is `Mutex`. "
"`Mutex` is interesting because it has the property that it converts a type "
"`T` from being `Sendable` to something `Sharable`:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:259
msgid "The `Copy` and `Sized` traits"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:261
msgid ""
"The final two builtin traits are `Copy` and `Share`. This RFC does not "
"propose any changes to those two traits but rather relies on the "
"specification from [the original opt-in RFC](0003-opt-in-builtin-traits.md)."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:265
msgid "Controlling copy vs move with the `Copy` trait"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:267
msgid ""
"The `Copy` trait is \"opt-in\" for user-declared structs and enums. A struct "
"or enum type is considered to implement the `Copy` trait only if it "
"implements the `Copy` trait.  This means that structs and enums would _move "
"by default_ unless their type is explicitly declared to be `Copy`. So, for "
"example, the following code would be in error:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:273
msgid ""
"    struct Point { x: int, y: int }\n"
"    ...\n"
"    let p = Point { x: 1, y: 2 };\n"
"    let q = p;  // moves p\n"
"    print(p.x); // ERROR\n"
"    "
msgstr ""

#: src/0019-opt-in-builtin-traits.md:279
msgid "To allow that example, one would have to impl `Copy` for `Point`:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:281
msgid ""
"    struct Point { x: int, y: int }\n"
"    impl Copy for Point { }\n"
"    ...\n"
"    let p = Point { x: 1, y: 2 };\n"
"    let q = p;  // copies p, because Point is Pod\n"
"    print(p.x); // OK\n"
"    "
msgstr ""

#: src/0019-opt-in-builtin-traits.md:288
msgid "Effectively, there is a three step ladder for types:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:290
msgid ""
"If you do nothing, your type is _linear_, meaning that it moves from place "
"to place and can never be copied in any way. (We need a better name for "
"that.)"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:293
msgid ""
"If you implement `Clone`, your type is _cloneable_, meaning that it moves "
"from place to place, but it can be explicitly cloned. This is suitable for "
"cases where copying is expensive."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:296
msgid ""
"If you implement `Copy`, your type is _copyable_, meaning that it is just "
"copied by default without the need for an explicit clone.  This is suitable "
"for small bits of data like ints or points."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:301
msgid ""
"What is nice about this change is that when a type is defined, the user "
"makes an _explicit choice_ between these three options."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:304
msgid "Determining whether a type is `Sized`"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:306
msgid ""
"Per the DST specification, the array types `[T]` and object types like "
"`Trait` are unsized, as are any structs that embed one of those types. The "
"`Sized` trait can never be explicitly implemented and membership in the "
"trait is always automatically determined."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:311
msgid "Matching and coherence for the builtin types `Copy` and `Sized`"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:313
msgid ""
"In general, determining whether a type implements a builtin trait can follow "
"the existing trait matching algorithm, but it will have to be somewhat "
"specialized. The problem is that we are somewhat limited in the kinds of "
"impls that we can write, so some of the implementations we would want must "
"be \"hard-coded\"."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:319
msgid ""
"Specifically we are limited around tuples, fixed-length array types, proc "
"types, closure types, and trait types:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:322
msgid ""
"_Fixed-length arrays:_ A fixed-length array `[T, ..n]` is `Copy` if `T` is "
"`Copy`. It is always `Sized` as `T` is required to be `Sized`."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:324
msgid ""
"_Tuples_: A tuple `(T_0, ..., T_n)` is `Copy/Sized` depending if, for all "
"`i`, `T_i` is `Copy/Sized`."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:326
msgid ""
"_Trait objects_ (including procs and closures): A trait object type `Trait:"
"K` (assuming DST here ;) is never `Copy` nor `Sized`."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:329
msgid ""
"We cannot currently express the above conditions using impls. We may at some "
"point in the future grow the ability to express some of them. For now, "
"though, these \"impls\" will be hardcoded into the algorithm as if they were "
"written in libstd."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:334
msgid ""
"Per the usual coherence rules, since we will have the above impls in "
"`libstd`, and we will have impls for types like tuples and fixed-length "
"arrays baked in, the only impls that end users are permitted to write are "
"impls for struct and enum types that they define themselves. Although this "
"rule is in the general spirit of the coherence checks, it will have to be "
"written specially."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:341
msgid "Design discussion"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:343
msgid "Why unsafe traits"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:345
msgid ""
"Without unsafe traits, it would be possible to create data races without "
"using the `unsafe` keyword:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:351
msgid "Balancing abstraction, safety, and convenience."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:353
msgid ""
"In general, the existence of default traits is _anti-abstraction_, in the "
"sense that it exposes implementation details a library might prefer to hide. "
"Specifically, adding new private fields can cause your types to become non-"
"sendable or non-sharable, which may break downstream clients without your "
"knowing. This is a known challenge with parallelism: knowing whether it is "
"safe to parallelize relies on implementation details we have traditionally "
"tried to keep secret from clients (often it is said that parallelism is "
"\"anti-modular\" or \"anti-compositional\" for this reason)."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:363
msgid ""
"I think this risk must be weighed against the limitations of requiring total "
"opt in. Requiring total opt in not only means that some types will "
"accidentally fail to implement send or share when they could, but it also "
"means that libraries which wish to employ marker traits cannot be composed "
"with other libraries that are not aware of those marker traits. In effect, "
"opt-in is anti-modular in its own way."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:370
msgid ""
"To be more specific, imagine that library A wishes to define a `Untainted` "
"trait, and it specifically opts out of `Untainted` for some base set of "
"types. It then wishes to have routines that only operate on `Untainted` "
"data. Now imagine that there is some other library B that defines a nifty "
"replacement for `Vector`, `NiftyVector`. Finally, some library C wishes to "
"use a `NiftyVector<uint>`, which should not be considered tainted, because "
"it doesn't reference any tainted strings. However, `NiftyVector<uint>` does "
"not implement `Untainted` (nor can it, without either library A or library B "
"knowing about one another). Similar problems arise for any trait, of course, "
"due to our coherence rules, but often they can be overcome with new types. "
"Not so with `Send` and `Share`."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:383
msgid "Other use cases"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:385
msgid ""
"Part of the design involves making space for other use cases. I'd like to "
"sketch out how some of those use cases can be implemented briefly. This is "
"not included in the _Detailed design_ section of the RFC because these "
"traits generally concern other features and would be added under RFCs of "
"their own."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:391
msgid ""
"**Isolating snapshot types.** It is useful to be able to identify types "
"which, when cloned, result in a logical _snapshot_. That is, a value which "
"can never be mutated.  Note that there may in fact be mutation under the "
"covers, but this mutation is not visible to the user. An example of such a "
"type is `Rc<T>` -- although the ref count on the `Rc` may change, the user "
"has no direct access and so `Rc<T>` is still logically snapshotable.  "
"However, not all `Rc` instances are snapshottable -- in particular, "
"something like `Rc<Cell<int>>` is not."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:400
msgid ""
"    trait Snapshot { }\n"
"    impl Snapshot for .. { }\n"
"    \n"
"    // In general, anything that can reach interior mutability is not\n"
"    // snapshotable.\n"
"    impl<T> !Snapshot for Unsafe<T> { }\n"
"    \n"
"    // But it's ok for Rc<T>.\n"
"    impl<T:Snapshot> Snapshot for Rc<T> { }\n"
"    "
msgstr ""

#: src/0019-opt-in-builtin-traits.md:410
msgid ""
"Note that these definitions could all occur in a library. That is, the `Rc` "
"type itself doesn't need to know about the `Snapshot` trait."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:413
msgid ""
"**Preventing access to managed data.** As part of the GC design, we expect "
"it will be useful to write specialized allocators or smart pointers that "
"explicitly do _not_ support tracing, so as to avoid any kind of GC overhead. "
"The general idea is that there should be a bound, let's call it `NoManaged`, "
"that indicates that a type cannot reach managed data and hence does not need "
"to be part of the GC's root set. This trait could be implemented as follows:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:425
msgid ""
"**Preventing access to destructors.** It is generally recognized that "
"allowing destructors to escape into managed data -- frequently referred to "
"as finalizers -- is a bad idea.  Therefore, we would generally like to "
"ensure that anything is placed into a managed box does not implement the "
"drop trait. Instead, we would prefer to regular the use of drop through a "
"guardian-like API, which basically means that destructors are not "
"asynchronously executed by the GC, as they would be in Java, but rather "
"enqueued for the mutator thread to run synchronously at its leisure. In "
"order to handle this, though, we presumably need some sort of guardian "
"wrapper types that can take a value which has a destructor and allow it to "
"be embedded within managed data. We can summarize this in a trait `GcSafe` "
"as follows:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:438
msgid ""
"    unsafe trait GcSafe { }\n"
"    unsafe impl GcSafe for .. { }\n"
"    \n"
"    // By default, anything which has drop trait is not GcSafe.\n"
"    impl<T:Drop> !GcSafe for T { }\n"
"    \n"
"    // But guardians are, even if `T` has drop.\n"
"    impl<T> GcSafe for Guardian<T> { }\n"
"    "
msgstr ""

#: src/0019-opt-in-builtin-traits.md:447
msgid "Why are `Copy` and `Sized` different?"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:449
msgid ""
"The `Copy` and `Sized` traits remain builtin to the compiler. This makes "
"sense because they are intimately tied to analyses the compiler performs. "
"For example, the running of destructors and tracking of moves requires "
"knowing which types are `Copy`. Similarly, the allocation of stack frames "
"need to know whether types are fully `Sized`. In contrast, sendability and "
"sharability has been fully exported to libraries at this point."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:457
msgid "In addition, opting in to `Copy` makes sense for several reasons:"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:459
msgid ""
"Experience has shown that \"data-like structs\", for which `Copy` is most "
"appropriate, are a very small percentage of the total."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:461
msgid ""
"Changing a public API from being copyable to being only movable has a "
"outsized impact on users of the API. It is common however that as APIs "
"evolve they will come to require owned data (like a `Vec`), even if they do "
"not initially, and hence will change from being copyable to only movable. "
"Opting in to `Copy` is a way of saying that you never foresee this coming to "
"pass."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:467
msgid ""
"Often it is useful to create linear \"tokens\" that do not themselves have "
"data but represent permissions. This can be done today using markers but it "
"is awkward. It becomes much more natural under this proposal."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:472
msgid "Drawbacks"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:474
msgid ""
"**API stability.** The main drawback of this approach over the existing opt-"
"in approach seems to be that a type may be \"accidentally\" sendable or "
"sharable. I discuss this above under the heading of \"balancing abstraction, "
"safety, and convenience\". One point I would like to add here, as it "
"specifically pertains to API stability, is that a library may, if they "
"choose, opt out of `Send` and `Share` pre-emptively, in order to \"reserve "
"the right\" to add non-sendable things in the future."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:483
msgid "Alternatives"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:485
msgid "The existing opt-in design is of course an alternative."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:487
msgid ""
"We could also simply add the notion of `unsafe` traits and _not_ default "
"impls and then allow types to unsafely implement `Send` or `Share`, "
"bypassing the normal safety guidelines. This gives an escape valve for a "
"downstream client to assert that something is sendable which was not "
"declared as sendable. However, such a solution is deeply unsatisfactory, "
"because it rests on the downstream client making an assertion about the "
"implementation of the library it uses. If that library should be updated, "
"the client's assumptions could be invalidated, but no compilation errors "
"will result (the impl was already declared as unsafe, after all)."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:498
msgid "Phasing"
msgstr ""

#: src/0019-opt-in-builtin-traits.md:500
msgid ""
"Many of the mechanisms described in this RFC are not needed immediately.  "
"Therefore, we would like to implement a minimal \"forwards compatible\" set "
"of changes now and then leave the remaining work for after the 1.0 release. "
"The builtin rules that the compiler currently implements for send and share "
"are quite close to what is proposed in this RFC. The major change is that "
"unsafe pointers and the `UnsafeCell` type are currently considered sendable."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:508
msgid ""
"Therefore, to be forwards compatible in the short term, we can use the same "
"hybrid of builtin and explicit impls for `Send` and `Share` that we use for "
"`Copy`, with the rule that unsafe pointers and `UnsafeCell` are not "
"considered sendable. We must also implement the `unsafe trait` and `unsafe "
"impl` concept."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:514
msgid ""
"What this means in practice is that using `*const T`, `*mut T`, and "
"`UnsafeCell` will make a type `T` non-sendable and non-sharable, and `T` "
"must then explicitly implement `Send` or `Share`."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:518
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/0019-opt-in-builtin-traits.md:520
msgid ""
"The terminology of \"unsafe trait\" seems somewhat misleading, since it "
"seems to suggest that \"using\" the trait is unsafe, rather than "
"implementing it. One suggestion for an alternate keyword was `trusted "
"trait`, which might dovetail with the use of `trusted` to specify a trusted "
"block of code. If we did use `trusted trait`, it seems that all impls would "
"also have to be `trusted impl`."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:526
msgid ""
"Perhaps we should declare a trait as a \"default trait\" directly, rather "
"than using the `impl Drop for ..` syntax. I don't know precisely what syntax "
"to use, though."
msgstr ""

#: src/0019-opt-in-builtin-traits.md:529
msgid ""
"Currently, there are special rules relating to object types and the builtin "
"traits. If the \"builtin\" traits are no longer builtin, we will have to "
"generalize object types to be simply a set of trait references. This is "
"already planned but merits a second RFC. Note that no changes here are "
"required for the 1.0, since the phasing plan dictates that builtin traits "
"remain special until after 1.0."
msgstr ""
