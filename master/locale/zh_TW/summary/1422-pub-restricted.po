msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:03Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1422-pub-restricted.md:1
msgid "Feature Name: pub_restricted"
msgstr ""

#: src/1422-pub-restricted.md:2
msgid "Start Date: 2015-12-18"
msgstr ""

#: src/1422-pub-restricted.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1422](https://github.com/rust-lang/rfcs/pull/1422)"
msgstr ""

#: src/1422-pub-restricted.md:4
msgid ""
"Rust Issue: [rust-lang/rust#32409](https://github.com/rust-lang/rust/"
"issues/32409)"
msgstr ""

#: src/1422-pub-restricted.md:6
msgid "Summary"
msgstr "摘要"

#: src/1422-pub-restricted.md:9
msgid ""
"Expand the current `pub`/non-`pub` categorization of items with the ability "
"to say \"make this item visible _solely_ to a (named) module tree.\""
msgstr ""

#: src/1422-pub-restricted.md:13
msgid ""
"The current `crate` is one such tree, and would be expressed via: "
"`pub(crate) item`. Other trees can be denoted via a path employed in a `use` "
"statement, e.g. `pub(a::b) item`, or `pub(super) item`."
msgstr ""

#: src/1422-pub-restricted.md:17
msgid "Motivation"
msgstr "動機"

#: src/1422-pub-restricted.md:20
msgid ""
"Right now, if you have a definition for an item `X` that you want to use in "
"many places in a module tree, you can either (1.) define `X` at the root of "
"the tree as a non-`pub` item, or (2.) you can define `X` as a `pub` item in "
"some submodule (and import into the root of the module tree via `use`)."
msgstr ""

#: src/1422-pub-restricted.md:26
msgid "But: Sometimes neither of these options is really what you want."
msgstr ""

#: src/1422-pub-restricted.md:28
msgid ""
"There are scenarios where developers would like an item to be visible to a "
"particular module subtree (or a whole crate in its entirety), but it is not "
"possible to move the item's (non-pub) definition to the root of that subtree "
"(which would be the usual way to expose an item to a subtree without making "
"it pub)."
msgstr ""

#: src/1422-pub-restricted.md:34
msgid ""
"If the definition of `X` itself needs access to other private items within a "
"submodule of the tree, then `X` _cannot_ be put at the root of the module "
"tree. Illustration:"
msgstr ""

#: src/1422-pub-restricted.md:39 src/1422-pub-restricted.md:71
#: src/1422-pub-restricted.md:272
msgid "// Intent: `a` exports `I`, `bar`, and `foo`, but nothing else.\n"
msgstr ""

#: src/1422-pub-restricted.md:43
msgid ""
"// `semisecret` will be used \"many\" places within `a`, but\n"
"    // is not meant to be exposed outside of `a`.\n"
msgstr ""

#: src/1422-pub-restricted.md:52 src/1422-pub-restricted.md:86
#: src/1422-pub-restricted.md:287
msgid "// J is meant to be hidden from the outside world.\n"
msgstr ""

#: src/1422-pub-restricted.md:58
msgid "(Note: the `pub mod a` is meant to be at the root of some crate.)"
msgstr ""

#: src/1422-pub-restricted.md:60
msgid ""
"The latter code fails to compile, due to the privacy violation where the "
"body of `fn semisecret` attempts to access `a::b::c::J`, which is not "
"visible in the context of `a`."
msgstr ""

#: src/1422-pub-restricted.md:64
msgid ""
"A standard way to deal with this today is to use the second approach "
"described above (labelled \"(2.)\"): move `fn semisecret` down into the "
"place where it can access `J`, marking `fn semisecret` as `pub` so that it "
"can still be accessed within the items of `a`, and then re-exporting "
"`semisecret` as necessary up the module tree."
msgstr ""

#: src/1422-pub-restricted.md:75
msgid ""
"// `semisecret` will be used \"many\" places within `a`, but\n"
"    // is not meant to be exposed outside of `a`.\n"
"    // (If we put `pub use` here, then *anyone* could access it.)\n"
msgstr ""

#: src/1422-pub-restricted.md:93
msgid ""
"This works, but there is a serious issue with it: One cannot easily tell "
"exactly how \"public\" `fn semisecret` is. In particular, understanding who "
"can access `semisecret` requires reasoning about (1.) all of the `pub use`'s "
"(aka re-exports) of `semisecret`, and (2.) the `pub`\\-ness of every module "
"in a path leading to `fn semisecret` or one of its re-exports."
msgstr ""

#: src/1422-pub-restricted.md:100
msgid "This RFC seeks to remedy the above problem via two main changes."
msgstr ""

#: src/1422-pub-restricted.md:102 src/1422-pub-restricted.md:175
msgid ""
"Give the user a way to explicitly restrict the intended scope of where a "
"`pub`\\-licized item can be used."
msgstr ""

#: src/1422-pub-restricted.md:105 src/1422-pub-restricted.md:178
msgid ""
"Modify the privacy rules so that `pub`\\-restricted items cannot be used nor "
"re-exported outside of their respective restricted areas."
msgstr ""

#: src/1422-pub-restricted.md:108
msgid "Impact"
msgstr ""

#: src/1422-pub-restricted.md:110
msgid ""
"This difficulty in reasoning about the \"publicness\" of a name is not just "
"a problem for users; it also complicates efforts within the compiler to "
"verify that a surface API for a type does not itself use or expose any "
"private names."
msgstr ""

#: src/1422-pub-restricted.md:115
msgid ""
"[There](https://github.com/rust-lang/rust/issues/18241) are [a](https://"
"github.com/rust-lang/rust/issues/28325) number [of](https://github.com/rust-"
"lang/rust/issues/28450) bugs [filed](https://github.com/rust-lang/rust/"
"issues/28514) against [privacy](https://github.com/rust-lang/rust/"
"issues/29668) checking; some are simply implementation issues, but the "
"comment threads in the issues make it clear that in some cases, different "
"people have very different mental models about how privacy interacts with "
"aliases (e.g. `type` declarations) and re-exports."
msgstr ""

#: src/1422-pub-restricted.md:122
msgid ""
"In theory, we can add the changes of this RFC without breaking any old code. "
"(That is, in principle the only affected code is that for item definitions "
"that use `pub(restriction)`. This limited addition would still provide value "
"to users in their reasoning about the visibility of such items.)"
msgstr ""

#: src/1422-pub-restricted.md:128
msgid ""
"In practice, I expect that as part of the implementation of this RFC, we "
"will probably fix pre-existing bugs in the parts of privacy checking "
"verifying that surface API's do not use or expose private names."
msgstr ""

#: src/1422-pub-restricted.md:133
msgid ""
"Important: No such fixes to such pre-existing bugs are being concretely "
"proposed by this RFC; I am merely musing that by adding a more expressive "
"privacy system, we will open the door to fix bugs whose exploits, under the "
"old system, were the only way to express certain patterns of interest to "
"developers."
msgstr ""

#: src/1422-pub-restricted.md:161
msgid "Detailed design"
msgstr "詳細設計"

#: src/1422-pub-restricted.md:164
msgid ""
"The main problem identified in the [motivation](#motivation) section is this:"
msgstr ""

#: src/1422-pub-restricted.md:166
msgid "From an module-internal definition like"
msgstr ""

#: src/1422-pub-restricted.md:170
msgid ""
"one cannot readily tell exactly how \"public\" the `fn semisecret` is meant "
"to be."
msgstr ""

#: src/1422-pub-restricted.md:172
msgid ""
"As already stated, this RFC seeks to remedy the above problem via two main "
"changes."
msgstr ""

#: src/1422-pub-restricted.md:181
msgid "Syntax"
msgstr ""

#: src/1422-pub-restricted.md:183
msgid ""
"The new feature is to restrict the scope by adding the module subtree (which "
"acts as the restricted area) in parentheses after the `pub` keyword, like so:"
msgstr ""

#: src/1422-pub-restricted.md:191
msgid ""
"The path in the restriction is resolved just like a `use` statement: it is "
"resolved absolutely, from the crate root."
msgstr ""

#: src/1422-pub-restricted.md:194
msgid ""
"Just like `use` statements, one can also write relative paths, by starting "
"them with `self` or a sequence of `super`'s."
msgstr ""

#: src/1422-pub-restricted.md:198
msgid "// or\n"
msgstr ""

#: src/1422-pub-restricted.md:200
msgid "// (semantically equiv to no `pub`; see below)\n"
msgstr ""

#: src/1422-pub-restricted.md:203
msgid "In addition to the forms analogous to `use`, there is one new form:"
msgstr ""

#: src/1422-pub-restricted.md:209
msgid "In other words, the grammar is changed like so:"
msgstr ""

#: src/1422-pub-restricted.md:211
msgid "old:"
msgstr ""

#: src/1422-pub-restricted.md:216
msgid "new:"
msgstr ""

#: src/1422-pub-restricted.md:221
msgid ""
"One can use these `pub(restriction)` forms anywhere that one can currently "
"use `pub`. In particular, one can use them on item definitions, methods in "
"an impl, the fields of a struct definition, and on `pub use` re-exports."
msgstr ""

#: src/1422-pub-restricted.md:226
msgid "Semantics"
msgstr ""

#: src/1422-pub-restricted.md:228
msgid ""
"The meaning of `pub(restriction)` is as follows: The definition of every "
"item, method, field, or name (e.g. a re-export) is associated with a "
"restriction."
msgstr ""

#: src/1422-pub-restricted.md:232
msgid ""
"A restriction is either: the universe of all crates (aka \"unrestricted\"), "
"the current crate, or an absolute path to a module sub-hierarchy in the "
"current crate. A restricted thing cannot be directly \"used\" in source code "
"outside of its restricted area.  (The term \"used\" here is meant to cover "
"both direct reference in the source, and also implicit reference as the "
"inferred type of an expression or pattern.)"
msgstr ""

#: src/1422-pub-restricted.md:240
msgid ""
"`pub` written with no explicit restriction means that there is no "
"restriction, or in other words, the restriction is the universe of all "
"crates."
msgstr ""

#: src/1422-pub-restricted.md:244
msgid "`pub(crate)` means that the restriction is the current crate."
msgstr ""

#: src/1422-pub-restricted.md:246
msgid ""
"`pub(<path>)` means that the restriction is the module sub-hierarchy denoted "
"by `<path>`, resolved in the context of the occurrence of the `pub` "
"modifier. (This is to ensure that `super` and `self` make sense in such "
"paths.)"
msgstr ""

#: src/1422-pub-restricted.md:251
msgid ""
"As noted above, the definition means that `pub(self) item` is the same as if "
"one had written just `item`."
msgstr ""

#: src/1422-pub-restricted.md:254
msgid ""
"The main reason to support this level of generality (which is otherwise just "
"\"redundant syntax\") is macros: one can write a macro that expands to "
"`pub($arg) item`, and a macro client can pass in `self` as the `$arg` to get "
"the effect of a non-pub definition."
msgstr ""

#: src/1422-pub-restricted.md:259
msgid ""
"NOTE: even if the restriction of an item or name indicates that it is "
"accessible in some context, it may still be impossible to reference it. In "
"particular, we will still keep our existing rules regarding `pub` items "
"defined in non-`pub` modules; such items would have no restriction, but "
"still may be inaccessible if they are not re-exported in some manner."
msgstr ""

#: src/1422-pub-restricted.md:266
msgid "Revised Example"
msgstr ""

#: src/1422-pub-restricted.md:269
msgid "In the running example, one could instead write:"
msgstr ""

#: src/1422-pub-restricted.md:276
msgid ""
"// `semisecret` will be used \"many\" places within `a`, but\n"
"    // is not meant to be exposed outside of `a`.\n"
"    // (`pub use` would be *rejected*; see Note 1 below)\n"
msgstr ""

#: src/1422-pub-restricted.md:289
msgid ""
"// `pub(a)` means \"usable within hierarchy of `mod a`, but not\n"
"            // elsewhere.\"\n"
msgstr ""

#: src/1422-pub-restricted.md:297
msgid ""
"Note 1: The compiler would reject the variation of the above written as:"
msgstr ""

#: src/1422-pub-restricted.md:304
msgid ""
"because `pub(a) fn semisecret` says that it cannot be used outside of `a`, "
"and therefore it be incorrect (or at least useless) to reexport `semisecret` "
"outside of `a`."
msgstr ""

#: src/1422-pub-restricted.md:308
msgid ""
"Note 2: The most direct interpretation of the rules here leads me to "
"conclude that `b`'s re-export of `semisecret` needs to be restricted to `a` "
"as well. However, it may be possible to loosen things so that the re-export "
"could just stay as `pub` with no extra restriction; see discussion of \"IRS:"
"PUNPM\" in Unresolved Questions."
msgstr ""

#: src/1422-pub-restricted.md:314
msgid ""
"This richer notion of privacy does offer us some other ways to re-write the "
"running example; instead of defining `fn semisecret` within `c` so that it "
"can access `J`, we might instead expose `J` to `mod b` and then put `fn "
"semisecret`, like so:"
msgstr ""

#: src/1422-pub-restricted.md:332
msgid ""
"(This RFC takes no position on which of the above two structures is "
"\"better\"; a toy example like this does not provide enough context to "
"judge.)"
msgstr ""

#: src/1422-pub-restricted.md:336
msgid "Restrictions"
msgstr ""

#: src/1422-pub-restricted.md:339
msgid "Lets discuss what the restrictions actually mean."
msgstr ""

#: src/1422-pub-restricted.md:341
msgid ""
"Some basic definitions: An item is just as it is declared in the Rust "
"reference manual: a component of a crate, located at a fixed path "
"(potentially at the \"outermost\" anonymous module) within the module tree "
"of the crate."
msgstr ""

#: src/1422-pub-restricted.md:346
msgid ""
"Every item can be thought of as having some hidden implementation "
"component(s) along with an exposed surface API."
msgstr ""

#: src/1422-pub-restricted.md:349
msgid ""
"So, for example, in `pub fn foo(x: Input) -> Output { Body }`, the surface "
"of `foo` includes `Input` and `Output`, while the `Body` is hidden."
msgstr ""

#: src/1422-pub-restricted.md:353
msgid ""
"The pre-existing privacy rules (both prior to and after this RFC) try to "
"enforce two things: (1.) when a item references a path, all of the names on "
"that path need to be visible (in terms of privacy) in the referencing "
"context and, (2.) private items should not be exposed in the surface of "
"public API's."
msgstr ""

#: src/1422-pub-restricted.md:359
msgid ""
"I am using the term \"surface\" rather than \"signature\" deliberately, "
"since I think the term \"signature\" is too broad to be used to accurately "
"describe the current semantics of rustc. See my recent [Surface blog post]"
"(http://blog.pnkfx.org/blog/2015/12/19/signatures-and-surfaces-thoughts-on-"
"privacy-versus-dependency/) for further discussion."
msgstr ""

#: src/1422-pub-restricted.md:366
msgid ""
"This RFC is expanding the scope of (2.) above, so that the rules are now:"
msgstr ""

#: src/1422-pub-restricted.md:368
msgid ""
"when a item references a path (in its implementation or in its signature), "
"all of the names on that path must be visible in the referencing context."
msgstr ""

#: src/1422-pub-restricted.md:372
msgid ""
"items _restricted_ to an area R should not be exposed in the surface API of "
"names or items that can themselves be exported beyond R. (Privacy is now a "
"special case of this more general notion.)"
msgstr ""

#: src/1422-pub-restricted.md:377
msgid ""
"For convenience, it is legal to declare a field (or inherent method) with a "
"strictly larger area of restriction than its `self`. See discussion in the "
"[examples](#fields-and-inherent-methods-more-public-than-self)."
msgstr ""

#: src/1422-pub-restricted.md:381
msgid ""
"In principle, validating (1.) can be done via the pre-existing privacy code. "
"(However, it may make sense to do it by mapping each name to its associated "
"restriction; I don't think that will change the outcome, but it might make "
"the checking code simpler. But I am not an expert on the current state of "
"the privacy checking code.)"
msgstr ""

#: src/1422-pub-restricted.md:387
msgid ""
"Validating (2.) requires traversing the surface API for each item and "
"comparing the restriction for every reference to the restriction of the item "
"itself."
msgstr ""

#: src/1422-pub-restricted.md:391
msgid "Trait methods"
msgstr ""

#: src/1422-pub-restricted.md:393
msgid "Currently, trait associated item syntax carries no `pub` modifier."
msgstr ""

#: src/1422-pub-restricted.md:395
msgid ""
"A question arises when trying to apply the terminology of this RFC: are "
"trait associated items implicitly `pub`, in the sense that they are "
"unrestricted?"
msgstr ""

#: src/1422-pub-restricted.md:399
msgid ""
"The simple answer is: No, associated items are not implicitly `pub`; at "
"least, not in general. (They are not in general implicitly `pub` today "
"either, as discussed in [RFC 136](https://github.com/rust-lang/rfcs/blob/"
"master/text/0136-no-privates-in-public.md#when-is-an-item-public).) (If they "
"were implicitly `pub`, things would be difficult; further discussion in "
"attached [appendix](#associated-items-digression).)"
msgstr ""

#: src/1422-pub-restricted.md:407
msgid ""
"However, since this RFC is introducing multiple kinds of `pub`, we should "
"address the topic of what _is_ the `pub`\\-ness of associated items."
msgstr ""

#: src/1422-pub-restricted.md:411
msgid ""
"When analyzing a trait definition, then associated items should be "
"considered to inherit the `pub`\\-ness, if any, of their defining trait."
msgstr ""

#: src/1422-pub-restricted.md:415
msgid "We want to make sure that this code continues to work:"
msgstr ""

#: src/1422-pub-restricted.md:421
msgid "// referencing `S` is ok, b/c `Trait` is not `pub`\n"
msgstr ""

#: src/1422-pub-restricted.md:426
msgid "And under this RFC, we now allow this as well:"
msgstr ""

#: src/1422-pub-restricted.md:434
msgid "// referencing `::a::S` is ok, b/c `Trait` is restricted to `::a`\n"
msgstr ""

#: src/1422-pub-restricted.md:441
msgid ""
"Note that in stable Rust today, it is an error to declare the latter trait "
"within `mod b` as non-`pub` (since the `use self::b::Trait` would be "
"referencing a private item), _and_ in the Rust nightly channel it is a "
"warning to declare it as `pub trait Trait { ... }`."
msgstr ""

#: src/1422-pub-restricted.md:447
msgid ""
"The point of this RFC is to give users a sensible way to declare such traits "
"within `b`, without allowing them to be exposed outside of `a`."
msgstr ""

#: src/1422-pub-restricted.md:451
msgid ""
"When analyzing an `impl Trait for Type`, there may be distinct restrictions "
"assigned to the `Trait` and the `Type`. However, since both the `Trait` and "
"the `Type` must be visible in the context of the module where the `impl` "
"occurs, there should be a subtree relationship between the two restrictions; "
"in other words, one restriction should be less than (or equal to) the other."
msgstr ""

#: src/1422-pub-restricted.md:458
msgid ""
"So just use the minimum of the two restrictions when analyzing the right-"
"hand sides of the associated items in the impl."
msgstr ""

#: src/1422-pub-restricted.md:461
msgid ""
"Note: I am largely adopting this rule in an attempt to be consistent with "
"[RFC 136](https://github.com/rust-lang/rfcs/blob/master/text/0136-no-"
"privates-in-public.md#when-is-an-item-public). I invite discussion of "
"whether this rule actually makes sense as phrased here."
msgstr ""

#: src/1422-pub-restricted.md:466
msgid "More examples!"
msgstr ""

#: src/1422-pub-restricted.md:469
msgid ""
"These examples meant to explore the syntax a bit. They are _not_ meant to "
"provide motivation for the feature (i.e. I am not claiming that the feature "
"is making this code cleaner or easier to reason about)."
msgstr ""

#: src/1422-pub-restricted.md:473
msgid "Impl item example"
msgstr ""

#: src/1422-pub-restricted.md:484
msgid "\"inside some_method_private_to_b\""
msgstr ""

#: src/1422-pub-restricted.md:490
msgid "\"only callable within `a`: {}\""
msgstr ""

#: src/1422-pub-restricted.md:497
msgid "//~ ERROR: `S::foo` not visible outside of module `a`\n"
msgstr ""

#: src/1422-pub-restricted.md:501
msgid ""
"(You may be wondering: \"Could we move that `impl S` out to the top-level, "
"out of `mod a`?\" Well ... see discussion in the [unresolved questions](#can-"
"definition-site-fall-outside-restriction).)"
msgstr ""

#: src/1422-pub-restricted.md:505
msgid "Restricting fields example"
msgstr ""

#: src/1422-pub-restricted.md:526
msgid ""
"// ... accesses to F.{x,y,z} ...\n"
"        // ... accesses to G.{0,1,2} ...\n"
msgstr ""

#: src/1422-pub-restricted.md:529
msgid ""
"// ... accesses to F.{x,z} ...\n"
"    // ... accesses to G.{0,2} ...\n"
msgstr ""

#: src/1422-pub-restricted.md:535
msgid ""
"// ... accesses to F and F.x ...\n"
"    // ... accesses to G and G.0 ...\n"
msgstr ""

#: src/1422-pub-restricted.md:541
msgid "Fields and inherent methods more public than self"
msgstr ""

#: src/1422-pub-restricted.md:544
msgid "In Rust today, one can write"
msgstr ""

#: src/1422-pub-restricted.md:550
msgid ""
"This RFC was crafted to say that fields and inherent methods can have an "
"associated restriction that is larger than the restriction of its `self`. "
"This was both to keep from breaking the above code, and also because it "
"would be annoying to be forced to write:"
msgstr ""

#: src/1422-pub-restricted.md:559
msgid ""
"(This RFC is not an attempt to resolve things like [Rust Issue 30079]"
"(https://github.com/rust-lang/rust/issues/30079); the decision of how to "
"handle that issue can be dealt with orthogonally, in my opinion.)"
msgstr ""

#: src/1422-pub-restricted.md:566
msgid "So, under this RFC, the following is legal:"
msgstr ""

#: src/1422-pub-restricted.md:579
msgid "\"X.y is now: {}\""
msgstr ""

#: src/1422-pub-restricted.md:591
msgid "In particular:"
msgstr ""

#: src/1422-pub-restricted.md:593
msgid ""
"It is okay that the fields `y` and `z` and the inherent method `fn "
"callanywhere` are more publicly visible than `X`."
msgstr ""

#: src/1422-pub-restricted.md:596
msgid ""
"(Just because we declare something `pub` does not mean it will actually be "
"_possible_ to reach it from arbitrary contexts. Whether or not such access "
"is possible will depend on many things, including but not limited to the "
"restriction attached and also future decisions about issues like [issue "
"30079](https://github.com/rust-lang/rust/issues/30079).)"
msgstr ""

#: src/1422-pub-restricted.md:602
msgid ""
"We are allowed to restrict an inherent method, `fn only_in_c`, to a subtree "
"of the module tree where `X` is itself visible."
msgstr ""

#: src/1422-pub-restricted.md:605
msgid "Re-exports"
msgstr ""

#: src/1422-pub-restricted.md:607
msgid ""
"Here is an example of a `pub use` re-export using the new feature, including "
"both correct and invalid uses of the extended form."
msgstr ""

#: src/1422-pub-restricted.md:613
msgid "// restricted to `mod a` tree\n"
msgstr ""

#: src/1422-pub-restricted.md:616
msgid "// ok: a::b::c is submodule of `a`\n"
msgstr ""

#: src/1422-pub-restricted.md:619
msgid "// ok: `P` accessible here\n"
msgstr ""

#: src/1422-pub-restricted.md:624
msgid "//~ ERROR: `c::d::P` not visible outside `a::b::c`\n"
msgstr ""

#: src/1422-pub-restricted.md:629
msgid "//~ ERROR: `X` cannot be reexported outside of `a`\n"
msgstr ""

#: src/1422-pub-restricted.md:633
msgid "// ok: `X` accessible from `mod a`.\n"
msgstr ""

#: src/1422-pub-restricted.md:639
msgid "Crate restricted visibility"
msgstr ""

#: src/1422-pub-restricted.md:641
msgid ""
"This is a concrete illusration of how one might use the `pub(crate) item` "
"form, (which is perhaps quite similar to Java's default \"package "
"visibility\")."
msgstr ""

#: src/1422-pub-restricted.md:644
msgid "Crate `c1`:"
msgstr ""

#: src/1422-pub-restricted.md:650
msgid "// ok: field allowed to be more public\n"
msgstr ""

#: src/1422-pub-restricted.md:653
msgid "//~ ERROR: `R` restricted solely to this crate\n"
msgstr ""

#: src/1422-pub-restricted.md:655
msgid "// ok: restricted to crate\n"
msgstr ""

#: src/1422-pub-restricted.md:658
msgid "// ok: `a::R` and `a::S` are both visible\n"
msgstr ""

#: src/1422-pub-restricted.md:660
msgid "//~ ERROR: `a::R` restricted solely to this crate\n"
msgstr ""

#: src/1422-pub-restricted.md:663
msgid "Crate `c2`:"
msgstr ""

#: src/1422-pub-restricted.md:668
msgid "// ok: `S` is unrestricted\n"
msgstr ""

#: src/1422-pub-restricted.md:670
msgid "//~ ERROR: `c1::a::R` not visible outside of its crate\n"
msgstr ""

#: src/1422-pub-restricted.md:673
msgid "Precedent"
msgstr ""

#: src/1422-pub-restricted.md:675
msgid ""
"When I started on this I was not sure if this form of delimited access to a "
"particular module subtree had a precedent; the closest thing I could think "
"of was C++ `friend` modifiers (but `friend` is far more ad-hoc and free-form "
"than what is being proposed here)."
msgstr ""

#: src/1422-pub-restricted.md:680
msgid "Scala"
msgstr ""

#: src/1422-pub-restricted.md:682
msgid ""
"It has since been pointed out to me that Scala has scoped access modifiers "
"`protected[Y]` and `private[Y]`, which specify that access is provided upto "
"`Y` (where `Y` can be a package, class or singleton object)."
msgstr ""

#: src/1422-pub-restricted.md:687
msgid ""
"The feature proposed by this RFC appears to be similar in intent to Scala's "
"scoped access modifiers."
msgstr ""

#: src/1422-pub-restricted.md:690
msgid ""
"Having said that, I will admit that I am not clear on what distinction, if "
"any, Scala draws between `protected[Y]` and `private[Y]` when `Y` is a "
"package, which is the main analogy for our purposes, or if they just allow "
"both forms as synonyms for convenience."
msgstr ""

#: src/1422-pub-restricted.md:696
msgid ""
"(I can imagine a hypothetical distinction in Scala when `Y` is a class, but "
"my skimming online has not provided insight as to what the actual "
"distinction is.)"
msgstr ""

#: src/1422-pub-restricted.md:700
msgid ""
"Even if there is some distinction drawn between the two forms in Scala, I "
"suspect Rust does not need an analogous distinction in it's `pub(restricted)`"
msgstr ""

#: src/1422-pub-restricted.md:704
msgid "Drawbacks"
msgstr ""

#: src/1422-pub-restricted.md:707
msgid ""
"Obviously, `pub(restriction) item` complicates the surface syntax of the "
"language."
msgstr ""

#: src/1422-pub-restricted.md:710
msgid ""
"However, my counter-argument to this drawback is that this feature in fact "
"_simplifies_ the developer's mental model. It is easier to directly encode "
"the expected visibility of an item via `pub(restriction)` than to figure out "
"the right concoction via a mix of nested `mod` and `pub use` statements. And "
"likewise, it is easier to read it too."
msgstr ""

#: src/1422-pub-restricted.md:717
msgid ""
"Developers may misuse this form and make it hard to access the tasty innards "
"of other modules."
msgstr ""

#: src/1422-pub-restricted.md:720
msgid "This is true, but I claim it is irrelevant."
msgstr ""

#: src/1422-pub-restricted.md:722
msgid ""
"The effect of this change is solely on the visibility of items _within_ a "
"crate. No rules for inter-crate access change."
msgstr ""

#: src/1422-pub-restricted.md:725
msgid ""
"From the perspective of cross-crate development, this RFC changes nothing, "
"except that it may lead some crate authors to make some things no longer "
"universally `pub` that they were forced to make visible before due to "
"earlier limitations. I claim that in such cases, those crate authors "
"probably always intended for such items to be non-`pub`, but language "
"limitations were forcing their hand."
msgstr ""

#: src/1422-pub-restricted.md:732
msgid ""
"As for intra-crate access: My expectation is that an individual crate will "
"be made by a team of developers who can work out what mutual visibility they "
"want and how it should evolve over time. This feature may affect their work "
"flow to some degree, but they can choose to either use it or not, based on "
"their own internal policies."
msgstr ""

#: src/1422-pub-restricted.md:740
msgid "Alternatives"
msgstr ""

#: src/1422-pub-restricted.md:743
msgid "Do not extend the language!"
msgstr ""

#: src/1422-pub-restricted.md:745
msgid ""
"Change privacy rules and make privacy analysis \"smarter\" (e.g. global "
"reachabiliy analysis)"
msgstr ""

#: src/1422-pub-restricted.md:748
msgid ""
"The main problem with this approach is that we tried it, and it did not work "
"well: The implementation was buggy, and the user-visible error messages were "
"hard to understand."
msgstr ""

#: src/1422-pub-restricted.md:752
msgid ""
"See discussion when the team was discussing the [public items amendment]"
"(https://github.com/rust-lang/meeting-minutes/blob/master/weekly-"
"meetings/2014-09-16.md#rfc-public-items)"
msgstr ""

#: src/1422-pub-restricted.md:756
msgid ""
"\"Fix\" the mental model of privacy (if necessary) without extending the "
"language."
msgstr ""

#: src/1422-pub-restricted.md:759
msgid ""
"The alternative is basically saying: \"Our existing system is fine; all of "
"the problems with it are due to bugs in the implementation\""
msgstr ""

#: src/1422-pub-restricted.md:762
msgid ""
"I am sympathetic to this response. However, I think it doesn't quite hold "
"up. Some users want to be able to define items that are exposed outside of "
"their module but still restrict the scope of where they can be referenced, "
"as discussed in the [motivation](#motivation) section, and I do not think "
"the current model can be \"fixed\" to support that use case, at least not "
"without adding some sort of global reachability analysis as discussed in the "
"previous bullet."
msgstr ""

#: src/1422-pub-restricted.md:770
msgid ""
"In addition, these two alternatives do not address the main point being made "
"in the [motivation](#motivation) section: one cannot tell exactly how "
"\"public\" a `pub` item is, without working backwards through the module "
"tree for all of its re-exports."
msgstr ""

#: src/1422-pub-restricted.md:775
msgid "Curb your ambitions!"
msgstr ""

#: src/1422-pub-restricted.md:777
msgid ""
"Instead of adding support for restricting to arbitrary module subtrees, "
"narrow the feature to just `pub(crate) item`, so that one chooses either "
"\"module private\" (by adding no modifier), or \"universally visible\" (by "
"adding `pub`), or \"visible to just the current crate\" (by adding "
"`pub(crate)`)."
msgstr ""

#: src/1422-pub-restricted.md:783
msgid ""
"This would be somewhat analogous to Java's relatively coarse grained privacy "
"rules, where one can choose `public`, `private`, `protected`, or the unnamed "
"\"package\" visibility."
msgstr ""

#: src/1422-pub-restricted.md:787
msgid ""
"I am all for keeping the implementation simple. However, the reason that we "
"should support arbitrary module subtrees is that doing so will enable "
"certain refactorings. Namely, if I decide I want to inline the definition "
"for one or more crates `A1`, `A2`, ... into client crate `C` (i.e. replacing "
"`extern crate A1;` with an suitably defined `mod A1 { ... }`, but I do not "
"want to worry about whether doing so will risk future changes violating "
"abstraction boundaries that were previously being enforced via `pub(crate)`, "
"then I believe allowing `pub(path)` will allow a mechanical tool to do the "
"inline refactoring, rewriting each `pub(crate)` as `pub(A1)` as necessary."
msgstr ""

#: src/1422-pub-restricted.md:799
msgid "Be more ambitious!"
msgstr ""

#: src/1422-pub-restricted.md:801
msgid "This feature could be extended in various ways."
msgstr ""

#: src/1422-pub-restricted.md:803
msgid "For example:"
msgstr ""

#: src/1422-pub-restricted.md:805
msgid ""
"As mentioned on the RFC comment thread, we could allow multiple paths in the "
"restriction-specification: `pub(path1, path2, path3)`."
msgstr ""

#: src/1422-pub-restricted.md:809
msgid ""
"This, for better or worse, would start to look a lot like `friend` "
"declarations from C++."
msgstr ""

#: src/1422-pub-restricted.md:812
msgid ""
"Also as mentioned on the RFC comment thread, the `pub(restricted)` form does "
"not have any variant where the restrction-specification denotes the whole "
"universe. In other words, there's no current way to get the same effect as "
"`pub item` via `pub(restricted) item`; you cannot say `pub(universe) item` "
"(even though I do so in a tongue-in-cheek manner elsewhere in this RFC)."
msgstr ""

#: src/1422-pub-restricted.md:820
msgid ""
"Some future syntaxes to support this have been proposed in the RFC comment "
"thread, such as `pub(::)`. But this RFC is leaving the actual choice to add "
"such an extension (and what syntax to use for it) up to a later amendment in "
"the future."
msgstr ""

#: src/1422-pub-restricted.md:825
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/1422-pub-restricted.md:828
msgid "Can definition site fall outside restriction?"
msgstr ""

#: src/1422-pub-restricted.md:831
msgid "For example, is it illegal to do the following:"
msgstr ""

#: src/1422-pub-restricted.md:840
msgid ""
"Or does it just mean that `J`, despite being defined in `mod b`, is itself "
"not accessible in `mod b`?"
msgstr ""

#: src/1422-pub-restricted.md:843
msgid ""
"pnkfelix is personally inclined to make this sort of thing illegal, mainly "
"because he finds it totally unintuitive, but is interested in hearing "
"counter-arguments."
msgstr ""

#: src/1422-pub-restricted.md:847
msgid "Implicit Restriction Satisfaction (IRS:PUNPM)"
msgstr ""

#: src/1422-pub-restricted.md:849
msgid ""
"If a re-export occurs within a non-`pub` module, can we treat it as "
"implicitly satisfying a restriction to `super` imposed by the item it is re-"
"exporting?"
msgstr ""

#: src/1422-pub-restricted.md:853
msgid "In particular, the [revised example](#revised-example) included:"
msgstr ""

#: src/1422-pub-restricted.md:856
msgid "// Intent: `a` exports `I` and `foo`, but nothing else.\n"
msgstr ""

#: src/1422-pub-restricted.md:866
msgid ""
"However, since `b` is non-`pub`, its `pub` items and re-exports are solely "
"accessible via the subhierarchy of its module parent (i.e., `mod a`, as long "
"as no entity attempts to re-export them to a broader scope."
msgstr ""

#: src/1422-pub-restricted.md:871
msgid ""
"In other words, in some sense `mod b { pub use item; }` _could_ implicitly "
"satisfy a restriction to `super` imposed by `item` (if we chose to allow it)."
msgstr ""

#: src/1422-pub-restricted.md:875
msgid ""
"Note: If it were `pub mod b` or `pub(restrict) mod b`, then the above "
"reasoning would not hold.  Therefore, this discussion is limited to re-"
"exports from non-`pub` modules."
msgstr ""

#: src/1422-pub-restricted.md:879
msgid ""
"If we do not allow such implicit restriction satisfaction for `pub use` re-"
"exports from non-`pub` modules (IRS:PUNPM), then:"
msgstr ""

#: src/1422-pub-restricted.md:892
msgid "would be rejected, and one would be expected to write either:"
msgstr ""

#: src/1422-pub-restricted.md:898
msgid "or"
msgstr ""

#: src/1422-pub-restricted.md:905
msgid ""
"(Side note: I am _not_ saying that under IRS:PUNPM, the two forms `pub use "
"item` and `pub(super) use item` would be considered synonymous, even in the "
"context of a non-pub module like `mod b`. In particular, `pub(super) use "
"item` may be imposing a new restriction on the re-exported name that was not "
"part of its original definition.)"
msgstr ""

#: src/1422-pub-restricted.md:911
msgid "Interaction with Globs"
msgstr ""

#: src/1422-pub-restricted.md:913
msgid ""
"Glob re-exports currently only re-export `pub` (as in `pub(universe)` items)."
msgstr ""

#: src/1422-pub-restricted.md:916
msgid "What should glob-reepxorts do with respect to `pub(restricted)`?"
msgstr ""

#: src/1422-pub-restricted.md:918
msgid ""
"Here is an illustrating example pointed out by petrochenkov in the comment "
"thread:"
msgstr ""

#: src/1422-pub-restricted.md:923
msgid "/*priv*/"
msgstr ""

#: src/1422-pub-restricted.md:930
msgid ""
"// What is reexported here?\n"
"        // Just `S4`?\n"
"        // Anything in `m` visible\n"
"        //  to `n` (which is not consistent with the current treatment of\n"
msgstr ""

#: src/1422-pub-restricted.md:939
msgid "// What is reexported here?\n"
msgstr ""

#: src/1422-pub-restricted.md:945
msgid ""
"This remains an unresolved question, but my personal inclination, at least "
"for the initial implementation, is to make globs only import purely `pub` "
"items; no non-`pub`, and no `pub(restricted)`."
msgstr ""

#: src/1422-pub-restricted.md:949
msgid ""
"After we get more experience with `pub(restricted)` (and perhaps make other "
"changes that may come in future RFCs), we will be in a better position to "
"evaluate what to do here."
msgstr ""

#: src/1422-pub-restricted.md:954
msgid "Appendices"
msgstr ""

#: src/1422-pub-restricted.md:956
msgid "Associated Items Digression"
msgstr ""

#: src/1422-pub-restricted.md:959
msgid ""
"If associated items were implicitly `pub`, in the sense that they are "
"unrestricted, then that would conflict with the rules imposed by this RFC, "
"in the sense that the surface API of a non-`pub` trait is composed of its "
"associated items, and so if all associated items were implicitly `pub` and "
"unrestricted, then this code would be rejected:"
msgstr ""

#: src/1422-pub-restricted.md:969
msgid "// is this implicitly `pub` and unrestricted?\n"
msgstr ""

#: src/1422-pub-restricted.md:971
msgid "\"():()\""
msgstr ""

#: src/1422-pub-restricted.md:972
msgid "\"{}:i32\""
msgstr ""

#: src/1422-pub-restricted.md:973
msgid "\"silly{}{}\""
msgstr ""

#: src/1422-pub-restricted.md:977
msgid ""
"If associated items were implicitly `pub` and unrestricted, then the above "
"code would be rejected under direct interpretation of the rules of this RFC "
"(because `fn make_s` is implicitly unrestricted, but the surface of `fn "
"make_s` references `S`, a non-`pub` item). This would be backwards-"
"incompatible (and just darn inconvenient too)."
msgstr ""

#: src/1422-pub-restricted.md:983
msgid ""
"So, to be clear, this RFC is _not_ suggesting that associated items be "
"implicitly `pub` and unrestricted."
msgstr ""
