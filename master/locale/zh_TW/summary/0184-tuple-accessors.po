msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0184-tuple-accessors.md:1
msgid "Start Date: 2014-07-24"
msgstr ""

#: src/0184-tuple-accessors.md:2
msgid "RFC PR #: https://github.com/rust-lang/rfcs/pull/184"
msgstr ""

#: src/0184-tuple-accessors.md:3
msgid "Rust Issue #: https://github.com/rust-lang/rust/issues/16950"
msgstr ""

#: src/0184-tuple-accessors.md:5
msgid "Summary"
msgstr ""

#: src/0184-tuple-accessors.md:7
msgid ""
"Add simple syntax for accessing values within tuples and tuple structs "
"behind a feature gate."
msgstr ""

#: src/0184-tuple-accessors.md:10
msgid "Motivation"
msgstr ""

#: src/0184-tuple-accessors.md:12
msgid ""
"Right now accessing fields of tuples and tuple structs is incredibly painful—"
"one must rely on pattern-matching alone to extract values. This became such "
"a problem that twelve traits were created in the standard library (`core::"
"tuple::Tuple*`) to make tuple value accesses easier, adding `.valN()`, `."
"refN()`, and `.mutN()` methods to help this. But this is not a very nice "
"solution—it requires the traits to be implemented in the standard library, "
"not the language, and for those traits to be imported on use. On the whole "
"this is not a problem, because most of the time `std::prelude::*` is "
"imported, but this is still a hack which is not a real solution to the "
"problem at hand. It also only supports tuples of length up to twelve, which "
"is normally not a problem but emphasises how bad the current situation is."
msgstr ""

#: src/0184-tuple-accessors.md:24
msgid "Detailed design"
msgstr ""

#: src/0184-tuple-accessors.md:26
msgid ""
"Add syntax of the form `<expr>.<integer>` for accessing values within tuples "
"and tuple structs. This (and the functionality it provides) would only be "
"allowed when the feature gate `tuple_indexing` is enabled. This syntax is "
"recognised wherever an unsuffixed integer literal is found in place of the "
"normal field or method name expected when accessing fields with `.`. Because "
"the parser would be expecting an integer, not a float, an expression like "
"`expr.0.1` would be a syntax error (because `0.1` would be treated as a "
"single token)."
msgstr ""

#: src/0184-tuple-accessors.md:34
msgid ""
"Tuple/tuple struct field access behaves the same way as accessing named "
"fields on normal structs:"
msgstr ""

#: src/0184-tuple-accessors.md:38
msgid "// With tuple struct\n"
msgstr ""

#: src/0184-tuple-accessors.md:43
msgid "// With normal struct\n"
msgstr ""

#: src/0184-tuple-accessors.md:51
msgid ""
"Effectively, a tuple or tuple struct field is just a normal named field with "
"an integer for a name."
msgstr ""

#: src/0184-tuple-accessors.md:54
msgid "Drawbacks"
msgstr ""

#: src/0184-tuple-accessors.md:56
msgid "This adds more complexity that is not strictly necessary."
msgstr ""

#: src/0184-tuple-accessors.md:58
msgid "Alternatives"
msgstr ""

#: src/0184-tuple-accessors.md:60
msgid ""
"Stay with the status quo. Either recommend using a struct with named fields "
"or suggest using pattern-matching to extract values. If extracting "
"individual fields of tuples is really necessary, the `TupleN` traits could "
"be used instead, and something like `#[deriving(Tuple3)]` could possibly be "
"added for tuple structs."
msgstr ""

#: src/0184-tuple-accessors.md:66
msgid "Unresolved questions"
msgstr ""

#: src/0184-tuple-accessors.md:68
msgid "None."
msgstr ""
