msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:03Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1560-name-resolution.md:1
msgid "Feature Name: item_like_imports"
msgstr ""

#: src/1560-name-resolution.md:2
msgid "Start Date: 2016-02-09"
msgstr ""

#: src/1560-name-resolution.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1560](https://github.com/rust-lang/rfcs/pull/1560)"
msgstr ""

#: src/1560-name-resolution.md:4
msgid ""
"Rust Issue: [rust-lang/rust#35120](https://github.com/rust-lang/rust/"
"issues/35120)"
msgstr ""

#: src/1560-name-resolution.md:6
msgid "Summary"
msgstr ""

#: src/1560-name-resolution.md:9
msgid "Some internal and language-level changes to name resolution."
msgstr ""

#: src/1560-name-resolution.md:11
msgid ""
"Internally, name resolution will be split into two parts - import resolution "
"and name lookup. Import resolution is moved forward in time to happen in the "
"same phase as parsing and macro expansion. Name lookup remains where name "
"resolution currently takes place (that may change in the future, but is "
"outside the scope of this RFC). However, name lookup can be done earlier if "
"required (importantly it can be done during macro expansion to allow using "
"the module system for macros, also outside the scope of this RFC). Import "
"resolution will use a new algorithm."
msgstr ""

#: src/1560-name-resolution.md:20
msgid ""
"The observable effects of this RFC (i.e., language changes) are some "
"increased flexibility in the name resolution rules, especially around globs "
"and shadowing."
msgstr ""

#: src/1560-name-resolution.md:23
msgid ""
"There is an implementation of the language changes in [PR #32213](https://"
"github.com/rust-lang/rust/pull/32213)."
msgstr ""

#: src/1560-name-resolution.md:26
msgid "Motivation"
msgstr ""

#: src/1560-name-resolution.md:29
msgid ""
"Naming and importing macros currently works very differently to naming and "
"importing any other item. It would be impossible to use the same rules, "
"since macro expansion happens before name resolution in the compilation "
"process. Implementing this RFC means that macro expansion and name "
"resolution can happen in the same phase, thus allowing macros to use the "
"Rust module system properly."
msgstr ""

#: src/1560-name-resolution.md:35
msgid ""
"At the same time, we should be able to accept more Rust programs by tweaking "
"the current rules around imports and name shadowing. This should make "
"programming using imports easier."
msgstr ""

#: src/1560-name-resolution.md:40
msgid "Some issues in Rust's name resolution"
msgstr ""

#: src/1560-name-resolution.md:42
msgid ""
"Whilst name resolution is sometimes considered a simple part of the "
"compiler, there are some details in Rust which make it tricky to properly "
"specify and implement. Some of these may seem obvious, but the distinctions "
"will be important later."
msgstr ""

#: src/1560-name-resolution.md:47
msgid ""
"Imported vs declared names - a name can be imported (e.g., `use foo;`) or "
"declared (e.g., `fn foo ...`)."
msgstr ""

#: src/1560-name-resolution.md:49
msgid ""
"Single vs glob imports - a name can be explicitly (e.g., `use a::foo;`) or "
"implicitly imported (e.g., `use a::*;` where `foo` is declared in `a`)."
msgstr ""

#: src/1560-name-resolution.md:51
msgid ""
"Public vs private names - the visibility of names is somewhat tied up with "
"name resolution, for example in current Rust `use a::*;` only imports the "
"public names from `a`."
msgstr ""

#: src/1560-name-resolution.md:54
msgid ""
"Lexical scoping - a name can be inherited from a surrounding scope, rather "
"than being declared in the current one, e.g., `let foo = ...; { foo(); }`."
msgstr ""

#: src/1560-name-resolution.md:56
msgid ""
"There are different kinds of scopes - at the item level, names are not "
"inherited from outer modules into inner modules. Items may also be declared "
"inside functions and blocks within functions, with different rules from "
"modules. At the expression level, blocks (`{...}`) give explicit scope, "
"however, from the point of view of macro hygiene and region inference, each "
"`let` statement starts a new implicit scope."
msgstr ""

#: src/1560-name-resolution.md:62
msgid ""
"Explicitly declared vs macro generated names - a name can be declared "
"explicitly in the source text, or could be declared as the result of "
"expanding a macro."
msgstr ""

#: src/1560-name-resolution.md:65
msgid ""
"Rust has multiple namespaces - types, values, and macros exist in separate "
"namespaces (some items produce names in multiple namespaces). Imports refer "
"(implicitly) to one or more names in different namespaces."
msgstr ""

#: src/1560-name-resolution.md:69
msgid ""
"Note that all top-level (i.e., not parameters, etc.) path segments in a path "
"other than the last must be in the type namespace, e.g., in `a::b::c`, `a` "
"and `b` are assumed to be in the type namespace, and `c` may be in any "
"namespace."
msgstr ""

#: src/1560-name-resolution.md:72
msgid ""
"Rust has an implicit prelude - the prelude defines a set of names which are "
"always (unless explicitly opted-out) nameable. The prelude includes macros. "
"Names in the prelude can be shadowed by any other names."
msgstr ""

#: src/1560-name-resolution.md:77
msgid "Detailed design"
msgstr ""

#: src/1560-name-resolution.md:80
msgid "Guiding principles"
msgstr ""

#: src/1560-name-resolution.md:82
msgid ""
"We would like the following principles to hold. There may be edge cases "
"where they do not, but we would like these to be as small as possible (and "
"prefer they don't exist at all)."
msgstr ""

#: src/1560-name-resolution.md:86
msgid ""
"Avoid 'time-travel' ambiguities, or different results of resolution if names"
msgstr ""

#: src/1560-name-resolution.md:87
msgid "are resolved in different orders."
msgstr ""

#: src/1560-name-resolution.md:89
msgid ""
"Due to macro expansion, it is possible for a name to be resolved and then to "
"become ambiguous, or (with rules formulated in a certain way) for a name to "
"be resolved, then to be ambiguous, then to be resolvable again (possibly to "
"different bindings)."
msgstr ""

#: src/1560-name-resolution.md:94
msgid ""
"Furthermore, there is some flexibility in the order in which macros can be "
"expanded. How a name resolves should be consistent under any ordering."
msgstr ""

#: src/1560-name-resolution.md:97
msgid ""
"The strongest form of this principle, I believe, is that at any stage of "
"macro expansion, and under any ordering of expansions, if a name resolves to "
"a binding then it should always (i.e., at any other stage of any other "
"expansion series) resolve to that binding, and if resolving a name produces "
"an error (n.b., distinct from not being able to resolve), it should always "
"produce an error."
msgstr ""

#: src/1560-name-resolution.md:105
msgid "Avoid errors due to the resolver being stuck."
msgstr ""

#: src/1560-name-resolution.md:107
msgid ""
"Errors with concrete causes and explanations are easier for the user to "
"understand and to correct. If an error is caused by name resolution getting "
"stuck, rather than by a concrete problem, this is hard to explain or correct."
msgstr ""

#: src/1560-name-resolution.md:111
msgid ""
"For example, if we support a rule that means that a certain glob can't be "
"expanded before a macro is, but the macro can only be named via that glob "
"import, then there is an obvious resolution that can't be reached due to our "
"ordering constraints."
msgstr ""

#: src/1560-name-resolution.md:117
msgid "The order of declarations of items should be irrelevant."
msgstr ""

#: src/1560-name-resolution.md:119
msgid ""
"I.e., names should be able to be used before they are declared. Note that "
"this clearly does not hold for declarations of variables in statements "
"inside function bodies."
msgstr ""

#: src/1560-name-resolution.md:124
msgid "Macros should be manually expandable."
msgstr ""

#: src/1560-name-resolution.md:126
msgid ""
"Compiling a program should have the same result before and after expanding a "
"macro 'by hand', so long as hygiene is accounted for."
msgstr ""

#: src/1560-name-resolution.md:130
msgid "Glob imports should be manually expandable."
msgstr ""

#: src/1560-name-resolution.md:132
msgid ""
"A programmer should be able to replace a glob import with a list import that "
"imports any names imported by the glob and used in the current scope, "
"without changing name resolution behaviour."
msgstr ""

#: src/1560-name-resolution.md:137
msgid "Visibility should not affect name resolution."
msgstr ""

#: src/1560-name-resolution.md:139
msgid ""
"Clearly, visibility affects whether a name can be used or not. However, it "
"should not affect the mechanics of name resolution. I.e., changing a name "
"from public to private (or vice versa), should not cause more or fewer name "
"resolution errors (it may of course cause more or fewer accessibility "
"errors)."
msgstr ""

#: src/1560-name-resolution.md:145
msgid "Changes to name resolution rules"
msgstr ""

#: src/1560-name-resolution.md:147
msgid "Multiple unused imports"
msgstr ""

#: src/1560-name-resolution.md:149
msgid ""
"A name may be imported multiple times, it is only a name resolution error if "
"that name is used. E.g.,"
msgstr ""

#: src/1560-name-resolution.md:152
msgid ""
"```\n"
"mod foo {\n"
"    pub struct Qux;\n"
"}\n"
"\n"
"mod bar {\n"
"    pub struct Qux;\n"
"}\n"
"\n"
"mod baz {\n"
"    use foo::*;\n"
"    use bar::*; // Ok, no name conflict.\n"
"}\n"
"```"
msgstr ""

#: src/1560-name-resolution.md:167
msgid ""
"In this example, adding a use of `Qux` in `baz` would cause a name "
"resolution error."
msgstr ""

#: src/1560-name-resolution.md:170
msgid "Multiple imports of the same binding"
msgstr ""

#: src/1560-name-resolution.md:172
msgid ""
"A name may be imported multiple times and used if both names bind to the "
"same item. E.g.,"
msgstr ""

#: src/1560-name-resolution.md:192
msgid "non-public imports"
msgstr ""

#: src/1560-name-resolution.md:194
msgid ""
"Currently `use` and `pub use` items are treated differently. Non-public "
"imports will be treated in the same way as public imports, so they may be "
"referenced from modules which have access to them. E.g.,"
msgstr ""

#: src/1560-name-resolution.md:198
msgid ""
"```\n"
"mod foo {\n"
"    pub struct Qux;\n"
"}\n"
"\n"
"mod bar {\n"
"    use foo::Qux;\n"
"\n"
"    mod baz {\n"
"        use bar::Qux; // Ok\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/1560-name-resolution.md:213
msgid "Glob imports of accessible but not public names"
msgstr ""

#: src/1560-name-resolution.md:215
msgid ""
"Glob imports will import all accessible names, not just public ones. E.g.,"
msgstr ""

#: src/1560-name-resolution.md:217
msgid ""
"```\n"
"struct Qux;\n"
"\n"
"mod foo {\n"
"    use super::*;\n"
"\n"
"    fn f(q: Qux) {} // Ok\n"
"}\n"
"```"
msgstr ""

#: src/1560-name-resolution.md:227
msgid ""
"This change is backwards incompatible. However, the second rule above should "
"address most cases, e.g.,"
msgstr ""

#: src/1560-name-resolution.md:230
msgid ""
"```\n"
"struct Qux;\n"
"\n"
"mod foo {\n"
"    use super::*;\n"
"    use super::Qux; // Legal due to the second rule above.\n"
"\n"
"    fn f(q: Qux) {} // Ok\n"
"}\n"
"```"
msgstr ""

#: src/1560-name-resolution.md:241
msgid ""
"The below rule (though more controversial) should make this change entirely "
"backwards compatible."
msgstr ""

#: src/1560-name-resolution.md:244
msgid ""
"Note that in combination with the above rule, this means non-public imports "
"are imported by globs where they are private but accessible."
msgstr ""

#: src/1560-name-resolution.md:248
msgid "Explicit names may shadow implicit names"
msgstr ""

#: src/1560-name-resolution.md:250
msgid ""
"Here, an implicit name means a name imported via a glob or inherited from an "
"outer scope (as opposed to being declared or imported directly in an inner "
"scope)."
msgstr ""

#: src/1560-name-resolution.md:253
msgid ""
"An explicit name may shadow an implicit name without causing a name "
"resolution error. E.g.,"
msgstr ""

#: src/1560-name-resolution.md:256
msgid ""
"```\n"
"mod foo {\n"
"    pub struct Qux;\n"
"}\n"
"\n"
"mod bar {\n"
"    pub struct Qux;\n"
"}\n"
"\n"
"mod baz {\n"
"    use foo::*;\n"
"\n"
"    struct Qux; // Shadows foo::Qux.\n"
"}\n"
"\n"
"mod boz {\n"
"    use foo::*;\n"
"    use bar::Qux; // Shadows foo::Qux; note, ordering is not important.\n"
"}\n"
"```"
msgstr ""

#: src/1560-name-resolution.md:277
msgid "or"
msgstr ""

#: src/1560-name-resolution.md:279
msgid ""
"```\n"
"fn main() {\n"
"    struct Foo; // 1.\n"
"    {\n"
"        struct Foo; // 2.\n"
"\n"
"        let x = Foo; // Ok and refers to declaration 2.\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/1560-name-resolution.md:290
msgid ""
"Note that shadowing is namespace specific. I believe this is consistent with "
"our general approach to name spaces. E.g.,"
msgstr ""

#: src/1560-name-resolution.md:293
msgid ""
"```\n"
"mod foo {\n"
"    pub struct Qux;\n"
"}\n"
"\n"
"mod bar {\n"
"    pub trait Qux;\n"
"}\n"
"\n"
"mod boz {\n"
"    use foo::*;\n"
"    use bar::Qux; // Shadows only in the type name space.\n"
"\n"
"    fn f(x: &Qux) {   // bound to bar::Qux.\n"
"        let _ = Qux;  // bound to foo::Qux.\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/1560-name-resolution.md:312
msgid ""
"Caveat: an explicit name which is defined by the expansion of a macro does "
"**not** shadow implicit names. Example:"
msgstr ""

#: src/1560-name-resolution.md:315
msgid ""
"```\n"
"macro_rules! foo {\n"
"    () => {\n"
"        fn foo() {}\n"
"    }\n"
"}\n"
"\n"
"mod a {\n"
"    fn foo() {}\n"
"}\n"
"\n"
"mod b {\n"
"    use a::*;\n"
"\n"
"    foo!(); // Expands to `fn foo() {}`, this `foo` does not shadow the "
"`foo`\n"
"            // imported from `a` and therefore there is a duplicate name "
"error.\n"
"}\n"
"```"
msgstr ""

#: src/1560-name-resolution.md:334
msgid ""
"The rationale for this caveat is so that during import resolution, if we "
"have a glob import (or other implicit name) we can be sure that any imported "
"names will not be shadowed, either the name will continue to be valid, or "
"there will be an error. Without this caveat, a name could be valid, and then "
"after further expansion, become shadowed by a higher priority name."
msgstr ""

#: src/1560-name-resolution.md:340
msgid ""
"An error is reported if there is an ambiguity between names due to the lack "
"of shadowing, e.g., (this example assumes modularised macros),"
msgstr ""

#: src/1560-name-resolution.md:343
msgid ""
"```\n"
"macro_rules! foo {\n"
"    () => {\n"
"        macro! bar { ... }\n"
"    }\n"
"}\n"
"\n"
"mod a {\n"
"    macro! bar { ... }\n"
"}\n"
"\n"
"mod b {\n"
"    use a::*;\n"
"\n"
"    foo!(); // Expands to `macro! bar { ... }`.\n"
"\n"
"    bar!(); // ERROR: bar is ambiguous.\n"
"}\n"
"```"
msgstr ""

#: src/1560-name-resolution.md:363
msgid ""
"Note on the caveat: there will only be an error emitted if an ambiguous name "
"is used directly or indirectly in a macro use. I.e., is the name of a macro "
"that is used, or is the name of a module that is used to name a macro either "
"in a macro use or in an import."
msgstr ""

#: src/1560-name-resolution.md:368
msgid ""
"Alternatives: we could emit an error even if the ambiguous name is not used, "
"or as a compromise between these two, we could emit an error if the name is "
"in the type or macro namespace (a name in the value namespace can never "
"cause problems)."
msgstr ""

#: src/1560-name-resolution.md:372
msgid ""
"This change is discussed in [issue 31337](https://github.com/rust-lang/rust/"
"issues/31337) and on this RFC PR's comment thread."
msgstr ""

#: src/1560-name-resolution.md:376
msgid "Re-exports, namespaces, and visibility."
msgstr ""

#: src/1560-name-resolution.md:378
msgid ""
"(This is something of a clarification point, rather than explicitly new "
"behaviour. See also discussion on [issue 31783](https://github.com/rust-lang/"
"rust/issues/31783))."
msgstr ""

#: src/1560-name-resolution.md:381
msgid ""
"An import (`use`) or re-export (`pub use`) imports a name in all available "
"namespaces. E.g., `use a::foo;` will import `foo` in the type and value "
"namespaces if it is declared in those namespaces in `a`."
msgstr ""

#: src/1560-name-resolution.md:385
msgid ""
"For a name to be re-exported, it must be public, e.g, `pub use a::foo;` "
"requires that `foo` is declared publicly in `a`. This is complicated by "
"namespaces. The following behaviour should be followed for a re-export of "
"`foo`:"
msgstr ""

#: src/1560-name-resolution.md:389
msgid ""
"`foo` is private in all namespaces in which it is declared - emit an error."
msgstr ""

#: src/1560-name-resolution.md:390
msgid ""
"`foo` is public in all namespaces in which it is declared - `foo` is re-"
"exported in all namespaces."
msgstr ""

#: src/1560-name-resolution.md:392
msgid ""
"`foo` is mixed public/private - `foo` is re-exported in the namespaces in "
"which it is declared publicly and imported but not re-exported in namespaces "
"in which it is declared privately."
msgstr ""

#: src/1560-name-resolution.md:396
msgid ""
"For a glob re-export, there is an error if there are no public items in any "
"namespace. Otherwise private names are imported and public names are re-"
"exported on a per-namespace basis (i.e., following the above rules)."
msgstr ""

#: src/1560-name-resolution.md:400
msgid "Changes to the implementation"
msgstr ""

#: src/1560-name-resolution.md:402
msgid ""
"Note: below I talk about \"the binding table\", this is sort of hand-waving. "
"I'm envisaging a sets-of-scopes system where there is effectively a single, "
"global binding table. However, the details of that are beyond the scope of "
"this RFC. One can imagine \"the binding table\" means one binding table per "
"scope, as in the current system."
msgstr ""

#: src/1560-name-resolution.md:408
msgid ""
"Currently, parsing and macro expansion happen in the same phase. With this "
"proposal, we add import resolution to that mix too. Binding tables as well "
"as the AST will be produced by libsyntax. Name lookup will continue to be "
"done where name resolution currently takes place."
msgstr ""

#: src/1560-name-resolution.md:413
msgid ""
"To resolve imports, the algorithm proceeds as follows: we start by parsing "
"as much of the program as we can; like today we don't parse macros. When we "
"find items which bind a name, we add the name to the binding table. When we "
"find an import which can't be resolved, we add it to a work list. When we "
"find a glob import, we have to record a 'back link', so that when a public "
"name is added for the supplying module, we can add it for the importing "
"module."
msgstr ""

#: src/1560-name-resolution.md:420
msgid ""
"We then loop over the work list and try to lookup names. If a name has "
"exactly one best binding then we use it (and record the binding on a list of "
"resolved names). If there are zero then we put it back on the work list. If "
"there is more than one binding, then we record an ambiguity error. When we "
"reach a fixed point, i.e., the work list no longer changes, then we are "
"done. If the work list is empty, then expansion/import resolution succeeded, "
"otherwise there are names not found, or ambiguous names, and we failed."
msgstr ""

#: src/1560-name-resolution.md:428
msgid ""
"As we are looking up names, we record the resolutions in the binding table. "
"If the name we are looking up is for a glob import, we add bindings for "
"every accessible name currently known."
msgstr ""

#: src/1560-name-resolution.md:432
msgid ""
"To expand a macro use, we try to resolve the macro's name. If that fails, we "
"put it on the work list. Otherwise, we expand that macro by parsing the "
"arguments, pattern matching, and doing hygienic expansion. We then parse the "
"generated code in the same way as we parsed the original program. We add new "
"names to the binding table, and expand any new macro uses."
msgstr ""

#: src/1560-name-resolution.md:438
msgid ""
"If we add names for a module which has back links, we must follow them and "
"add these names to the importing module (if they are accessible)."
msgstr ""

#: src/1560-name-resolution.md:441
msgid "In pseudo-code:"
msgstr ""

#: src/1560-name-resolution.md:443
msgid ""
"```\n"
"// Assumes parsing is already done, but the two things could be done in the "
"same\n"
"// pass.\n"
"fn parse_expand_and_resolve() {\n"
"    loop until fixed point {\n"
"        process_names()\n"
"        loop until fixed point {\n"
"            process_work_list()\n"
"        }\n"
"        expand_macros()\n"
"    }\n"
"\n"
"    for item in work_list {\n"
"        report_error()\n"
"    } else {\n"
"        success!()\n"
"    }\n"
"}\n"
"\n"
"fn process_names() {\n"
"    // 'module' includes `mod`s, top level of the crate, function bodies\n"
"    for each unseen item in any module {\n"
"        if item is a definition {\n"
"            // struct, trait, type, local variable def, etc.\n"
"            bindings.insert(item.name, module, item)\n"
"            populate_back_links(module, item)\n"
"        } else {\n"
"            try_to_resolve_import(module, item)\n"
"        }\n"
"        record_macro_uses()\n"
"    }\n"
"}\n"
"\n"
"fn try_to_resolve_import(module, item) {\n"
"    if item is an explicit use {\n"
"        // item is use a::b::c as d;\n"
"        match try_to_resolve(item) {\n"
"            Ok(r) => {\n"
"                add(bindings.insert(d, module, r, Priority::Explicit))\n"
"                populate_back_links(module, item)\n"
"            }\n"
"            Err() => work_list.push(module, item)\n"
"        }\n"
"    } else if item is a glob {\n"
"        // use a::b::*;\n"
"        match try_to_resolve(a::b) {\n"
"            Ok(n) => \n"
"                for binding in n {\n"
"                    bindings.insert_if_no_higher_priority_binding(binding."
"name, module, binding, Priority::Glob)\n"
"                    populate_back_links(module, binding)\n"
"                }\n"
"                add_back_link(n to module)\n"
"                work_list.remove()\n"
"            Err(_) => work_list.push(module, item)\n"
"        }\n"
"    }    \n"
"}\n"
"\n"
"fn process_work_list() {\n"
"    for each (module, item) in work_list {\n"
"        work_list.remove()\n"
"        try_to_resolve_import(module, item)\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/1560-name-resolution.md:509
msgid ""
"Note that this pseudo-code elides some details: that names are imported into "
"distinct namespaces (the type and value namespaces, and with changes to "
"macro naming, also the macro namespace), and that we must record whether a "
"name is due to macro expansion or not to abide by the caveat to the "
"'explicit names shadow glob names' rule."
msgstr ""

#: src/1560-name-resolution.md:515
msgid ""
"If Rust had a single namespace (or had some other properties), we would not "
"have to distinguish between failed and unresolved imports. However, it does "
"and we must. This is not clear from the pseudo-code because it elides "
"namespaces, but consider the following small example:"
msgstr ""

#: src/1560-name-resolution.md:520
msgid ""
"```\n"
"use a::foo; // foo exists in the value namespace of a.\n"
"use b::*;   // foo exists in the type namespace of b.\n"
"```"
msgstr ""

#: src/1560-name-resolution.md:525
msgid ""
"Can we resolve a use of `foo` in type position to the import from `b`? That "
"depends on whether `foo` exists in the type namespace in `a`. If we can "
"prove that it does not (i.e., resolution fails) then we can use the glob "
"import. If we cannot (i.e., the name is unresolved but we can't prove it "
"will not resolve later), then it is not safe to use the glob import because "
"it may be shadowed by the explicit import. (Note, since `foo` exists in at "
"least the value namespace in `a`, there will be no error due to a bad "
"import)."
msgstr ""

#: src/1560-name-resolution.md:533
msgid ""
"In order to keep macro expansion comprehensible to programmers, we must "
"enforce that all macro uses resolve to the same binding at the end of "
"resolution as they do when they were resolved."
msgstr ""

#: src/1560-name-resolution.md:537
msgid ""
"We rely on a monotonicity property in macro expansion - once an item exists "
"in a certain place, it will always exist in that place. It will never "
"disappear and never change. Note that for the purposes of this property, I "
"do not consider code annotated with a macro to exist until it has been fully "
"expanded."
msgstr ""

#: src/1560-name-resolution.md:542
msgid ""
"A consequence of this is that if the compiler resolves a name, then does "
"some expansion and resolves it again, the first resolution will still be "
"valid. However, another resolution may appear, so the resolution of a name "
"may change as we expand. It can also change from a good resolution to an "
"ambiguity. It is also possible to change from good to ambiguous to good "
"again. There is even an edge case where we go from good to ambiguous to the "
"same good resolution (but via a different route)."
msgstr ""

#: src/1560-name-resolution.md:550
msgid ""
"If import resolution succeeds, then we check our record of name resolutions. "
"We re-resolve and check we get the same result. We can also check for un-"
"used macros at this point."
msgstr ""

#: src/1560-name-resolution.md:554
msgid ""
"Note that the rules in the previous section have been carefully formulated "
"to ensure that this check is sufficient to prevent temporal ambiguities. "
"There are many slight variations for which this check would not be enough."
msgstr ""

#: src/1560-name-resolution.md:558
msgid "Privacy"
msgstr ""

#: src/1560-name-resolution.md:560
msgid ""
"In order to resolve imports (and in the future for macro privacy), we must "
"be able to decide if names are accessible. This requires doing privacy "
"checking as required during parsing/expansion/import resolution. We can keep "
"the current algorithm, but check accessibility on demand, rather than as a "
"separate pass."
msgstr ""

#: src/1560-name-resolution.md:565
msgid ""
"During macro expansion, once a name is resolvable, then we can safely "
"perform privacy checking, because parsing and macro expansion will never "
"remove items, nor change the module structure of an item once it has been "
"expanded."
msgstr ""

#: src/1560-name-resolution.md:569
msgid "Metadata"
msgstr ""

#: src/1560-name-resolution.md:571
msgid ""
"When a crate is packed into metadata, we must also include the binding "
"table. We must include private entries due to macros that the crate might "
"export. We don't need data for function bodies. For functions which are "
"serialised for inlining/monomorphisation, we should include local data "
"(although it's probably better to serialise the HIR or MIR, then the local "
"bindings are unnecessary)."
msgstr ""

#: src/1560-name-resolution.md:578
msgid "Drawbacks"
msgstr ""

#: src/1560-name-resolution.md:581
msgid ""
"It's a lot of work and name resolution is complex, therefore there is scope "
"for introducing bugs."
msgstr ""

#: src/1560-name-resolution.md:584
msgid ""
"The macro changes are not backwards compatible, which means having a macro "
"system 2.0. If users are reluctant to use that, we will have two macro "
"systems forever."
msgstr ""

#: src/1560-name-resolution.md:588
msgid "Alternatives"
msgstr ""

#: src/1560-name-resolution.md:591
msgid "Naming rules"
msgstr ""

#: src/1560-name-resolution.md:593
msgid ""
"We could take a subset of the shadowing changes (or none at all), whilst "
"still changing the implementation of name resolution. In particular, we "
"might want to discard the explicit/glob shadowing rule change, or only allow "
"items, not imported names to shadow."
msgstr ""

#: src/1560-name-resolution.md:598
msgid ""
"We could also consider different shadowing rules around namespacing. In the "
"'globs and explicit names' rule change, we could consider an explicit name "
"to shadow both name spaces and emit a custom error. The example becomes:"
msgstr ""

#: src/1560-name-resolution.md:603
msgid ""
"```\n"
"mod foo {\n"
"    pub struct Qux;\n"
"}\n"
"\n"
"mod bar {\n"
"    pub trait Qux;\n"
"}\n"
"\n"
"mod boz {\n"
"    use foo::*;\n"
"    use bar::Qux; // Shadows both name spaces.\n"
"\n"
"    fn f(x: &Qux) {   // bound to bar::Qux.\n"
"        let _ = Qux;  // ERROR, unresolved name Qux; the compiler would emit "
"a\n"
"                      // note about shadowing and namespaces.\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/1560-name-resolution.md:623
msgid "Import resolution algorithm"
msgstr ""

#: src/1560-name-resolution.md:625
msgid ""
"Rather than lookup names for imports during the fixpoint iteration, one "
"could save links between imports and definitions. When lookup is required "
"(for macros, or later in the compiler), these links are followed to find a "
"name, rather than having the name being immediately available."
msgstr ""

#: src/1560-name-resolution.md:631
msgid "Unresolved questions"
msgstr ""

#: src/1560-name-resolution.md:634
msgid "Name lookup"
msgstr ""

#: src/1560-name-resolution.md:636
msgid ""
"The name resolution phase would be replaced by a cut-down name lookup phase, "
"where the binding tables generated during expansion are used to lookup names "
"in the AST."
msgstr ""

#: src/1560-name-resolution.md:640
msgid ""
"We could go further, two appealing possibilities are merging name lookup "
"with the lowering from AST to HIR, so the HIR is a name-resolved data "
"structure. Or, name lookup could be done lazily (probably with some caching) "
"so no tables binding names to definitions are kept. I prefer the first "
"option, but this is not really in scope for this RFC."
msgstr ""

#: src/1560-name-resolution.md:646
msgid "`pub(restricted)`"
msgstr ""

#: src/1560-name-resolution.md:648
msgid ""
"Where this RFC touches on the privacy system there are some edge cases "
"involving the `pub(path)` form of restricted visibility. I expect the "
"precise solutions will be settled during implementation and this RFC should "
"be amended to reflect those choices."
msgstr ""

#: src/1560-name-resolution.md:654
msgid "References"
msgstr ""

#: src/1560-name-resolution.md:656
msgid ""
"[Niko's prototype](https://github.com/nikomatsakis/rust-name-resolution-"
"algorithm)"
msgstr ""

#: src/1560-name-resolution.md:657
msgid ""
"[Blog post](http://ncameron.org/blog/name-resolution/), includes details "
"about how the name resolution algorithm interacts with sets of scopes "
"hygiene."
msgstr ""
