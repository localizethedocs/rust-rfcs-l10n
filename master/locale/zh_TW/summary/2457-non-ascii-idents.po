msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:04Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2457-non-ascii-idents.md:1
msgid "Feature Name: `non_ascii_idents`"
msgstr ""

#: src/2457-non-ascii-idents.md:2
msgid "Start Date: 2018-06-03"
msgstr ""

#: src/2457-non-ascii-idents.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2457](https://github.com/rust-lang/rfcs/pull/2457)"
msgstr ""

#: src/2457-non-ascii-idents.md:4
msgid ""
"Rust Issue: [rust-lang/rust#55467](https://github.com/rust-lang/rust/"
"issues/55467)"
msgstr ""

#: src/2457-non-ascii-idents.md:6
msgid "Summary"
msgstr "ÊëòË¶Å"

#: src/2457-non-ascii-idents.md:9
msgid ""
"Allow non-ASCII letters (such as accented characters, Cyrillic, Greek, "
"Kanji, etc.) in Rust identifiers."
msgstr ""

#: src/2457-non-ascii-idents.md:11
msgid "Motivation"
msgstr "ÂãïÊ©ü"

#: src/2457-non-ascii-idents.md:14
msgid ""
"Writing code using domain-specific terminology simplifies implementation and "
"discussion as opposed to translating words from the project requirements. "
"When the code is only intended for a limited audience such as with in-house "
"projects or in teaching it can be beneficial to write code in the group's "
"language as it boosts communication and helps people not fluent in English "
"to participate and write Rust code themselves."
msgstr ""

#: src/2457-non-ascii-idents.md:16
msgid ""
"The rationale from [PEP 3131](https://www.python.org/dev/peps/pep-3131/) "
"nicely explains it:"
msgstr ""

#: src/2457-non-ascii-idents.md:18
msgid ""
"~~Python~~ _Rust_ code is written by many people in the world who are not "
"familiar with the English language, or even well-acquainted with the Latin "
"writing system. Such developers often desire to define classes and functions "
"with names in their native languages, rather than having to come up with an "
"(often incorrect) English translation of the concept they want to name. By "
"using identifiers in their native language, code clarity and maintainability "
"of the code among speakers of that language improves."
msgstr ""

#: src/2457-non-ascii-idents.md:20
msgid ""
"For some languages, common transliteration systems exist (in particular, for "
"the Latin-based writing systems). For other languages, users have larger "
"difficulties to use Latin to write their native words."
msgstr ""

#: src/2457-non-ascii-idents.md:22
msgid ""
"Additionally some math oriented projects may want to use identifiers closely "
"resembling mathematical writing."
msgstr ""

#: src/2457-non-ascii-idents.md:24
msgid "Guide-level explanation"
msgstr ""

#: src/2457-non-ascii-idents.md:27
msgid ""
"Identifiers include variable names, function and trait names and module "
"names. They start with a letter or an underscore and may be followed by more "
"letters, digits and some connecting punctuation."
msgstr ""

#: src/2457-non-ascii-idents.md:29
msgid "Examples of valid identifiers are:"
msgstr ""

#: src/2457-non-ascii-idents.md:31
msgid ""
"ASCII letters and digits: `image_width`, `line2`, `Photo`, `el_tren`, "
"`_unused`"
msgstr ""

#: src/2457-non-ascii-idents.md:32
msgid "words containing accented characters: `gar√ßon`, `h√ºhnerv√∂gel`"
msgstr ""

#: src/2457-non-ascii-idents.md:33
msgid "identifiers in other scripts: `–ú–æ—Å–∫–≤–∞`, `Êù±‰∫¨`, ..."
msgstr ""

#: src/2457-non-ascii-idents.md:35
msgid "Examples of invalid identifiers are:"
msgstr ""

#: src/2457-non-ascii-idents.md:37
msgid "Keywords: `impl`, `fn`, `_` (underscore), ..."
msgstr ""

#: src/2457-non-ascii-idents.md:38
msgid ""
"Identifiers starting with numbers or containing \"non letters\": "
"`42_the_answer`, `third‚àöof7`, `‚óÜ‚óÜ‚óÜ`, ..."
msgstr ""

#: src/2457-non-ascii-idents.md:39
msgid "Many Emojis: üôÇ, ü¶Ä, üí©, ..."
msgstr ""

#: src/2457-non-ascii-idents.md:41
msgid ""
"[Composed characters](https://en.wikipedia.org/wiki/Precomposed_character) "
"like those used in the word `kÃÅuÃ≠oÃÑÃÅn` can be represented in different ways with "
"Unicode. These different representations are all the same identifier in Rust."
msgstr ""

#: src/2457-non-ascii-idents.md:43
msgid ""
"To disallow any Unicode identifiers in a project (for example to ease "
"collaboration or for security reasons) limiting the accepted identifiers to "
"ASCII add this lint to the `lib.rs` or `main.rs` file of your project:"
msgstr ""

#: src/2457-non-ascii-idents.md:49
msgid ""
"Some Unicode character look confusingly similar to each other or even "
"identical like the Latin **A** and the Cyrillic **–ê**. The compiler may warn "
"you about names that are easy to confuse with keywords, names from the same "
"crate and imported items. If needed (but not recommended) this warning can "
"be silenced with a `#[allow(confusable_idents)]` annotation on the enclosing "
"function or module."
msgstr ""

#: src/2457-non-ascii-idents.md:51
msgid "Usage notes"
msgstr ""

#: src/2457-non-ascii-idents.md:53
msgid ""
"All code written in the Rust Language Organization (_rustc_, tools, std, "
"common crates) will continue to only use ASCII identifiers and the English "
"language."
msgstr ""

#: src/2457-non-ascii-idents.md:55
msgid ""
"For open source crates it is suggested to write them in English and use "
"ASCII-only. An exception can be made if the application domain (e.g. math) "
"benefits from Unicode and the target audience (e.g. for a crate interfacing "
"with Russian passports) is comfortable with the used language and "
"characters. Additionally crates should consider to provide an ASCII-only API."
msgstr ""

#: src/2457-non-ascii-idents.md:57
msgid ""
"Private projects can use any script and language the developer(s) desire. It "
"is still a good idea (as with any language feature) not to overdo it."
msgstr ""

#: src/2457-non-ascii-idents.md:59
msgid "Reference-level explanation"
msgstr ""

#: src/2457-non-ascii-idents.md:62
msgid ""
"Identifiers in Rust are based on the [Unicode¬Æ Standard Annex #31 Unicode "
"Identifier and Pattern Syntax](http://www.unicode.org/reports/tr31/)."
msgstr ""

#: src/2457-non-ascii-idents.md:64
msgid ""
"Note: The supported Unicode version should be stated in the documentation."
msgstr ""

#: src/2457-non-ascii-idents.md:66
msgid "The lexer defines identifiers as:"
msgstr ""

#: src/2457-non-ascii-idents.md:68
msgid ""
"**<sup>Lexer:</sup>** IDENTIFIER_OR_KEYWORD:  \n"
"¬†¬† XID_Start¬†XID_Continue<sup>\\*</sup>  \n"
"¬†¬† | `_` XID_Continue<sup>\\*</sup>"
msgstr ""

#: src/2457-non-ascii-idents.md:73
msgid ""
"IDENTIFIER :  \n"
"IDENTIFIER_OR_KEYWORD <sub>_Except a \\[strict\\] or \\[reserved\\] "
"keyword_</sub>"
msgstr ""

#: src/2457-non-ascii-idents.md:76
msgid ""
"`XID_Start` and `XID_Continue` are used as defined in the aforementioned "
"standard. The definition of identifiers is forward compatible with each "
"successive release of Unicode as only appropriate new characters are added "
"to the classes but none are removed. We effectively are using UAX 31's "
"default definition of valid identifier, with a tailoring that underscores "
"are included with `XID_Start`. (Note that this allows bare underscores to be "
"identifiers, that is currently also the case with `_` in identifier contexts "
"being a reserved keyword)"
msgstr ""

#: src/2457-non-ascii-idents.md:78
msgid ""
"Rust lexers normalize identifiers to [NFC](https://www.unicode.org/reports/"
"tr15/). Every API accepting identifiers as strings (such as `proc_macro::"
"Ident::new` normalizes them to NFC and APIs returning them as strings (like "
"`proc_macro::Ident::to_string`) return the normalized form. Procedural and "
"declarative macros receive normalized identifiers in their input as well. "
"This means two identifiers are equal if their NFC forms are equal."
msgstr ""

#: src/2457-non-ascii-idents.md:80
msgid ""
"A `non_ascii_idents` lint is added to the compiler. This lint is `allow` by "
"default. The lint checks if any identifier in the current context contains a "
"codepoint with a value equal to or greater than 0x80 (outside ASCII range). "
"Not only locally defined identifiers are checked but also those imported "
"from other crates and modules into the current context."
msgstr ""

#: src/2457-non-ascii-idents.md:82
msgid "Remaining ASCII-only names"
msgstr ""

#: src/2457-non-ascii-idents.md:84
msgid ""
"Only ASCII identifiers are allowed within an external block and in the "
"signature of a function declared `#[no_mangle]`. Otherwise an error is "
"reported."
msgstr ""

#: src/2457-non-ascii-idents.md:87
msgid ""
"Note: These functions interface with other programming languages and these "
"may allow different characters or may not apply normalization to "
"identifiers. As this is a niche use-case it is excluded from this RFC. A "
"future RFC may lift the restriction."
msgstr ""

#: src/2457-non-ascii-idents.md:92
msgid ""
"This RFC keeps out-of-line modules without a `#[path]` attribute ASCII-only. "
"The allowed character set for names on crates.io is not changed."
msgstr ""

#: src/2457-non-ascii-idents.md:95
msgid ""
"Note: This is to avoid dealing with file systems on different systems _right "
"now_. A future RFC may allow non-ASCII characters after the file system "
"issues are resolved."
msgstr ""

#: src/2457-non-ascii-idents.md:98 src/2457-non-ascii-idents.md:219
msgid "Confusable detection"
msgstr ""

#: src/2457-non-ascii-idents.md:100
msgid ""
"Rust compilers should detect confusingly similar Unicode identifiers and "
"warn the user about it."
msgstr ""

#: src/2457-non-ascii-idents.md:102
msgid ""
"Note: This is _not_ a mandatory for all Rust compilers as it requires "
"considerable implementation effort and is not related to the core function "
"of the compiler. It rather is a tool to detect accidental misspellings and "
"intentional homograph attacks."
msgstr ""

#: src/2457-non-ascii-idents.md:104
msgid ""
"A new `confusable_idents` lint is added to the compiler. The default setting "
"is `warn`."
msgstr ""

#: src/2457-non-ascii-idents.md:106
msgid ""
"Note: The confusable detection is set to `warn` instead of `deny` to enable "
"forward compatibility. The list of confusable characters will be extended in "
"the future and programs that were once valid would fail to compile."
msgstr ""

#: src/2457-non-ascii-idents.md:108
msgid ""
"The confusable detection algorithm is based on [Unicode¬Æ Technical Standard "
"#39 Unicode Security Mechanisms Section 4 Confusable Detection](https://www."
"unicode.org/reports/tr39/#Confusable_Detection). For every distinct "
"identifier X execute the function `skeleton(X)`. If there exist two distinct "
"identifiers X and Y in the same crate where `skeleton(X) = skeleton(Y)` "
"report it. The compiler uses the same mechanism to check if an identifier is "
"too similar to a keyword."
msgstr ""

#: src/2457-non-ascii-idents.md:110
msgid ""
"Note: A fast way to implement this is to compute `skeleton` for each "
"identifier once and place the result in a hashmap as a key. If one tries to "
"insert a key that already exists check if the two identifiers differ from "
"each other. If so report the two confusable identifiers."
msgstr ""

#: src/2457-non-ascii-idents.md:112
msgid "Exotic codepoint detection"
msgstr ""

#: src/2457-non-ascii-idents.md:114
msgid ""
"A new `less_used_codepoints` lint is added to the compiler. The default "
"setting is to `warn`."
msgstr ""

#: src/2457-non-ascii-idents.md:116
msgid ""
"The lint is triggered by identifiers that contain a codepoint that is not "
"part of the set of \"Allowed\" codepoints as described by [Unicode¬Æ "
"Technical Standard #39 Unicode Security Mechanisms Section 3.1 General "
"Security Profile for Identifiers](https://www.unicode.org/reports/tr39/"
"#General_Security_Profile)."
msgstr ""

#: src/2457-non-ascii-idents.md:118
msgid ""
"Note: New Unicode versions update the set of allowed codepoints. "
"Additionally the compiler authors may decide to allow more codepoints or "
"warn about those that have been found to cause confusion."
msgstr ""

#: src/2457-non-ascii-idents.md:120
msgid ""
"For reference, a list of all the code points allowed by this lint can be "
"found [here](https://unicode.org/cldr/utility/list-unicodeset.jsp?"
"a=%5B%5B%3AIdentifier_Status%3DAllowed%3A%5D%26%5B%3AXID_Continue%3DYes%3A%5D%5D&g=&i=Script_Extensions), "
"with the script group mentioned on the right."
msgstr ""

#: src/2457-non-ascii-idents.md:122
msgid ""
"There are some specific interesting code points that we feel necessary to "
"call out here:"
msgstr ""

#: src/2457-non-ascii-idents.md:124
msgid ""
"`less_used_codepoints` will warn on U+200C ZERO WIDTH NON-JOINER and U+200D "
"ZERO WIDTH JOINER, despite these being useful in the  Perso-Arabic and some "
"Indic scripts. In Indic scripts these characters force different visual "
"forms, which is not very necessary for programming. These have further "
"semantic meaning in Arabic where they can be used to mark prefixes or mixed-"
"script words, which will not crop up so often in programming (we're not able "
"to use `-` in identifiers for marking pre/suffixes in Latin-script "
"identifiers and it's fine). Persian seems to make the most use of these, "
"with some compound words requiring use of these. For now this RFC does not "
"attempt to deal with this and follows the recommendation of the "
"specification, if there is a need for it in the future we can add this for "
"Persian users."
msgstr ""

#: src/2457-non-ascii-idents.md:125
msgid ""
"`less_used_codepoints` will not warn about U+02BB MODIFIER LETTER TURNED "
"COMMA or U+02BC MODIFIER LETTER APOSTROPHE. These look somewhat like "
"punctuation relevant to Rust's syntax, so they're a bit tricky. However, "
"these code points are important in Ukrainian, Hawaiian, and a bunch of other "
"languages (U+02BB is considered a full-fledged letter in Hawaiian). For now "
"this RFC follows the recommendation of the specification and allows these, "
"however we can change this in the future. The hope is that syntax "
"highlighting is enough to deal with confusions caused by such characters."
msgstr ""

#: src/2457-non-ascii-idents.md:128
msgid "Adjustments to the \"bad style\" lints"
msgstr ""

#: src/2457-non-ascii-idents.md:130
msgid ""
"Rust [RFC 0430](http://rust-lang.github.io/rfcs/0430-finalizing-naming-"
"conventions.html) establishes naming conventions for Rust ASCII identifiers. "
"The _rustc_ compiler includes lints to promote these recommendations."
msgstr ""

#: src/2457-non-ascii-idents.md:132
msgid "The following names refer to Unicode character categories:"
msgstr ""

#: src/2457-non-ascii-idents.md:134
msgid "`Ll`: Letter, Lowercase"
msgstr ""

#: src/2457-non-ascii-idents.md:135
msgid "`Lu`: Letter, Uppercase"
msgstr ""

#: src/2457-non-ascii-idents.md:137
msgid ""
"These are the three different naming conventions and how their corresponding "
"lints are specified to accommodate non-ASCII codepoints:"
msgstr ""

#: src/2457-non-ascii-idents.md:139
msgid ""
"UpperCamelCase/`non_camel_case_types`: The first codepoint must not be in "
"`Ll`. Underscores are not allowed except as a word separator between two "
"codepoints from neither `Lu` or `Ll`."
msgstr ""

#: src/2457-non-ascii-idents.md:140
msgid "snake_case/`non_snake_case`: Must not contain `Lu` codepoints."
msgstr ""

#: src/2457-non-ascii-idents.md:141
msgid ""
"SCREAMING_SNAKE_CASE/`non_upper_case_globals`: Must not contain `Ll` "
"codepoints."
msgstr ""

#: src/2457-non-ascii-idents.md:143
msgid ""
"Note: Scripts with upper- and lowercase variants (\"bicameral scripts\") "
"behave similar to ASCII. Scripts without this distinction (\"unicameral "
"scripts\") are also usable but all identifiers look the same regardless if "
"they refer to a type, variable or constant. Underscores can be used to "
"separate words in unicameral scripts even in UpperCamelCase contexts."
msgstr ""

#: src/2457-non-ascii-idents.md:145
msgid "Mixed script confusables lint"
msgstr ""

#: src/2457-non-ascii-idents.md:147
msgid ""
"We keep track of the script groups in use in a document using the comparison "
"heuristics in [Unicode¬Æ Technical Standard #39 Unicode Security Mechanisms "
"Section 5.2 Restriction-Level Detection](https://www.unicode.org/reports/"
"tr39/#Restriction_Level_Detection)."
msgstr ""

#: src/2457-non-ascii-idents.md:149
msgid ""
"We identify lists of code points which are `Allowed` by [UTS 39 section 3.1]"
"(https://www.unicode.org/reports/tr39/#General_Security_Profile) (i.e., code "
"points not already linted by `less_used_codepoints`) and are \"exact\" "
"confusables between code points from other `Allowed` scripts. This is stuff "
"like Cyrillic `–æ` (confusable with Latin `o`), but does not include things "
"like Hebrew `◊°` which is somewhat distinguishable from Latin `o`. This list "
"of exact confusables can be modified in the future."
msgstr ""

#: src/2457-non-ascii-idents.md:151
msgid ""
"We expect most of these to be between Cyrillic-Latin-Greek and some in "
"Ethiopic-Armenian, but a proper review can be done before stabilization. "
"There are also confusable modifiers between many script."
msgstr ""

#: src/2457-non-ascii-idents.md:153
msgid ""
"In a code base, if the _only_ code points from a given script group (aside "
"from `Latin`, `Common`, and `Inherited`) are such exact confusables, lint "
"about it with `mixed_script_confusables` (lint name can be finalized later)."
msgstr ""

#: src/2457-non-ascii-idents.md:155
msgid ""
"As an implementation note, it may be worth dealing with confusable modifiers "
"via a separate lint check -- if a modifier is from a different (non-`Common`/"
"`Inherited`) script group from the thing preceding it. This has some "
"behavioral differences but should not increase the chance of false positives."
msgstr ""

#: src/2457-non-ascii-idents.md:157
msgid ""
"The exception for `Latin` is made because the standard library is Latin-"
"script. It could potentially be removed since a code base using the standard "
"library (or any Latin-using library) is likely to be using enough of it that "
"there will be non-confusable characters in use. (This is in unresolved "
"questions)"
msgstr ""

#: src/2457-non-ascii-idents.md:160
msgid "Reusability"
msgstr ""

#: src/2457-non-ascii-idents.md:162
msgid ""
"The code used for implementing the various lints and checks will be released "
"to crates.io. This includes:"
msgstr ""

#: src/2457-non-ascii-idents.md:164
msgid "Testing validity of an identifier"
msgstr ""

#: src/2457-non-ascii-idents.md:165
msgid ""
"Testing for `less_used_codepoints` ([UTS #39 Section 3.1](https://www."
"unicode.org/reports/tr39/#General_Security_Profile))"
msgstr ""

#: src/2457-non-ascii-idents.md:166
msgid ""
"Script identification and comparison for `mixed_script_confusables`  ([UTS "
"#39 Section 5.2](https://www.unicode.org/reports/tr39/"
"#Restriction_Level_Detection))"
msgstr ""

#: src/2457-non-ascii-idents.md:167
msgid ""
"`skeleton(X)` algorithm for confusable detection ([UTS #39 Section 4]"
"(https://www.unicode.org/reports/tr39/#Confusable_Detection))"
msgstr ""

#: src/2457-non-ascii-idents.md:169
msgid ""
"Confusables detection works well when there are other identifiers to compare "
"against, but in some cases there's only one instance of an identifier in the "
"code, and it's compared with user-supplied strings. For example we have "
"crates that use proc macros to expose command line options or REST "
"endpoints. Crates that do things like these can use such algorithms to "
"ensure better error handling; for example if we accidentally end up having "
"an `/–∞—Ä—Ä` endpoint (in Cyrillic) because of a `#[annotation] fn –∞—Ä—Ä()`, "
"visiting `/app` (in Latin) may show a comprehensive error (or pass-through, "
"based on requirements)"
msgstr ""

#: src/2457-non-ascii-idents.md:171
msgid "Conformance Statement"
msgstr ""

#: src/2457-non-ascii-idents.md:173
msgid ""
"UAX31-C1: The Rust language conforms to the Unicode¬Æ Standard Annex #31 for "
"Unicode Version 10.0.0."
msgstr ""

#: src/2457-non-ascii-idents.md:174
msgid "UAX31-C2: It observes the following requirements:"
msgstr ""

#: src/2457-non-ascii-idents.md:175
msgid ""
"UAX31-R1. Default Identifiers: To determine whether a string is an "
"identifier it uses UAX31-D1 with the following profile:"
msgstr ""

#: src/2457-non-ascii-idents.md:176
msgid "Start := XID_Start, plus `_`"
msgstr ""

#: src/2457-non-ascii-idents.md:177
msgid "Continue := XID_Continue"
msgstr ""

#: src/2457-non-ascii-idents.md:178
msgid "Medial := empty"
msgstr ""

#: src/2457-non-ascii-idents.md:179
msgid ""
"UAX31-R1b. Stable Identifiers: Once a string qualifies as an identifier, it "
"does so in all future versions."
msgstr ""

#: src/2457-non-ascii-idents.md:180
msgid ""
"UAX31-R3. Pattern_White_Space and Pattern_Syntax Characters: Rust only uses "
"characters from these categories for whitespace and syntax. Other characters "
"may or may not be allowed in identifiers."
msgstr ""

#: src/2457-non-ascii-idents.md:181
msgid ""
"UAX31-R4. Equivalent Normalized Identifiers: All identifiers are normalized "
"according to normalization form C before comparison."
msgstr ""

#: src/2457-non-ascii-idents.md:185
msgid "Drawbacks"
msgstr ""

#: src/2457-non-ascii-idents.md:188
msgid ""
"\"ASCII is enough for anyone.\" As source code should be written in English "
"and in English only (source: various people) no characters outside the ASCII "
"range are needed to express identifiers. Therefore support for Unicode "
"identifiers introduces unnecessary complexity to the compiler."
msgstr ""

#: src/2457-non-ascii-idents.md:189
msgid ""
"\"Foreign characters are hard to type.\" Usually computer keyboards provide "
"access to the US-ASCII printable characters and the local language "
"characters. Characters from other scripts are difficult to type, require "
"entering numeric codes or are not available at all. These characters either "
"need to be copy-pasted or entered with an alternative input method."
msgstr ""

#: src/2457-non-ascii-idents.md:190
msgid ""
"\"Foreign characters are hard to read.\" If one is not familiar with the "
"characters used it can be hard to tell them apart (e.g. œÜ and œà) and one may "
"not be able refer to the identifiers in an appropriate way (e.g. \"loop\" "
"and \"trident\" instead of phi and psi)"
msgstr ""

#: src/2457-non-ascii-idents.md:191
msgid ""
"\"My favorite terminal/text editor/web browser\" has incomplete Unicode "
"support.\" Even in 2018 some characters are not widely supported in all "
"places where source code is usually displayed."
msgstr ""

#: src/2457-non-ascii-idents.md:192
msgid ""
"Homoglyph attacks are possible. Without confusable detection identifiers can "
"be distinct for the compiler but visually the same. Even with confusable "
"detection there are still similar looking characters that may be confused by "
"the casual reader."
msgstr ""

#: src/2457-non-ascii-idents.md:194
msgid "Rationale and alternatives"
msgstr ""

#: src/2457-non-ascii-idents.md:197
msgid ""
"As stated in [Motivation](#motivation) allowing Unicode identifiers outside "
"the ASCII range improves Rusts accessibility for developers not working in "
"English. Especially in teaching and when the application domain vocabulary "
"is not in English it can be beneficial to use names from the native "
"language. To facilitate this it is necessary to allow a wide range of "
"Unicode character in identifiers. The proposed implementation based on the "
"Unicode TR31 is already used by other programming languages and is "
"implemented behind the `non_ascii_idents` in _rustc_ but lacks the NFC "
"normalization proposed."
msgstr ""

#: src/2457-non-ascii-idents.md:199
msgid ""
"NFC normalization was chosen over NFKC normalization for the following "
"reasons:"
msgstr ""

#: src/2457-non-ascii-idents.md:201
msgid ""
"[Mathematicians want to use symbols mapped to the same NFKC form](https://"
"github.com/rust-lang/rfcs/pull/2457#issuecomment-394928432) like œÄ and œñ in "
"the same context."
msgstr ""

#: src/2457-non-ascii-idents.md:202
msgid ""
"[Some words are mangled by NFKC](https://github.com/rust-lang/rfcs/"
"pull/2457#issuecomment-394922103) in surprising ways."
msgstr ""

#: src/2457-non-ascii-idents.md:203
msgid ""
"Naive (search) tools can't find different variants of the same NFKC "
"identifier. As most text is already in NFC form search tools work well."
msgstr ""

#: src/2457-non-ascii-idents.md:205
msgid "Possible variants:"
msgstr ""

#: src/2457-non-ascii-idents.md:207
msgid "Require all identifiers to be already in NFC form."
msgstr ""

#: src/2457-non-ascii-idents.md:208
msgid "Two identifiers are only equal if their codepoints are equal."
msgstr ""

#: src/2457-non-ascii-idents.md:209
msgid "Perform NFKC mapping instead of NFC mapping for identifiers."
msgstr ""

#: src/2457-non-ascii-idents.md:210
msgid "Only a number of common scripts could be supported."
msgstr ""

#: src/2457-non-ascii-idents.md:211
msgid ""
"A [restriction level](https://www.unicode.org/reports/tr39/"
"#Restriction_Level_Detection) is specified allowing only a subset of scripts "
"and limit script-mixing within an identifier."
msgstr ""

#: src/2457-non-ascii-idents.md:213
msgid ""
"An alternative design would use [Immutable Identifiers](http://unicode.org/"
"reports/tr31/#Alternative_Identifier_Syntax) as done in [C++](https://en."
"cppreference.com/w/cpp/language/identifiers). In this case a list of Unicode "
"codepoints is reserved for syntax (ASCII operators, braces, whitespace) and "
"all other codepoints (including currently unassigned codepoints) are allowed "
"in identifiers. The advantages are that the compiler does not need to know "
"the Unicode character classes XID_Start and XID_Continue for each character "
"and that the set of allowed identifiers never changes. It is disadvantageous "
"that all not explicitly excluded characters at the time of creation can be "
"used in identifiers. This allows developers to create identifiers that can't "
"be recognized as such. It also impedes other uses of Unicode in Rust syntax "
"like custom operators if they were not initially reserved."
msgstr ""

#: src/2457-non-ascii-idents.md:215
msgid "It always a possibility to do nothing and limit identifiers to ASCII."
msgstr ""

#: src/2457-non-ascii-idents.md:217
msgid ""
"It has been suggested that Unicode identifiers should be opt-in instead of "
"opt-out. The proposal chooses opt-out to benefit the international Rust "
"community. New Rust users should not need to search for the configuration "
"option they may not even know exists. Additionally it simplifies tutorials "
"in other languages as they can omit an annotation in every code snippet."
msgstr ""

#: src/2457-non-ascii-idents.md:221
msgid ""
"The current design was chosen because the algorithm and list of similar "
"characters are already provided by the Unicode Consortium. A different "
"algorithm and list of characters could be created. I am not aware of any "
"other programming language implementing confusable detection. The confusable "
"detection was primarily included because homoglyph attacks are a huge "
"concern for some members of the community."
msgstr ""

#: src/2457-non-ascii-idents.md:223
msgid ""
"Instead of offering confusable detection the lint `forbid(non_ascii_idents)` "
"is sufficient to protect a project written in English from homoglyph "
"attacks. Projects using different languages are probably either written by "
"students, by a small group or inside a regional company. These projects are "
"not threatened as much as large open source projects by homoglyph attacks "
"but still benefit from the easier debugging of typos."
msgstr ""

#: src/2457-non-ascii-idents.md:226
msgid "Alternative mixed script lints"
msgstr ""

#: src/2457-non-ascii-idents.md:228
msgid ""
"These are previously-proposed lints attempting to prevent problems caused by "
"mixing scripts, which were ultimately replaced by the current mixed script "
"confusables lint."
msgstr ""

#: src/2457-non-ascii-idents.md:230
msgid "Mixed script detection"
msgstr ""

#: src/2457-non-ascii-idents.md:232
msgid ""
"A new `mixed_script_idents` lint would be added to the compiler. The default "
"setting is to `warn`."
msgstr ""

#: src/2457-non-ascii-idents.md:234
msgid ""
"The lint is triggered by identifiers that do not qualify for the "
"\"Moderately Restrictive\" identifier profile specified in [Unicode¬Æ "
"Technical Standard #39 Unicode Security Mechanisms Section 5.2 Restriction-"
"Level Detection](https://www.unicode.org/reports/tr39/"
"#Restriction_Level_Detection)."
msgstr ""

#: src/2457-non-ascii-idents.md:236
msgid ""
"Note: The definition of \"Moderately Restrictive\" can be changed by future "
"versions of the Unicode standard to reflect changes in the natural languages "
"used or for other reasons."
msgstr ""

#: src/2457-non-ascii-idents.md:238
msgid "Global mixed script detection with confusables"
msgstr ""

#: src/2457-non-ascii-idents.md:240
msgid ""
"As an additional measure, we would try to detect cases where a codebase "
"primarily using a certain script has identifiers from a different script "
"confusable with that script."
msgstr ""

#: src/2457-non-ascii-idents.md:242
msgid ""
"During `mixed_script_idents` computation, keep track of how often "
"identifiers from various script groups crop up. If an identifier is from a "
"less-common script group (say, \\<1% of identifiers), _and_ it is entirely "
"confusable with the majority script in use (e.g. the string `\"–∞—Ä—Ä\"` or "
"`\"—Ä–æ—Ä–µ\"` in Cyrillic)"
msgstr ""

#: src/2457-non-ascii-idents.md:244
msgid ""
"This can trigger `confusable_idents`, `mixed_script_idents`, or a new lint."
msgstr ""

#: src/2457-non-ascii-idents.md:246
msgid ""
"We identify sets of characters which are entirely confusable: For example, "
"for Cyrillic-Latin, we have `–∞, –µ, –æ, —Ä, —Å, —É, —Ö, —ï, —ñ, —ò, ‘õ, ‘ù, —ê, —ë, —ó, ”±, "
"”ß, ”ì, ”ï, ”ë` amongst the lowercase letters (and more amongst the capitals). "
"This list likely can be programmatically derived from the confusables data "
"that Unicode already has. It may be worth filtering for exact confusables. "
"For example, Cyrillic, Greek, and Latin have a lot of confusables that are "
"almost indistinguishable in most fonts, whereas `⁄æ` and `◊°` are noticeably "
"different-looking from `o` even though they're marked as a confusables."
msgstr ""

#: src/2457-non-ascii-idents.md:248
msgid ""
"The main confusable script pairs we have to worry about are Cyrillic/Latin/"
"Greek, Armenian/Ethiopic, and a couple Armenian characters mapping to Greek/"
"Latin. We can implement this lint conservatively at first by dealing with a "
"blacklist of known confusables for these script pairs, and expand it if "
"there is a need."
msgstr ""

#: src/2457-non-ascii-idents.md:250
msgid ""
"There are many confusables _within_ scripts -- Arabic has a bunch of these "
"as does Han (both with other Han characters and with kana), but since these "
"are within the same language group this is outside the scope of this RFC. "
"Such confusables are equivalent to `l` vs `I` being confusable in some fonts."
msgstr ""

#: src/2457-non-ascii-idents.md:252
msgid ""
"For reference, a list of all possible Rust identifier characters that do not "
"trip `less_used_codepoints` but have confusables can be found [here](https://"
"unicode.org/cldr/utility/list-unicodeset.jsp?"
"a=%5B%5B%3AIdentifier_Status%3DAllowed%3A%5D%26%5B%3AXID_Continue%3DYes%3A%5D%26%5B%3AConfusable_MA%3A%5D%5D&g=&i=Confusable_MA%2CScript_Extensions), "
"with their confusable skeleton and script group mentioned on the right. Note "
"that in many cases the confusables are visually distinguishable, or are "
"diacritic marks."
msgstr ""

#: src/2457-non-ascii-idents.md:255
msgid "Prior art"
msgstr ""

#: src/2457-non-ascii-idents.md:258
msgid ""
"\"[Python PEP 3131](https://www.python.org/dev/peps/pep-3131/): Supporting "
"Non-ASCII Identifiers\" is the Python equivalent to this proposal. The "
"proposed identifier grammar **XID_Start¬†XID_Continue<sup>\\*</sup>** is "
"identical to the one used in Python 3. While Python uses KC normalization "
"this proposes to use normalization form C."
msgstr ""

#: src/2457-non-ascii-idents.md:260
msgid ""
"[JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-names-and-"
"keywords) supports Unicode identifiers based on the same Default Identifier "
"Syntax but does not apply normalization."
msgstr ""

#: src/2457-non-ascii-idents.md:262
msgid ""
"The [CPP reference](https://en.cppreference.com/w/cpp/language/identifiers) "
"describes the allowed Unicode identifiers it is based on the immutable "
"identifier principle."
msgstr ""

#: src/2457-non-ascii-idents.md:264
msgid ""
"[Java](https://docs.oracle.com/javase/specs/jls/se10/html/jls-3."
"html#jls-3.8) also supports Unicode identifiers. Character must belong to a "
"number of Unicode character classes similar to XID_start and XID_continue "
"used in Python. Unlike in Python no normalization is performed."
msgstr ""

#: src/2457-non-ascii-idents.md:266
msgid ""
"The [Go language](https://golang.org/ref/spec#Identifiers) allows "
"identifiers in the form **Letter (Letter | Number)\\*** where **Letter** is "
"a Unicode letter and **Number** is a Unicode decimal number. This is more "
"restricted than the proposed design mainly as is does not allow combining "
"characters needed to write some languages such as Hindi."
msgstr ""

#: src/2457-non-ascii-idents.md:268
msgid "Unresolved questions"
msgstr "Êú™Ëß£Ê±∫ÁöÑÂïèÈ°å"

#: src/2457-non-ascii-idents.md:271
msgid ""
"Which context is adequate for confusable detection: file, current scope, "
"crate?"
msgstr ""

#: src/2457-non-ascii-idents.md:272
msgid ""
"Should [ZWNJ and ZWJ be allowed in identifiers](https://www.unicode.org/"
"reports/tr31/#Layout_and_Format_Control_Characters)?"
msgstr ""

#: src/2457-non-ascii-idents.md:273
msgid "How are non-ASCII idents best supported in debuggers?"
msgstr ""

#: src/2457-non-ascii-idents.md:274
msgid "Which name mangling scheme is used by the compiler?"
msgstr ""

#: src/2457-non-ascii-idents.md:275
msgid "Is there a better name for the `less_used_codepoints` lint?"
msgstr ""

#: src/2457-non-ascii-idents.md:276
msgid ""
"Which lint should the global mixed scripts confusables detection trigger?"
msgstr ""

#: src/2457-non-ascii-idents.md:277
msgid ""
"How badly do non-ASCII idents exacerbate const pattern confusion (rust-lang/"
"rust#7526, rust-lang/rust#49680)? Can we improve precision of linting here?"
msgstr ""

#: src/2457-non-ascii-idents.md:280
msgid ""
"In `mixed_script_confusables`, do we actually need to make an exception for "
"`Latin` identifiers?"
msgstr ""

#: src/2457-non-ascii-idents.md:281
msgid ""
"Terminal width is a tricky with unicode. Some characters are long, some have "
"lengths dependent on the fonts installed (e.g. emoji sequences), and "
"modifiers are a thing. The concept of monospace font doesn't generalize to "
"other scripts as well. How does rustfmt deal with this when determining line "
"width?"
msgstr ""

#: src/2457-non-ascii-idents.md:282
msgid ""
"right-to-left scripts can lead to weird rendering in mixed contexts "
"(depending on the software used), especially when mixed with operators. This "
"is not something that should block stabilization, however we feel it is "
"important to explicitly call out. Future RFCs (preferably put forth by RTL-"
"using communities) may attempt to improve this situation (e.g. by allowing "
"bidi control characters in specific contexts)."
msgstr ""
