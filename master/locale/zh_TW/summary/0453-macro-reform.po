msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0453-macro-reform.md:1
msgid "Start Date: 2014-11-05"
msgstr ""

#: src/0453-macro-reform.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#453](https://github.com/rust-lang/rfcs/pull/453)"
msgstr ""

#: src/0453-macro-reform.md:3
msgid ""
"Rust Issue: [rust-lang/rust#20008](https://github.com/rust-lang/rust/"
"issues/20008)"
msgstr ""

#: src/0453-macro-reform.md:5
msgid "Summary"
msgstr ""

#: src/0453-macro-reform.md:7
msgid "Various enhancements to macros ahead of their standardization in 1.0."
msgstr ""

#: src/0453-macro-reform.md:9
msgid ""
"**Note**: This is not the final Rust macro system design for all time.  "
"Rather, it addresses the largest usability problems within the limited time "
"frame for 1.0.  It's my hope that a lot of these problems can be solved in "
"nicer ways in the long term (there is some discussion of this below)."
msgstr ""

#: src/0453-macro-reform.md:14
msgid "Motivation"
msgstr ""

#: src/0453-macro-reform.md:16
msgid ""
"`macro_rules!` has [many rough edges](https://github.com/rust-lang/rfcs/"
"issues/440).  A few of the big ones:"
msgstr ""

#: src/0453-macro-reform.md:19
msgid "You can't re-export macros"
msgstr ""

#: src/0453-macro-reform.md:20
msgid ""
"Even if you could, names produced by the re-exported macro won't follow the "
"re-export"
msgstr ""

#: src/0453-macro-reform.md:21
msgid ""
"You can't use the same macro in-crate and exported, without the \"curious "
"inner-module\" hack"
msgstr ""

#: src/0453-macro-reform.md:22
msgid "There's no namespacing at all"
msgstr ""

#: src/0453-macro-reform.md:23
msgid "You can't control which macros are imported from a crate"
msgstr ""

#: src/0453-macro-reform.md:24
msgid "You need the feature-gated `#[phase(plugin)]` to import macros"
msgstr ""

#: src/0453-macro-reform.md:26
msgid ""
"These issues in particular are things we have a chance of addressing for "
"1.0. This RFC contains plans to do so."
msgstr ""

#: src/0453-macro-reform.md:29
msgid "Semantic changes"
msgstr ""

#: src/0453-macro-reform.md:31
msgid ""
"These are the substantial changes to the macro system.  The examples also "
"use the improved syntax, described later."
msgstr ""

#: src/0453-macro-reform.md:34
msgid "`$crate`"
msgstr ""

#: src/0453-macro-reform.md:36
msgid ""
"The first change is to disallow importing macros from an `extern crate` that "
"is not at the crate root.  In that case, if"
msgstr ""

#: src/0453-macro-reform.md:40
msgid "\"bar\""
msgstr ""

#: src/0453-macro-reform.md:43
msgid ""
"imports macros, then it's also introducing ordinary paths of the form `::"
"foo::...`.  We call `foo` the _crate ident_ of the `extern crate`."
msgstr ""

#: src/0453-macro-reform.md:46
msgid ""
"We introduce a special macro metavar `$crate` which expands to `::foo` when "
"a macro was imported through crate ident `foo`, and to nothing when it was "
"defined in the crate where it is being expanded.  `$crate::bar::baz` will be "
"an absolute path either way."
msgstr ""

#: src/0453-macro-reform.md:51
msgid ""
"This feature eliminates the need for the \"curious inner-module\" and also "
"enables macro re-export (see below).  It is [implemented and tested](https://"
"github.com/kmcallister/rust/commits/macro-reexport) but needs a rebase."
msgstr ""

#: src/0453-macro-reform.md:56
msgid ""
"We can add a lint to warn about cases where an exported macro has paths that "
"are not absolute-with-crate or `$crate`\\-relative.  This will have some "
"(hopefully rare) false positives."
msgstr ""

#: src/0453-macro-reform.md:60
msgid "Macro scope"
msgstr ""

#: src/0453-macro-reform.md:62
msgid ""
"In this document, the \"syntax environment\" refers to the set of syntax "
"extensions that can be invoked at a given position in the crate.  The names "
"in the syntax environment are simple unqualified identifiers such as `panic` "
"and `vec`.  Informally we may write `vec!` to distinguish from an ordinary "
"item. However, the exclamation point is really part of the invocation "
"syntax, not the name, and some syntax extensions are invoked with no "
"exclamation point, for example item decorators like `deriving`."
msgstr ""

#: src/0453-macro-reform.md:70
msgid ""
"We introduce an attribute `macro_use` to specify which macros from an "
"external crate should be imported to the syntax environment:"
msgstr ""

#: src/0453-macro-reform.md:74
msgid "\"fail\""
msgstr ""

#: src/0453-macro-reform.md:81
msgid ""
"The list of macros to import is optional. Omitting the list imports all "
"macros, similar to a glob `use`.  (This is also the mechanism by which `std` "
"will inject its macros into every non-`no_std` crate.)"
msgstr ""

#: src/0453-macro-reform.md:85
msgid ""
"Importing with rename is an optional part of this proposal that will be "
"implemented for 1.0 only if time permits."
msgstr ""

#: src/0453-macro-reform.md:88
msgid ""
"Macros imported this way can be used anywhere in the module after the "
"`extern crate` item, including in child modules.  Since a macro-importing "
"`extern crate` must appear at the crate root, and view items come before "
"other items, this effectively means imported macros will be visible for the "
"entire crate."
msgstr ""

#: src/0453-macro-reform.md:94
msgid ""
"Any name collision between macros, whether imported or defined in-crate, is "
"a hard error."
msgstr ""

#: src/0453-macro-reform.md:97
msgid ""
"Many macros expand using other \"helper macros\" as an implementation "
"detail. For example, librustc's `declare_lint!` uses `lint_initializer!`.  "
"The client should not know about this macro, although it still needs to be "
"exported for cross-crate use.  For this reason we allow `#[macro_use]` on a "
"macro definition."
msgstr ""

#: src/0453-macro-reform.md:104
msgid "/// Not to be imported directly.\n"
msgstr ""

#: src/0453-macro-reform.md:107
msgid "/// Declare a lint.\n"
msgstr ""

#: src/0453-macro-reform.md:119
msgid ""
"The macro `lint_initializer!`, imported from the same crate as `declare_lint!"
"`, will be visible only during further expansion of the result of invoking "
"`declare_lint!`."
msgstr ""

#: src/0453-macro-reform.md:123
msgid ""
"`macro_use` on `macro_rules` is an optional part of this proposal that will "
"be implemented for 1.0 only if time permits.  Without it, libraries that use "
"helper macros will need to list them in documentation so that users can "
"import them."
msgstr ""

#: src/0453-macro-reform.md:128
msgid ""
"Procedural macros need their own way to manipulate the syntax environment, "
"but that's an unstable internal API, so it's outside the scope of this RFC."
msgstr ""

#: src/0453-macro-reform.md:131
msgid "New syntax"
msgstr ""

#: src/0453-macro-reform.md:133
msgid ""
"We also clean up macro syntax in a way that complements the semantic changes "
"above."
msgstr ""

#: src/0453-macro-reform.md:135
msgid "`#[macro_use(...)] mod`"
msgstr ""

#: src/0453-macro-reform.md:137
msgid ""
"The `macro_use` attribute can be applied to a `mod` item as well.  The "
"specified macros will \"escape\" the module and become visible throughout "
"the rest of the enclosing module, including any child modules.  A crate "
"might start with"
msgstr ""

#: src/0453-macro-reform.md:147
msgid ""
"to define some macros for use by the whole crate, without putting those "
"definitions in `lib.rs`."
msgstr ""

#: src/0453-macro-reform.md:150
msgid ""
"Note that `#[macro_use]` (without a list of names) is equivalent to the "
"current `#[macro_escape]`.  However, the new convention is to use an outer "
"attribute, in the file whose syntax environment is affected, rather than an "
"inner attribute in the file defining the macros."
msgstr ""

#: src/0453-macro-reform.md:155
msgid "Macro export and re-export"
msgstr ""

#: src/0453-macro-reform.md:157
msgid ""
"Currently in Rust, a macro definition qualified by `#[macro_export]` becomes "
"available to other crates.  We keep this behavior in the new system.  A "
"macro qualified by `#[macro_export]` can be the target of "
"`#[macro_use(...)]`, and will be imported automatically when `#[macro_use]` "
"is given with no list of names."
msgstr ""

#: src/0453-macro-reform.md:163
msgid ""
"`#[macro_export]` has no effect on the syntax environment for the current "
"crate."
msgstr ""

#: src/0453-macro-reform.md:166
msgid ""
"We can also re-export macros that were imported from another crate.  For "
"example, libcollections defines a `vec!` macro, which would now look like:"
msgstr ""

#: src/0453-macro-reform.md:180
msgid ""
"Currently, libstd duplicates this macro in its own `macros.rs`.  Now it "
"could do"
msgstr ""

#: src/0453-macro-reform.md:188
msgid ""
"as long as the module `std::vec` is interface-compatible with `collections::"
"vec`."
msgstr ""

#: src/0453-macro-reform.md:191
msgid ""
"(Actually the current libstd `vec!` is completely different for efficiency, "
"but it's just an example.)"
msgstr ""

#: src/0453-macro-reform.md:194
msgid ""
"Because macros are exported in crate metadata as strings, macro re-export "
"\"just works\" as soon as `$crate` is available.  It's implemented as part "
"of the `$crate` branch mentioned above."
msgstr ""

#: src/0453-macro-reform.md:198
msgid "`#[plugin]` attribute"
msgstr ""

#: src/0453-macro-reform.md:200
msgid ""
"`#[phase(plugin)]` becomes simply `#[plugin]` and is still feature-gated.  "
"It only controls whether to search for and run a plugin registrar function.  "
"The plugin itself will decide whether it's to be linked at runtime, by "
"calling a `Registry` method."
msgstr ""

#: src/0453-macro-reform.md:205
msgid ""
"`#[plugin]` can optionally take any [meta items](http://doc.rust-lang.org/"
"syntax/ast/enum.MetaItem_.html) as \"arguments\", e.g."
msgstr ""

#: src/0453-macro-reform.md:214
msgid ""
"rustc itself will not interpret these arguments, but will make them "
"available to the plugin through a `Registry` method.  This facilitates "
"plugin configuration.  The alternative in many cases is to use interacting "
"side effects between procedural macros, which are harder to reason about."
msgstr ""

#: src/0453-macro-reform.md:219
msgid "Syntax convention"
msgstr ""

#: src/0453-macro-reform.md:221
msgid ""
"`macro_rules!` already allows `{ }` for the macro body, but the convention "
"is `( )` for some reason.  In accepting this RFC we would change to a `{ }` "
"convention for consistency with the rest of the language."
msgstr ""

#: src/0453-macro-reform.md:225
msgid "Reserve `macro` as a keyword"
msgstr ""

#: src/0453-macro-reform.md:227
msgid ""
"A lot of the syntax alternatives discussed for this RFC involved a `macro` "
"keyword.  The consensus is that macros are too unfinished to merit using the "
"keyword now.  However, we should reserve it for a future macro system."
msgstr ""

#: src/0453-macro-reform.md:231
msgid "Implementation and transition"
msgstr ""

#: src/0453-macro-reform.md:233
msgid ""
"I will coordinate implementation of this RFC, and I expect to write most of "
"the code myself."
msgstr ""

#: src/0453-macro-reform.md:236
msgid ""
"To ease the transition, we can keep the old syntax as a deprecated synonym, "
"to be removed before 1.0."
msgstr ""

#: src/0453-macro-reform.md:239
msgid "Drawbacks"
msgstr ""

#: src/0453-macro-reform.md:241
msgid "This is big churn on a major feature, not long before 1.0."
msgstr ""

#: src/0453-macro-reform.md:243
msgid ""
"We can ship improved versions of `macro_rules!` in a back-compatible way (in "
"theory; I would like to smoke test this idea before 1.0).  So we could defer "
"much of this reform until after 1.0.  The main reason not to is macro import/"
"export.  Right now every macro you import will be expanded using your local "
"copy of `macro_rules!`, regardless of what the macro author had in mind."
msgstr ""

#: src/0453-macro-reform.md:249
msgid "Alternatives"
msgstr ""

#: src/0453-macro-reform.md:251
msgid ""
"We could try to implement proper hygienic capture of crate names in macros. "
"This would be wonderful, but I don't think we can get it done for 1.0."
msgstr ""

#: src/0453-macro-reform.md:254
msgid ""
"We would have to actually parse the macro RHS when it's defined, find all "
"the paths it wants to emit (somehow), and then turn each crate reference "
"within such a path into a globally unique thing that will still work when "
"expanded in another crate.  Right now libsyntax is oblivious to librustc's "
"name resolution rules, and those rules can't be applied until macro "
"expansion is done, because (for example) a macro can expand to a `use` item."
msgstr ""

#: src/0453-macro-reform.md:261
msgid ""
"nrc suggested dropping the `#![macro_escape]` functionality as part of this "
"reform.  Two ways this could work out:"
msgstr ""

#: src/0453-macro-reform.md:264
msgid ""
"_All_ macros are visible throughout the crate.  This seems bad; I depend on "
"module scoping to stay (marginally) sane when working with macros.  You can "
"have private helper macros in two different modules without worrying that "
"the names will clash."
msgstr ""

#: src/0453-macro-reform.md:269
msgid ""
"Only macros at the crate root are visible throughout the crate.  I'm also "
"against this because I like keeping `lib.rs` as a declarative description of "
"crates, modules, etc. without containing any actual code.  Forcing the "
"user's hand as to which file a particular piece of code goes in seems un-"
"Rusty."
msgstr ""

#: src/0453-macro-reform.md:275
msgid "Unresolved questions"
msgstr ""

#: src/0453-macro-reform.md:277
msgid ""
"Should we forbid `$crate` in non-exported macros?  It seems useless, however "
"I think we should allow it anyway, to encourage the habit of writing "
"`$crate::` for any references to the local crate."
msgstr ""

#: src/0453-macro-reform.md:281
msgid ""
"Should `#[macro_reexport]` support the \"glob\" behavior of `#[macro_use]` "
"with no names listed?"
msgstr ""

#: src/0453-macro-reform.md:284
msgid "Acknowledgements"
msgstr ""

#: src/0453-macro-reform.md:286
msgid ""
"This proposal is edited by Keegan McAllister.  It has been refined through "
"many engaging discussions with:"
msgstr ""

#: src/0453-macro-reform.md:289
msgid ""
"Brian Anderson, Shachaf Ben-Kiki, Lars Bergstrom, Nick Cameron, John "
"Clements, Alex Crichton, Cathy Douglass, Steven Fackler, Manish Goregaokar, "
"Dave Herman, Steve Klabnik, Felix S. Klock II, Niko Matsakis, Matthew "
"McPherrin, Paul Stansifer, Sam Tobin-Hochstadt, Erick Tryzelaar, Aaron "
"Turon, Huon Wilson, Brendan Zabarauskas, Cameron Zwarich"
msgstr ""

#: src/0453-macro-reform.md:290
msgid ""
"_GitHub_: `@bill-myers` `@blaenk` `@comex` `@glaebhoerl` `@Kimundi` "
"`@mitchmindtree` `@mitsuhiko` `@P1Start` `@petrochenkov` `@skinner`"
msgstr ""

#: src/0453-macro-reform.md:291
msgid ""
"_Reddit_: `gnusouth` `ippa` `!kibwen` `Mystor` `Quxxy` `rime-frost` "
"`Sinistersnare` `tejp` `UtherII` `yigal100`"
msgstr ""

#: src/0453-macro-reform.md:292
msgid "_IRC_: `bstrie` `ChrisMorgan` `cmr` `Earnestly` `eddyb` `tiffany`"
msgstr ""

#: src/0453-macro-reform.md:294
msgid ""
"My apologies if I've forgotten you, used an un-preferred name, or "
"accidentally categorized you as several different people.  Pull requests are "
"welcome :)"
msgstr ""
