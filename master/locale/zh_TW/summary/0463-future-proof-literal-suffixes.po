msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0463-future-proof-literal-suffixes.md:1
msgid "Start Date: 2014-09-28"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:2
msgid "RFC PR: [\\#463](https://github.com/rust-lang/rfcs/pull/463)"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:3
msgid "Rust Issue: [\\#19088](https://github.com/rust-lang/rust/issues/19088)"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:5
msgid "Summary"
msgstr "摘要"

#: src/0463-future-proof-literal-suffixes.md:7
msgid ""
"Include identifiers immediately after literals in the literal token to allow "
"future expansion, e.g. `\"foo\"bar` and a `1baz` are considered whole (but "
"semantically invalid) tokens, rather than two separate tokens `\"foo\"`, "
"`bar` and `1`, `baz` respectively. This allows future expansion of handling "
"literals without risking breaking (macro) code."
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:14
msgid "Motivation"
msgstr "動機"

#: src/0463-future-proof-literal-suffixes.md:16
msgid ""
"Currently a few kinds of literals (integers and floats) can have a fixed set "
"of suffixes and other kinds do not include any suffixes. The valid suffixes "
"on numbers are:"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:27
msgid ""
"Most things not in this list are just ignored and treated as an entirely "
"separate token (prefixes of `128` are errors: e.g. `1u12` has an error "
"`\"invalid int suffix\"`), and similarly any suffixes on other literals are "
"also separate tokens. For example:"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:34
msgid "// makes a tuple\n"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:39
#: src/0463-future-proof-literal-suffixes.md:40
msgid "\"suffix\""
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:43
#: src/0463-future-proof-literal-suffixes.md:44
#: src/0463-future-proof-literal-suffixes.md:100
#: src/0463-future-proof-literal-suffixes.md:101
msgid "\"{}\""
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:43
#: src/0463-future-proof-literal-suffixes.md:100
msgid "\"foo\""
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:44
#: src/0463-future-proof-literal-suffixes.md:101
msgid "'x'"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:45
msgid ""
"/*\n"
"output:\n"
"(1, 256)\n"
"(foo, suffix)\n"
"(x, suffix)\n"
"*/"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:54
msgid ""
"The compiler is eating the `1u` and then seeing the invalid suffix `256` and "
"so treating that as a separate token, and similarly for the string and "
"character literals. (This problem is only visible in macros, since that is "
"the only place where two literals/identifiers can be placed directly "
"adjacent.)"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:60
msgid ""
"This behaviour means we would be unable to expand the possibilities for "
"literals after freezing the language/macros, which would be unfortunate, "
"since [user defined literals in C++](http://en.cppreference.com/w/cpp/"
"language/user_literal) are reportedly very nice, proposals for \"bit data\" "
"would like to use types like `u1` and `u5` (e.g. [RFC PR 327](https://github."
"com/rust-lang/rfcs/pull/327)), and there are \"fringe\" types like [`f16`]"
"(http://en.wikipedia.org/wiki/Half-precision_floating-point_format), [`f128`]"
"(https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format) "
"and `u128` that have uses but are not common enough to warrant adding to the "
"language now."
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:73
msgid "Detailed design"
msgstr "詳細設計"

#: src/0463-future-proof-literal-suffixes.md:75
msgid ""
"The tokenizer will have grammar `literal: raw_literal identifier?` where "
"`raw_literal` covers strings, characters and numbers without suffixes (e.g. "
"`\"foo\"`, `'a'`, `1`, `0x10`)."
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:79
msgid ""
"Examples of \"valid\" literals after this change (that is, entities that "
"will be consumed as a single token):"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:82
msgid ""
"```\n"
"\"foo\"bar \"foo\"_baz\n"
"'a'x 'a'_y\n"
"\n"
"15u16 17i18 19f20 21.22f23\n"
"0b11u25 0x26i27 28.29e30f31\n"
"\n"
"123foo 0.0bar\n"
"```"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:92
msgid ""
"Placing a space between the letter of the suffix and the literal will cause "
"it to be parsed as two separate tokens, just like today. That is "
"`\"foo\"bar` is one token, `\"foo\" bar` is two tokens."
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:96
msgid "The example above would then be an error, something like:"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:99
msgid "// error: literal with unsupported size\n"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:100
#: src/0463-future-proof-literal-suffixes.md:101
msgid "// error: literal with unsupported suffix\n"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:104
msgid ""
"The above demonstrates that numeric suffixes could be special cased to "
"detect `u<...>` and `i<...>` to give more useful error messages."
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:107
msgid ""
"(The macro example there is definitely an error because it is using the "
"incorrectly-suffixed literals as `expr`s. If it was only handling them as a "
"token, i.e. `tt`, there is the possibility that it wouldn't have to be "
"illegal, e.g. `stringify!(1u256)` doesn't have to be illegal because the "
"`1u256` never occurs at runtime/in the type system.)"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:114
msgid "Drawbacks"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:116
msgid ""
"None beyond outlawing placing a literal immediately before a pattern, but "
"the current behaviour can easily be restored with a space: `123u 456`. (If a "
"macro is using this for the purpose of hacky generalised literals, the "
"unresolved question below touches on this.)"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:121
msgid "Alternatives"
msgstr "替代方案"

#: src/0463-future-proof-literal-suffixes.md:123
msgid ""
"Don't do this, or consider doing it for adjacent suffixes with an "
"alternative syntax, e.g. `10'bar` or `10$bar`."
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:126
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/0463-future-proof-literal-suffixes.md:128
msgid ""
"Should it be the parser or the tokenizer rejecting invalid suffixes? This is "
"effectively asking if it is legal for syntax extensions to be passed the raw "
"literals? That is, can a `foo` procedural syntax extension accept and handle "
"literals like `foo!(1u2)`?"
msgstr ""

#: src/0463-future-proof-literal-suffixes.md:133
msgid "Should this apply to all expressions, e.g. `(1 + 2)bar`?"
msgstr ""
