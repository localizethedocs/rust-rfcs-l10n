msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:45Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2580-ptr-meta.md:1
msgid "Feature Name: `ptr-meta`"
msgstr ""

#: src/2580-ptr-meta.md:2
msgid "Start Date: 2018-10-26"
msgstr ""

#: src/2580-ptr-meta.md:3
msgid "RFC PR: https://github.com/rust-lang/rfcs/pull/2580"
msgstr ""

#: src/2580-ptr-meta.md:4
msgid "Rust Issue: https://github.com/rust-lang/rust/issues/81513"
msgstr ""

#: src/2580-ptr-meta.md:6
msgid "Summary"
msgstr "摘要"

#: src/2580-ptr-meta.md:9
msgid "Add generic APIs that allow manipulating the metadata of fat pointers:"
msgstr ""

#: src/2580-ptr-meta.md:11
msgid "Naming the metadata’s type  (as an associated type)"
msgstr ""

#: src/2580-ptr-meta.md:12
msgid "Extracting metadata from a pointer"
msgstr ""

#: src/2580-ptr-meta.md:13
msgid "Reconstructing a pointer from a data pointer and metadata"
msgstr ""

#: src/2580-ptr-meta.md:14
msgid ""
"Representing vtables, the metadata for trait objects, as a type with some "
"limited API"
msgstr ""

#: src/2580-ptr-meta.md:16
msgid ""
"This RFC does _not_ propose a mechanism for defining custom dynamically-"
"sized types, but tries to stay compatible with future proposals that do."
msgstr ""

#: src/2580-ptr-meta.md:20
msgid "Background"
msgstr ""

#: src/2580-ptr-meta.md:23
msgid ""
"Typical high-level code doesn’t need to worry about fat pointers, a "
"reference `&Foo` “just works” whether or not `Foo` is a DST. But unsafe code "
"such as a custom collection library may want to access a fat pointer’s "
"components separately."
msgstr ""

#: src/2580-ptr-meta.md:28
msgid ""
"In Rust 1.11 we _removed_ a [`std::raw::Repr`](https://doc.rust-lang."
"org/1.10.0/std/raw/trait.Repr.html) trait and a [`std::raw::Slice`](https://"
"doc.rust-lang.org/1.10.0/std/raw/struct.Slice.html) type from the standard "
"library. `Slice` could be `transmute`d to a `&[U]` or `&mut [U]` reference "
"to a slice as it was guaranteed to have the same memory layout. This was "
"replaced with more specific and less wildly unsafe `std::slice::"
"from_raw_parts` and `std::slice::from_raw_parts_mut` functions, together "
"with `as_ptr` and `len` methods that extract each fat pointer component "
"separately."
msgstr ""

#: src/2580-ptr-meta.md:36
msgid ""
"For trait objects, where we still have an unstable `std::raw::TraitObject` "
"type that can only be used with `transmute`:"
msgstr ""

#: src/2580-ptr-meta.md:52
msgid "Motivation"
msgstr "動機"

#: src/2580-ptr-meta.md:55
msgid ""
"We now have APIs in Stable Rust to let unsafe code freely and reliably "
"manipulate slices, accessing the separate components of a fat pointers and "
"then re-assembling them. However `std::raw::TraitObject` is still unstable, "
"but it’s probably not the style of API that we’ll want to stabilize as it "
"encourages dangerous `transmute` calls. This is a “hole” in available APIs "
"to manipulate existing Rust types."
msgstr ""

#: src/2580-ptr-meta.md:62
msgid ""
"For example [this library](https://play.rust-lang.org/?"
"version=nightly&mode=debug&edition=2015&gist=bbeecccc025f5a7a0ad06086678e13f3) "
"stores multiple trait objects of varying size in contiguous memory together "
"with their vtable pointers, and during iteration recreates fat pointers from "
"separate data and vtable pointers."
msgstr ""

#: src/2580-ptr-meta.md:66
msgid ""
"The new `Thin` trait alias also expanding to [extern types](https://github."
"com/rust-lang/rust/issues/43467) some APIs that were unnecessarily "
"restricted to `Sized` types because there was previously no way to express "
"pointer-thinness in generic code."
msgstr ""

#: src/2580-ptr-meta.md:73
msgid "Guide-level explanation"
msgstr ""

#: src/2580-ptr-meta.md:77
msgid ""
"Let’s build generic type similar to `Box<dyn Trait>`, but where the vtable "
"pointer is stored in heap memory next to the value so that the pointer is "
"thin. First, let’s get some boilerplate out of the way:"
msgstr ""

#: src/2580-ptr-meta.md:100
msgid ""
"Since [unsized rvalues](https://github.com/rust-lang/rust/issues/48055) are "
"not implemented yet, our constructor is going to “unsize” from a concrete "
"type that implements our trait. The `Unsize` bound ensures we can cast from "
"`&S` to a `&Dyn` trait object and construct the appropriate metadata."
msgstr ""

#: src/2580-ptr-meta.md:107
msgid "We let `Box` do the memory layout computation and allocation:"
msgstr ""

#: src/2580-ptr-meta.md:119
msgid ""
"(Another possible constructor is `pub fn new_copy(value: &Dyn) where Dyn: "
"Copy`, but it would involve slightly more code.)"
msgstr ""

#: src/2580-ptr-meta.md:122
msgid "Accessing the value requires knowing its alignment:"
msgstr ""

#: src/2580-ptr-meta.md:135
msgid ""
"/// <https://github.com/rust-lang/rust/blob/1.30.0/src/libcore/alloc.rs#L199-"
"L219>\n"
msgstr ""

#: src/2580-ptr-meta.md:140
msgid "// Similarly Deref\n"
msgstr ""

#: src/2580-ptr-meta.md:151
msgid ""
"Finally, in `Drop` we may not be able to take advantage of `Box` again since "
"the original `Sized` type `S` is not statically known at this point."
msgstr ""

#: src/2580-ptr-meta.md:158
msgid "/* left as an exercise for the reader */"
msgstr ""

#: src/2580-ptr-meta.md:167
msgid "Reference-level explanation"
msgstr ""

#: src/2580-ptr-meta.md:170
msgid ""
"The APIs whose full definition is found below are added to `core::ptr` and "
"re-exported in `std::ptr`:"
msgstr ""

#: src/2580-ptr-meta.md:173
msgid ""
"A `Pointee` trait, implemented automatically for all types (similar to how "
"`Sized` and `Unsize` are implemented automatically)."
msgstr ""

#: src/2580-ptr-meta.md:176
msgid ""
"A `Thin` [trait alias](https://github.com/rust-lang/rust/issues/41517). If "
"this RFC is implemented before type aliases are, uses of `Thin` should be "
"replaced with its definition."
msgstr ""

#: src/2580-ptr-meta.md:179
msgid "A `metadata` free function"
msgstr ""

#: src/2580-ptr-meta.md:180
msgid "A `DynMetadata` struct"
msgstr ""

#: src/2580-ptr-meta.md:181
msgid ""
"A `from_raw_parts` constructor for each of `*const T`, `*mut T`, and "
"`NonNull<T>`."
msgstr ""

#: src/2580-ptr-meta.md:183
msgid ""
"The bounds on `null()` and `null_mut()` function in that same module as well "
"as the `NonNull::dangling` constructor are changed from (implicit) `T: "
"Sized` to `T: ?Sized + Thin`. Similarly for the `U` type parameter of the "
"`NonNull::cast` method. This enables using those functions with [extern "
"types](https://github.com/rust-lang/rust/issues/43467)."
msgstr ""

#: src/2580-ptr-meta.md:189
msgid ""
"The `Pointee` trait is implemented for all types. This can be relied on in "
"generic code, even if a type parameter `T` does not have an explicit `T: "
"Pointee` bound. This is similar to how the `Any` trait can be used without "
"an explicit `T: Any` bound, only `T: 'static`, because a blanket `impl<T: "
"'static> Any for T {…}` exists. (Except that `Pointee` is not restricted to "
"`'static`.)"
msgstr ""

#: src/2580-ptr-meta.md:196
msgid ""
"For the purpose of pointer casts being allowed by the `as` operator, a "
"pointer to `T` is considered to be thin if `T: Thin` instead of `T: Sized`. "
"This similarly includes extern types."
msgstr ""

#: src/2580-ptr-meta.md:200
msgid ""
"`std::raw::TraitObject` and `std::raw` are deprecated and eventually removed."
msgstr ""

#: src/2580-ptr-meta.md:206
msgid ""
"/// This trait is automatically implemented for every type.\n"
"///\n"
"/// Raw pointer types and reference types in Rust can be thought of as made "
"of two parts:\n"
"/// a data pointer that contains the memory address of the value, and some "
"metadata.\n"
"///\n"
"/// For statically-sized types (that implement the `Sized` traits)\n"
"/// as well as for `extern` types,\n"
"/// pointers are said to be “thin”: metadata is zero-sized and its type is "
"`()`.\n"
"///\n"
"/// Pointers to [dynamically-sized types][dst] are said to be “fat”\n"
"/// and have non-zero-sized metadata:\n"
"///\n"
"/// * For structs whose last field is a DST, metadata is the metadata for "
"the last field\n"
"/// * For the `str` type, metadata is the length in bytes as `usize`\n"
"/// * For slice types like `[T]`, metadata is the length in items as "
"`usize`\n"
"/// * For trait objects like `dyn SomeTrait`, metadata is "
"[`DynMetadata<Self>`][DynMetadata]\n"
"///   (e.g. `DynMetadata<dyn SomeTrait>`).\n"
"///\n"
"/// In the future, the Rust language may gain new kinds of types\n"
"/// that have different pointer metadata.\n"
"///\n"
"/// Pointer metadata can be extracted from a pointer or reference with the "
"[`metadata`] function.\n"
"/// The data pointer can be extracted by casting a (fat) pointer\n"
"/// to a (thin) pointer to a `Sized` type with the `as` operator,\n"
"/// for example `(x: &dyn SomeTrait) as *const SomeTrait as *const ()`\n"
"/// or `(x: *const dyn SomeTrait).cast::<()>()`.\n"
"///\n"
"/// [dst]: https://doc.rust-lang.org/nomicon/exotic-sizes.html#dynamically-"
"sized-types-dsts\n"
msgstr ""

#: src/2580-ptr-meta.md:234
msgid "\"pointee\""
msgstr ""

#: src/2580-ptr-meta.md:236
msgid "/// The type for metadata in pointers and references to `Self`.\n"
msgstr ""

#: src/2580-ptr-meta.md:239
msgid ""
"/// Pointers to types implementing this trait alias are “thin”:\n"
"///\n"
"/// ```rust\n"
"/// fn this_never_panics<T: std::ptr::Thin>() {\n"
"///     assert_eq!(std::mem::size_of::<&T>(), std::mem::size_of::<usize>())\n"
"/// }\n"
"/// ```\n"
msgstr ""

#: src/2580-ptr-meta.md:248
msgid ""
"/// Extract the metadata component of a pointer.\n"
"///\n"
"/// Values of type `*mut T`, `&T`, or `&mut T` can be passed directly to "
"this function\n"
"/// as they implicitly coerce to `*const T`.\n"
"/// For example:\n"
"///\n"
"/// ```\n"
"/// assert_eq(std::ptr::metadata(\"foo\"), 3_usize);\n"
"/// ```\n"
"///\n"
"/// Note that the data component of a (fat) pointer can be extracted by "
"casting\n"
"/// to a (thin) pointer to any `Sized` type:\n"
"///\n"
"/// ```\n"
"/// # trait SomeTrait {}\n"
"/// # fn example(something: &SomeTrait) {\n"
"/// let object: &SomeTrait = something;\n"
"/// let data_ptr = object as *const SomeTrait as *const ();\n"
"/// # }\n"
"/// ```\n"
msgstr ""

#: src/2580-ptr-meta.md:286
msgid ""
"/// The metadata for a `DynTrait = dyn SomeTrait` trait object type.\n"
"///\n"
"/// It is a pointer to a vtable (virtual call table)\n"
"/// that represents all the necessary information\n"
"/// to manipulate the concrete type stored inside a trait object.\n"
"/// The vtable notably it contains:\n"
"///\n"
"/// * type size\n"
"/// * type alignment\n"
"/// * a pointer to the type’s `drop_in_place` impl (may be a no-op for plain-"
"old-data)\n"
"/// * pointers to all the methods for the type’s implementation of the "
"trait\n"
"///\n"
"/// Note that the first three are special because they’re necessary to "
"allocate, drop,\n"
"/// and deallocate any trait object.\n"
"///\n"
"/// It is possible to name this struct with a type parameter that is not a "
"`dyn` trait object\n"
"/// (for example `DynMetadata<u64>`) but not to obtain a meaningful value of "
"that struct.\n"
msgstr ""

#: src/2580-ptr-meta.md:306
msgid "// Private fields\n"
msgstr ""

#: src/2580-ptr-meta.md:312
msgid "/// Returns the size of the type associated with this vtable.\n"
msgstr ""

#: src/2580-ptr-meta.md:315
msgid "/// Returns the alignment of the type associated with this vtable.\n"
msgstr ""

#: src/2580-ptr-meta.md:318
msgid "/// Returns the size and alignment together as a `Layout`\n"
msgstr ""

#: src/2580-ptr-meta.md:328
msgid "Rationale and alternatives"
msgstr ""

#: src/2580-ptr-meta.md:331
msgid ""
"The status quo is that code (such as linked in [Motivation](#motivation)) "
"that requires this functionality needs to transmute to and from `std::raw::"
"TraitObject` or a copy of it (to be compatible with Stable Rust). "
"Additionally, in cases where constructing the data pointer requires knowing "
"the alignment of the concrete type, a dangling pointer such as "
"`0x8000_0000_usize as *mut ()` needs to be created. It is not clear whether "
"`std::mem::align_of(&*ptr)` with `ptr: *const dyn SomeTrait` is Undefined "
"Behavior with a dangling data pointer."
msgstr ""

#: src/2580-ptr-meta.md:340
msgid ""
"A [previous iteration](https://github.com/rust-lang/rfcs/pull/2579) of this "
"RFC proposed a `DynTrait` that would only be implemented for trait objects "
"like `dyn SomeTrait`. There would be no `Metadata` associated type, "
"`DynMetadata` was hard-coded in the trait. In addition to being more general "
"and (hopefully) more compatible with future custom DSTs proposals, this RFC "
"resolves the question of what happens if trait objects with super-fat "
"pointers with multiple vtable pointers are ever added. (Answer: they can use "
"a different metadata type, possibly like `(DynMetadata<dyn Trait>, "
"DynMetadata<dyn OtherTrait>)`.)"
msgstr ""

#: src/2580-ptr-meta.md:353
msgid "Prior art"
msgstr ""

#: src/2580-ptr-meta.md:356
msgid ""
"A previous [Custom Dynamically-Sized Types](https://github.com/rust-lang/"
"rfcs/pull/1524) RFC was postponed. [Internals thread #6663](https://"
"internals.rust-lang.org/t/pre-erfc-lets-fix-dsts/6663) took the same ideas "
"and was even more ambitious in being very general. Except for "
"`DynMetadata`’s methods, this RFC proposes a subset of what that thread did."
msgstr ""

#: src/2580-ptr-meta.md:365
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/2580-ptr-meta.md:368
msgid ""
"The name of `Pointee`. [Internals thread #6663](https://internals.rust-lang."
"org/t/pre-erfc-lets-fix-dsts/6663) used `Referent`."
msgstr ""

#: src/2580-ptr-meta.md:370
msgid ""
"The location of `DynMetadata`. Is another module more appropriate than `std::"
"ptr`?"
msgstr ""

#: src/2580-ptr-meta.md:372
msgid ""
"Should `DynMetadata` not have a type parameter? This might reduce "
"monomorphization cost, but would force that the size, alignment, and "
"destruction pointers be in the same location (offset) for every vtable. But "
"keeping them in the same location is probably desirable anyway to keep code "
"size small."
msgstr ""

#: src/2580-ptr-meta.md:378
msgid ""
"The name of `Thin`. This name is short and sweet but `T: Thin` suggests that "
"`T` itself is thin, rather than pointers and references to `T`."
msgstr ""

#: src/2580-ptr-meta.md:382
msgid "The location of `Thin`. Better in `std::marker`?"
msgstr ""

#: src/2580-ptr-meta.md:384
msgid ""
"Should `Thin` be added as a supertrait of `Sized`? Or could it ever make "
"sense to have fat pointers to statically-sized types?"
msgstr ""

#: src/2580-ptr-meta.md:387
msgid ""
"Are there other generic standard library APIs like `ptr::null()` that have "
"an (implicit) `T: Sized` bound that unnecessarily excludes extern types?"
msgstr ""

#: src/2580-ptr-meta.md:390
msgid "Should `<*mut _>::from_raw_parts` and friends be `unsafe fn`s?"
msgstr ""

#: src/2580-ptr-meta.md:392
msgid ""
"API design: free functions v.s. methods/constructors on `*mut _` and `*const "
"_`?"
msgstr ""

#: src/2580-ptr-meta.md:394
msgid ""
"Add `into_raw_parts` that returns `(*const (), T::Metadata)`? Using the "
"`cast` method to a `Sized` type to extract the address as a thin pointer is "
"less discoverable. Possibly _instead_ of the metadata function?"
msgstr ""
