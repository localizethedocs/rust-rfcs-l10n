msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0068-const-unsafe-pointers.md:1
msgid "Start Date: 2014-06-11"
msgstr ""

#: src/0068-const-unsafe-pointers.md:2
msgid "RFC PR: [rust-lang/rfcs#68](https://github.com/rust-lang/rfcs/pull/68)"
msgstr ""

#: src/0068-const-unsafe-pointers.md:3
msgid ""
"Rust Issue: [rust-lang/rust#7362](https://github.com/rust-lang/rust/"
"issues/7362)"
msgstr ""
"Rust 議題：[rust-lang/rust#7362](https://github.com/rust-lang/rust/"
"issues/7362)"

#: src/0068-const-unsafe-pointers.md:5
msgid "Summary"
msgstr "摘要"

#: src/0068-const-unsafe-pointers.md:7
msgid ""
"Rename `*T` to `*const T`, retain all other semantics of unsafe pointers."
msgstr ""

#: src/0068-const-unsafe-pointers.md:9
msgid "Motivation"
msgstr "動機"

#: src/0068-const-unsafe-pointers.md:11
msgid ""
"Currently the `T*` type in C is equivalent to `*mut T` in Rust, and the "
"`const T*` type in C is equivalent to the `*T` type in Rust. Noticeably, the "
"two most similar types, `T*` and `*T` have different meanings in Rust and C, "
"frequently causing confusion and often incorrect declarations of C functions."
msgstr ""

#: src/0068-const-unsafe-pointers.md:16
msgid ""
"If the compiler is ever to take advantage of the guarantees of declaring an "
"FFI function as taking `T*` or `const T*` (in C), then it is crucial that "
"the FFI declarations in Rust are faithful to the declaration in C."
msgstr ""

#: src/0068-const-unsafe-pointers.md:20
msgid ""
"The current difference in Rust unsafe pointers types with C pointers types "
"is proving to be too error prone to realistically enable these optimizations "
"at a future date. By renaming Rust's unsafe pointers to closely match their "
"C brethren, the likelihood for erroneously transcribing a signature is "
"diminished."
msgstr ""

#: src/0068-const-unsafe-pointers.md:25
msgid "Detailed design"
msgstr "詳細設計"

#: src/0068-const-unsafe-pointers.md:27
msgid ""
"This section will assume that the current unsafe pointer design is forgotten "
"completely, and will explain the unsafe pointer design from scratch."
msgstr ""

#: src/0068-const-unsafe-pointers.md:30
msgid ""
"There are two unsafe pointers in rust, `*mut T` and `*const T`. These two "
"types are primarily useful when interacting with foreign functions through a "
"FFI. The `*mut T` type is equivalent to the `T*` type in C, and the `*const "
"T` type is equivalent to the `const T*` type in C."
msgstr ""

#: src/0068-const-unsafe-pointers.md:35
msgid ""
"The type `&mut T` will automatically coerce to `*mut T` in the normal "
"locations that coercion occurs today. It will also be possible to explicitly "
"cast with an `as` expression. Additionally, the `&T` type will automatically "
"coerce to `*const T`.  Note that `&mut T` will not automatically coerce to "
"`*const T`."
msgstr ""

#: src/0068-const-unsafe-pointers.md:40
msgid ""
"The two unsafe pointer types will be freely castable among one another via "
"`as` expressions, but no coercion will occur between the two. Additionally, "
"values of type `uint` can be casted to unsafe pointers."
msgstr ""

#: src/0068-const-unsafe-pointers.md:44
msgid "When is a coercion valid?"
msgstr ""

#: src/0068-const-unsafe-pointers.md:46
msgid ""
"When coercing from `&'a T` to `*const T`, Rust will guarantee that the "
"memory will remain valid for the lifetime `'a` and the memory will be "
"immutable up to memory stored in `Unsafe<U>`. It is the responsibility of "
"the code working with the `*const T` that the pointer is only dereferenced "
"in the lifetime `'a`."
msgstr ""

#: src/0068-const-unsafe-pointers.md:51
msgid ""
"When coercing from `&'a mut T` to `*mut T`, Rust will guarantee that the "
"memory will stay valid during `'a` and that the memory will _not be "
"accessed_ during `'a`. Additionally, Rust will _consume_ the `&'a mut T` "
"during the coercion. It is the responsibility of the code working with the "
"`*mut T` to guarantee that the unsafe pointer is only dereferenced in the "
"lifetime `'a`, and that the memory is \"valid again\" after `'a`."
msgstr ""

#: src/0068-const-unsafe-pointers.md:58
msgid ""
"**Note**: Rust will consume `&mut T` coercions with both implicit and "
"explicit coercions."
msgstr ""

#: src/0068-const-unsafe-pointers.md:61
msgid ""
"The term \"valid again\" is used to represent that some types in Rust "
"require internal invariants, such as `Box<T>` never being `NULL`. This is "
"often a per-type invariant, so it is the responsibility of the unsafe code "
"to uphold these invariants."
msgstr ""

#: src/0068-const-unsafe-pointers.md:66
msgid "When is a safe cast valid?"
msgstr ""

#: src/0068-const-unsafe-pointers.md:68
msgid ""
"Unsafe code can convert an unsafe pointer to a safe pointer via "
"dereferencing inside of an unsafe block. This section will discuss when this "
"action is valid."
msgstr ""

#: src/0068-const-unsafe-pointers.md:71
msgid ""
"When converting `*mut T` to `&'a mut T`, it must be guaranteed that the "
"memory is initialized to start out with and that nobody will access the "
"memory during `'a` except for the converted pointer."
msgstr ""

#: src/0068-const-unsafe-pointers.md:75
msgid ""
"When converting `*const T` to `&'a T`, it must be guaranteed that the memory "
"is initialized to start out with and that nobody will write to the pointer "
"during `'a` except for memory within `Unsafe<U>`."
msgstr ""

#: src/0068-const-unsafe-pointers.md:79
msgid "Drawbacks"
msgstr ""

#: src/0068-const-unsafe-pointers.md:81
msgid ""
"Today's unsafe pointers design is consistent with the borrowed pointers "
"types in Rust, using the `mut` qualifier for a mutable pointer, and no "
"qualifier for an \"immutable\" pointer. Renaming the pointers would be "
"divergence from this consistency, and would also introduce a keyword that is "
"not used elsewhere in the language, `const`."
msgstr ""

#: src/0068-const-unsafe-pointers.md:87
msgid "Alternatives"
msgstr ""

#: src/0068-const-unsafe-pointers.md:89
msgid ""
"The current `*mut T` type could be removed entirely, leaving only one unsafe "
"pointer type, `*T`. This will not allow FFI calls to take advantage of the "
"`const T*` optimizations on the caller side of the function. Additionally, "
"this may not accurately express to the programmer what a FFI API is "
"intending to do. Note, however, that other variants of unsafe pointer types "
"could likely be added in the future in a backwards-compatible way."
msgstr ""

#: src/0068-const-unsafe-pointers.md:96
msgid ""
"More effort could be invested in auto-generating bindings, and hand-"
"generating bindings could be greatly discouraged. This would maintain "
"consistency with Rust pointer types, and it would allow APIs to usually "
"being transcribed accurately by automating the process. It is unknown how "
"realistic this solution is as it is currently not yet implemented. There may "
"still be confusion as well that `*T` is not equivalent to C's `T*`."
msgstr ""

#: src/0068-const-unsafe-pointers.md:103
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/0068-const-unsafe-pointers.md:105
msgid ""
"How much can the compiler help out when coercing `&mut T` to `*mut T`? As "
"previously stated, the source pointer `&mut T` is consumed during the "
"coercion (it's already a linear type), but this can lead to some unexpected "
"results:"
msgstr ""

#: src/0068-const-unsafe-pointers.md:120
msgid ""
"This code is invalid because it is creating two copies of the same mutable "
"pointer, and the external function is unaware that the two pointers alias. "
"The rule that the programmer has violated is that the pointer `*mut T` is "
"only dereferenced during the lifetime of the `&'a mut T` pointer. For "
"example, here are the lifetimes spelled out:"
msgstr ""

#: src/0068-const-unsafe-pointers.md:126
msgid ""
"    fn foo(a: &mut int) {\n"
"        unsafe {\n"
"            bar(&mut *a, &mut *a);\n"
"    //          |-----|  |-----|\n"
"    //             |        |\n"
"    //             |       Lifetime of second argument\n"
"    //            Lifetime of first argument\n"
"        }\n"
"    }\n"
"    "
msgstr ""

#: src/0068-const-unsafe-pointers.md:136
msgid ""
"Here it can be seen that it is impossible for the C code to safely "
"dereference the pointers passed in because lifetimes don't extend into the "
"function call itself. The compiler could, in this case, _extend the "
"lifetime_ of a coerced pointer to follow the otherwise applied temporary "
"rules for expressions."
msgstr ""

#: src/0068-const-unsafe-pointers.md:141
msgid ""
"In the example above, the compiler's temporary lifetime rules would cause "
"the first coercion to last for the entire lifetime of the call to `bar`, "
"thereby disallowing the second reborrow because it has an overlapping "
"lifetime with the first."
msgstr ""

#: src/0068-const-unsafe-pointers.md:146
msgid ""
"It is currently an open question how necessary this sort of treatment will "
"be, and this lifetime treatment will likely require a new RFC."
msgstr ""

#: src/0068-const-unsafe-pointers.md:149
msgid ""
"Will all pointer types in C need to have their own keyword in Rust for "
"representation in the FFI?"
msgstr ""

#: src/0068-const-unsafe-pointers.md:152
msgid ""
"To what degree will the compiler emit metadata about FFI function calls in "
"order to take advantage of optimizations on the caller side of a function "
"call? Do the theoretical wins justify the scope of this redesign? There is "
"currently no concrete data measuring what benefits could be gained from "
"informing optimization passes about const vs non-const pointers."
msgstr ""
