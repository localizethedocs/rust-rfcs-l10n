msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:03Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1199-simd-infrastructure.md:1
msgid "Feature Name: repr_simd, platform_intrinsics, cfg_target_feature"
msgstr ""

#: src/1199-simd-infrastructure.md:2
msgid "Start Date: 2015-06-02"
msgstr ""

#: src/1199-simd-infrastructure.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1199](https://github.com/rust-lang/rfcs/pull/1199)"
msgstr ""

#: src/1199-simd-infrastructure.md:4
msgid ""
"Rust Issue: [rust-lang/rust#27731](https://github.com/rust-lang/rust/"
"issues/27731)"
msgstr ""

#: src/1199-simd-infrastructure.md:6
msgid "Summary"
msgstr "摘要"

#: src/1199-simd-infrastructure.md:8
msgid "Lay the ground work for building powerful SIMD functionality."
msgstr ""

#: src/1199-simd-infrastructure.md:10
msgid "Motivation"
msgstr "動機"

#: src/1199-simd-infrastructure.md:12
msgid ""
"SIMD (Single-Instruction Multiple-Data) is an important part of performant "
"modern applications. Most CPUs used for that sort of task provide dedicated "
"hardware and instructions for operating on multiple values in a single "
"instruction, and exposing this is an important part of being a low-level "
"language."
msgstr ""

#: src/1199-simd-infrastructure.md:18
msgid ""
"This RFC lays the ground-work for building nice SIMD functionality, but "
"doesn't fill everything out. The goal here is to provide the raw types and "
"access to the raw instructions on each platform."
msgstr ""

#: src/1199-simd-infrastructure.md:22
msgid ""
"(An earlier variant of this RFC was discussed as a [pre-RFC](https://"
"internals.rust-lang.org/t/pre-rfc-simd-groundwork/2343).)"
msgstr ""

#: src/1199-simd-infrastructure.md:25
msgid "Where does this code go? Aka. why not in `std`?"
msgstr ""

#: src/1199-simd-infrastructure.md:27
msgid ""
"This RFC is focused on building stable, powerful SIMD functionality in "
"external crates, not `std`."
msgstr ""

#: src/1199-simd-infrastructure.md:30
msgid ""
"This makes it much easier to support functionality only \"occasionally\" "
"available with Rust's preexisting `cfg` system. There's no way for `std` to "
"conditionally provide an API based on the target features used for the final "
"artifact. Building `std` in every configuration is certainly untenable. "
"Hence, if it were to be in `std`, there would need to be some highly delayed "
"`cfg` system to support that sort of conditional API exposure."
msgstr ""

#: src/1199-simd-infrastructure.md:38
msgid ""
"With an external crate, we can leverage `cargo`'s existing build "
"infrastructure: compiling with some target features will rebuild with those "
"features enabled."
msgstr ""

#: src/1199-simd-infrastructure.md:43
msgid "Detailed design"
msgstr "詳細設計"

#: src/1199-simd-infrastructure.md:45
msgid "The design comes in three parts, all on the path to stabilisation:"
msgstr ""

#: src/1199-simd-infrastructure.md:47
msgid "types (`feature(repr_simd)`)"
msgstr ""

#: src/1199-simd-infrastructure.md:48
msgid "operations (`feature(platform_intrinsics)`)"
msgstr ""

#: src/1199-simd-infrastructure.md:49
msgid "platform detection (`feature(cfg_target_feature)`)"
msgstr ""

#: src/1199-simd-infrastructure.md:51
msgid ""
"The general idea is to avoid bad performance cliffs, so that an intrinsic "
"call in Rust maps to preferably one CPU instruction, or, if not, the "
"\"optimal\" sequence required to do the given operation anyway. This means "
"exposing a _lot_ of platform specific details, since platforms behave very "
"differently: both across architecture families (x86, x86-64, ARM, "
"MIPS, ...), and even within a family (x86-64's Skylake, Haswell, "
"Nehalem, ...)."
msgstr ""

#: src/1199-simd-infrastructure.md:59
msgid ""
"There is definitely a common core of SIMD functionality shared across many "
"platforms, but this RFC doesn't try to extract that, it is just building "
"tools that can be wrapped into a more uniform API later."
msgstr ""

#: src/1199-simd-infrastructure.md:64
msgid "Types"
msgstr ""

#: src/1199-simd-infrastructure.md:66
msgid "There is a new attribute: `repr(simd)`."
msgstr ""

#: src/1199-simd-infrastructure.md:76
msgid ""
"The `simd` `repr` can be attached to a struct and will cause such a struct "
"to be compiled to a SIMD vector. It can be generic, but it is required that "
"any fully monomorphised instance of the type consist of only a single "
"\"primitive\" type, repeated some number of times."
msgstr ""

#: src/1199-simd-infrastructure.md:81
msgid ""
"The `repr(simd)` may not enforce that any trait bounds exists/does the right "
"thing at the type checking level for generic `repr(simd)` types. As such, it "
"will be possible to get the code-generator to error out (ala the old "
"`transmute` size errors), however, this shouldn't cause problems in "
"practice: libraries wrapping this functionality would layer type-safety on "
"top (i.e. generic `repr(simd)` types would use some `unsafe` trait as a "
"bound that is designed to only be implemented by types that will work)."
msgstr ""

#: src/1199-simd-infrastructure.md:90
msgid ""
"Adding `repr(simd)` to a type may increase its minimum/preferred alignment, "
"based on platform behaviour. (E.g. x86 wants its 128-bit SSE vectors to be "
"128-bit aligned.)"
msgstr ""

#: src/1199-simd-infrastructure.md:94
msgid "Operations"
msgstr ""

#: src/1199-simd-infrastructure.md:96
msgid ""
"CPU vendors usually offer \"standard\" C headers for their CPU specific "
"operations, such as [`arm_neon.h`](http://infocenter.arm.com/help/topic/com."
"arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf) and [the `...mmintrin."
"h` headers for x86(-64)](https://software.intel.com/sites/landingpage/"
"IntrinsicsGuide)."
msgstr ""

#: src/1199-simd-infrastructure.md:103
msgid ""
"All of these would be exposed as compiler intrinsics with names very similar "
"to those that the vendor suggests (only difference would be some form of "
"manual namespacing, e.g. prefixing with the CPU target), loadable via an "
"`extern` block with an appropriate ABI. This subset of intrinsics would be "
"on the path to stabilisation (that is, one can \"import\" them with `extern` "
"in stable code), and would not be exported by `std`."
msgstr ""

#: src/1199-simd-infrastructure.md:111
msgid "Example:"
msgstr ""

#: src/1199-simd-infrastructure.md:114 src/1199-simd-infrastructure.md:141
#: src/1199-simd-infrastructure.md:192 src/1199-simd-infrastructure.md:226
#: src/1199-simd-infrastructure.md:242 src/1199-simd-infrastructure.md:263
msgid "\"platform-intrinsic\""
msgstr ""

#: src/1199-simd-infrastructure.md:116 src/1199-simd-infrastructure.md:197
#: src/1199-simd-infrastructure.md:266
msgid "// ...\n"
msgstr ""

#: src/1199-simd-infrastructure.md:120
msgid ""
"These all use entirely concrete types, and this is the core interface to "
"these intrinsics: essentially it is just allowing code to exactly specify a "
"CPU instruction to use. These intrinsics only actually work on a subset of "
"the CPUs that Rust targets, and will result in compile time errors if they "
"are called on platforms that do not support them. The signatures are "
"typechecked, but in a \"duck-typed\" manner: it will just ensure that the "
"types are SIMD vectors with the appropriate length and element type, it will "
"not enforce a specific nominal type."
msgstr ""

#: src/1199-simd-infrastructure.md:129
msgid ""
"NB. The structural typing is just for the declaration: if a SIMD intrinsic "
"is declared to take a type `X`, it must always be called with `X`, even if "
"other types are structurally equal to `X`. Also, within a signature, SIMD "
"types that must be structurally equal must be nominally equal. I.e. if the "
"`add_...` all refer to the same intrinsic to add a SIMD vector of bytes,"
msgstr ""

#: src/1199-simd-infrastructure.md:137
msgid "// (same length)\n"
msgstr ""

#: src/1199-simd-infrastructure.md:142 src/1199-simd-infrastructure.md:143
msgid "// ok\n"
msgstr ""

#: src/1199-simd-infrastructure.md:144
msgid "// error, expected B, found A\n"
msgstr ""

#: src/1199-simd-infrastructure.md:145 src/1199-simd-infrastructure.md:152
msgid "// error, expected A, found B\n"
msgstr ""

#: src/1199-simd-infrastructure.md:156
msgid ""
"There would additionally be a small set of cross-platform operations that "
"are either generally efficiently supported everywhere or are extremely "
"useful. These won't necessarily map to a single instruction, but will be "
"shimmed as efficiently as possible."
msgstr ""

#: src/1199-simd-infrastructure.md:161
msgid "shuffles and extracting/inserting elements"
msgstr ""

#: src/1199-simd-infrastructure.md:162
msgid "comparisons"
msgstr ""

#: src/1199-simd-infrastructure.md:163
msgid "arithmetic"
msgstr ""

#: src/1199-simd-infrastructure.md:164
msgid "conversions"
msgstr ""

#: src/1199-simd-infrastructure.md:166
msgid ""
"All of these intrinsics are imported via an `extern` directive similar to "
"the process for pre-existing intrinsics like `transmute`, however, the SIMD "
"operations are provided under a special ABI: `platform-intrinsic`. Use of "
"this ABI (and hence the intrinsics) is initially feature-gated under the "
"`platform_intrinsics` feature name. Why `platform-intrinsic` rather than say "
"`simd-intrinsic`? There are non-SIMD platform-specific instructions that may "
"be nice to expose (for example, Intel defines an `_addcarry_u32` intrinsic "
"corresponding to the `ADC` instruction)."
msgstr ""

#: src/1199-simd-infrastructure.md:176
msgid "Shuffles & element operations"
msgstr ""

#: src/1199-simd-infrastructure.md:178
msgid ""
"One of the most powerful features of SIMD is the ability to rearrange data "
"within vectors, giving super-linear speed-ups sometimes. As such, shuffles "
"are exposed generally: intrinsics that represent arbitrary shuffles."
msgstr ""

#: src/1199-simd-infrastructure.md:183
msgid ""
"This may violate the \"one instruction per intrinsic\" principal depending "
"on the shuffle, but rearranging SIMD vectors is extremely useful, and "
"providing a direct intrinsic lets the compiler (a) do the programmers work "
"in synthesising the optimal (short) sequence of instructions to get a given "
"shuffle and (b) track data through shuffles without having to understand all "
"the details of every platform specific intrinsic for shuffling."
msgstr ""

#: src/1199-simd-infrastructure.md:201
msgid ""
"The raw definitions are only checked for validity at monomorphisation time, "
"ensure that `T` and `U` are SIMD vector with the same element type, `U` has "
"the appropriate length etc. Libraries can use traits to ensure that these "
"will be enforced by the type checker too."
msgstr ""

#: src/1199-simd-infrastructure.md:206
msgid ""
"This approach has similar type \"safety\"/code-generation errors to the "
"vectors themselves."
msgstr ""

#: src/1199-simd-infrastructure.md:209
msgid "These operations are semantically:"
msgstr ""

#: src/1199-simd-infrastructure.md:212
msgid "// vector of double length\n"
msgstr ""

#: src/1199-simd-infrastructure.md:218
msgid ""
"The index array `idx` has to be compile time constants. Out of bounds "
"indices yield errors."
msgstr ""

#: src/1199-simd-infrastructure.md:221
msgid ""
"Similarly, intrinsics for inserting/extracting elements into/out of vectors "
"are provided, to allow modelling the SIMD vectors as actual CPU registers as "
"much as possible:"
msgstr ""

#: src/1199-simd-infrastructure.md:232
msgid ""
"The `i0` indices do not have to be constant. These are equivalent to `v[i0] "
"= elem` and `v[i0]` respectively. They are type checked similarly to the "
"shuffles."
msgstr ""

#: src/1199-simd-infrastructure.md:236
msgid "Comparisons"
msgstr ""

#: src/1199-simd-infrastructure.md:238
msgid ""
"Comparisons are implemented via intrinsics. The raw signatures would look "
"like:"
msgstr ""

#: src/1199-simd-infrastructure.md:252
msgid ""
"These are type checked during code-generation similarly to the shuffles: "
"ensuring that `T` and `U` have the same length, and that `U` is "
"appropriately \"boolean\"-y. Libraries can use traits to ensure that these "
"will be enforced by the type checker too."
msgstr ""

#: src/1199-simd-infrastructure.md:257
msgid "Arithmetic"
msgstr ""

#: src/1199-simd-infrastructure.md:259
msgid ""
"Intrinsics will be provided for arithmetic operations like addition and "
"multiplication."
msgstr ""

#: src/1199-simd-infrastructure.md:270
msgid "These will have codegen time checks that the element type is correct:"
msgstr ""

#: src/1199-simd-infrastructure.md:272
msgid "`add`, `sub`, `mul`: any float or integer type"
msgstr ""

#: src/1199-simd-infrastructure.md:273
msgid "`div`: any float type"
msgstr ""

#: src/1199-simd-infrastructure.md:274
msgid ""
"`and`, `or`, `xor`, `shl` (shift left), `shr` (shift right): any integer type"
msgstr ""

#: src/1199-simd-infrastructure.md:277
msgid ""
"(The integer types are `i8`, ..., `i64`, `u8`, ..., `u64` and the float "
"types are `f32` and `f64`.)"
msgstr ""

#: src/1199-simd-infrastructure.md:280
msgid "Why not inline asm?"
msgstr ""

#: src/1199-simd-infrastructure.md:282
msgid ""
"One alternative to providing intrinsics is to instead just use inline-asm to "
"expose each CPU instruction. However, this approach has essentially only one "
"benefit (avoiding defining the intrinsics), but several downsides, e.g."
msgstr ""

#: src/1199-simd-infrastructure.md:287
msgid ""
"assembly is generally a black-box to optimisers, inhibiting optimisations, "
"like algebraic simplification/transformation,"
msgstr ""

#: src/1199-simd-infrastructure.md:289
msgid ""
"programmers would have to manually synthesise the right sequence of "
"operations to achieve a given shuffle, while having a generic shuffle "
"intrinsic lets the compiler do it (NB. the intention is that the programmer "
"will still have access to the platform specific operations for when the "
"compiler synthesis isn't quite right),"
msgstr ""

#: src/1199-simd-infrastructure.md:294
msgid ""
"inline assembly is not currently stable in Rust and there's not a strong "
"push for it to be so in the immediate future (although this could change)."
msgstr ""

#: src/1199-simd-infrastructure.md:298
msgid ""
"Benefits of manual assembly writing, like instruction scheduling and "
"register allocation don't apply to the (generally) one-instruction `asm!` "
"blocks that replace the intrinsics (they need to be designed so that the "
"compiler has full control over register allocation, or else the result will "
"be strictly worse). Those possible advantages of hand written assembly over "
"intrinsics only come in to play when writing longer blocks of raw assembly, "
"i.e. some inner loop might be faster when written as a single chunk of asm "
"rather than as intrinsics."
msgstr ""

#: src/1199-simd-infrastructure.md:307
msgid "Platform Detection"
msgstr ""

#: src/1199-simd-infrastructure.md:309
msgid ""
"The availability of efficient SIMD functionality is very fine-grained, and "
"our current `cfg(target_arch = \"...\")` is not precise enough. This RFC "
"proposes a `target_feature` `cfg`, that would be set to the features of the "
"architecture that are known to be supported by the exact target e.g."
msgstr ""

#: src/1199-simd-infrastructure.md:315
msgid ""
"a default x86-64 compilation would essentially only set `target_feature = "
"\"sse\"` and `target_feature = \"sse2\"`"
msgstr ""

#: src/1199-simd-infrastructure.md:317
msgid ""
"compiling with `-C target-feature=\"+sse4.2\"` would set `target_feature = "
"\"sse4.2\"`, `target_feature = \"sse.4.1\"`, ..., `target_feature = \"sse\"`."
msgstr ""

#: src/1199-simd-infrastructure.md:320
msgid ""
"compiling with `-C target-cpu=native` on a modern CPU might set "
"`target_feature = \"avx2\"`, `target_feature = \"avx\"`, ..."
msgstr ""

#: src/1199-simd-infrastructure.md:323
msgid ""
"The possible values of `target_feature` will be a selected whitelist, not "
"necessarily just everything LLVM understands. There are other non-SIMD "
"features that might have `target_feature`s set too, such as `popcnt` and "
"`rdrnd` on x86/x86-64.)"
msgstr ""

#: src/1199-simd-infrastructure.md:328
msgid ""
"With a `cfg_if!` macro that expands to the first `cfg` that is satisfied "
"(ala [@alexcrichton's `cfg-if`](https://crates.io/crates/cfg-if)), code "
"might look like:"
msgstr ""

#: src/1199-simd-infrastructure.md:336
msgid "\"avx\""
msgstr ""

#: src/1199-simd-infrastructure.md:337
msgid "/* use AVX things */"
msgstr ""

#: src/1199-simd-infrastructure.md:338
msgid "\"sse4.1\""
msgstr ""

#: src/1199-simd-infrastructure.md:339
msgid "/* use SSE4.1 things */"
msgstr ""

#: src/1199-simd-infrastructure.md:340
msgid "\"sse2\""
msgstr ""

#: src/1199-simd-infrastructure.md:341
msgid "/* use SSE2 things */"
msgstr ""

#: src/1199-simd-infrastructure.md:342
msgid "\"neon\""
msgstr ""

#: src/1199-simd-infrastructure.md:343
msgid "/* use NEON things */"
msgstr ""

#: src/1199-simd-infrastructure.md:345
msgid "/* universal fallback */"
msgstr ""

#: src/1199-simd-infrastructure.md:350
msgid "Extensions"
msgstr ""

#: src/1199-simd-infrastructure.md:352
msgid ""
"scatter/gather operations allow (partially) operating on a SIMD vector of "
"pointers. This would require allowing pointers(/references?) in `repr(simd)` "
"types."
msgstr ""

#: src/1199-simd-infrastructure.md:355
msgid ""
"allow (and ignore for everything but type checking) zero-sized types in "
"`repr(simd)` structs, to allow tagging them with markers"
msgstr ""

#: src/1199-simd-infrastructure.md:357
msgid ""
"the shuffle intrinsics could be made more relaxed in their type checking (i."
"e. not require that they return their second type parameter), to allow more "
"type safety when combined with generic simd types:"
msgstr ""

#: src/1199-simd-infrastructure.md:362
msgid ""
"    #[repr(simd)] struct Simd2<T>(T, T);\n"
"    extern \"platform-intrinsic\" {\n"
"        fn simd_shuffle2<T, U>(x: T, y: T, idx: [u32; 2]) -> Simd2<U>;\n"
"    }\n"
"    "
msgstr ""

#: src/1199-simd-infrastructure.md:367
msgid "This should be a backwards-compatible generalisation."
msgstr ""

#: src/1199-simd-infrastructure.md:369
msgid "Alternatives"
msgstr "替代方案"

#: src/1199-simd-infrastructure.md:371
msgid ""
"Intrinsics could instead by namespaced by ABI, `extern \"x86-intrinsic\"`, "
"`extern \"arm-intrinsic\"`."
msgstr ""

#: src/1199-simd-infrastructure.md:373
msgid ""
"There could be more syntactic support for shuffles, either with true syntax, "
"or with a syntax extension. The latter might look like: `shuffle![x, y, i0, "
"i1, i2, i3, i4, ...]`. However, this requires that shuffles are restricted "
"to a single type only (i.e. `Simd4<T>` can be shuffled to `Simd4<T>` but "
"nothing else), or some sort of type synthesis. The compiler has to somehow "
"work out the return value:"
msgstr ""

#: src/1199-simd-infrastructure.md:385
msgid "// reverse all the elements.\n"
msgstr ""

#: src/1199-simd-infrastructure.md:389
msgid ""
"Presumably `z` should be `Simd8<u32>`, but it's not obvious how the compiler "
"can know this. The `repr(simd)` approach means there may be more than one "
"SIMD-vector type with the `Simd8<u32>` shape (or, in fact, there may be "
"zero)."
msgstr ""

#: src/1199-simd-infrastructure.md:393
msgid "With type-level integers, there could be one shuffle intrinsic:"
msgstr ""

#: src/1199-simd-infrastructure.md:395
msgid ""
"fn simd_shuffle\\<T, U, const N: usize>(x: T, y: T, idx: \\[u32; N\\]) -> U;"
msgstr ""

#: src/1199-simd-infrastructure.md:397
msgid ""
"NB. It is possible to add this as an additional intrinsic (possibly "
"deprecating the `simd_shuffleNNN` forms) later."
msgstr ""

#: src/1199-simd-infrastructure.md:399
msgid ""
"Type-level values can be applied more generally: since the shuffle indices "
"have to be compile time constants, the shuffle could be"
msgstr ""

#: src/1199-simd-infrastructure.md:404
msgid ""
"Instead of platform detection, there could be feature detection (e.g. "
"\"platform supports something equivalent to x86's `DPPS`\"), but there "
"probably aren't enough cross-platform commonalities for this to be worth it. "
"(Each \"feature\" would essentially be a platform specific `cfg` anyway.)"
msgstr ""

#: src/1199-simd-infrastructure.md:409
msgid "Check vector operators in debug mode just like the scalar versions."
msgstr ""

#: src/1199-simd-infrastructure.md:410
msgid ""
"Make fixed length arrays `repr(simd)`\\-able (via just flattening), so that, "
"say, `#[repr(simd)] struct u32x4([u32; 4]);` and `#[repr(simd)] struct "
"f64x8([f64; 4], [f64; 4]);` etc works. This will be most useful if/when we "
"allow generic-lengths, `#[repr(simd)] struct Simd<T, n>([T; n]);`"
msgstr ""

#: src/1199-simd-infrastructure.md:415
msgid ""
"have 100% guaranteed type-safety for generic `#[repr(simd)]` types and the "
"generic intrinsics. This would probably require a relatively complicated set "
"of traits (with compiler integration)."
msgstr ""

#: src/1199-simd-infrastructure.md:419
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/1199-simd-infrastructure.md:421
msgid ""
"Should integer vectors get division automatically? Most CPUs don't support "
"them for vectors."
msgstr ""

#: src/1199-simd-infrastructure.md:423
msgid "How should out-of-bounds shuffle and insert/extract indices be handled?"
msgstr ""
