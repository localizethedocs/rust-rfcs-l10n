msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:05Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2645-transparent-unions.md:1
msgid "Feature Name: `transparent_enunions`"
msgstr ""

#: src/2645-transparent-unions.md:2
msgid "Start Date: 2019-02-13"
msgstr ""

#: src/2645-transparent-unions.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2645](https://github.com/rust-lang/rfcs/pull/2645)"
msgstr ""

#: src/2645-transparent-unions.md:4
msgid ""
"Rust Issue: [rust-lang/rust#60405](https://github.com/rust-lang/rust/"
"issues/60405)"
msgstr ""

#: src/2645-transparent-unions.md:6
msgid "Summary"
msgstr ""

#: src/2645-transparent-unions.md:9
msgid ""
"Allow `#[repr(transparent)]` on `union`s and univariant `enum`s that have "
"exactly one non-zero-sized field (just like `struct`s)."
msgstr ""

#: src/2645-transparent-unions.md:11
msgid "Motivation"
msgstr ""

#: src/2645-transparent-unions.md:14
msgid ""
"Some `union` types are thin newtype-style wrappers around another type, like "
"`MaybeUninit<T>` (and [once upon a time](https://doc.rust-lang.org/1.28.0/"
"src/core/mem.rs.html#955), `ManuallyDrop<T>`). This type is intended to be "
"used in the same places as `T`, but without being `#[repr(transparent)]` the "
"actual compatibility between it and `T` is left unspecified."
msgstr ""

#: src/2645-transparent-unions.md:16
msgid ""
"Likewise, some `enum` types only have a single variant, and are similarly "
"thin wrappers around another type."
msgstr ""

#: src/2645-transparent-unions.md:18
msgid ""
"Making types like these `#[repr(transparent)]` would be useful in certain "
"cases. For example, making the type `Wrapper<T>` (which is a `union` or "
"univariant `enum` with a single field of type `T`) transparent:"
msgstr ""

#: src/2645-transparent-unions.md:20
msgid "Clearly expresses the intent of the developer."
msgstr ""

#: src/2645-transparent-unions.md:21
msgid ""
"Protects against accidental violations of that intent (e.g., adding a new "
"variant or non-ZST field will result in a compiler error)."
msgstr ""

#: src/2645-transparent-unions.md:22
msgid ""
"Makes a clear API guarantee that a `Wrapper<T>` can be transmuted to a `T` "
"or substituted for a `T` in an FFI function's signature (though users must "
"be careful to not pass uninitialized values through FFI to code where "
"uninitialized values are undefined behavior (like C and C++))."
msgstr ""

#: src/2645-transparent-unions.md:24
msgid ""
"Transparent `union`s and univariant `enum`s are a nice complement to "
"transparent `struct`s, and this RFC rounds out the `#[repr(transparent)]` "
"feature."
msgstr ""

#: src/2645-transparent-unions.md:26
msgid "Guide-level explanation"
msgstr ""

#: src/2645-transparent-unions.md:29
msgid ""
"A `union` may be `#[repr(transparent)]` in exactly the same conditions in "
"which a `struct` may be `#[repr(transparent)]`. An `enum` may be "
"`#[repr(transparent)]` if it has exactly one variant, and that variant "
"matches the same conditions which `struct` requires for transparency. Some "
"concrete illustrations follow."
msgstr ""

#: src/2645-transparent-unions.md:31
msgid ""
"A union may be `#[repr(transparent)]` if it has exactly one non-zero-sized "
"field:"
msgstr ""

#: src/2645-transparent-unions.md:34
msgid "// This union has the same representation as `f32`.\n"
msgstr ""

#: src/2645-transparent-unions.md:39
msgid "// This union has the same representation as `usize`.\n"
msgstr ""

#: src/2645-transparent-unions.md:46
msgid "// This enum has the same representation as `f32`.\n"
msgstr ""

#: src/2645-transparent-unions.md:52
msgid "// This enum has the same representation as `usize`.\n"
msgstr ""

#: src/2645-transparent-unions.md:60
msgid ""
"For consistency with transparent `struct`s, `union`s and `enum`s must have "
"exactly one non-zero-sized field. If all fields are zero-sized, the `union` "
"or `enum` must not be `#[repr(transparent)]`:"
msgstr ""

#: src/2645-transparent-unions.md:63
msgid "// This (non-transparent) union is already valid in stable Rust:\n"
msgstr ""

#: src/2645-transparent-unions.md:67
msgid "// This (non-transparent) enum is already valid in stable Rust:\n"
msgstr ""

#: src/2645-transparent-unions.md:72
msgid ""
"// Error: transparent union needs exactly one non-zero-sized field, but has "
"0\n"
msgstr ""

#: src/2645-transparent-unions.md:78 src/2645-transparent-unions.md:84
msgid ""
"// Error: transparent enum needs exactly one non-zero-sized field, but has "
"0\n"
msgstr ""

#: src/2645-transparent-unions.md:92
msgid ""
"The one exception is if the `union` or `enum` is generic over `T` and has a "
"field of type `T`, it may be `#[repr(transparent)]` even if `T` is a zero-"
"sized type:"
msgstr ""

#: src/2645-transparent-unions.md:95
msgid "// This union has the same representation as `T`.\n"
msgstr ""

#: src/2645-transparent-unions.md:97
msgid "// Unions with non-`Copy` fields are unstable.\n"
msgstr ""

#: src/2645-transparent-unions.md:101
msgid "// This enum has the same representation as `T`.\n"
msgstr ""

#: src/2645-transparent-unions.md:107
msgid "// This is okay even though `()` is a zero-sized type.\n"
msgstr ""

#: src/2645-transparent-unions.md:113
msgid ""
"Transparent `enum`s have the additional restriction that they require "
"exactly one variant:"
msgstr ""

#: src/2645-transparent-unions.md:116
msgid "// Error: transparent enum needs exactly one variant, but has 0\n"
msgstr ""

#: src/2645-transparent-unions.md:120
msgid "// Error: transparent enum needs exactly one variant, but has 2\n"
msgstr ""

#: src/2645-transparent-unions.md:129
msgid "Reference-level explanation"
msgstr ""

#: src/2645-transparent-unions.md:132
msgid ""
"The logic controlling whether a `union` of type `U` may be "
"`#[repr(transparent)]` should match the logic controlling whether a `struct` "
"of type `S` may be `#[repr(transparent)]` (assuming `U` and `S` have the "
"same generic parameters and fields). An `enum` of type `E` may be "
"`#[repr(transparent)]` if it has exactly one variant, and that variant "
"follows all the rules and logic controlling whether a `struct` of type `S` "
"may be `#[repr(transparent)]` (assuming `E` and `S` have the same generic "
"parameters, and `E`'s variant and `S` have the same and fields)."
msgstr ""

#: src/2645-transparent-unions.md:134
msgid ""
"Like transarent `struct`s, a transparent `union` of type `U` and transparent "
"`enum` of type `E` have the same layout, size, and ABI as their single non-"
"ZST field. If they are generic over a type `T`, and all their fields are "
"ZSTs except for exactly one field of type `T`, then they have the same "
"layout and ABI as `T` (even if `T` is a ZST when monomorphized)."
msgstr ""

#: src/2645-transparent-unions.md:136
msgid ""
"Like transparent `struct`s, transparent `union`s and `enum`s are FFI-safe if "
"and only if their underlying representation type is also FFI-safe."
msgstr ""

#: src/2645-transparent-unions.md:138
msgid ""
"A `union` may not be eligible for the same nonnull-style optimizations that "
"a `struct` or `enum` (with the same fields) are eligible for. Adding "
"`#[repr(transparent)]` to  `union` does not change this. To give a more "
"concrete example, it is unspecified whether `size_of::<T>()` is equal to "
"`size_of::<Option<T>>()`, where `T` is a `union` (regardless of whether it "
"is transparent). The Rust compiler is free to perform this optimization if "
"possible, but is not required to, and different compiler versions may differ "
"in their application of these optimizations."
msgstr ""

#: src/2645-transparent-unions.md:140
msgid "Drawbacks"
msgstr ""

#: src/2645-transparent-unions.md:143
msgid ""
"`#[repr(transparent)]` on a `union` or `enum` is of limited use. There are "
"cases where it is useful, but they're not common and some users might "
"unnecessarily apply `#[repr(transparent)]` to a type in a cargo-cult fashion."
msgstr ""

#: src/2645-transparent-unions.md:145
msgid "Rationale and alternatives"
msgstr ""

#: src/2645-transparent-unions.md:148
msgid ""
"It would be nice to make `MaybeUninit<T>` `#[repr(transparent)]`. This type "
"is a `union`, and thus this RFC is required to allow making it transparent. "
"One example in which a transparent representation would be useful is for "
"unused parameters in an FFI-function:"
msgstr ""

#: src/2645-transparent-unions.md:153 src/2645-transparent-unions.md:187
msgid "// Imagine there a few fields here, defined by an external C library.\n"
msgstr ""

#: src/2645-transparent-unions.md:156 src/2645-transparent-unions.md:162
#: src/2645-transparent-unions.md:192
msgid "\"C\""
msgstr ""

#: src/2645-transparent-unions.md:158
msgid ""
"// Log the message here, but ignore the context since we don't need it.\n"
msgstr ""

#: src/2645-transparent-unions.md:167
msgid "// Set the log handler so the external C library can call log_event.\n"
msgstr ""

#: src/2645-transparent-unions.md:169
msgid ""
"// Transmuting is safe since MaybeUninit<Context> and Context\n"
"        // have the same ABI.\n"
msgstr ""

#: src/2645-transparent-unions.md:174
msgid ""
"// We can call it too. And since we don't care about the context and\n"
"    // we're using MaybeUninit, we don't have to pay any extra cost for\n"
"    // initializing something that's unused.\n"
msgstr ""

#: src/2645-transparent-unions.md:177
msgid "b\"Hello, world!\\x00\""
msgstr ""

#: src/2645-transparent-unions.md:182
msgid "It is also useful for consuming pointers to uninitialized memory:"
msgstr ""

#: src/2645-transparent-unions.md:189
msgid ""
"// This function may be called from C (or Rust!), and matches the C\n"
"// function signature: bool(Cryptor *cryptor)\n"
msgstr ""

#: src/2645-transparent-unions.md:193
msgid "// Initialize the cryptor and return whether we succeeded\n"
msgstr ""

#: src/2645-transparent-unions.md:197
msgid "Prior art"
msgstr ""

#: src/2645-transparent-unions.md:200
msgid ""
"See [the discussion on RFC #1758](https://github.com/rust-lang/rfcs/"
"pull/1758) (which introduced `#[repr(transparent)]`) for some discussion on "
"applying the attribute to a `union` or `enum`. A summary of the discussion:"
msgstr ""

#: src/2645-transparent-unions.md:203
msgid ""
"**[nagisa](https://github.com/rust-lang/rfcs/pull/1758#discussion_r80436621):"
"** \"Why not univariant unions and enums?\""
msgstr ""

#: src/2645-transparent-unions.md:204
msgid ""
"**nox:** \"I tried to be conservative for now given I don't have a use case "
"for univariant unions and enums in FFI context.\""
msgstr ""

#: src/2645-transparent-unions.md:207
msgid ""
"**[eddyb](https://github.com/rust-lang/rfcs/"
"pull/1758#issuecomment-254872520):** \"I found another important usecase: "
"for `ManuallyDrop<T>`, to be useful in arrays (i.e. small vector "
"optimizations), it needs to have the same layout as `T` and AFAICT "
"`#[repr(C)]` is not guaranteed to do the right thing\""
msgstr ""

#: src/2645-transparent-unions.md:208
msgid ""
"**retep998:** \"So we'd need to be able to specify `#[repr(transparent)]` on "
"unions?\""
msgstr ""

#: src/2645-transparent-unions.md:209
msgid "**eddyb:** \"That's the only way to be sure AFAICT, yes.\""
msgstr ""

#: src/2645-transparent-unions.md:212
msgid ""
"**[joshtriplett](https://github.com/rust-lang/rfcs/"
"pull/1758#issuecomment-274670231):** \"In terms of interactions with other "
"features, I think this needs to specify what happens if you apply it to a "
"union with one field, a union with multiple fields, a struct (tuple or "
"otherwise) with multiple fields, a single-variant enum with one field, an "
"enum struct variant where the enum uses `repr(u32)` or similar. The answer "
"to some of those might be \"compile error\", but some of them (e.g. the "
"union case) may potentially make sense in some contexts.\""
msgstr ""

#: src/2645-transparent-unions.md:215
msgid ""
"**[pnkfelix](https://github.com/rust-lang/rfcs/"
"pull/1758#issuecomment-290757356):** \"However, I personally do not think we "
"need to expand the scope of the feature. So I am okay with leaving it solely "
"defined on `struct`, and leave `union`/`enum` to a follow-on RFC later. "
"(Much the same with a hypothetical `newtype` feature.)\""
msgstr ""

#: src/2645-transparent-unions.md:217
msgid ""
"In summary, many of the questions regarding `#[repr(transparent)]` on a "
"`union` or `enum` were the same as applying it to a multi-field `struct`. "
"These questions have since been answered, so there should be no problems "
"with applying those same answers to `union` univariant `enum`."
msgstr ""

#: src/2645-transparent-unions.md:219
msgid "Unresolved questions"
msgstr ""

#: src/2645-transparent-unions.md:222
msgid ""
"The role of `#[repr(transparent)]` in nonnull-style optimizations is not "
"entirely clear. Specifically, it is unclear whether the user can rely on "
"these optimizations to be performed when they make a type transparent. "
"[Transparent `union`s somewhat complicate the matter](https://github.com/"
"rust-lang/rfcs/pull/2645#issuecomment-470699497). General consensus seems to "
"be that the compiler is free to decide where and when to perform nonnull-"
"style optimizations on `union`s (regardless of whether or not the `union` is "
"transparent), and no guarantees are made to the user about when and if those "
"optimizations will be applied. It is still an open question exactly what "
"guarantees (if any) Rust makes about transparent `struct`s (and `enum`s) and "
"nonnull-style optimizations."
msgstr ""

#: src/2645-transparent-unions.md:224
msgid ""
"This RFC doesn't propose any changes to transparent `struct`s, and so does "
"not strictly depend on this question being resolved. But since this RFC is "
"attempting to round out the `#[repr(transparent)]` feature, it seems "
"reasonable to dedicate some time to attempting to round out the guarantees "
"about `#[repr(transparent)]` on `struct`s."
msgstr ""

#: src/2645-transparent-unions.md:226
msgid "Future possibilities"
msgstr ""

#: src/2645-transparent-unions.md:229
msgid ""
"If a `union` has multiple non-ZST fields, a future RFC could propose a way "
"to choose the representation of that `union` ([example](https://internals."
"rust-lang.org/t/pre-rfc-transparent-unions/9441/6))."
msgstr ""
