msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:05Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/3086-macro-metavar-expr.md:1
msgid "Feature Name: `macro_metavar_expr`"
msgstr ""

#: src/3086-macro-metavar-expr.md:2
msgid "Start Date: 2021-01-23"
msgstr ""

#: src/3086-macro-metavar-expr.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#3086](https://github.com/rust-lang/rfcs/pull/3086)"
msgstr ""

#: src/3086-macro-metavar-expr.md:4
msgid ""
"Rust Issue: [rust-lang/rust#83527](https://github.com/rust-lang/rust/"
"issues/83527)"
msgstr ""

#: src/3086-macro-metavar-expr.md:6
msgid "Summary"
msgstr ""

#: src/3086-macro-metavar-expr.md:9
msgid ""
"Add new syntax to declarative macros to give their authors easy access to "
"additional metadata about macro metavariables, such as the index, length, or "
"count of macro repetitions."
msgstr ""

#: src/3086-macro-metavar-expr.md:13
msgid "Motivation"
msgstr ""

#: src/3086-macro-metavar-expr.md:16
msgid ""
"Macros with repetitions often expand to code that needs to know or could "
"benefit from knowing how many repetitions there are, or which repetition is "
"currently being expanded.  Consider the example macro used in the guide to "
"introduce the concept of macro repetitions: building a vector, recreating "
"the `vec!` macro from the standard library:"
msgstr ""

#: src/3086-macro-metavar-expr.md:36
msgid ""
"This would be more efficient if it could use `Vec::with_capacity` to "
"preallocate the vector with the correct length.  However, there is no "
"standard facility in declarative macros to achieve this, as there is no way "
"to obtain the _number_ of repetitions of `$x`."
msgstr ""

#: src/3086-macro-metavar-expr.md:41
msgid "Guide-level explanation"
msgstr ""

#: src/3086-macro-metavar-expr.md:44
msgid ""
"The [example `vec` macro definition in the guide](https://doc.rust-lang.org/"
"book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-"
"metaprogramming) could be made more efficient if it could use `Vec::"
"with_capacity` to pre-allocate a vector with the correct capacity.  To do "
"this, we need to know the number of repetitions."
msgstr ""

#: src/3086-macro-metavar-expr.md:51
msgid ""
"Metadata about metavariables, like the number of repetitions, can be "
"accessed using **metavariable expressions**.  The metavariable expression "
"for the count of the number of repetitions of a metavariable `x` is "
"`${count(x)}`, so we can improve the `vec` macro as follows:"
msgstr ""

#: src/3086-macro-metavar-expr.md:71
msgid "The following metavariable expressions are available:"
msgstr ""

#: src/3086-macro-metavar-expr.md:73
msgid "Expression"
msgstr ""

#: src/3086-macro-metavar-expr.md:73
msgid "Meaning"
msgstr ""

#: src/3086-macro-metavar-expr.md:75
msgid "`${count(ident)}`"
msgstr ""

#: src/3086-macro-metavar-expr.md:75
msgid "The number of times `$ident` repeats in total."
msgstr ""

#: src/3086-macro-metavar-expr.md:76
msgid "`${count(ident, depth)}`"
msgstr ""

#: src/3086-macro-metavar-expr.md:76
msgid ""
"The number of times `$ident` repeats at up to `depth` nested repetition "
"depths."
msgstr ""

#: src/3086-macro-metavar-expr.md:77
msgid "`${index()}`"
msgstr ""

#: src/3086-macro-metavar-expr.md:77
msgid "The current index of the inner-most repetition."
msgstr ""

#: src/3086-macro-metavar-expr.md:78
msgid "`${index(depth)}`"
msgstr ""

#: src/3086-macro-metavar-expr.md:78
msgid "The current index of the nested repetition at `depth` steps out."
msgstr ""

#: src/3086-macro-metavar-expr.md:79
msgid "`${length()}`"
msgstr ""

#: src/3086-macro-metavar-expr.md:79
msgid "The length of the inner-most repetition."
msgstr ""

#: src/3086-macro-metavar-expr.md:80
msgid "`${length(depth)}`"
msgstr ""

#: src/3086-macro-metavar-expr.md:80
msgid "The length of the nested repetition at `depth` steps out."
msgstr ""

#: src/3086-macro-metavar-expr.md:81
msgid "`${ignore(ident)}`"
msgstr ""

#: src/3086-macro-metavar-expr.md:81
msgid "Binds `$ident` for repetition, but expands to nothing."
msgstr ""

#: src/3086-macro-metavar-expr.md:82
msgid "`$$`"
msgstr ""

#: src/3086-macro-metavar-expr.md:82
msgid ""
"Expands to a single `$`, for removing ambiguity in recursive macro "
"definitions."
msgstr ""

#: src/3086-macro-metavar-expr.md:84
msgid "Reference-level explanation"
msgstr ""

#: src/3086-macro-metavar-expr.md:87
msgid ""
"Metavariable expressions in declarative macros provide expansions for "
"information about metavariables that are otherwise not easily obtainable."
msgstr ""

#: src/3086-macro-metavar-expr.md:90
msgid ""
"This is a backwards-compatible change as both `$$` and `${ .. }` are not "
"currently accepted as valid."
msgstr ""

#: src/3086-macro-metavar-expr.md:93
msgid ""
"The metavariable expressions added in this RFC are concerned with "
"declarative macro metavariable repetitions, and obtaining the information "
"that the compiler knows about the repetitions that are being processed."
msgstr ""

#: src/3086-macro-metavar-expr.md:97
msgid "Count"
msgstr ""

#: src/3086-macro-metavar-expr.md:99
msgid ""
"The `${count(x)}` metavariable expression shown in the `vec` example in the "
"previous section counts the number of repetitions that will occur if the "
"identifier is used in a repetition at this depth.  This means that in a "
"macro expansion like:"
msgstr ""

#: src/3086-macro-metavar-expr.md:108
msgid ""
"the expression `${count(x)}` will expand to an unsuffixed integer literal "
"equal to the number of times the `$( $x )*` repetition will repeat.  For "
"example, if the metavariable `$x` repeats four times then it will expand to "
"the integer literal `4`."
msgstr ""

#: src/3086-macro-metavar-expr.md:113
msgid ""
"If repetitions are nested, then an optional depth parameter can be used to "
"limit the number of nested repetitions that are counted.  For example, a "
"macro expansion like:"
msgstr ""

#: src/3086-macro-metavar-expr.md:121
msgid ""
"The three values this expands to are the number of outer-most repetitions "
"(the number of times `a` would be generated), the sum of the number of "
"middle repetitions (the number of times `b` would be generated), and the "
"total number of repetitions of `$x`."
msgstr ""

#: src/3086-macro-metavar-expr.md:126
msgid "Index and length"
msgstr ""

#: src/3086-macro-metavar-expr.md:128
msgid ""
"Within a repetition, the `${index()}` and `${length()}` metavariable "
"expressions give the index of the current repetition and the length of the "
"repetition (i.e., the number of times it will repeat). The index value "
"ranges from `0` to `length - 1`, and the expanded values are unsuffixed "
"integer literals so they are also suitable for tuple indexing."
msgstr ""

#: src/3086-macro-metavar-expr.md:134
msgid ""
"For nested repetitions, the `${index()}` and `${length()}` metavariable "
"expressions expand to the inner-most index and length respectively. If the "
"`depth` parameter is specified, then the metavariable expression expands to "
"the index or length of the surrounding nested repetition, counting outwards "
"from the inner-most repetition.  The expressions `${index()}` and "
"`${index(0)}` are equivalent."
msgstr ""

#: src/3086-macro-metavar-expr.md:141
msgid "For example in the expression:"
msgstr ""

#: src/3086-macro-metavar-expr.md:147
msgid ""
"the first pair of values are the index and length of the inner-most "
"repetition, the second pair are the index and length of the middle "
"repetition, and the third pair are the index and length of the outer-most "
"repetition."
msgstr ""

#: src/3086-macro-metavar-expr.md:152
msgid "Ignore"
msgstr ""

#: src/3086-macro-metavar-expr.md:154
msgid ""
"Sometimes it is desired to repeat an expansion the same number of times as a "
"metavariable repeats but without actually expanding the metavariable.  It "
"may be possible to work around this by expanding the metavariable in an "
"expression like `{ $x ; 1 }`, where the expanded value of `$x` is ignored, "
"but this is only possible if what `$x` expands to is valid in this kind of "
"expression."
msgstr ""

#: src/3086-macro-metavar-expr.md:160
msgid ""
"The `${ignore(ident)}` metavariable acts as if `ident` was used for the "
"purposes of repetition, but expands to nothing.  This means a macro "
"expansion like:"
msgstr ""

#: src/3086-macro-metavar-expr.md:167
msgid ""
"will expand to a sequence of `a` tokens repeated the number of times that "
"`x` repeats."
msgstr ""

#: src/3086-macro-metavar-expr.md:169
msgid "Dollar dollar"
msgstr ""

#: src/3086-macro-metavar-expr.md:171
msgid ""
"Since metavariable expressions always apply during the expansion of the "
"macro, they cannot be used in recursive macro definitions.  To allow "
"recursive macro definitions to use metavariable expressions, the `$$` "
"expression expands to a single `$` token."
msgstr ""

#: src/3086-macro-metavar-expr.md:176
msgid ""
"This is also necessary for unambiguously defining repetitions in nested "
"macros.  For example, this resolves [issue 35853](https://github.com/rust-"
"lang/rust/issues/35853), as the example in that issue can be expressed as:"
msgstr ""

#: src/3086-macro-metavar-expr.md:194
msgid "Larger example"
msgstr ""

#: src/3086-macro-metavar-expr.md:196
msgid ""
"For a larger example of these metavariable expressions in use, consider the "
"following macro that operates over three nested repetitions:"
msgstr ""

#: src/3086-macro-metavar-expr.md:222
msgid "Given this input:"
msgstr ""

#: src/3086-macro-metavar-expr.md:230
msgid "The macro would expand to:"
msgstr ""

#: src/3086-macro-metavar-expr.md:268
msgid "Drawbacks"
msgstr ""

#: src/3086-macro-metavar-expr.md:271
msgid ""
"This adds additional syntax to the language, that program authors must learn "
"and understand.  We may not want to add more syntax."
msgstr ""

#: src/3086-macro-metavar-expr.md:274
msgid ""
"The author believes it is worth the overhead of new syntax, as even though "
"there exist workarounds for obtaining the information if it's really needed, "
"these workarounds are sometimes difficult to discover and naive "
"implementations can significantly harm compiler performance."
msgstr ""

#: src/3086-macro-metavar-expr.md:279
msgid ""
"Furthermore, the additional syntax is limited to declarative macros, and its "
"use should be limited to specific circumstances where it is more "
"understandable than the alternatives."
msgstr ""

#: src/3086-macro-metavar-expr.md:283
msgid "Rationale and alternatives"
msgstr ""

#: src/3086-macro-metavar-expr.md:286
msgid ""
"This RFC proposes a modest but powerful extension to macro syntax that makes "
"it possible to obtain information that the compiler already knows, but "
"requires inefficient and complex techniques to obtain in the macro."
msgstr ""

#: src/3086-macro-metavar-expr.md:290
msgid ""
"The original proposal was for a shorter syntax to provide the count of "
"repetitions: `$#ident`.  During discussions of this syntax, it became clear "
"that it was not obvious as to which number this referred to: the count of "
"repetitions at this level, or the length of the current repetition.  It also "
"does not provide a way to discover counts or lengths for other repetition "
"depths.  There was also interest in being able to discover the index of the "
"current repetition, and the `#` character had been used in similar proposals "
"for that.  There was some reservation expressed for the use of the `#` token "
"because of the cognitive burden of another sigil, and its common use in the "
"`quote!` macro."
msgstr ""

#: src/3086-macro-metavar-expr.md:301
msgid ""
"The meaning of the `depth` parameter in `index` and `count` originally "
"counted inwards from the outer-most nesting.  This was changed to count "
"outwards from the inner-most nesting so that expressions can be copied to a "
"different nesting depth without needing to change them."
msgstr ""

#: src/3086-macro-metavar-expr.md:306
msgid ""
"This RFC proposes using `${ ... }` as the delimiter for metavariable "
"expressions.  Available alternatives are:"
msgstr ""

#: src/3086-macro-metavar-expr.md:308
msgid "`$[ ...  ]`, e.g.: `$[count(value)]`"
msgstr ""

#: src/3086-macro-metavar-expr.md:309
msgid "`$:`, e.g. `$:count(value)`"
msgstr ""

#: src/3086-macro-metavar-expr.md:310
msgid "`$@`, e.g. `$@count(value)`"
msgstr ""

#: src/3086-macro-metavar-expr.md:311
msgid "`$!`, e.g. `$!count(value)`"
msgstr ""

#: src/3086-macro-metavar-expr.md:312
msgid ""
"Another sigil, although `#` should be avoided to avoid clashes with the "
"`quote!` macro."
msgstr ""

#: src/3086-macro-metavar-expr.md:315
msgid "Why not a proc macro or built-in macro?"
msgstr ""

#: src/3086-macro-metavar-expr.md:317
msgid ""
"To avoid extending the language with new syntax, we could consider writing "
"something that looks like a macro invocation, such as `count!(value)`, which "
"would be implemented as a procedural macro or built-in to the compiler."
msgstr ""

#: src/3086-macro-metavar-expr.md:321
msgid ""
"While this is compelling from a language simplicity perspective, it creates "
"some problems due to the way macro expansions are processed.  During macro "
"transcription, other macro invocations are not evaluated, so in the macro:"
msgstr ""

#: src/3086-macro-metavar-expr.md:331
msgid ""
"During transcription, `example!(a, b, c)` would expand to `count!(x)`.  At "
"this point, the knowledge of the metavariable `x` and its repetition is "
"lost, and no procedural macro or built-in macro would be able to work out "
"the count."
msgstr ""

#: src/3086-macro-metavar-expr.md:335
msgid ""
"To workaround this we would need to re-expand the repetition (`count!($($x),"
"*)`, forcing the `count!` macro to re-parse and count the repetitions.  This "
"is additional unnecessary work that this RFC seeks to address."
msgstr ""

#: src/3086-macro-metavar-expr.md:340
msgid ""
"Another way to think of metavariable expressions is as \"macro transcriber "
"directives\". You can think of the macro transcriber as performing the "
"following operations:"
msgstr ""

#: src/3086-macro-metavar-expr.md:344
msgid "`$var` => the value of `var`"
msgstr ""

#: src/3086-macro-metavar-expr.md:345
msgid "`$( ... ) ...` => a repetition"
msgstr ""

#: src/3086-macro-metavar-expr.md:347
msgid "This RFC adds two more:"
msgstr ""

#: src/3086-macro-metavar-expr.md:349
msgid "`${ directive(args) }` => a special transcriber directive"
msgstr ""

#: src/3086-macro-metavar-expr.md:350
msgid "`$$` => `$`"
msgstr ""

#: src/3086-macro-metavar-expr.md:352
msgid ""
"We could special-case certain macro invocations like `count!` during "
"transcription, but that feels like a worse solution. It would make it harder "
"to understand what the macro transcriber is going to do with arbitrary code "
"without remembering all of the special macros that don't work like other "
"macros."
msgstr ""

#: src/3086-macro-metavar-expr.md:358
msgid "Prior art"
msgstr ""

#: src/3086-macro-metavar-expr.md:361
msgid ""
"Declarative macros with repetition are commonly used in Rust for things that "
"are implemented using variadic functions in other languages.  Usually these "
"other languages provide mechanisms for finding the number of variadic "
"arguments, and it is a notable limitation that Rust does not."
msgstr ""

#: src/3086-macro-metavar-expr.md:366
msgid ""
"Scripting languages, like Bash, which use `$var` for variables, often use "
"similar `${...}` syntax for values based on variables: for example `${#var}` "
"is used for the length of `$var`.  This means `${...}` expressions should "
"not seem too weird to developers familiar with these scripting languages."
msgstr ""

#: src/3086-macro-metavar-expr.md:371
msgid ""
"A proposal for counting sequence repetitions was made in [RFC 88](https://"
"github.com/rust-lang/rfcs/pull/88).  That RFC proposed several options for "
"additional syntax, however the issue was postponed to after the 1.0 "
"release.  This RFC addresses the needs of RFC 88, and also goes further, as "
"it proposes a more general syntax useful for more than just counting "
"repetitions, such as obtaing the index of the current repetition.  Since the "
"generated values are integer literals, it also addresses the ability to "
"index tuples in repetitions (using `tup.${index()}`), which was noted as an "
"omission in RFC 88.  It's also not possible to implement efficiently as a "
"procedural macro, as the procedural macro would not have access to the "
"repetition counts without generating a sequence and then counting it again."
msgstr ""

#: src/3086-macro-metavar-expr.md:385
msgid "Unresolved questions"
msgstr ""

#: src/3086-macro-metavar-expr.md:388
msgid "No unresolved questions at present."
msgstr ""

#: src/3086-macro-metavar-expr.md:390
msgid ""
"While more expressions are possible, expressions beyond those defined in "
"this RFC are out-of-scope."
msgstr ""

#: src/3086-macro-metavar-expr.md:392
msgid "Future possibilities"
msgstr ""

#: src/3086-macro-metavar-expr.md:395
msgid ""
"The metavariable expression syntax (`${...}`) is purposefully generic, and "
"may be extended in future RFCs to anything that may be useful for the macro "
"expander to produce."
msgstr ""

#: src/3086-macro-metavar-expr.md:399
msgid ""
"The syntax `$[...]` is still invalid, and so remains available for any other "
"extensions which may come in the future and don't fit in with metavariable "
"expression syntax.  Additionally, any symbol after `$` is also invalid, so "
"other sequences, such as `$@`, are available."
msgstr ""
