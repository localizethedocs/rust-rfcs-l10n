msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:03Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1665-windows-subsystem.md:1
msgid "Feature Name: Windows Subsystem"
msgstr ""

#: src/1665-windows-subsystem.md:2
msgid "Start Date: 2016-07-03"
msgstr ""

#: src/1665-windows-subsystem.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1665](https://github.com/rust-lang/rfcs/pull/1665)"
msgstr ""

#: src/1665-windows-subsystem.md:4
msgid ""
"Rust Issue: [rust-lang/rust#37499](https://github.com/rust-lang/rust/"
"issues/37499)"
msgstr ""

#: src/1665-windows-subsystem.md:6
msgid "Summary"
msgstr ""

#: src/1665-windows-subsystem.md:9
msgid ""
"Rust programs compiled for Windows will always allocate a console window on "
"startup. This behavior is controlled via the `SUBSYSTEM` parameter passed to "
"the linker, and so _can_ be overridden with specific compiler flags. "
"However, doing so will bypass the Rust-specific initialization code in "
"`libstd`, as when using the MSVC toolchain, the entry point must be named "
"`WinMain`."
msgstr ""

#: src/1665-windows-subsystem.md:15
msgid ""
"This RFC proposes supporting this case explicitly, allowing `libstd` to "
"continue to be initialized correctly."
msgstr ""

#: src/1665-windows-subsystem.md:18
msgid "Motivation"
msgstr ""

#: src/1665-windows-subsystem.md:21
msgid ""
"The `WINDOWS` subsystem is commonly used on Windows: desktop applications "
"typically do not want to flash up a console window on startup."
msgstr ""

#: src/1665-windows-subsystem.md:24
msgid ""
"Currently, using the `WINDOWS` subsystem from Rust is undocumented, and the "
"process is non-trivial when targeting the MSVC toolchain. There are a couple "
"of approaches, each with their own downsides:"
msgstr ""

#: src/1665-windows-subsystem.md:28
msgid "Define a WinMain symbol"
msgstr ""

#: src/1665-windows-subsystem.md:30
msgid ""
"A new symbol `pub extern \"system\" WinMain(...)` with specific argument and "
"return types must be declared, which will become the new entry point for the "
"program."
msgstr ""

#: src/1665-windows-subsystem.md:34
msgid "This is unsafe, and will skip the initialization code in `libstd`."
msgstr ""

#: src/1665-windows-subsystem.md:36
msgid "The GNU toolchain will accept either entry point."
msgstr ""

#: src/1665-windows-subsystem.md:38
msgid "Override the entry point via linker options"
msgstr ""

#: src/1665-windows-subsystem.md:40
msgid ""
"This uses the same method as will be described in this RFC. However, it will "
"result in build scripts also being compiled for the `WINDOWS` subsystem, "
"which can cause additional console windows to pop up during compilation, "
"making the system unusable while a build is in progress."
msgstr ""

#: src/1665-windows-subsystem.md:45
msgid "Detailed design"
msgstr ""

#: src/1665-windows-subsystem.md:48
msgid ""
"When an executable is linked while compiling for a Windows target, it will "
"be linked for a specific _subsystem_. The subsystem determines how the "
"operating system will run the executable, and will affect the execution "
"environment of the program."
msgstr ""

#: src/1665-windows-subsystem.md:53
msgid ""
"In practice, only two subsystems are very commonly used: `CONSOLE` and "
"`WINDOWS`, and from a user's perspective, they determine whether a console "
"will be automatically created when the program is started."
msgstr ""

#: src/1665-windows-subsystem.md:57
msgid "New crate attribute"
msgstr ""

#: src/1665-windows-subsystem.md:59
msgid ""
"This RFC proposes two changes to solve this problem. The first is adding a "
"top-level crate attribute to allow specifying which subsystem to use:"
msgstr ""

#: src/1665-windows-subsystem.md:62
msgid "`#![windows_subsystem = \"windows\"]`"
msgstr ""

#: src/1665-windows-subsystem.md:64
msgid ""
"Initially, the set of possible values will be `{windows, console}`, but may "
"be extended in future if desired."
msgstr ""

#: src/1665-windows-subsystem.md:67
msgid ""
"The use of this attribute in a non-executable crate will result in a "
"compiler warning. If compiling for a non-Windows target, the attribute will "
"be silently ignored."
msgstr ""

#: src/1665-windows-subsystem.md:71
msgid "Additional linker argument"
msgstr ""

#: src/1665-windows-subsystem.md:73
msgid ""
"For the GNU toolchain, this will be sufficient. However, for the MSVC "
"toolchain, the linker will be expecting a `WinMain` symbol, which will not "
"exist."
msgstr ""

#: src/1665-windows-subsystem.md:76
msgid ""
"There is some complexity to the way in which a different entry point is "
"expected when using the `WINDOWS` subsystem. Firstly, the C-runtime library "
"exports two symbols designed to be used as an entry point:"
msgstr ""

#: src/1665-windows-subsystem.md:84
msgid ""
"`LINK.exe` will use the subsystem to determine which of these symbols to use "
"as the default entry point if not overridden."
msgstr ""

#: src/1665-windows-subsystem.md:87
msgid ""
"Each one performs some unspecified initialization of the CRT, before calling "
"out to a symbol defined within the program (`main` or `WinMain` "
"respectively)."
msgstr ""

#: src/1665-windows-subsystem.md:90
msgid ""
"The second part of the solution is to pass an additional linker option when "
"targeting the MSVC toolchain: `/ENTRY:mainCRTStartup`"
msgstr ""

#: src/1665-windows-subsystem.md:94
msgid ""
"This will override the entry point to always be `mainCRTStartup`. For "
"console-subsystem programs this will have no effect, since it was already "
"the default, but for `WINDOWS` subsystem programs, it will eliminate the "
"need for a `WinMain` symbol to be defined."
msgstr ""

#: src/1665-windows-subsystem.md:99
msgid ""
"This command line option will always be passed to the linker, regardless of "
"the presence or absence of the `windows_subsystem` crate attribute, except "
"when the user specifies their own entry point in the linker arguments. This "
"will require `rustc` to perform some basic parsing of the linker options."
msgstr ""

#: src/1665-windows-subsystem.md:104
msgid "Drawbacks"
msgstr ""

#: src/1665-windows-subsystem.md:107
msgid "A new platform-specific crate attribute."
msgstr ""

#: src/1665-windows-subsystem.md:108
msgid ""
"The difficulty of manually calling the Rust initialization code is "
"potentially a more general problem, and this only solves a specific (if "
"common) case."
msgstr ""

#: src/1665-windows-subsystem.md:110
msgid ""
"The subsystem must be specified earlier than is strictly required: when "
"compiling C/C++ code only the linker, not the compiler, needs to actually be "
"aware of the subsystem."
msgstr ""

#: src/1665-windows-subsystem.md:113
msgid ""
"It is assumed that the initialization performed by the two CRT entry points "
"is identical. This seems to currently be the case, and is unlikely to change "
"as this technique appears to be used fairly widely."
msgstr ""

#: src/1665-windows-subsystem.md:117
msgid "Alternatives"
msgstr ""

#: src/1665-windows-subsystem.md:120
msgid ""
"Only emit one of either `WinMain` or `main` from `rustc` based on a new "
"command line option."
msgstr ""

#: src/1665-windows-subsystem.md:123
msgid ""
"This command line option would only be applicable when compiling an "
"executable, and only for Windows platforms. No other supported platforms "
"require a different entry point or additional linker arguments for programs "
"designed to run with a graphical user interface."
msgstr ""

#: src/1665-windows-subsystem.md:128
msgid ""
"`rustc` will react to this command line option by changing the exported name "
"of the entry point to `WinMain`, and passing additional arguments to the "
"linker to configure the correct subsystem. A mismatch here would result in "
"linker errors."
msgstr ""

#: src/1665-windows-subsystem.md:133
msgid ""
"A similar option would need to be added to `Cargo.toml` to make usage as "
"simple as possible."
msgstr ""

#: src/1665-windows-subsystem.md:136
msgid ""
"There's some bike-shedding which can be done on the exact command line "
"interface, but one possible option is shown below."
msgstr ""

#: src/1665-windows-subsystem.md:139
msgid "Rustc usage: `rustc foo.rs --crate-subsystem windows`"
msgstr ""

#: src/1665-windows-subsystem.md:142
msgid "Cargo.toml"
msgstr ""

#: src/1665-windows-subsystem.md:143
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"\n"
"[[bin]]\n"
"name = \"foo\"\n"
"path = \"src/foo.rs\"\n"
"subsystem = \"windows\"\n"
"```"
msgstr ""

#: src/1665-windows-subsystem.md:153
msgid ""
"The `crate-subsystem` command line option would exist on all platforms, but "
"would be ignored when compiling for a non-Windows target, so as to support "
"cross-compiling. If not compiling a binary crate, specifying the option is "
"an error regardless of the target."
msgstr ""

#: src/1665-windows-subsystem.md:158
msgid "Unresolved questions"
msgstr ""

#: src/1665-windows-subsystem.md:161
msgid "None"
msgstr ""
