msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:05Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2627-raw-dylib-kind.md:1
msgid "Feature Name: `raw_dylib_kind`"
msgstr ""

#: src/2627-raw-dylib-kind.md:2
msgid "Start Date: 2019-01-22"
msgstr ""

#: src/2627-raw-dylib-kind.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2627](https://github.com/rust-lang/rfcs/pull/2627)"
msgstr ""

#: src/2627-raw-dylib-kind.md:4
msgid ""
"Rust Issue: [rust-lang/rust#58713](https://github.com/rust-lang/rust/"
"issues/58713)"
msgstr ""

#: src/2627-raw-dylib-kind.md:6
msgid "Summary"
msgstr "摘要"

#: src/2627-raw-dylib-kind.md:9
msgid ""
"Extend the `#[link]` attribute by adding a new kind `kind=\"raw-dylib\"` for "
"use on Windows which emits idata sections for the items in the attached "
"`extern` block, so they may be linked against without linking against an "
"import library. Also add a `#[link_ordinal]` attribute for specifying "
"symbols that are actually ordinals."
msgstr ""

#: src/2627-raw-dylib-kind.md:11
msgid "Motivation"
msgstr "動機"

#: src/2627-raw-dylib-kind.md:16
msgid ""
"Traditionally, to link against a [dll](https://en.wikipedia.org/wiki/Dynamic-"
"link_library), the program must actually link against an import library. For "
"example to depend on some symbols from `kernel32.dll` the program links to "
"`kernel32.lib`. However, this requires that the correct import libraries be "
"available to link against, and for third party libraries that are only "
"distributed as a dll creating an import library can be quite difficult, "
"especially given that `lib.exe` is incapable of creating an import library "
"that links to `stdcall` symbols."
msgstr ""

#: src/2627-raw-dylib-kind.md:18
msgid ""
"A real advantage of this feature, however, is the fact that symbols will be "
"_guaranteed_ to come from the specified dll. Currently, linking is a very "
"finnicky process where if multiple libraries provide the same symbol the "
"linker will choose one of them to provide the symbol and the user has little "
"control over it. With `kind=\"raw-dylib\"` the user is ensured that the "
"symbol will come from the specified dll."
msgstr ""

#: src/2627-raw-dylib-kind.md:20
msgid ""
"Sometimes, a crate may know exactly which dll it wants to link against, but "
"which import library it ends up linking against is unknown. In particular "
"the `d3dcompiler.lib` provided by the Windows SDK can link to several "
"different versions of the d3dcompiler dll depending on which version of the "
"Windows SDK the user has installed. `kind=\"raw-dylib\"` would allow "
"`winapi` to link to a specific version of that dll and ensure the symbols "
"are correct for that version."
msgstr ""

#: src/2627-raw-dylib-kind.md:22
msgid ""
"This would also allow `winapi` to not have to bundle import libraries for "
"the `pc-windows-gnu` targets, saving on bandwidth and disk space for users."
msgstr ""

#: src/2627-raw-dylib-kind.md:24
msgid "Guide-level explanation"
msgstr ""

#: src/2627-raw-dylib-kind.md:27
msgid ""
"When trying to link to a Windows dll, the `dylib` kind may sometimes be "
"unsuitable, and `kind=\"raw-dylib\"` can be used instead. A central "
"requirement of `kind=\"raw-dylib\"` is that the dll has a stable ABI. Here "
"are some examples of valid reasons to use `kind=\"raw-dylib\"`:"
msgstr ""

#: src/2627-raw-dylib-kind.md:29
msgid ""
"You've had it up to here with trying to create an import library for a dll "
"that has `stdcall` functions."
msgstr ""

#: src/2627-raw-dylib-kind.md:30
msgid ""
"You're in linking hell with multiple import libraries providing the same "
"symbol but from different dlls."
msgstr ""

#: src/2627-raw-dylib-kind.md:31
msgid ""
"You know exactly which dll you need a symbol from, but you don't know which "
"version of the dll the import library is going to give you."
msgstr ""

#: src/2627-raw-dylib-kind.md:32
msgid "You maintain `winapi`."
msgstr ""

#: src/2627-raw-dylib-kind.md:34
msgid "Here is an example of usage:"
msgstr ""

#: src/2627-raw-dylib-kind.md:38
msgid "\"kernel32.dll\""
msgstr ""

#: src/2627-raw-dylib-kind.md:38 src/2627-raw-dylib-kind.md:49
msgid "\"raw-dylib\""
msgstr ""

#: src/2627-raw-dylib-kind.md:40 src/2627-raw-dylib-kind.md:51
msgid "\"system\""
msgstr ""

#: src/2627-raw-dylib-kind.md:45
msgid ""
"Some symbols are only exported by ordinal from the dll in which case "
"`#[link_ordinal(..)]` may be used:"
msgstr ""

#: src/2627-raw-dylib-kind.md:49
msgid "\"ws2_32.dll\""
msgstr ""

#: src/2627-raw-dylib-kind.md:57
msgid "Reference-level explanation"
msgstr ""

#: src/2627-raw-dylib-kind.md:60
msgid ""
"Add a new attribute `#[link_ordinal]` taking a single unsuffixed integer "
"value, such as `#[link_ordinal(116)]`. It can only be specified on symbols "
"in an extern block using `kind=\"raw-dylib\"`."
msgstr ""

#: src/2627-raw-dylib-kind.md:62
msgid ""
"Add a new possible value `raw-dylib` to the `kind` property of the `link` "
"attribute. When this kind is specified, the `name` must explicitly include "
"the extension. In addition, for all items in the associated extern block, "
"Rust will _keep_ the symbol mangled, instead of having an unmangled symbol. "
"Rust will emit an idata section that maps from the _mangled_ symbol to a "
"symbol in the specified dll. The symbol in the dll that the idata section "
"maps to depends on which attributes are specified on the item in question:"
msgstr ""

#: src/2627-raw-dylib-kind.md:64
msgid ""
"If `#[link_ordinal]` is specified the idata section will map from the "
"mangled symbol to the ordinal specified in the dll."
msgstr ""

#: src/2627-raw-dylib-kind.md:65
msgid ""
"If `#[link_name]` is specified the idata section will map from the mangled "
"symbol to the name specified in the dll, without any calling convention "
"decorations added. If calling convention decorations are desired they must "
"be specified explicitly in the value of the `#[link_name]` attribute."
msgstr ""

#: src/2627-raw-dylib-kind.md:66
msgid ""
"If both `#[link_ordinal]` and `#[link_name]` are specified, an error will be "
"emitted."
msgstr ""

#: src/2627-raw-dylib-kind.md:67
msgid ""
"If neither `#[link_ordinal]` nor `#[link_name]` are specified, the idata "
"section will map from the mangled symbol to its unmangled equivalent in the "
"dll. The unmangled symbol will _not_ have calling convention decorations."
msgstr ""

#: src/2627-raw-dylib-kind.md:68
msgid "If `#[no_mangle]` is specified an error will be emitted."
msgstr ""

#: src/2627-raw-dylib-kind.md:73
msgid ""
"The [idata section](https://docs.microsoft.com/en-us/windows/desktop/debug/"
"pe-format#the-idata-section) that is produced is equivalent to the idata "
"sections found in [import libraries](https://docs.microsoft.com/en-us/"
"windows/desktop/debug/pe-format#import-library-format), and should result in "
"identical code generation by the linker."
msgstr ""

#: src/2627-raw-dylib-kind.md:75
msgid "Drawbacks"
msgstr ""

#: src/2627-raw-dylib-kind.md:78
msgid ""
"Additional complexity in the language through a new `kind` and a new "
"attribute for specifying ordinals."
msgstr ""

#: src/2627-raw-dylib-kind.md:80
msgid "Rationale and alternatives"
msgstr ""

#: src/2627-raw-dylib-kind.md:83
msgid ""
"The RFC as proposed would allow for full control over linking to symbols "
"from dlls with syntax as close as possible to existing extern blocks."
msgstr ""

#: src/2627-raw-dylib-kind.md:85
msgid "No alternatives are currently known other than the status quo."
msgstr ""

#: src/2627-raw-dylib-kind.md:87
msgid "Prior art"
msgstr ""

#: src/2627-raw-dylib-kind.md:90
msgid ""
"Many non-native languages have the ability to import symbols from dlls, but "
"this uses runtime loading by the language runtime and is not the same as "
"what is being proposed here."
msgstr ""

#: src/2627-raw-dylib-kind.md:92
msgid ""
"Delphi is a native language that has the ability to import symbols from dlls "
"without import libraries."
msgstr ""

#: src/2627-raw-dylib-kind.md:94
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/2627-raw-dylib-kind.md:97
msgid "Whether there are any unresolved questions is an unresolved question."
msgstr ""

#: src/2627-raw-dylib-kind.md:99
msgid "Future possibilities"
msgstr ""

#: src/2627-raw-dylib-kind.md:102
msgid ""
"With the features described in this RFC, we would be one step closer towards "
"a fully standalone pure Rust target for Windows that does not rely on any "
"external libraries (aside from the obvious and unavoidable runtime "
"dependence on system libraries), allowing for easy installation and easy "
"cross compilation."
msgstr ""

#: src/2627-raw-dylib-kind.md:103
msgid ""
"If that were to happen, we'd no longer need to pretend the pc-windows-gnu "
"toolchain is standalone, and we'd be able to stop bundling MinGW bits "
"entirely in favor of the user's own MinGW installation, thereby resolving a "
"bunch of issues such as [rust-lang/rust#53454](https://github.com/rust-lang/"
"rust/issues/53454)."
msgstr ""

#: src/2627-raw-dylib-kind.md:104
msgid ""
"Also with that pure Rust target users would stop complaining about having to "
"install several gigabytes of VC++ just to link their Rust binaries."
msgstr ""

#: src/2627-raw-dylib-kind.md:105
msgid ""
"A future extension of this feature would be the ability to optionally lazily "
"load such external functions, since Rust would naturally have all the "
"information required to do so. This would allow users to use functions that "
"may not exist, and be able to write fallback code for older versions."
msgstr ""

#: src/2627-raw-dylib-kind.md:106
msgid ""
"Another future extension would be to extend this feature to support shared "
"libraries on other platform, as they could also benefit from the ability to "
"be more precise about linking. For example, on Linux and other platforms "
"using ELF shared libraries, the compiler would emit an ELF `NEEDED` entry "
"for the specified shared library name, and an undefined symbol for each "
"function declared. (On ELF platforms, using the `link_ordinal` attribute "
"would produce an error.) On such platforms, the `link_name` attribute may "
"also specify a symbol name that includes a symbol version, including the "
"`@@`."
msgstr ""

#: src/2627-raw-dylib-kind.md:107
msgid ""
"Windows, however, should be the priority and figuring out details of support "
"for other platforms should **not** block implementation and stabilization of "
"this feature on Windows."
msgstr ""
