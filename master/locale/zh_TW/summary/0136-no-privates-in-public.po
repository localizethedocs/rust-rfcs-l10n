msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0136-no-privates-in-public.md:1
msgid "Start Date: 2014-06-24"
msgstr ""

#: src/0136-no-privates-in-public.md:2
msgid "RFC PR #: [\\#136](https://github.com/rust-lang/rfcs/pull/136)"
msgstr ""

#: src/0136-no-privates-in-public.md:3
msgid ""
"Rust Issue #: [\\#16463](https://github.com/rust-lang/rust/issues/16463)"
msgstr ""

#: src/0136-no-privates-in-public.md:5
msgid "Summary"
msgstr "摘要"

#: src/0136-no-privates-in-public.md:7
msgid ""
"Require a feature gate to expose private items in public APIs, until we grow "
"the appropriate language features to be able to remove the feature gate and "
"forbid it entirely."
msgstr ""

#: src/0136-no-privates-in-public.md:11
msgid "Motivation"
msgstr "動機"

#: src/0136-no-privates-in-public.md:13
msgid ""
"Privacy is central to guaranteeing the invariants necessary to write correct "
"code that employs unsafe blocks. Although the current language rules prevent "
"a private item from being directly named from outside the current module, "
"they still permit direct access to private items in some cases. For example, "
"a public function might return a value of private type. A caller from "
"outside the module could then invoke this function and, thanks to type "
"inference, gain access to the private type (though they still could not "
"invoke public methods or access public fields). This access could undermine "
"the reasoning of the author of the module. Fortunately, it is not hard to "
"prevent."
msgstr ""

#: src/0136-no-privates-in-public.md:24
msgid "Detailed design"
msgstr "詳細設計"

#: src/0136-no-privates-in-public.md:26
msgid "Overview"
msgstr ""

#: src/0136-no-privates-in-public.md:28
msgid "The general idea is that:"
msgstr ""

#: src/0136-no-privates-in-public.md:30
msgid ""
"If an item is declared as public, items referred to in the public-facing "
"parts of that item (e.g. its type) must themselves be declared as public."
msgstr ""

#: src/0136-no-privates-in-public.md:34
msgid "Details follow."
msgstr ""

#: src/0136-no-privates-in-public.md:36
msgid "The rules"
msgstr ""

#: src/0136-no-privates-in-public.md:38
msgid ""
"These rules apply as long as the feature gate is not enabled. After the "
"feature gate has been removed, they will apply always."
msgstr ""

#: src/0136-no-privates-in-public.md:41
msgid "When is an item \"public\"?"
msgstr ""

#: src/0136-no-privates-in-public.md:43
msgid ""
"Items that are explicitly declared as `pub` are always public. In addition, "
"items in the `impl` of a trait (not an inherent impl) are considered public "
"if all of the following conditions are met:"
msgstr ""

#: src/0136-no-privates-in-public.md:47
msgid "The trait being implemented is public."
msgstr ""

#: src/0136-no-privates-in-public.md:48
msgid "All input types (currently, the self type) of the impl are public."
msgstr ""

#: src/0136-no-privates-in-public.md:49
msgid ""
"_Motivation:_ If any of the input types or the trait is public, it should be "
"impossible for an outside to access the items defined in the impl. They "
"cannot name the types nor they can get direct access to a value of those "
"types."
msgstr ""

#: src/0136-no-privates-in-public.md:54
msgid "What restrictions apply to public items?"
msgstr ""

#: src/0136-no-privates-in-public.md:56
msgid "The rules for various kinds of public items are as follows:"
msgstr ""

#: src/0136-no-privates-in-public.md:58
msgid ""
"If it is a `static` declaration, items referred to in its type must be "
"public."
msgstr ""

#: src/0136-no-privates-in-public.md:60
msgid ""
"If it is an `fn` declaration, items referred to in its trait bounds, "
"argument types, and return type must be public."
msgstr ""

#: src/0136-no-privates-in-public.md:63
msgid ""
"If it is a `struct` or `enum` declaration, items referred to in its trait "
"bounds and in the types of its `pub` fields must be public."
msgstr ""

#: src/0136-no-privates-in-public.md:66
msgid ""
"If it is a `type` declaration, items referred to in its definition must be "
"public."
msgstr ""

#: src/0136-no-privates-in-public.md:69
msgid ""
"If it is a `trait` declaration, items referred to in its super-traits, in "
"the trait bounds of its type parameters, and in the signatures of its "
"methods (see `fn` case above) must be public."
msgstr ""

#: src/0136-no-privates-in-public.md:73
msgid "Examples"
msgstr ""

#: src/0136-no-privates-in-public.md:75
msgid "Here are some examples to demonstrate the rules."
msgstr ""

#: src/0136-no-privates-in-public.md:77
msgid "Struct fields"
msgstr ""

#: src/0136-no-privates-in-public.md:79
msgid ""
"```\n"
"// A private struct may refer to any type in any field.\n"
"struct Priv {\n"
"    a: Priv,\n"
"    b: Pub,\n"
"    pub c: Priv\n"
"}\n"
"\n"
"enum Vapor<A> { X, Y, Z } // Note that A is not used\n"
"\n"
"// Public fields of a public struct may only refer to public types.\n"
"pub struct Item {\n"
"    // Private field may reference a private type.\n"
"    a: Priv,\n"
"    \n"
"    // Public field must refer to a public type.\n"
"    pub b: Pub,\n"
"\n"
"    // ERROR: Public field refers to a private type.\n"
"    pub c: Priv,\n"
"    \n"
"    // ERROR: Public field refers to a private type.\n"
"    // For the purposes of this test, we do not descend into the type,\n"
"    // but merely consider the names that appear in type parameters\n"
"    // on the type, regardless of usage (or lack thereof) within the type\n"
"    // definition itself.\n"
"    pub d: Vapor<Priv>,\n"
"}\n"
"\n"
"pub struct Pub { ... }\n"
"```"
msgstr ""

#: src/0136-no-privates-in-public.md:111
msgid "Methods"
msgstr ""

#: src/0136-no-privates-in-public.md:113
msgid ""
"```\n"
"struct Priv { .. }\n"
"pub struct Pub { .. }\n"
"pub struct Foo { .. }\n"
"\n"
"impl Foo {\n"
"    // Illegal: public method with argument of private type.\n"
"    pub fn foo(&self, p: Priv) { .. }\n"
"}\n"
"```"
msgstr ""

#: src/0136-no-privates-in-public.md:124
msgid "Trait bounds"
msgstr ""

#: src/0136-no-privates-in-public.md:126
msgid ""
"```\n"
"trait PrivTrait { ... }\n"
"\n"
"// Error: type parameter on public item bounded by a private trait.\n"
"pub struct Foo<X: PrivTrait> { ... }\n"
"\n"
"// OK: type parameter on private item.\n"
"struct Foo<X: PrivTrait> { ... }\n"
"```"
msgstr ""

#: src/0136-no-privates-in-public.md:136
msgid "Trait definitions"
msgstr ""

#: src/0136-no-privates-in-public.md:138
msgid ""
"```\n"
"struct PrivStruct { ... }\n"
"\n"
"pub trait PubTrait {\n"
"    // Error: private struct referenced from method in public trait\n"
"    fn method(x: PrivStruct) { ... }\n"
"}\n"
"\n"
"trait PrivTrait {\n"
"    // OK: private struct referenced from method in private trait \n"
"    fn method(x: PrivStruct) { ... }\n"
"}\n"
"```"
msgstr ""

#: src/0136-no-privates-in-public.md:152
msgid "Implementations"
msgstr ""

#: src/0136-no-privates-in-public.md:154
msgid ""
"To some extent, implementations are prevented from exposing private types "
"because their types must match the trait. However, that is not true with "
"generics."
msgstr ""

#: src/0136-no-privates-in-public.md:158
msgid ""
"``````````\n"
"pub trait PubTrait<T> {\n"
"    fn method(t: T);\n"
"}\n"
"\n"
"struct PubStruct { ... }\n"
"\n"
"struct PrivStruct { ... }\n"
"\n"
"impl PubTrait<PrivStruct> for PubStruct {\n"
"           // ^~~~~~~~~~ Error: Private type referenced from impl of\n"
"           //            public trait on a public type. [Note: this is\n"
"           //            an \"associated type\" here, not an input.]\n"
"\n"
"    fn method(t: PrivStruct) {\n"
"              // ^~~~~~~~~~ Error: Private type in method signature.\n"
"              //\n"
"              // Implementation note. It may not be a good idea to report\n"
"              // an error here; I think private types can only appear in\n"
"              // an impl by having an associated type bound to a private\n"
"              // type.\n"
"    }\n"
"}\n"
"``````````"
msgstr ""

#: src/0136-no-privates-in-public.md:183
msgid "Type aliases"
msgstr ""

#: src/0136-no-privates-in-public.md:185
msgid "Note that the path to the public item does not have to be private."
msgstr ""

#: src/0136-no-privates-in-public.md:194
msgid "Negative examples"
msgstr ""

#: src/0136-no-privates-in-public.md:196
msgid "The following examples should fail to compile under these rules."
msgstr ""

#: src/0136-no-privates-in-public.md:198
msgid "Non-public items referenced by a pub use"
msgstr ""

#: src/0136-no-privates-in-public.md:200
msgid ""
"These examples are illegal because they use a `pub use` to re-export a "
"private item:"
msgstr ""

#: src/0136-no-privates-in-public.md:203
msgid ""
"```\n"
"struct Item { ... }\n"
"pub mod module {\n"
"    // Error: Item is not declared as public, but is referenced from\n"
"    // a `pub use`.\n"
"    pub use Item;\n"
"}\n"
"```"
msgstr ""

#: src/0136-no-privates-in-public.md:212
msgid ""
"```\n"
"struct Foo { ... }\n"
"// Error: Non-public item referenced by `pub use`.\n"
"pub use Item = Foo;\n"
"```"
msgstr ""

#: src/0136-no-privates-in-public.md:218
msgid ""
"If it was desired to have a private name that is publicly \"renamed\" using "
"a pub use, that can be achieved using a module:"
msgstr ""

#: src/0136-no-privates-in-public.md:228
msgid "Drawbacks"
msgstr ""

#: src/0136-no-privates-in-public.md:230
msgid "Adds a (temporary) feature gate."
msgstr ""

#: src/0136-no-privates-in-public.md:232
msgid ""
"Requires some existing code to opt-in to the feature gate before "
"transitioning to a more explicit alternative."
msgstr ""

#: src/0136-no-privates-in-public.md:235
msgid "Requires effort to implement."
msgstr ""

#: src/0136-no-privates-in-public.md:237
msgid "Alternatives"
msgstr ""

#: src/0136-no-privates-in-public.md:239
msgid ""
"If we stick with the status quo, we'll have to resolve several bizarre "
"questions and keep supporting its behavior indefinitely after 1.0."
msgstr ""

#: src/0136-no-privates-in-public.md:242
msgid ""
"Instead of a feature gate, we could just ban these things outright right "
"away, at the cost of temporarily losing some convenience and a small amount "
"of expressiveness before the more principled replacement features are "
"implemented."
msgstr ""

#: src/0136-no-privates-in-public.md:246
msgid ""
"We could make an exception for private supertraits, as these are not quite "
"as problematic as the other cases. However, especially given that a more "
"principled alternative is known (private methods), I would rather not make "
"any exceptions."
msgstr ""

#: src/0136-no-privates-in-public.md:250
msgid ""
"The original design of this RFC had a stronger notion of \"public\" which "
"also considered whether a public path existed to the item. In other words, a "
"module `X` could not refer to a public item `Y` from a submodule `Z`, unless "
"`X` also exposed a public path to `Y` (whether that be because `Z` was "
"public, or via a `pub use`).  This definition strengthened the basic "
"guarantee of \"private things are only directly accessible from within the "
"current module\" to include the idea that public functions in outer modules "
"cannot accidentally refer to public items from inner modules unless there is "
"a public path from the outer to the inner module.  Unfortunately, these "
"rules were complex to state concisely and also hard to understand in "
"practice; when an error occurred under these rules, it was very hard to "
"evaluate whether the error was legitimate. The newer rules are simpler while "
"still retaining the basic privacy guarantee."
msgstr ""

#: src/0136-no-privates-in-public.md:265
msgid ""
"One important advantage of the earlier approach, and a scenario not directly "
"addressed in this RFC, is that there may be items which are declared as "
"public by an inner module but _still_ not intended to be exposed to the "
"world at large (in other words, the items are only expected to be used "
"within some subtree). A special case of this is crate-local data. In the "
"older rules, the \"intended scope\" of privacy could be somewhat inferred "
"from the existence (or non-existence) of `pub use` declarations. However, in "
"the author's opinion, this scenario would be best addressed by making `pub` "
"declarations more expressive so that the intended scope can be stated "
"directly."
msgstr ""
