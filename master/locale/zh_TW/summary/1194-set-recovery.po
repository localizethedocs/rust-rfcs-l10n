msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:03Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1194-set-recovery.md:1
msgid "Feature Name: `set_recovery`"
msgstr ""

#: src/1194-set-recovery.md:2
msgid "Start Date: 2015-07-08"
msgstr ""

#: src/1194-set-recovery.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1194](https://github.com/rust-lang/rfcs/pull/1194)"
msgstr ""

#: src/1194-set-recovery.md:4
msgid ""
"Rust Issue: [rust-lang/rust#28050](https://github.com/rust-lang/rust/"
"issues/28050)"
msgstr ""

#: src/1194-set-recovery.md:6
msgid "Summary"
msgstr "摘要"

#: src/1194-set-recovery.md:8
msgid "Add element-recovery methods to the set types in `std`."
msgstr ""

#: src/1194-set-recovery.md:10
msgid "Motivation"
msgstr "動機"

#: src/1194-set-recovery.md:12
msgid ""
"Sets are sometimes used as a cache keyed on a certain property of a type, "
"but programs may need to access the type's other properties for efficiency "
"or functionality. The sets in `std` do not expose their elements (by "
"reference or by value), making this use-case impossible."
msgstr ""

#: src/1194-set-recovery.md:16
msgid "Consider the following example:"
msgstr ""

#: src/1194-set-recovery.md:21
msgid "// The `Widget` type has two fields that are inseparable.\n"
msgstr ""

#: src/1194-set-recovery.md:34
msgid ""
"// Widgets are normally considered equal if all their corresponding fields "
"are equal, but we would\n"
"// also like to maintain a set of widgets keyed only on their `bar` field. "
"To this end, we create a\n"
"// new type with custom `{PartialEq, Hash}` impls.\n"
msgstr ""

#: src/1194-set-recovery.md:51
msgid ""
"// In our program, users are allowed to interactively query the set of "
"widgets according to\n"
"    // their `bar` field, as well as insert, replace, and remove widgets.\n"
msgstr ""

#: src/1194-set-recovery.md:56
msgid "// Add some default widgets.\n"
msgstr ""

#: src/1194-set-recovery.md:57
msgid "\"iron\""
msgstr ""

#: src/1194-set-recovery.md:58
msgid "\"nickel\""
msgstr ""

#: src/1194-set-recovery.md:59
msgid "\"copper\""
msgstr ""

#: src/1194-set-recovery.md:61
msgid ""
"// At this point, the user enters commands and receives output like:\n"
"    //\n"
"    // ```\n"
"    // > get 1\n"
"    // Some(iron)\n"
"    // > get 4\n"
"    // None\n"
"    // > remove 2\n"
"    // removed nickel\n"
"    // > add 2 cobalt\n"
"    // added cobalt\n"
"    // > add 3 zinc\n"
"    // replaced copper with zinc\n"
"    // ```\n"
"    //\n"
"    // However, `HashSet` does not expose its elements via its `{contains, "
"insert, remove}`\n"
"    // methods,  instead providing only a boolean indicator of the "
"elements's presence in the set,\n"
"    // preventing us from implementing the desired functionality.\n"
msgstr ""

#: src/1194-set-recovery.md:82
msgid "Detailed design"
msgstr "詳細設計"

#: src/1194-set-recovery.md:84
msgid ""
"Add the following element-recovery methods to `std::collections::{BTreeSet, "
"HashSet}`:"
msgstr ""

#: src/1194-set-recovery.md:88
msgid ""
"// Like `contains`, but returns a reference to the element if the set "
"contains it.\n"
msgstr ""

#: src/1194-set-recovery.md:91
msgid "// Like `remove`, but returns the element if the set contained it.\n"
msgstr ""

#: src/1194-set-recovery.md:94
msgid ""
"// Like `insert`, but replaces the element with the given one and returns "
"the previous element\n"
"    // if the set contained it.\n"
msgstr ""

#: src/1194-set-recovery.md:100
msgid "Drawbacks"
msgstr ""

#: src/1194-set-recovery.md:102
msgid "This complicates the collection APIs."
msgstr ""

#: src/1194-set-recovery.md:104
msgid "Alternatives"
msgstr ""

#: src/1194-set-recovery.md:106
msgid "Do nothing."
msgstr ""
