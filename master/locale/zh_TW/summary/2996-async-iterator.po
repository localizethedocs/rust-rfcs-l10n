msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:05Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2996-async-iterator.md:1
msgid "Feature Name: `async_iterator`"
msgstr ""

#: src/2996-async-iterator.md:2
msgid "Start Date: 2020-09-29"
msgstr ""

#: src/2996-async-iterator.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2996](https://github.com/rust-lang/rfcs/pull/2996)"
msgstr ""

#: src/2996-async-iterator.md:4
msgid ""
"Rust Issue: [rust-lang/rust#79024](https://github.com/rust-lang/rust/"
"issues/79024)"
msgstr ""

#: src/2996-async-iterator.md:6
msgid "Summary"
msgstr "ÊëòË¶Å"

#: src/2996-async-iterator.md:9
msgid ""
"Introduce the `AsyncIterator` trait into the standard library, using the "
"design from `futures`. Redirect the `Stream` trait definition in the "
"`futures-core` crate (which is \"pub-used\" by the `futures` crate) to the "
"`AsyncIterator` trait in the standard library."
msgstr ""

#: src/2996-async-iterator.md:14
msgid "Motivation"
msgstr "ÂãïÊ©ü"

#: src/2996-async-iterator.md:17
msgid ""
"Async iterators are a core async abstraction. These behave similarly to "
"`Iterator`, but rather than blocking between each item yield, it allows "
"other tasks to run while it waits."
msgstr ""

#: src/2996-async-iterator.md:21
msgid ""
"People can do this currently using the `Stream` trait defined in the "
"[futures](https://crates.io/crates/futures) crate. However, we would like to "
"add `Stream` to the standard library as `AsyncIterator`."
msgstr ""

#: src/2996-async-iterator.md:25
msgid ""
"Including `AsyncIterator` in the standard library would clarify the "
"stability guarantees of the trait. For example, if [Tokio](https://tokio."
"rs/) wishes to declare a [5 year stability period](http://smallcultfollowing."
"com/babysteps/blog/2020/02/11/async-interview-6-eliza-weisman/#communicating-"
"stability), having the `AsyncIterator` trait in the standard library means "
"there are no concerns about the trait changing during that time ([citation]"
"(http://smallcultfollowing.com/babysteps/blog/2019/12/23/async-interview-3-"
"carl-lerche/#what-should-we-do-next-stabilize-stream))."
msgstr ""

#: src/2996-async-iterator.md:30
msgid "Examples of current crates that are consuming async iterators"
msgstr ""

#: src/2996-async-iterator.md:32
msgid "async-h1"
msgstr ""

#: src/2996-async-iterator.md:34
msgid ""
"[async-h1](https://docs.rs/async-h1)'s server implementation takes "
"`TcpStream` instances produced by a `TcpListener` in a loop."
msgstr ""

#: src/2996-async-iterator.md:36
msgid "async-sse"
msgstr ""

#: src/2996-async-iterator.md:38
msgid ""
"[async-sse](https://docs.rs/async-sse/) parses incoming buffers into an "
"async iterator of messages."
msgstr ""

#: src/2996-async-iterator.md:40
msgid "Why a shared trait?"
msgstr ""

#: src/2996-async-iterator.md:42
msgid ""
"We eventually want dedicated syntax for working with async iterators, which "
"will require a shared trait. This includes a trait for producing async "
"iterators and a trait for consuming async iterators."
msgstr ""

#: src/2996-async-iterator.md:45
msgid "Guide-level explanation"
msgstr ""

#: src/2996-async-iterator.md:48
msgid ""
"An \"async iterator\" is the async version of an [iterator](https://doc.rust-"
"lang.org/std/iter/trait.Iterator.html)."
msgstr ""

#: src/2996-async-iterator.md:50
msgid ""
"The `Iterator` trait includes a `next` method, which computes and returns "
"the next item in the sequence. The `AsyncIterator` trait includes the "
"`poll_next` method to assist with defining a async iterator. In the future, "
"we should add a `next` method for use when consuming and interacting with a "
"async iterator (see the [Future possiblilities](#future-possibilities) "
"section later in this RFC)."
msgstr ""

#: src/2996-async-iterator.md:52
msgid "poll_next method"
msgstr ""

#: src/2996-async-iterator.md:54
msgid ""
"When implementing a `AsyncIterator`, users will define a `poll_next` method. "
"The `poll_next` method asks if the next item is ready. If so, it returns the "
"item. Otherwise, `poll_next` will return [`Poll::Pending`](https://doc.rust-"
"lang.org/std/task/enum.Poll.html#variant.Pending)."
msgstr ""

#: src/2996-async-iterator.md:58
msgid ""
"Just as with a [`Future`](https://doc.rust-lang.org/std/future/trait.Future."
"html), returning [`Poll::Pending`](https://doc.rust-lang.org/std/task/enum."
"Poll.html#variant.Pending) implies that the async iterator has arranged for "
"the current task to be re-awoken when the data is ready."
msgstr ""

#: src/2996-async-iterator.md:66
msgid "// Defined in std::async_iter module\n"
msgstr ""

#: src/2996-async-iterator.md:68
msgid "// Core items:\n"
msgstr ""

#: src/2996-async-iterator.md:72
msgid "// Optional optimization hint, just like with iterators:\n"
msgstr ""

#: src/2996-async-iterator.md:80
msgid ""
"The arguments to `poll_next` match that of the [`Future::poll`](https://doc."
"rust-lang.org/std/future/trait.Future.html#tymethod.poll) method:"
msgstr ""

#: src/2996-async-iterator.md:82
msgid ""
"The self must be a pinned reference, ensuring both unique access to the "
"async iterator and that the async iterator value itself will not move. "
"Pinning allows the async iterator to save pointers into itself when it "
"suspends, which will be required to support generator syntax at some point."
msgstr ""

#: src/2996-async-iterator.md:86
msgid ""
"The [context](https://doc.rust-lang.org/std/task/struct.Context.html) `cx` "
"defines details of the current task. In particular, it gives access to the "
"[`Waker`](https://doc.rust-lang.org/std/task/struct.Waker.html) for the "
"task, which will allow the task to be re-awoken once data is ready."
msgstr ""

#: src/2996-async-iterator.md:95
msgid "Usage"
msgstr ""

#: src/2996-async-iterator.md:97
msgid ""
"A user could create an async iterator as follows (Example taken from "
"@yoshuawuyts' [implementation pull request](https://github.com/rust-lang/"
"rust/pull/79023))."
msgstr ""

#: src/2996-async-iterator.md:99
msgid ""
"Creating an async iterator involves two steps: creating a `struct` to hold "
"the async iterator's state, and then implementing `AsyncIterator` for that "
"`struct`."
msgstr ""

#: src/2996-async-iterator.md:103
msgid ""
"Let's make an async iterator named `Counter` which counts from `1` to `5`:"
msgstr ""

#: src/2996-async-iterator.md:110
msgid "// First, the struct:\n"
msgstr ""

#: src/2996-async-iterator.md:112
msgid "/// An async iterator which counts from one to five\n"
msgstr ""

#: src/2996-async-iterator.md:117
msgid ""
"// we want our count to start at one, so let's add a new() method to help.\n"
"// This isn't strictly necessary, but is convenient. Note that we start\n"
"// `count` at zero, we'll see why in `poll_next()`'s implementation below.\n"
msgstr ""

#: src/2996-async-iterator.md:126
msgid "// Then, we implement `AsyncIterator` for our `Counter`:\n"
msgstr ""

#: src/2996-async-iterator.md:130
msgid "// we will be counting with usize\n"
msgstr ""

#: src/2996-async-iterator.md:133
msgid "// poll_next() is the only required method\n"
msgstr ""

#: src/2996-async-iterator.md:135
msgid "// Increment our count. This is why we started at zero.\n"
msgstr ""

#: src/2996-async-iterator.md:138
msgid "// Check to see if we've finished counting or not.\n"
msgstr ""

#: src/2996-async-iterator.md:148
msgid "Initial impls"
msgstr ""

#: src/2996-async-iterator.md:150
msgid "There are a number of simple \"bridge\" impls that are also provided:"
msgstr ""

#: src/2996-async-iterator.md:183
msgid "Reference-level explanation"
msgstr ""

#: src/2996-async-iterator.md:186
msgid ""
"This section goes into details about various aspects of the design and why "
"they ended up the way they did."
msgstr ""

#: src/2996-async-iterator.md:189
msgid "Where does `AsyncIterator` live in the std lib?"
msgstr ""

#: src/2996-async-iterator.md:191
msgid ""
"`AsyncIterator` will live in the `core::async_iter` module and be re-"
"exported as `std::async_iter`."
msgstr ""

#: src/2996-async-iterator.md:193
msgid ""
"It is possible that it could live in another area as well, though this "
"follows the pattern of `core::future`."
msgstr ""

#: src/2996-async-iterator.md:196
msgid "Why use a `poll` method?"
msgstr ""

#: src/2996-async-iterator.md:198
msgid ""
"An alternative design for the async iterator trait would be to have a trait "
"that defines an async `next` method:"
msgstr ""

#: src/2996-async-iterator.md:209
msgid ""
"Unfortunately, async methods in traits are not currently supported, and "
"there [are a number of challenges to be resolved](https://rust-lang.github."
"io/wg-async-foundations/design_notes/async_fn_in_traits.html) before they "
"can be added."
msgstr ""

#: src/2996-async-iterator.md:214
msgid ""
"Moreover, it is not clear yet how to make traits that contain async "
"functions be `dyn` safe, and it is important to be able to pass around `dyn "
"AsyncIterator` values without the need to monomorphize the functions that "
"work with them."
msgstr ""

#: src/2996-async-iterator.md:219
msgid ""
"Unfortunately, the use of poll does mean that it is harder to write async "
"iterator implementations. The long-term fix for this, discussed in the "
"[Future possiblilities](#future-possibilities) section, is dedicated "
"[generator syntax](#generator-syntax)."
msgstr ""

#: src/2996-async-iterator.md:222
msgid "Rationale and alternatives"
msgstr ""

#: src/2996-async-iterator.md:225
msgid "Where should async iterator live?"
msgstr ""

#: src/2996-async-iterator.md:227
msgid ""
"As mentioned above, `core::async_iter` is analogous to `core::future`. But, "
"do we want to find some other naming scheme that can scale up to other "
"future additions, such as io traits or channels?"
msgstr ""

#: src/2996-async-iterator.md:230
msgid "Naming"
msgstr ""

#: src/2996-async-iterator.md:232
msgid ""
"When considering what to name the trait and concepts, there were two options:"
msgstr ""

#: src/2996-async-iterator.md:234
msgid ""
"**`Stream`:** with prior art in `futures-rs`, runtimes, and much of the of "
"the async ecosystem."
msgstr ""

#: src/2996-async-iterator.md:236
msgid ""
"**`AsyncIterator`:** which follows the pattern established of prefixing the "
"async version of another trait with `Async` in the ecosystem. For example "
"[`AsyncRead`](https://docs.rs/futures-io/latest/futures_io/trait.AsyncRead."
"html) is an async version of [`Read`](https://doc.rust-lang.org/std/io/trait."
"Read.html)."
msgstr ""

#: src/2996-async-iterator.md:241
msgid ""
"We ended up choosing `AsyncIterator` over `Stream` for a number of reasons:"
msgstr ""

#: src/2996-async-iterator.md:243
msgid ""
"It provides consistency between async and non-async Rust. Prefixing the "
"async version of an existing trait with `Async` helps with discoverability, "
"and teaching how APIs relate to each other. For example in this RFC we "
"describe `AsyncIterator` as \"an async version of `Iterator`\"."
msgstr ""

#: src/2996-async-iterator.md:247
msgid ""
"The word \"stream\" is fairly established terminology within computing: it "
"commonly refers to a type which yields data repeatedly. Traits such as "
"`Iterator`, `Read`, and `Write` are often referred to as \"streams\" or "
"\"streaming\".  Naming a single trait `Stream` can lead to confusion, as it "
"is not the only trait which streams."
msgstr ""

#: src/2996-async-iterator.md:252
msgid ""
"`std::net::TcpStream` does not in fact implement `Stream`, despite the name "
"suggesting it might. In the ecosystem async versions of `TcpStream` don't "
"either: `Async{Read,Write}` are used instead. This can be confusing."
msgstr ""

#: src/2996-async-iterator.md:256
msgid ""
"Additionally, there is prior art in other languages for using an "
"\"iterator\"/\"async iterator\" naming scheme:"
msgstr ""

#: src/2996-async-iterator.md:259
msgid ""
"JavaScript: [`Symbol.Iterator`](https://developer.mozilla.org/en-US/docs/Web/"
"JavaScript/Reference/Global_Objects/Symbol/iterator) and [`Symbol."
"AsyncIterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/"
"Reference/Global_Objects/Symbol/asyncIterator)"
msgstr ""

#: src/2996-async-iterator.md:261
msgid ""
"C#: [`IEnumerable`](https://docs.microsoft.com/en-us/dotnet/api/system."
"collections.generic.ienumerable-1?view=net-5.0) and [`IAsyncEnumerable`]"
"(https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-"
"iterating-with-async-enumerables-in-csharp-8)"
msgstr ""

#: src/2996-async-iterator.md:263
msgid ""
"Python: [`__iter__`](https://wiki.python.org/moin/Iterator) and [`__aiter__`]"
"(https://www.python.org/dev/peps/pep-0525/)"
msgstr ""

#: src/2996-async-iterator.md:265
msgid ""
"Swift: [`Sequence`](https://developer.apple.com/documentation/swift/"
"sequence) and [`AsyncSequence`](https://github.com/apple/swift-evolution/"
"blob/main/proposals/0298-asyncsequence.md)"
msgstr ""

#: src/2996-async-iterator.md:268
msgid ""
"Despite being a clearer in many regards, the name `AsyncIterator` loses to "
"`Stream` in terms of brevity. `AsyncIterator` / `async_iter` / \"async "
"iterator\" is longer to write than `stream` in every instance."
msgstr ""

#: src/2996-async-iterator.md:272
msgid ""
"Additionally the Rust ecosystem has a multi-year history of using `Stream` "
"to describe the concept of \"async iterators\". But we expect that as "
"`AsyncIterator` becomes the agreed upon terminology to refer to \"async "
"iterators\", the historical benefit of using \"stream\" terminology will "
"lessen over time."
msgstr ""

#: src/2996-async-iterator.md:277
msgid ""
"Overall we found that despite having some downsides, the name "
"`AsyncIterator` is strongly preferable over `Stream`."
msgstr ""

#: src/2996-async-iterator.md:280
msgid "Future possibilities"
msgstr ""

#: src/2996-async-iterator.md:283
msgid "Next method"
msgstr ""

#: src/2996-async-iterator.md:285
msgid ""
"While users will be able to implement a `AsyncIterator` as defined in this "
"RFC, they will not have a way to interact with it in the core library. As "
"soon as we figure out a way to do it in an object safe manner, we should add "
"a `next` method  either in the `AsyncIterator` trait or elsewhere."
msgstr ""

#: src/2996-async-iterator.md:287
msgid ""
"The `Iterator` trait includes a `next` method, which computes and returns "
"the next item in the sequence. We should also implement a `next` method for "
"`AsyncIterator`, similar to [the implementation in the futures-util crate]"
"(https://docs.rs/futures-util/0.3.5/src/futures_util/stream/stream/next.rs."
"html#10-12)."
msgstr ""

#: src/2996-async-iterator.md:289
msgid ""
"The core `poll_next` method is unergonomic; it does not let you iterate over "
"the items coming out of the async iterator. Therefore, we include a few "
"minimal convenience methods that are not dependent on any unstable features, "
"such as `next`."
msgstr ""

#: src/2996-async-iterator.md:293
msgid ""
"As @yoshuawuyts states in their [pull request which adds `core::stream::"
"Stream` to the standard library](https://github.com/rust-lang/rust/"
"pull/79023):"
msgstr ""

#: src/2996-async-iterator.md:295
msgid ""
"Unlike `Iterator`, `AsyncIterator` makes a distinction between the "
"`poll_next` method which is used when implementing a `AsyncIterator`, and "
"the `next` method which is used when consuming an async iterator. Consumers "
"of `AsyncIterator` only need to consider `next`, which when called, returns "
"a future which yields `Option<Item>`."
msgstr ""

#: src/2996-async-iterator.md:301
msgid ""
"The future returned by `next` will yield `Some(Item)` as long as there are "
"elements, and once they've all been exhausted, will yield `None` to indicate "
"that iteration is finished. If we're waiting on something asynchronous to "
"resolve, the future will wait until the async iterator is ready to yield "
"again."
msgstr ""

#: src/2996-async-iterator.md:306
msgid ""
"As defined in the [`Future` docs](https://doc.rust-lang.org/stable/std/"
"future/trait.Future.html):"
msgstr ""

#: src/2996-async-iterator.md:308
msgid ""
"Once a future has completed (returned Ready from poll), calling its poll "
"method again may panic, block forever, or cause other kinds of problems; the "
"Future trait places no requirements on the effects of such a call. However, "
"as the poll method is not marked unsafe, Rust's usual rules apply: calls "
"must never cause undefined behavior (memory corruption, incorrect use of "
"unsafe functions, or the like), regardless of the future's state."
msgstr ""

#: src/2996-async-iterator.md:310
msgid ""
"This is similar to the `Future` trait. The `Future::poll` method is rarely "
"called directly, it is almost always used to implement other Futures. "
"Interacting with futures is done through `async/await`."
msgstr ""

#: src/2996-async-iterator.md:314
msgid ""
"We need something like the `next()` method in order to iterate over the "
"async iterator directly in an `async` block or function. It is essentially "
"an adapter from `AsyncIterator` to `Future`."
msgstr ""

#: src/2996-async-iterator.md:316
msgid "This would allow a user to await on a future:"
msgstr ""

#: src/2996-async-iterator.md:324
msgid ""
"We could also consider adding a `try_next` method, allowing a user to write:"
msgstr ""

#: src/2996-async-iterator.md:331
msgid "But this could also be written as:"
msgstr ""

#: src/2996-async-iterator.md:337
msgid "More Usage Examples"
msgstr ""

#: src/2996-async-iterator.md:339
msgid ""
"Using the example of `AsyncIterator` implemented on a struct called "
"`Counter`, the user would interact with the async iterator like so:"
msgstr ""

#: src/2996-async-iterator.md:345 src/2996-async-iterator.md:348
#: src/2996-async-iterator.md:351 src/2996-async-iterator.md:354
#: src/2996-async-iterator.md:357 src/2996-async-iterator.md:426
#: src/2996-async-iterator.md:443
msgid "\"{}\""
msgstr ""

#: src/2996-async-iterator.md:362
msgid "This would print `1` through `5`, each on their own line."
msgstr ""

#: src/2996-async-iterator.md:364
msgid ""
"An earlier draft of the RFC prescribed an implementation of the `next` "
"method on the `AsyncIterator` trait. Unfortunately, as detailed in [this "
"comment](https://github.com/rust-lang/rust/"
"pull/79023#discussion_r547425181), it made the async iterator non-object "
"safe. More experimentation is required - and it may need to be an unstable "
"language feature for more testing before it can be added to core."
msgstr ""

#: src/2996-async-iterator.md:366
msgid "More Convenience methods"
msgstr ""

#: src/2996-async-iterator.md:368
msgid ""
"The `Iterator` trait also defines a number of useful combinators, like "
"`map`.  The `AsyncIterator` trait being proposed here does not include any "
"such conveniences.  Instead, they are available via extension traits, such "
"as the [`AsyncIteratorExt`](https://docs.rs/futures/0.3.5/futures/stream/"
"trait.AsyncIteratorExt.html) trait offered by the [`futures`](https://crates."
"io/crates/futures) crate."
msgstr ""

#: src/2996-async-iterator.md:376
msgid ""
"The reason that we have chosen to exclude combinators is that a number of "
"them would require access to async closures. As of this writing, async "
"closures are unstable and there are a number of [outstanding design issues]"
"(https://rust-lang.github.io/wg-async-foundations/design_docs/async_closures."
"html) to be resolved before they are added. Therefore, we've decided to "
"enable progress on the async iterator trait by stabilizing a core, and to "
"come back to the problem of extending it with combinators."
msgstr ""

#: src/2996-async-iterator.md:385
msgid ""
"This path does carry some risk. Adding combinator methods can cause existing "
"code to stop compiling due to the ambiguities in method resolution. We have "
"had problems in the past with attempting to migrate iterator helper methods "
"from `itertools` for this same reason."
msgstr ""

#: src/2996-async-iterator.md:390
msgid ""
"While such breakage is technically permitted by our semver guidelines, it "
"would obviously be best to avoid it, or at least to go to great lengths to "
"mitigate its effects. One option would be to extend the language to allow "
"method resolution to \"favor\" the extension trait in existing code, perhaps "
"as part of an edition migration."
msgstr ""

#: src/2996-async-iterator.md:396
msgid "Designing such a migration feature is out of scope for this RFC."
msgstr ""

#: src/2996-async-iterator.md:398
msgid "IntoAsyncIterator / FromAsyncIterator traits"
msgstr ""

#: src/2996-async-iterator.md:400
msgid "IntoAsyncIterator"
msgstr ""

#: src/2996-async-iterator.md:402 src/2996-async-iterator.md:493
msgid "**Iterators**"
msgstr ""

#: src/2996-async-iterator.md:404
msgid ""
"Iterators have an `IntoIterator` that is used with `for` loops to convert "
"items of other types to an iterator."
msgstr ""

#: src/2996-async-iterator.md:418
msgid ""
"Examples are taken from the Rust docs on [for loops and into_iter](https://"
"doc.rust-lang.org/std/iter/index.html#for-loops-and-intoiterator)"
msgstr ""

#: src/2996-async-iterator.md:420
msgid "`for x in iter` uses `impl IntoIterator for T`"
msgstr ""

#: src/2996-async-iterator.md:430
msgid "Desugars to:"
msgstr ""

#: src/2996-async-iterator.md:449
msgid "`for x in &iter` uses `impl IntoIterator for &T`"
msgstr ""

#: src/2996-async-iterator.md:450
msgid "`for x in &mut iter` uses `impl IntoIterator for &mut T`"
msgstr ""

#: src/2996-async-iterator.md:452
msgid "**AsyncIterators**"
msgstr ""

#: src/2996-async-iterator.md:454
msgid ""
"We may want a trait similar to this for `AsyncIterator`. The "
"`IntoAsyncIterator` trait would provide a way to convert something into a "
"`AsyncIterator`."
msgstr ""

#: src/2996-async-iterator.md:456 src/2996-async-iterator.md:533
msgid "This trait could look like this:"
msgstr ""

#: src/2996-async-iterator.md:471
msgid ""
"This trait (as expressed by @taiki-e in [a comment on a draft of this RFC]"
"(https://github.com/rust-lang/wg-async-foundations/pull/15/"
"files#r449880986)) makes it easy to write streams in combination with [async "
"iterator](https://github.com/taiki-e/futures-async-stream). For example:"
msgstr ""

#: src/2996-async-iterator.md:491
msgid "FromAsyncIterator"
msgstr ""

#: src/2996-async-iterator.md:495
msgid ""
"Iterators have an `FromIterator` that is used to convert iterators into "
"another type."
msgstr ""

#: src/2996-async-iterator.md:506
msgid ""
"It should be noted that this trait is rarely used directly, instead used "
"through Iterator's collect method ([source](https://doc.rust-lang.org/std/"
"iter/trait.FromIterator.html))."
msgstr ""

#: src/2996-async-iterator.md:517
msgid ""
"Examples are taken from the Rust docs on [iter and collect](https://doc.rust-"
"lang.org/std/iter/trait.Iterator.html#method.collect)"
msgstr ""

#: src/2996-async-iterator.md:529
msgid "**Async Iterators**"
msgstr ""

#: src/2996-async-iterator.md:531
msgid ""
"We may want a trait similar to this for `AsyncIterator`. The "
"`FromAsyncIterator` trait would provide a way to convert a `AsyncIterator` "
"into another type."
msgstr ""

#: src/2996-async-iterator.md:543
msgid ""
"We could potentially include a collect method for AsyncIterator as well."
msgstr ""

#: src/2996-async-iterator.md:554
msgid ""
"When drafting this RFC, there was [discussion](https://github.com/rust-lang/"
"wg-async-foundations/pull/15#discussion_r451182595) about whether to "
"implement from_async_iter for all T where `T: FromIterator` as well. "
"`FromAsyncIterator` is perhaps more general than `FromIterator` because the "
"await point is allowed to suspend execution of the current function, but "
"doesn't have to. Therefore, many (if not all) existing impls of "
"`FromIterator` would work for `FromAsyncIterator` as well. While this would "
"be a good point for a future discussion, it is not in the scope of this RFC."
msgstr ""

#: src/2996-async-iterator.md:560
msgid "Converting an Iterator to a AsyncIterator"
msgstr ""

#: src/2996-async-iterator.md:562
msgid ""
"If a user wishes to convert an Iterator to a AsyncIterator, they may not be "
"able to use IntoAsyncIterator because a blanked impl for Iterator would "
"conflict with more specific impls they may wish to write. Having a function "
"that takes an `impl Iterator<Item = T>` and returns an `impl "
"AsyncIterator<Item = T>` would be quite helpful."
msgstr ""

#: src/2996-async-iterator.md:564
msgid ""
"The [async-std](https://github.com/async-rs/async-std) crate has [stream::"
"from_iter](https://docs.rs/async-std/1.6.5/async_std/stream/fn.from_iter."
"html). The [futures-rs](https://github.com/rust-lang/futures-rs) crate has "
"[stream::iter](https://docs.rs/futures/0.3.5/futures/stream/fn.iter.html). "
"Either of these approaches could work once we expose `AsyncIterator` in the "
"standard library."
msgstr ""

#: src/2996-async-iterator.md:566
msgid ""
"Adding this functionality is out of the scope of this RFC, but is something "
"we should revisit once `AsyncIterator` is in the standard library."
msgstr ""

#: src/2996-async-iterator.md:568
msgid "Other Traits"
msgstr ""

#: src/2996-async-iterator.md:570
msgid ""
"Eventually, we may also want to add some (if not all) of the roster of "
"traits we found useful for `Iterator`."
msgstr ""

#: src/2996-async-iterator.md:572
msgid ""
"[async_std::stream](https://docs.rs/async-std/1.6.0/async_std/stream/index."
"html) has created several async counterparts to the traits in [std::iter]"
"(https://doc.rust-lang.org/std/iter/). These include:"
msgstr ""

#: src/2996-async-iterator.md:574
msgid ""
"DoubleEndedAsyncIterator: An async iterator able to yield elements from both "
"ends."
msgstr ""

#: src/2996-async-iterator.md:575
msgid "ExactSizeAsyncIterator: An async iterator that knows its exact length."
msgstr ""

#: src/2996-async-iterator.md:576
msgid "Extend: Extends a collection with the contents of an async iterator."
msgstr ""

#: src/2996-async-iterator.md:577
msgid "FromAsyncIterator: Conversion from a AsyncIterator."
msgstr ""

#: src/2996-async-iterator.md:578
msgid ""
"FusedAsyncIterator: An async iterator that always continues to yield None "
"when exhausted."
msgstr ""

#: src/2996-async-iterator.md:579
msgid "IntoAsyncIterator: Conversion into a AsyncIterator."
msgstr ""

#: src/2996-async-iterator.md:580
msgid ""
"Product: Trait to represent types that can be created by multiplying the "
"elements of an async iterator."
msgstr ""

#: src/2996-async-iterator.md:581
msgid "AsyncIterator: An asynchronous stream of values."
msgstr ""

#: src/2996-async-iterator.md:582
msgid ""
"Sum: Trait to represent types that can be created by summing up an async "
"iterator."
msgstr ""

#: src/2996-async-iterator.md:584
msgid ""
"As detailed in previous sections, the migrations to add these traits are out "
"of scope for this RFC."
msgstr ""

#: src/2996-async-iterator.md:586
msgid "Async iteration syntax"
msgstr ""

#: src/2996-async-iterator.md:588
msgid ""
"Currently, if someone wishes to iterate over a `AsyncIterator` as defined in "
"the `futures` crate, they are not able to use  `for` loops, they must use "
"`while let` and `next/try_next` instead."
msgstr ""

#: src/2996-async-iterator.md:591
msgid ""
"We may wish to extend the `for` loop so that it works over async iterators "
"as well."
msgstr ""

#: src/2996-async-iterator.md:598
msgid ""
"One of the complications of using `while let` syntax is the need to pin. A "
"`for` loop syntax that takes ownership of the async iterator would be able "
"to do the pinning for you."
msgstr ""

#: src/2996-async-iterator.md:602
msgid ""
"We may not want to make sequential processing \"too easy\" without also "
"enabling parallel/concurrent processing, which people frequently want. One "
"challenge is that parallel processing wouldn't naively permit early returns "
"and other complex control flow. We could add a `par_async_iter()` method, "
"similar to [Rayon's](https://github.com/rayon-rs/rayon) `par_iter()`."
msgstr ""

#: src/2996-async-iterator.md:608
msgid ""
"Designing this extension is out of scope for this RFC. However, it could be "
"prototyped using procedural macros today."
msgstr ""

#: src/2996-async-iterator.md:610
msgid "\"Lending\" async iterators"
msgstr ""

#: src/2996-async-iterator.md:612
msgid ""
"There has been much discussion around lending async iterators (also referred "
"to as attached async iterators)."
msgstr ""

#: src/2996-async-iterator.md:614
msgid "Definitions"
msgstr ""

#: src/2996-async-iterator.md:616
msgid ""
"[Source](https://smallcultfollowing.com/babysteps/blog/2019/12/10/async-"
"interview-2-cramertj-part-2/#the-need-for-streaming-streams-and-iterators)"
msgstr ""

#: src/2996-async-iterator.md:619
msgid ""
"In a **lending** async iterator (also known as an \"attached\" async "
"iterator), the `Item` that gets returned by `AsyncIterator` may be borrowed "
"from `self`. It can only be used as long as the `self` reference remains "
"live."
msgstr ""

#: src/2996-async-iterator.md:623
msgid ""
"In a **non-lending** async iterator (also known as a \"detached\" async "
"iterator), the `Item` that gets returned by `AsyncIterator` is \"detached\" "
"from self. This means it can be stored and moved about independently from "
"`self`."
msgstr ""

#: src/2996-async-iterator.md:627
msgid ""
"This RFC does not cover the addition of lending async iterators (async "
"iterators as implemented through this RFC are all non-lending async "
"iterators). Lending async iterators depend on [Generic Associated Types]"
"(https://rust-lang.github.io/rfcs/1598-generic_associated_types.html), which "
"are not (at the time of this RFC) stable."
msgstr ""

#: src/2996-async-iterator.md:630
msgid ""
"We can add the `AsyncIterator` trait to the standard library now and delay "
"adding in this distinction between the two types of async iterators - "
"lending and non-lending. The advantage of this is it would allow us to copy "
"the `AsyncIterator` trait from `futures` largely 'as is'."
msgstr ""

#: src/2996-async-iterator.md:635
msgid ""
"The disadvantage of this is functions that consume async iterators would "
"first be written to work with `AsyncIterator`, and then potentially have to "
"be rewritten later to work with `LendingAsyncIterator`s."
msgstr ""

#: src/2996-async-iterator.md:639
msgid "Current AsyncIterator Trait"
msgstr ""

#: src/2996-async-iterator.md:654
msgid ""
"This trait, like `Iterator`, always gives ownership of each item back to its "
"caller. This offers flexibility - such as the ability to spawn off futures "
"processing each item in parallel."
msgstr ""

#: src/2996-async-iterator.md:657
msgid "Potential Lending AsyncIterator Trait"
msgstr ""

#: src/2996-async-iterator.md:684
msgid ""
"This is a \"conversion\" trait such that anything which implements "
"`AsyncIterator` can also implement `LendingAsyncIterator`."
msgstr ""

#: src/2996-async-iterator.md:687
msgid ""
"This trait captures the case where we re-use internal buffers. This would be "
"less flexible for consumers, but potentially more efficient. Types could "
"implement the `LendingAsyncIterator` where they need to re-use an internal "
"buffer and `AsyncIterator` if they do not. There is room for both."
msgstr ""

#: src/2996-async-iterator.md:691
msgid ""
"We would also need to pursue the same design for iterators - whether through "
"adding two traits or one new trait with a \"conversion\" from the old trait."
msgstr ""

#: src/2996-async-iterator.md:694
msgid ""
"This also brings up the question of whether we should allow conversion in "
"the opposite way - if every non-lending async iterator can become a lending "
"one, should _some_ lending async iterators be able to become non-lending "
"ones?"
msgstr ""

#: src/2996-async-iterator.md:698
msgid "**Coherence**"
msgstr ""

#: src/2996-async-iterator.md:700
msgid ""
"The impl above has a problem. As the Rust language stands today, we cannot "
"cleanly convert impl AsyncIterator to impl LendingAsyncIterator due to a "
"coherence conflict."
msgstr ""

#: src/2996-async-iterator.md:703
msgid "If you have other impls like:"
msgstr ""

#: src/2996-async-iterator.md:709
msgid "and"
msgstr ""

#: src/2996-async-iterator.md:715
msgid ""
"There is a coherence conflict for `Box<impl AsyncIterator>`, so presumably "
"it will fail the coherence rules."
msgstr ""

#: src/2996-async-iterator.md:717
msgid ""
"[More examples are available here](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2018&gist=a667a7560f8dc97ab82a780e27dfc9eb)."
msgstr ""

#: src/2996-async-iterator.md:719
msgid ""
"Resolving this would require either an explicit ‚Äúwrapper‚Äù step or else some "
"form of language extension."
msgstr ""

#: src/2996-async-iterator.md:721
msgid ""
"It should be noted that the same applies to Iterator, it is not unique to "
"AsyncIterator."
msgstr ""

#: src/2996-async-iterator.md:723
msgid ""
"We may eventually want a super trait relationship available in the Rust "
"language"
msgstr ""

#: src/2996-async-iterator.md:729
msgid "This would allow us to leverage `default impl`."
msgstr ""

#: src/2996-async-iterator.md:731
msgid ""
"These use cases for lending/non-lending async iterators need more thought, "
"which is part of the reason it is out of the scope of this particular RFC."
msgstr ""

#: src/2996-async-iterator.md:734
msgid "Generator syntax"
msgstr ""

#: src/2996-async-iterator.md:737
msgid ""
"In the future, we may wish to introduce a new form of function - `gen fn` in "
"iterators and `async gen fn` in async code that can contain `yield` "
"statements. Calling such a function would yield a `impl Iterator` or `impl "
"AsyncIterator`, for sync and async respectively. Given an \"attached\" or "
"\"borrowed\" async iterator, the generator could yield references to local "
"variables. Given a \"detached\" or \"owned\" async iterator, the generator "
"could yield owned values or things that were borrowed from its caller."
msgstr ""

#: src/2996-async-iterator.md:746
msgid "In Iterators"
msgstr ""

#: src/2996-async-iterator.md:754
msgid "After desugaring, this would result in a function like:"
msgstr ""

#: src/2996-async-iterator.md:760
msgid "In Async Code"
msgstr ""

#: src/2996-async-iterator.md:766
msgid "After desugaring would result in a function like:"
msgstr ""

#: src/2996-async-iterator.md:772
msgid ""
"If we introduce `-> impl AsyncIterator` first, we will have to permit "
"`LendingAsyncIterator` in the future. Additionally, if we introduce "
"`LendingAsyncIterator` later, we'll have to figure out how to convert a "
"`LendingAsyncIterator` into a `AsyncIterator` seamlessly."
msgstr ""

#: src/2996-async-iterator.md:776
msgid "Differences between Iterator generators and Async generators"
msgstr ""

#: src/2996-async-iterator.md:778
msgid ""
"We want `AsyncIterator` and `Iterator` to work as analogously as possible, "
"including when used with generators. However, in the current design, there "
"are some crucial differences between the two."
msgstr ""

#: src/2996-async-iterator.md:780
msgid "Consider Iterator's core `next` method:"
msgstr ""

#: src/2996-async-iterator.md:790
msgid ""
"Iterator does not require pinning its core next method. In order for a `gen "
"fn` to operate with the Iterator ecosystem, there must be some kind of "
"initial pinning step that converts its result into an iterator. This will be "
"tricky, since you can't return a pinned value except by boxing."
msgstr ""

#: src/2996-async-iterator.md:792
msgid "The general shape will be:"
msgstr ""

#: src/2996-async-iterator.md:798
msgid ""
"With async iterators, the core interface _is_ pinned, so pinning occurs at "
"the last moment."
msgstr ""

#: src/2996-async-iterator.md:800
msgid "The general shape would be"
msgstr ""

#: src/2996-async-iterator.md:806
msgid ""
"Pinning at the end, like with an async iterator, lets you build and return "
"those adapters and then apply pinning at the end. This may be the more "
"efficient setup and implies that, in order to have a `gen fn` that produces "
"iterators, we will need to potentially disallow borrowing yields or "
"implement some kind of `PinnedIterator` trait that can be \"adapted\" into "
"an iterator by pinning."
msgstr ""

#: src/2996-async-iterator.md:808
msgid "For example:"
msgstr ""

#: src/2996-async-iterator.md:817
msgid ""
"// this would be nice.. but would lead to name resolution ambiguity for our "
"combinators üò¨ \n"
msgstr ""

#: src/2996-async-iterator.md:822
msgid ""
"Pinning also applies to the design of AsyncRead/AsyncWrite, which currently "
"uses Pin even through there is no clear plan to make them implemented with "
"generator type syntax. The asyncification of a signature is currently "
"understood as pinned receiver + context arg + return poll."
msgstr ""

#: src/2996-async-iterator.md:824
msgid ""
"Another key difference between `Iterator`s and `AsyncIterator`s is that "
"futures are ultimately passed to some executor API like spawn which expects "
"a `'static` future. To achieve that, the futures contain all the state they "
"need and references are internal to that state. Iterators are almost never "
"required to be `'static` by the APIs that consume them."
msgstr ""

#: src/2996-async-iterator.md:826
msgid ""
"It is, admittedly, somewhat confusing to have Async generators require "
"Pinning and Iterator generators to not require pinning, users may feel they "
"are creating code in an unnatural way when using the Async generators. This "
"will need to be discussed more when generators are proposed in the future."
msgstr ""

#: src/2996-async-iterator.md:828
msgid "Disallowing self-borrowing generators in `gen fn`"
msgstr ""

#: src/2996-async-iterator.md:830
msgid ""
"Another option is to make the generators returned by `gen fn` always be "
"`Unpin` so that the user doesn't have to think about pinning unless they're "
"already in an async context."
msgstr ""

#: src/2996-async-iterator.md:832
msgid ""
"In the spirit of experimentation, boats has written the [propane](https://"
"github.com/withoutboats/propane) crate. This crate includes a `#[propane] "
"fn` that changes the function signature to return `impl Iterator` and lets "
"you `yield`. The non-async version uses (nightly-only) generators which are "
"non-`static`, disallowing self-borrowing. In other words, you can't hold a "
"reference to something on the stack across a `yield`."
msgstr ""

#: src/2996-async-iterator.md:838
msgid ""
"This should still allow yielding from inside a for loop, as long as the for "
"loop is over a borrowed input and not something owned by the stack frame."
msgstr ""

#: src/2996-async-iterator.md:843
msgid "Further designing generator functions is out of the scope of this RFC."
msgstr ""
