msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:04Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2341-const-locals.md:1
msgid "Feature Name: `const_locals`"
msgstr ""

#: src/2341-const-locals.md:2
msgid "Start Date: 2018-01-11"
msgstr ""

#: src/2341-const-locals.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2341](https://github.com/rust-lang/rfcs/pull/2341)"
msgstr ""

#: src/2341-const-locals.md:4
msgid ""
"Rust Issue: [rust-lang/rust#48821](https://github.com/rust-lang/rust/"
"issues/48821)"
msgstr ""

#: src/2341-const-locals.md:6
msgid "Summary"
msgstr ""

#: src/2341-const-locals.md:9
msgid ""
"Allow `let` bindings in the body of constants and const fns. Additionally "
"enable destructuring in `let` bindings and const fn arguments."
msgstr ""

#: src/2341-const-locals.md:12
msgid "Motivation"
msgstr ""

#: src/2341-const-locals.md:15
msgid ""
"It makes writing const fns much more like writing regular functions and is "
"not possible right now because the old constant evaluator was a constant "
"folder that could only process expressions. With the miri const evaluator "
"this feature exists but is still disallowed."
msgstr ""

#: src/2341-const-locals.md:20
msgid "Guide-level explanation"
msgstr ""

#: src/2341-const-locals.md:23
msgid ""
"`let` bindings in constants and const fn work just like `let` bindings "
"everywhere else. Historically these did not exist in constants and const fn "
"because it would have been very hard to support them in the old const "
"evaluator."
msgstr ""

#: src/2341-const-locals.md:27
msgid ""
"This means that you can only move out of any let binding once, even though "
"in a const environment obtaining a copy of the object could be done by "
"executing the code twice, side effect free. All invariants held by runtime "
"code are also upheld by constant evaluation."
msgstr ""

#: src/2341-const-locals.md:32
msgid "Reference-level explanation"
msgstr ""

#: src/2341-const-locals.md:35
msgid "Expressions like `a + b + c` are already transformed to"
msgstr ""

#: src/2341-const-locals.md:42
msgid ""
"With this RFC we can create bindings ourselves instead of only allowing "
"compiler generated bindings."
msgstr ""

#: src/2341-const-locals.md:45
msgid "Drawbacks"
msgstr ""

#: src/2341-const-locals.md:48
msgid ""
"You can create mutable locals in constants and then actually modify them. "
"This has no real impact on the constness, as the mutation happens entirely "
"at compile time and results in an immutable value."
msgstr ""

#: src/2341-const-locals.md:52
msgid "Rationale and alternatives"
msgstr ""

#: src/2341-const-locals.md:55
msgid ""
"The backend already supports this 100%. This is essentially just disabling a "
"check"
msgstr ""

#: src/2341-const-locals.md:58
msgid "Why is this design the best in the space of possible designs?"
msgstr ""

#: src/2341-const-locals.md:60
msgid "Being the only design makes it the best design by definition"
msgstr ""

#: src/2341-const-locals.md:62
msgid "What is the impact of not doing this?"
msgstr ""

#: src/2341-const-locals.md:64
msgid ""
"Not having locals and destructuring severely limits the functions that can "
"be turned into const fn and generally leads to unreadable const fns."
msgstr ""

#: src/2341-const-locals.md:67
msgid "Unresolved questions"
msgstr ""
