msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0387-higher-ranked-trait-bounds.md:1
msgid "Start Date: 2014-10-10"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#387](https://github.com/rust-lang/rfcs/pull/387)"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:3
msgid ""
"Rust Issue: [rust-lang/rust#18639](https://github.com/rust-lang/rust/"
"issues/18639)"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:5
msgid "Summary"
msgstr "摘要"

#: src/0387-higher-ranked-trait-bounds.md:7
msgid ""
"Add the ability to have trait bounds that are polymorphic over lifetimes."
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:9
msgid "Motivation"
msgstr "動機"

#: src/0387-higher-ranked-trait-bounds.md:11
msgid ""
"Currently, closure types can be polymorphic over lifetimes. But closure "
"types are deprecated in favor of traits and object types as part of RFC #44 "
"(unboxed closures). We need to close the gap. The canonical example of where "
"you want this is if you would like a closure that accepts a reference with "
"any lifetime. For example, today you might write:"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:25
msgid ""
"If we try to write this using unboxed closures today, we have a problem:"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:27
msgid ""
"```\n"
"fn with<'a, T>(callback: T)\n"
"    where T : FnMut(&'a Data)\n"
"{\n"
"    let data = Data { ... };\n"
"    callback(&data)\n"
"}\n"
"\n"
"// Note that the `()` syntax is shorthand for the following:\n"
"fn with<'a, T>(callback: T)\n"
"    where T : FnMut<(&'a Data,),()>\n"
"{\n"
"    let data = Data { ... };\n"
"    callback(&data)\n"
"}\n"
"```"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:44
msgid ""
"The problem is that the argument type `&'a Data` must include a lifetime, "
"and there is no lifetime one could write in the fn sig that represents \"the "
"stack frame of the `with` function\". Naturally we have the same problem if "
"we try to use an `FnMut` object (which is the closer analog to the original "
"closure example):"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:64
msgid "Under this proposal, you would be able to write this code as follows:"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:66
msgid ""
"```\n"
"// Using the FnMut(&Data) notation, the &Data is\n"
"// in fact referencing an implicit bound lifetime, just\n"
"// as with closures today.\n"
"fn with<T>(callback: T)\n"
"    where T : FnMut(&Data)\n"
"{\n"
"    let data = Data { ... };\n"
"    callback(&data)\n"
"}\n"
"\n"
"// If you prefer, you can use an explicit name,\n"
"// introduced by the `for<'a>` syntax.\n"
"fn with<T>(callback: T)\n"
"    where T : for<'a> FnMut(&'a Data)\n"
"{\n"
"    let data = Data { ... };\n"
"    callback(&data)\n"
"}\n"
"\n"
"// No sugar at all.\n"
"fn with<T>(callback: T)\n"
"    where T : for<'a> FnMut<(&'a Data,),()>\n"
"{\n"
"    let data = Data { ... };\n"
"    callback(&data)\n"
"}\n"
"```"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:95
msgid "And naturally the object form(s) work as well:"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:98
msgid ""
"// The preferred notation, using `()`, again introduces\n"
"// implicit binders for omitted lifetimes:\n"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:105
msgid "// Explicit names work too.\n"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:112
msgid ""
"// The fully explicit notation requires an explicit `for`,\n"
"// as before, to declare the bound lifetimes.\n"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:122
msgid "The syntax for `fn` types must be updated as well to use `for`."
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:124
msgid "Detailed design"
msgstr "詳細設計"

#: src/0387-higher-ranked-trait-bounds.md:126
msgid "For syntax"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:128
msgid "We modify the grammar for a trait reference to include"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:133
msgid ""
"This syntax can be used in where clauses and types. The `for` syntax is not "
"permitted in impls nor in qualified paths (`<T as Trait>`).  In impls, the "
"distinction between early and late-bound lifetimes are inferred. In "
"qualified paths, which are used to select a member from an impl, no bound "
"lifetimes are permitted."
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:139
msgid "Update syntax of fn types"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:141
msgid ""
"The existing bare fn types will be updated to use the same `for` notation. "
"Therefore, `<'a> fn(&'a int)` becomes `for<'a> fn(&'a int)`."
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:144
msgid "Implicit binders when using parentheses notation and in fn types"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:146
msgid ""
"When using the `Trait(T1, ..., Tn)` notation, implicit binders are "
"introduced for omitted lifetimes. In other words, `FnMut(&int)` is "
"effectively shorthand for `for<'a> FnMut(&'a int)`, which is itself "
"shorthand for `for<'a> FnMut<(&'a int,),()>`. No implicit binders are "
"introduced when not using the parentheses notation (i.e., `Trait<T1,...,"
"Tn>`). These binders interact with lifetime elision in the usual way, and "
"hence `FnMut(&Foo) -> &Bar` is shorthand for `for<'a> FnMut(&'a Foo) -> &'a "
"Bar`. The same is all true (and already true) for fn types."
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:156
msgid "Distinguishing early vs late bound lifetimes in impls"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:158
msgid ""
"We will distinguish early vs late-bound lifetimes on impls in the same way "
"as we do for fns. Background on this process can be found in these two blog "
"posts \\[[1](http://smallcultfollowing.com/babysteps/blog/2013/10/29/"
"intermingled-parameter-lists/), [2](http://smallcultfollowing.com/babysteps/"
"blog/2013/11/04/intermingled-parameter-lists/)\\]. The basic idea is to "
"distinguish early-bound lifetimes, which must be substituted immediately, "
"from late-bound lifetimes, which can be made into a higher-ranked trait "
"reference."
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:165
msgid ""
"The rule is that any lifetime parameter `'x` declared on an impl is "
"considered _early bound_ if `'x` appears in any of the following locations:"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:168
msgid "the self type of the impl;"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:169
msgid ""
"a where clause associated with the impl (here we assume that all bounds on "
"impl parameters are desugared into where clauses)."
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:172
msgid "All other lifetimes are considered _late bound_."
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:174
msgid ""
"When we decide what kind of trait-reference is _provided_ by an impl, late "
"bound lifetimes are moved into a `for` clause attached to the reference. "
"Here are some examples:"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:179
msgid ""
"// Here 'late does not appear in any where clause nor in the self type,\n"
"// and hence it is late-bound. Thus this impl is considered to provide:\n"
"//\n"
"//     SomeType : for<'late> FnMut<(&'late Foo,),()>\n"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:184
msgid ""
"// Here 'early appears in the self type and hence it is early bound.\n"
"// This impl thus provides:\n"
"//\n"
"//     SomeOtherType<'early> : FnMut<(&'early Foo,),()>\n"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:192
msgid ""
"This means that if there were a consumer that required a type which "
"implemented `FnMut(&Foo)`, only `SomeType` could be used, not "
"`SomeOtherType`:"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:199
msgid "// ok\n"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:200
msgid "// not ok\n"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:206
msgid "Instantiating late-bound lifetimes in a trait reference"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:208
msgid ""
"Whenever an associated item from a trait reference is accessed, all late-"
"bound lifetimes are instantiated. This means basically when a method is "
"called and so forth.  Here are some examples:"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:213
msgid ""
"    fn foo<'b,T:for<'a> FnMut(&'a &'b Foo)>(t: T) {\n"
"        t(...); // here, 'a is freshly instantiated\n"
"        t(...); // here, 'a is freshly instantiated again\n"
"    }\n"
"    "
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:218
msgid "Other times when a late-bound lifetime would be instantiated:"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:220
msgid "Accessing an associated constant, once those are implemented."
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:221
msgid "Accessing an associated type."
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:223
msgid ""
"Another way to state these rules is that bound lifetimes are not permitted "
"in the traits found in qualified paths -- and things like method calls and "
"accesses to associated items can all be desugared into calls via qualified "
"paths. For example, the call `t(...)` above is equivalent to:"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:229
msgid ""
"    fn foo<'b,T:for<'a> FnMut(&'a &'b Foo)>(t: T) {\n"
"        // Here, per the usual rules, the omitted lifetime on the outer\n"
"        // reference will be instantiated with a fresh variable.\n"
"        <t as FnMut<(&&'b Foo,),()>::call_mut(&mut t, ...);\n"
"        <t as FnMut<(&&'b Foo,),()>::call_mut(&mut t, ...);\n"
"    }\n"
"    "
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:236
msgid "Subtyping of trait references"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:238
msgid ""
"The subtyping rules for trait references that involve higher-ranked "
"lifetimes will be defined in an analogous way to the current subtyping rules "
"for closures. The high-level idea is to replace each higher-ranked lifetime "
"with a skolemized variable, perform the usual subtyping checks, and then "
"check whether those skolemized variables would be being unified with "
"anything else. The interested reader is referred to [Simon Peyton-Jones "
"rather thorough but quite readable paper on the topic](http://research."
"microsoft.com/en-us/um/people/simonpj/papers/higher-rank/) or the "
"documentation in `src/librustc/middle/typeck/infer/region_inference/doc.rs`."
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:249
msgid ""
"The most important point is that the rules provide for subtyping that goes "
"from \"more general\" to \"less general\". For example, if I have a trait "
"reference like `for<'a> FnMut(&'a int)`, that would be usable wherever a "
"trait reference with a concrete lifetime, like `FnMut(&'static int)`, is "
"expected."
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:257
msgid "Drawbacks"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:259
msgid ""
"This feature is needed. There isn't really any particular drawback beyond "
"language complexity."
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:262
msgid "Alternatives"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:264
msgid ""
"**Drop the keyword.** The `for` keyword is used due to potential ambiguities "
"surrounding UFCS notation. Under UFCS, it is legal to write e.g. `<T>::Foo::"
"Bar` in a type context. This is awfully close to something like `<'a> ::std::"
"FnMut`. Currently, the parser could probably use the lifetime distinction to "
"know the difference, but future extensions (see next paragraph) could allow "
"types to be used as well, and it is still possible we will opt to \"drop the "
"tick\" in lifetimes. Moreover, the syntax `<'a> FnMut(&'a uint)` is not "
"exactly beautiful to begin with."
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:274
msgid ""
"**Permit higher-ranked traits with type variables.** This RFC limits "
"\"higher-rankedness\" to lifetimes. It is plausible to extend the system in "
"the future to permit types as well, though only in where clauses and not in "
"types. For example, one might write:"
msgstr ""

#: src/0387-higher-ranked-trait-bounds.md:281
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/0387-higher-ranked-trait-bounds.md:283
msgid "None. Implementation is underway though not complete."
msgstr ""
