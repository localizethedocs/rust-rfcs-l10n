msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:03Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1268-allow-overlapping-impls-on-marker-traits.md:1
msgid "Feature Name: `overlapping_marker_traits`"
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:2
msgid "Start Date: 2015-09-02"
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1268](https://github.com/rust-lang/rfcs/pull/1268)"
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:4
msgid ""
"Rust Issue: [rust-lang/rust#29864](https://github.com/rust-lang/rust/"
"issues/29864)"
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:6
msgid "Summary"
msgstr "摘要"

#: src/1268-allow-overlapping-impls-on-marker-traits.md:8
msgid ""
"Preventing overlapping implementations of a trait makes complete sense in "
"the context of determining method dispatch. There must not be ambiguity in "
"what code will actually be run for a given type. However, for marker traits, "
"there are no associated methods for which to indicate ambiguity. There is no "
"harm in a type being marked as `Sync` for multiple reasons."
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:14
msgid "Motivation"
msgstr "動機"

#: src/1268-allow-overlapping-impls-on-marker-traits.md:16
msgid ""
"This is purely to improve the ergonomics of adding/implementing marker "
"traits. While specialization will certainly make all cases not covered today "
"possible, removing the restriction entirely will improve the ergonomics in "
"several edge cases."
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:21
msgid "Some examples include:"
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:23
msgid ""
"the coercible trait design presents at [RFC #91](https://github.com/rust-"
"lang/rfcs/pull/91);"
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:24
msgid ""
"the `ExnSafe` trait proposed in [RFC #1236](https://github.com/rust-lang/"
"rfcs/pull/1236)."
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:29
msgid "Detailed design"
msgstr "詳細設計"

#: src/1268-allow-overlapping-impls-on-marker-traits.md:31
msgid ""
"For the purpose of this RFC, the definition of a marker trait is a trait "
"with no associated items. The design here is quite straightforward. The "
"following code fails to compile today:"
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:47
msgid ""
"The two impls are considered overlapping, as there is no way to prove "
"currently that `A` and `B` are not the same type. However, in the case of "
"marker traits, there is no actual reason that they couldn't be overlapping, "
"as no code could actually change based on the `impl`."
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:52
msgid "For a concrete use case, consider some setup like the following:"
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:68
msgid "However, when the following becomes introduced:"
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:84
msgid ""
"It becomes impossible to satisfy the requirements of `select`. The following "
"impl is disallowed today:"
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:101
msgid ""
"Since `Left` and `Right` might be the same type, this causes an overlap. "
"However, there's also no reason to forbid the overlap. There is no way to "
"work around this today. Even if you write an impl that is more specific "
"about the tables, that would be considered a non-crate local blanket "
"implementation. The only way to write it today is to specify each column "
"individually."
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:107
msgid "Drawbacks"
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:109
msgid ""
"With this change, adding any methods to an existing marker trait, even "
"defaulted, would be a breaking change. Once specialization lands, this could "
"probably be considered an acceptable breakage."
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:113
msgid "Alternatives"
msgstr "替代方案"

#: src/1268-allow-overlapping-impls-on-marker-traits.md:115
msgid ""
"If the lattice rule for specialization is eventually accepted, there does "
"not appear to be a case that is impossible to write, albeit with some "
"additional boilerplate, as you'll have to manually specify the empty impl "
"for any overlap that might occur."
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:120
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/1268-allow-overlapping-impls-on-marker-traits.md:122
msgid ""
"**How can we implement this design?** Simply lifting the coherence "
"restrictions is easy enough, but we will encounter some challenges when we "
"come to test whether a given trait impl holds. For example, if we have "
"something like:"
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:132
msgid ""
"means that a type `Foo: MarkerTrait` can hold _either_ by `Foo: Send` _or_ "
"by `Foo: Sync`. Today, we prefer to break down an obligation like `Foo: "
"MarkerTrait` into component obligations (e.g., `Foo: Send`). Due to "
"coherence, there is always one best way to do this (sort of --- where "
"clauses complicate matters). That is, except for complications due to type "
"inference, there is a best impl to choose. But under this proposal, there "
"would not be. Experimentation is needed (similar concerns arise with the "
"proposals around specialization, so it may be that progress on that front "
"will answer the questions raised here)."
msgstr ""

#: src/1268-allow-overlapping-impls-on-marker-traits.md:142
msgid ""
"**Should we add some explicit way to indicate that this is a marker trait?** "
"This would address the drawback that adding items is a backwards "
"incompatible change."
msgstr ""
