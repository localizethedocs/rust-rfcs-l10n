msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:04Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2008-non-exhaustive.md:1
msgid "Feature Name: non_exhaustive"
msgstr ""

#: src/2008-non-exhaustive.md:2
msgid "Start Date: 2017-05-24"
msgstr ""

#: src/2008-non-exhaustive.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2008](https://github.com/rust-lang/rfcs/pull/2008)"
msgstr ""

#: src/2008-non-exhaustive.md:4
msgid ""
"Rust Issue: [rust-lang/rust#44109](https://github.com/rust-lang/rust/"
"issues/44109)"
msgstr ""

#: src/2008-non-exhaustive.md:6
msgid "Summary"
msgstr "摘要"

#: src/2008-non-exhaustive.md:8
msgid ""
"This RFC introduces the `#[non_exhaustive]` attribute for enums and structs, "
"which indicates that more variants/fields may be added to an enum/struct in "
"the future."
msgstr ""

#: src/2008-non-exhaustive.md:12
msgid ""
"Adding this hint to enums will force downstream crates to add a wildcard arm "
"to `match` statements, ensuring that adding new variants is not a breaking "
"change."
msgstr ""

#: src/2008-non-exhaustive.md:15
msgid ""
"Adding this hint to structs or enum variants will prevent downstream crates "
"from constructing or exhaustively matching, to ensure that adding new fields "
"is not a breaking change."
msgstr ""

#: src/2008-non-exhaustive.md:19
msgid ""
"This is a post-1.0 version of [RFC 757](https://github.com/rust-lang/rfcs/"
"pull/757), with some additions."
msgstr ""

#: src/2008-non-exhaustive.md:21
msgid "Motivation"
msgstr "動機"

#: src/2008-non-exhaustive.md:23 src/2008-non-exhaustive.md:284
msgid "Enums"
msgstr ""

#: src/2008-non-exhaustive.md:25
msgid ""
"The most common use for non-exhaustive enums is error types. Because adding "
"features to a crate may result in different possibilities for errors, it "
"makes sense that more types of errors will be added in the future."
msgstr ""

#: src/2008-non-exhaustive.md:29
msgid ""
"For example, the rustdoc for [`std::io::ErrorKind`](https://doc.rust-lang."
"org/1.17.0/std/io/enum.ErrorKind.html) shows:"
msgstr ""

#: src/2008-non-exhaustive.md:51
msgid "// some variants omitted\n"
msgstr ""

#: src/2008-non-exhaustive.md:55
msgid ""
"Because the standard library continues to grow, it makes sense to eventually "
"add more error types. However, this can be a breaking change if we're not "
"careful; let's say that a user does a match statement like this:"
msgstr ""

#: src/2008-non-exhaustive.md:84
msgid ""
"If we were to add another variant to this enum, this `match` would fail, "
"requiring an additional arm to handle the extra case. But, if force users to "
"add an arm like so:"
msgstr ""

#: src/2008-non-exhaustive.md:90 src/2008-non-exhaustive.md:252
#: src/2008-non-exhaustive.md:366 src/2008-non-exhaustive.md:538
#: src/2008-non-exhaustive.md:561 src/2008-non-exhaustive.md:573
msgid "// ...\n"
msgstr ""

#: src/2008-non-exhaustive.md:95
msgid ""
"Then we can add as many variants as we want without breaking any downstream "
"matches."
msgstr ""

#: src/2008-non-exhaustive.md:98
msgid "How we do this today"
msgstr ""

#: src/2008-non-exhaustive.md:100
msgid ""
"We force users add this arm for [`std::io::ErrorKind`](https://doc.rust-lang."
"org/1.17.0/std/io/enum.ErrorKind.html) by adding a hidden variant:"
msgstr ""

#: src/2008-non-exhaustive.md:104 src/2008-non-exhaustive.md:155
msgid "\"io_error_internals\""
msgstr ""

#: src/2008-non-exhaustive.md:105 src/2008-non-exhaustive.md:156
msgid ""
"\"better expressed through extensible enums that this \\\n"
"                     enum cannot be exhaustively matched against\""
msgstr ""

#: src/2008-non-exhaustive.md:107 src/2008-non-exhaustive.md:158
msgid "\"0\""
msgstr ""

#: src/2008-non-exhaustive.md:112
msgid ""
"Because this feature doesn't show up in the docs, and doesn't work in stable "
"rust, we can safely assume that users won't use it."
msgstr ""

#: src/2008-non-exhaustive.md:115
msgid ""
"A lot of crates take advantage of `#[doc(hidden)]` variants to tell users "
"that they should add a wildcard branch to matches. However, the standard "
"library takes this trick further by making the variant `unstable`, ensuring "
"that it cannot be used in stable Rust. Outside the standard library, here's "
"a look at [`diesel::result::Error`](https://docs.rs/diesel/0.13.0/diesel/"
"result/enum.Error.html):"
msgstr ""

#: src/2008-non-exhaustive.md:133
msgid ""
"Even though the variant is hidden in the rustdoc, there's nothing actually "
"stopping a user from using the `__Nonexhaustive` variant. This code works "
"totally fine, for example:"
msgstr ""

#: src/2008-non-exhaustive.md:149
msgid ""
"This seems unintended, even though this is currently the best way to make "
"non-exhaustive enums outside the standard library. In fact, even the "
"standard library remarks that this is a hack. Recall the hidden variant for "
"[`std::io::ErrorKind`](https://doc.rust-lang.org/1.17.0/std/io/enum."
"ErrorKind.html):"
msgstr ""

#: src/2008-non-exhaustive.md:163
msgid ""
"Using `#[doc(hidden)]` will forever feel like a hack to fix this problem. "
"Additionally, while plenty of crates could benefit from the idea of non-"
"exhaustiveness, plenty don't because this isn't documented in the Rust book, "
"and only documented elsewhere as a hack until a better solution is proposed."
msgstr ""

#: src/2008-non-exhaustive.md:168
msgid "Opportunity for optimisation"
msgstr ""

#: src/2008-non-exhaustive.md:170
msgid ""
"Currently, the `#[doc(hidden)]` hack leads to a few missed opportunities for "
"optimisation. For example, take this enum:"
msgstr ""

#: src/2008-non-exhaustive.md:180
msgid ""
"Currently, this enum takes up the same amount of space as `String` because "
"of the non-zero optimisation. If we add our non-exhaustive variant:"
msgstr ""

#: src/2008-non-exhaustive.md:192
msgid ""
"Then this enum needs an extra bit to distinguish `Other` and "
"`__Nonexhaustive`, which is ultimately never used. This will likely add an "
"extra 8 bytes on a 64-bit system to ensure alignment."
msgstr ""

#: src/2008-non-exhaustive.md:196
msgid "More importantly, take the following code:"
msgstr ""

#: src/2008-non-exhaustive.md:201 src/2008-non-exhaustive.md:202
#: src/2008-non-exhaustive.md:203
msgid "/* lots of code */"
msgstr ""

#: src/2008-non-exhaustive.md:207
msgid ""
"As a human, we can determine that the wildcard match is dead code and can be "
"removed from the binary. Unfortunately, Rust can't make this distinction "
"because we could still _technically_ use that wildcard branch."
msgstr ""

#: src/2008-non-exhaustive.md:211
msgid ""
"Although these options will unlikely matter in this example because error-"
"handling code (hopefully) shouldn't run very often, it could matter for "
"other use cases."
msgstr ""

#: src/2008-non-exhaustive.md:215 src/2008-non-exhaustive.md:336
msgid "Structs"
msgstr ""

#: src/2008-non-exhaustive.md:217
msgid ""
"The most common use for non-exhaustive structs is config types. It often "
"makes sense to make fields public for ease-of-use, although this can "
"ultimately lead to breaking changes if we're not careful."
msgstr ""

#: src/2008-non-exhaustive.md:221
msgid "For example, take this config struct:"
msgstr ""

#: src/2008-non-exhaustive.md:230
msgid ""
"As this configuration struct gets larger, it makes sense that more fields "
"will be added. In the future, the crate may decide to add more public "
"fields, or some private fields. For example, let's assume we make the "
"following addition:"
msgstr ""

#: src/2008-non-exhaustive.md:242
msgid "Now, code that constructs the struct, like below, will fail to compile:"
msgstr ""

#: src/2008-non-exhaustive.md:248
msgid ""
"And code that matches the struct, like below, will also fail to compile:"
msgstr ""

#: src/2008-non-exhaustive.md:256
msgid ""
"Adding this new setting is now a breaking change! To rectify this, we could "
"always add a private field:"
msgstr ""

#: src/2008-non-exhaustive.md:268
msgid ""
"But this makes it more difficult for the crate itself to construct `Config`, "
"because you have to add a `non_exhaustive: ()` field every time you make a "
"new value."
msgstr ""

#: src/2008-non-exhaustive.md:272
msgid "Other kinds of structs"
msgstr ""

#: src/2008-non-exhaustive.md:274
msgid ""
"Because enum variants are _kind_ of like a struct, any change we make to "
"structs should apply to them too. Additionally, any change should apply to "
"tuple structs as well."
msgstr ""

#: src/2008-non-exhaustive.md:278
msgid "Detailed design"
msgstr "詳細設計"

#: src/2008-non-exhaustive.md:280
msgid ""
"An attribute `#[non_exhaustive]` is added to the language, which will (for "
"now) fail to compile if it's used on anything other than an enum or struct "
"definition, or enum variant."
msgstr ""

#: src/2008-non-exhaustive.md:286
msgid ""
"Within the crate that defines the enum, this attribute is essentially "
"ignored, so that the current crate can continue to exhaustively match the "
"enum. The justification for this is that any changes to the enum will likely "
"result in more changes to the rest of the crate. Consider this example:"
msgstr ""

#: src/2008-non-exhaustive.md:303
msgid "\"other or unknown error\""
msgstr ""

#: src/2008-non-exhaustive.md:309
msgid ""
"It seems undesirable for the crate author to use a wildcard arm here, to "
"ensure that an appropriate description is given for every variant. In fact, "
"if they use a wildcard arm in addition to the existing variants, it should "
"be identified as dead code, because it will never be run."
msgstr ""

#: src/2008-non-exhaustive.md:314
msgid ""
"Outside the crate that defines the enum, users should be required to add a "
"wildcard arm to ensure forward-compatibility, like so:"
msgstr ""

#: src/2008-non-exhaustive.md:327
msgid ""
"And it should _not_ be marked as dead code, even if the compiler does mark "
"it as dead and remove it."
msgstr ""

#: src/2008-non-exhaustive.md:330
msgid ""
"Note that this can _potentially_ cause breaking changes if a user adds "
"`#[deny(dead_code)]` to a match statement _and_ the upstream crate removes "
"the `#[non_exhaustive]` lint. That said, modifying warn-only lints is "
"generally assumed to not be a breaking change, even though users can make it "
"a breaking change by manually denying lints."
msgstr ""

#: src/2008-non-exhaustive.md:338
msgid ""
"Like with enums, the attribute is essentially ignored in the crate that "
"defines the struct, so that users can continue to construct values for the "
"struct. However, this will prevent downstream users from constructing or "
"exhaustively matching the struct, because fields may be added to the struct "
"in the future."
msgstr ""

#: src/2008-non-exhaustive.md:343
msgid ""
"Additionally, adding `#[non_exhaustive]` to an enum variant will operate "
"exactly the same as if the variant were a struct."
msgstr ""

#: src/2008-non-exhaustive.md:346
msgid "Using our `Config` again:"
msgstr ""

#: src/2008-non-exhaustive.md:356
msgid "We can still construct our config within the defining crate like so:"
msgstr ""

#: src/2008-non-exhaustive.md:362
msgid "And we can even exhaustively match on it, like so:"
msgstr ""

#: src/2008-non-exhaustive.md:370
msgid ""
"But users outside the crate won't be able to construct their own values, "
"because otherwise, adding extra fields would be a breaking change."
msgstr ""

#: src/2008-non-exhaustive.md:373
msgid "Users can still match on `Config`s non-exhaustively, as usual:"
msgstr ""

#: src/2008-non-exhaustive.md:379
msgid "But without the `..`, this code will fail to compile."
msgstr ""

#: src/2008-non-exhaustive.md:381
msgid ""
"Although it should not be explicitly forbidden by the language to mark a "
"struct with some private fields as non-exhaustive, it should emit a warning "
"to tell the user that the attribute has no effect."
msgstr ""

#: src/2008-non-exhaustive.md:385
msgid "Tuple structs"
msgstr ""

#: src/2008-non-exhaustive.md:387
msgid ""
"Non-exhaustive tuple structs will operate similarly to structs, however, "
"will disallow matching directly. For example, take this example on stable "
"today:"
msgstr ""

#: src/2008-non-exhaustive.md:394
msgid ""
"The below code does not work, because you can't match tuple structs with "
"private fields:"
msgstr ""

#: src/2008-non-exhaustive.md:401
msgid "However, this code _does_ work:"
msgstr ""

#: src/2008-non-exhaustive.md:407
msgid "So, if we label a struct non-exhaustive:"
msgstr ""

#: src/2008-non-exhaustive.md:414
msgid "Then we the only valid way of matching will be:"
msgstr ""

#: src/2008-non-exhaustive.md:420
msgid ""
"We can think of this as lowering the visibility of the constructor to "
"`pub(crate)` if it is marked as `pub`, then applying the standard structure "
"rules."
msgstr ""

#: src/2008-non-exhaustive.md:424
msgid "Unit structs"
msgstr ""

#: src/2008-non-exhaustive.md:426
msgid ""
"Unit structs will work very similarly to tuple structs. Consider this struct:"
msgstr ""

#: src/2008-non-exhaustive.md:433
msgid ""
"We won't be able to construct any values of this struct, but we will be able "
"to match it like:"
msgstr ""

#: src/2008-non-exhaustive.md:440
msgid ""
"Similarly to tuple structs, this will simply lower the visibility of the "
"constructor to `pub(crate)` if it were marked as `pub`."
msgstr ""

#: src/2008-non-exhaustive.md:443
msgid "Functional record updates"
msgstr ""

#: src/2008-non-exhaustive.md:445
msgid ""
"Functional record updates will operate very similarly to if the struct had "
"an extra, private field. Take this example:"
msgstr ""

#: src/2008-non-exhaustive.md:463
msgid "We'd expect this code to work without the `non_exhaustive` attribute:"
msgstr ""

#: src/2008-non-exhaustive.md:465
msgid ""
"```\n"
"let c = Config { width: 1920, height: 1080, ..Config::default() };\n"
"println!(\"{:?}\", c);\n"
"```"
msgstr ""

#: src/2008-non-exhaustive.md:470
msgid ""
"Although outside of the defining crate, it will not, because `Config` could, "
"in the future, contain private fields that the user didn't account for."
msgstr ""

#: src/2008-non-exhaustive.md:473
msgid "Changes to rustdoc"
msgstr ""

#: src/2008-non-exhaustive.md:475
msgid ""
"Right now, the only indicator that rustdoc gives for non-exhaustive enums "
"and structs is a comment saying \"some variants/fields omitted.\" This shows "
"up whenever variants or fields are marked as `#[doc(hidden)]`, or when "
"fields are private. rustdoc should continue to emit this message in these "
"cases."
msgstr ""

#: src/2008-non-exhaustive.md:480
msgid ""
"However, after this message (if any), it should offer an additional message "
"saying \"more variants/fields may be added in the future,\" to clarify that "
"the enum/struct is non-exhaustive. It also hints to the user that in the "
"future, they may want to fine-tune any match code for enums to include "
"future variants when they are added."
msgstr ""

#: src/2008-non-exhaustive.md:486
msgid ""
"These two messages should be distinct; the former says \"this enum/struct "
"has stuff that you shouldn't see,\" while the latter says \"this enum/struct "
"is incomplete and may be extended in the future.\""
msgstr ""

#: src/2008-non-exhaustive.md:490
msgid "How We Teach This"
msgstr ""

#: src/2008-non-exhaustive.md:492
msgid ""
"Changes to rustdoc should make it easier for users to understand the concept "
"of non-exhaustive enums and structs in the wild."
msgstr ""

#: src/2008-non-exhaustive.md:495
msgid ""
"In the chapter on enums, a section should be added specifically for non-"
"exhaustive enums. Because error types are common in almost all crates, this "
"case is important enough to be taught when a user learns Rust for the first "
"time."
msgstr ""

#: src/2008-non-exhaustive.md:500
msgid ""
"Additionally, non-exhaustive structs should be documented in an early "
"chapter on structs. Public fields should be preferred over getter/setter "
"methods in Rust, although users should be aware that adding extra fields is "
"a potentially breaking change. In this chapter, users should be taught about "
"non-exhaustive enum variants as well."
msgstr ""

#: src/2008-non-exhaustive.md:506
msgid "Drawbacks"
msgstr ""

#: src/2008-non-exhaustive.md:508
msgid "The `#[doc(hidden)]` hack in practice is usually good enough."
msgstr ""

#: src/2008-non-exhaustive.md:509
msgid "An attribute may be more confusing than a dedicated syntax."
msgstr ""

#: src/2008-non-exhaustive.md:510
msgid "`non_exhaustive` may not be the clearest name."
msgstr ""

#: src/2008-non-exhaustive.md:512
msgid "Alternatives"
msgstr ""

#: src/2008-non-exhaustive.md:514
msgid ""
"Provide a dedicated syntax instead of an attribute. This would likely be "
"done by adding a `...` variant or field, as proposed by the original "
"[extensible enums RFC](https://github.com/rust-lang/rfcs/pull/757)."
msgstr ""

#: src/2008-non-exhaustive.md:517
msgid ""
"Allow creating private enum variants and/or private fields for enum "
"variants, giving a less-hacky way to create a hidden variant/field."
msgstr ""

#: src/2008-non-exhaustive.md:519
msgid "Document the `#[doc(hidden)]` hack and make it more well-known."
msgstr ""

#: src/2008-non-exhaustive.md:521
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/2008-non-exhaustive.md:523
msgid ""
"It may make sense to have a \"not exhaustive enough\" lint to non-exhaustive "
"enums or structs, so that users can be warned if they are missing fields or "
"variants despite having a wildcard arm to warn on them."
msgstr ""

#: src/2008-non-exhaustive.md:527
msgid ""
"Although this is beyond the scope of this particular RFC, it may be good as "
"a clippy lint in the future."
msgstr ""

#: src/2008-non-exhaustive.md:530
msgid "Extending to traits"
msgstr ""

#: src/2008-non-exhaustive.md:532
msgid ""
"Tangentially, it also makes sense to have non-exhaustive traits as well, "
"even though they'd be non-exhaustive in a different way. Take this example "
"from [`byteorder`](https://github.com/BurntSushi/byteorder/tree/"
"f8e7685b3a81c52f5448fd77fb4e0535bc92f880):"
msgstr ""

#: src/2008-non-exhaustive.md:542
msgid ""
"The `ByteOrder` trait requires these traits so that a user can simply write "
"a bound of `T: ByteOrder` without having to add other useful traits, like "
"`Hash` or `Eq`."
msgstr ""

#: src/2008-non-exhaustive.md:546
msgid ""
"This trait is useful, but the crate has no intention of letting other users "
"implement this trait themselves, because then adding an additional trait "
"dependency for `ByteOrder` could be a breaking change."
msgstr ""

#: src/2008-non-exhaustive.md:550
msgid ""
"The way that this crate solves this problem is by adding a hidden trait "
"dependency:"
msgstr ""

#: src/2008-non-exhaustive.md:560 src/2008-non-exhaustive.md:572
msgid "/* ... */"
msgstr ""

#: src/2008-non-exhaustive.md:565
msgid ""
"This way, although downstream crates can use this trait, they cannot "
"actually implement things for this trait."
msgstr ""

#: src/2008-non-exhaustive.md:568
msgid "This pattern could again be solved by using `#[non_exhaustive]`:"
msgstr ""

#: src/2008-non-exhaustive.md:577
msgid ""
"This would indicate to downstream traits that this trait might gain "
"additional requirements (dependent traits or methods to implement), and as "
"such, cannot be implemented downstream."
msgstr ""
