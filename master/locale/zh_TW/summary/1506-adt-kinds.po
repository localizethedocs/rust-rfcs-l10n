msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:03Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1506-adt-kinds.md:1
msgid "Feature Name: clarified_adt_kinds"
msgstr ""

#: src/1506-adt-kinds.md:2
msgid "Start Date: 2016-02-07"
msgstr ""

#: src/1506-adt-kinds.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1506](https://github.com/rust-lang/rfcs/pull/1506)"
msgstr ""

#: src/1506-adt-kinds.md:4
msgid ""
"Rust Issue: [rust-lang/rust#35626](https://github.com/rust-lang/rust/"
"issues/35626)"
msgstr ""

#: src/1506-adt-kinds.md:6
msgid "Summary"
msgstr ""

#: src/1506-adt-kinds.md:9
msgid ""
"Provide a simple model describing three kinds of structs and variants and "
"their relationships.  \n"
"Provide a way to match on structs/variants in patterns regardless of their "
"kind (`S{..}`).  \n"
"Permit tuple structs and tuple variants with zero fields (`TS()`)."
msgstr ""

#: src/1506-adt-kinds.md:13
msgid "Motivation"
msgstr ""

#: src/1506-adt-kinds.md:16
msgid ""
"There's some mental model lying under the current implementation of ADTs, "
"but it is not written out explicitly and not implemented completely "
"consistently. Writing this model out helps to identify its missing parts. "
"Some of this missing parts turn out to be practically useful. This RFC can "
"also serve as a piece of documentation."
msgstr ""

#: src/1506-adt-kinds.md:22
msgid "Detailed design"
msgstr ""

#: src/1506-adt-kinds.md:25
msgid ""
"The text below mostly talks about structures, but almost everything is "
"equally applicable to variants."
msgstr ""

#: src/1506-adt-kinds.md:28
msgid "Braced structs"
msgstr ""

#: src/1506-adt-kinds.md:30
msgid "Braced structs are declared with braces (unsurprisingly)."
msgstr ""

#: src/1506-adt-kinds.md:40
msgid ""
"Braced structs are the basic struct kind, other kinds are built on top of "
"them. Braced structs have 0 or more user-named fields and are defined only "
"in type namespace."
msgstr ""

#: src/1506-adt-kinds.md:43
msgid ""
"Braced structs can be used in struct expressions `S{field1: expr, field2: "
"expr}`, including functional record update (FRU) `S{field1: expr, ..s}`/`S{.."
"s}` and with struct patterns `S{field1: pat, field2: pat}`/`S{field1: "
"pat, ..}`/`S{..}`. In all cases the path `S` of the expression or pattern is "
"looked up in the type namespace (so these expressions/patterns can be used "
"with type aliases). Fields of a braced struct can be accessed with dot "
"syntax `s.field1`."
msgstr ""

#: src/1506-adt-kinds.md:50
msgid ""
"Note: struct _variants_ are currently defined in the value namespace in "
"addition to type namespace, there are no particular reasons for this and "
"this is probably temporary."
msgstr ""

#: src/1506-adt-kinds.md:53
msgid "Unit structs"
msgstr ""

#: src/1506-adt-kinds.md:55
msgid "Unit structs are defined without any fields or brackets."
msgstr ""

#: src/1506-adt-kinds.md:61
msgid ""
"Unit structs can be thought of as a single declaration for two things: a "
"basic struct"
msgstr ""

#: src/1506-adt-kinds.md:67
msgid "and a constant with the same name<sup>Note 1</sup>"
msgstr ""

#: src/1506-adt-kinds.md:73
msgid ""
"Unit structs have 0 fields and are defined in both type (the type `US`) and "
"value (the constant `US`) namespaces."
msgstr ""

#: src/1506-adt-kinds.md:76
msgid ""
"As a basic struct, a unit struct can participate in struct expressions `US{}"
"`, including FRU `US{..s}` and in struct patterns `US{}`/`US{..}`. In both "
"cases the path `US` of the expression or pattern is looked up in the type "
"namespace (so these expressions/patterns can be used with type aliases). "
"Fields of a unit struct could also be accessed with dot syntax, but it "
"doesn't have any fields."
msgstr ""

#: src/1506-adt-kinds.md:82
msgid ""
"As a constant, a unit struct can participate in unit struct expressions `US` "
"and unit struct patterns `US`, both of these are looked up in the value "
"namespace in which the constant `US` is defined (so these expressions/"
"patterns cannot be used with type aliases)."
msgstr ""

#: src/1506-adt-kinds.md:86
msgid ""
"Note 1: the constant is not exactly a `const` item, there are subtle "
"differences (e.g. with regards to `match` exhaustiveness), but it's a close "
"approximation.  \n"
"Note 2: the constant is pretty weirdly namespaced in case of unit "
"_variants_, constants can't be defined in \"enum modules\" manually."
msgstr ""

#: src/1506-adt-kinds.md:91
msgid "Tuple structs"
msgstr ""

#: src/1506-adt-kinds.md:93
msgid "Tuple structs are declared with parentheses."
msgstr ""

#: src/1506-adt-kinds.md:98
msgid ""
"Tuple structs can be thought of as a single declaration for two things: a "
"basic struct"
msgstr ""

#: src/1506-adt-kinds.md:108
msgid "and a constructor function with the same name<sup>Note 2</sup>"
msgstr ""

#: src/1506-adt-kinds.md:116
msgid ""
"Tuple structs have 0 or more automatically-named fields and are defined in "
"both type (the type `TS`) and the value (the constructor function `TS`) "
"namespaces."
msgstr ""

#: src/1506-adt-kinds.md:119
msgid ""
"As a basic struct, a tuple struct can participate in struct expressions "
"`TS{0: expr, 1: expr}`, including FRU `TS{0: expr, ..ts}`/`TS{..ts}` and in "
"struct patterns `TS{0: pat, 1: pat}`/`TS{0: pat, ..}`/`TS{..}`. In both "
"cases the path `TS` of the expression or pattern is looked up in the type "
"namespace (so these expressions/patterns can be used with type aliases). "
"Fields of a tuple struct can be accessed with dot syntax `ts.0`."
msgstr ""

#: src/1506-adt-kinds.md:126
msgid ""
"As a constructor, a tuple struct can participate in tuple struct expressions "
"`TS(expr, expr)` and tuple struct patterns `TS(pat, pat)`/`TS(..)`, both of "
"these are looked up in the value namespace in which the constructor `TS` is "
"defined (so these expressions/patterns cannot be used with type aliases). "
"Tuple struct expressions `TS(expr, expr)` are usual function calls, but the "
"compiler reserves the right to make observable improvements to them based on "
"the additional knowledge, that `TS` is a constructor."
msgstr ""

#: src/1506-adt-kinds.md:133
msgid ""
"Note 1: the automatically assigned field names are quite interesting, they "
"are not identifiers lexically (they are integer literals), so such fields "
"can't be defined manually.  \n"
"Note 2: the constructor function is not exactly a `fn` item, there are "
"subtle differences (e.g. with regards to privacy checks), but it's a close "
"approximation."
msgstr ""

#: src/1506-adt-kinds.md:138
msgid "Summary of the changes."
msgstr ""

#: src/1506-adt-kinds.md:140
msgid ""
"Everything related to braced structs and unit structs is already implemented."
msgstr ""

#: src/1506-adt-kinds.md:142
msgid ""
"New: Permit tuple structs and tuple variants with 0 fields. This restriction "
"is artificial and can be lifted trivially. Macro writers dealing with tuple "
"structs/variants will be happy to get rid of this one special case."
msgstr ""

#: src/1506-adt-kinds.md:146
msgid ""
"New: Permit using tuple structs and tuple variants in braced struct patterns "
"and expressions not requiring naming their fields - `TS{..ts}`/`TS{}`/`TS{..}"
"`. This doesn't require much effort to implement as well.  \n"
"This also means that `S{..}` patterns can be used to match structures and "
"variants of any kind. The desire to have such \"match everything\" patterns "
"is sometimes expressed given that number of fields in structures and "
"variants can change from zero to non-zero and back during development.  \n"
"An extra benefit is ability to match/construct tuple structs using their "
"type aliases."
msgstr ""

#: src/1506-adt-kinds.md:155
msgid ""
"New: Permit using tuple structs and tuple variants in braced struct patterns "
"and expressions requiring naming their fields - `TS{0: expr}`/`TS{0: pat}`/"
"etc. While this change is important for consistency, there's not much "
"motivation for it in hand-written code besides shortening patterns like "
"`ItemFn(_, _, unsafety, _, _, _)` into something like `ItemFn{2: "
"unsafety, ..}` and ability to match/construct tuple structs using their type "
"aliases.  \n"
"However, automatic code generators (e.g. syntax extensions) can get more "
"benefits from the ability to generate uniform code for all structure "
"kinds.  \n"
"`#[derive]` for example, currently has separate code paths for generating "
"expressions and patterns for braces structs (`ExprStruct`/`PatKind::"
"Struct`), tuple structs (`ExprCall`/`PatKind::TupleStruct`) and unit structs "
"(`ExprPath`/`PatKind::Path`). With proposed changes `#[derive]` could "
"simplify its logic and always generate braced forms for expressions and "
"patterns."
msgstr ""

#: src/1506-adt-kinds.md:168
msgid "Drawbacks"
msgstr ""

#: src/1506-adt-kinds.md:171 src/1506-adt-kinds.md:176
#: src/1506-adt-kinds.md:181
msgid "None."
msgstr ""

#: src/1506-adt-kinds.md:173
msgid "Alternatives"
msgstr ""

#: src/1506-adt-kinds.md:178
msgid "Unresolved questions"
msgstr ""
