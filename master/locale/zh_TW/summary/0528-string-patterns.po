msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:42Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0528-string-patterns.md:1
msgid "Feature Name: `pattern`"
msgstr ""

#: src/0528-string-patterns.md:2
msgid "Start Date: 2015-02-17"
msgstr ""

#: src/0528-string-patterns.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#528](https://github.com/rust-lang/rfcs/pull/528)"
msgstr ""

#: src/0528-string-patterns.md:4
msgid ""
"Rust Issue: [rust-lang/rust#27721](https://github.com/rust-lang/rust/"
"issues/27721)"
msgstr ""

#: src/0528-string-patterns.md:6
msgid "Summary"
msgstr "摘要"

#: src/0528-string-patterns.md:8
msgid ""
"Stabilize all string functions working with search patterns around a new "
"generic API that provides a unified way to define and use those patterns."
msgstr ""

#: src/0528-string-patterns.md:11
msgid "Motivation"
msgstr "動機"

#: src/0528-string-patterns.md:13
msgid ""
"Right now, string slices define a couple of methods for string manipulation "
"that work with user provided values that act as search patterns. For "
"example, `split()` takes an type implementing `CharEq` to split the slice at "
"all codepoints that match that predicate."
msgstr ""

#: src/0528-string-patterns.md:18
msgid ""
"Among these methods, the notion of what exactly is being used as a search "
"pattern varies inconsistently: Many work with the generic `CharEq`, which "
"only looks at a single codepoint at a time; and some work with `char` or "
"`&str` directly, sometimes duplicating a method to provide operations for "
"both."
msgstr ""

#: src/0528-string-patterns.md:24
msgid "This presents a couple of issues:"
msgstr ""

#: src/0528-string-patterns.md:26
msgid "The API is inconsistent."
msgstr ""

#: src/0528-string-patterns.md:27
msgid ""
"The API duplicates similar operations on different types. (`contains` vs "
"`contains_char`)"
msgstr ""

#: src/0528-string-patterns.md:28
msgid ""
"The API does not provide all operations for all types. (For example, no "
"`rsplit` for `&str` patterns)"
msgstr ""

#: src/0528-string-patterns.md:29
msgid "The API is not extensible, eg to allow splitting at regex matches."
msgstr ""

#: src/0528-string-patterns.md:30
msgid ""
"The API offers no way to explicitly decide between different search "
"algorithms for the same pattern, for example to use Boyer-Moore string "
"searching."
msgstr ""

#: src/0528-string-patterns.md:33
msgid ""
"At the moment, the full set of relevant string methods roughly looks like "
"this:"
msgstr ""

#: src/0528-string-patterns.md:59 src/0528-string-patterns.md:282
msgid "// ...\n"
msgstr ""

#: src/0528-string-patterns.md:63
msgid ""
"This RFC proposes to fix those issues by providing a unified `Pattern` trait "
"that all \"string pattern\" types would implement, and that would be used by "
"the string API exclusively."
msgstr ""

#: src/0528-string-patterns.md:67
msgid ""
"This fixes the duplication, consistency, and extensibility problems, and "
"also allows to define newtype wrappers for the same pattern types that use "
"different or specific search implementations."
msgstr ""

#: src/0528-string-patterns.md:71
msgid ""
"As an additional design goal, the new abstractions should also not pose a "
"problem for optimization - like for iterators, a concrete instance should "
"produce similar machine code to a hardcoded optimized loop written in C."
msgstr ""

#: src/0528-string-patterns.md:75
msgid "Detailed design"
msgstr "詳細設計"

#: src/0528-string-patterns.md:77
msgid "New traits"
msgstr ""

#: src/0528-string-patterns.md:79
msgid "First, new traits will be added to the `str` module in the std library:"
msgstr ""

#: src/0528-string-patterns.md:86 src/0528-string-patterns.md:87
#: src/0528-string-patterns.md:89 src/0528-string-patterns.md:129
#: src/0528-string-patterns.md:130 src/0528-string-patterns.md:135
#: src/0528-string-patterns.md:136
msgid "/* default*/"
msgstr ""

#: src/0528-string-patterns.md:93
msgid ""
"A `Pattern` represents a builder for an associated type implementing a "
"family of `Searcher` traits (see below), and will be implemented by all "
"types that represent string patterns, which includes:"
msgstr ""

#: src/0528-string-patterns.md:97
msgid "`&str`"
msgstr ""

#: src/0528-string-patterns.md:98
msgid "`char`, and everything else implementing `CharEq`"
msgstr ""

#: src/0528-string-patterns.md:99
msgid "Third party types like `&Regex` or `Ascii`"
msgstr ""

#: src/0528-string-patterns.md:100
msgid "Alternative algorithm wrappers like `struct BoyerMoore(&str)`"
msgstr ""

#: src/0528-string-patterns.md:103 src/0528-string-patterns.md:104
#: src/0528-string-patterns.md:106 src/0528-string-patterns.md:107
#: src/0528-string-patterns.md:109 src/0528-string-patterns.md:440
msgid "/* ... */"
msgstr ""

#: src/0528-string-patterns.md:112
msgid ""
"The lifetime parameter on `Pattern` exists in order to allow threading the "
"lifetime of the haystack (the string to be searched through) through the "
"API, and is a workaround for not having associated higher kinded types yet."
msgstr ""

#: src/0528-string-patterns.md:116
msgid ""
"Consumers of this API can then call `into_searcher()` on the pattern to "
"convert it into a type implementing a family of `Searcher` traits:"
msgstr ""

#: src/0528-string-patterns.md:141
msgid ""
"The basic idea of a `Searcher` is to expose a interface for iterating "
"through all connected string fragments of the haystack while classifying "
"them as either a match, or a reject."
msgstr ""

#: src/0528-string-patterns.md:144
msgid ""
"This happens in form of the returned enum value. A `Match` needs to contain "
"the start and end indices of a complete non-overlapping match, while a "
"`Rejects` may be emitted for arbitrary non-overlapping rejected parts of the "
"string, as long as the start and end indices lie on valid utf8 boundaries."
msgstr ""

#: src/0528-string-patterns.md:146
msgid ""
"Similar to iterators, depending on the concrete implementation a searcher "
"can have additional capabilities that build on each other, which is why they "
"will be defined in terms of a three-tier hierarchy:"
msgstr ""

#: src/0528-string-patterns.md:150
msgid ""
"`Searcher<'a>` is the basic trait that all searchers need to implement. It "
"contains a `next()` method that returns the `start` and `end` indices of the "
"next match or reject in the haystack, with the search beginning at the front "
"(left) of the string. It also contains a `haystack()` getter for returning "
"the actual haystack, which is the source of the `'a` lifetime on the "
"hierarchy. The reason for this getter being made part of the trait is "
"twofold:"
msgstr ""

#: src/0528-string-patterns.md:156
msgid "Every searcher needs to store some reference to the haystack anyway."
msgstr ""

#: src/0528-string-patterns.md:157
msgid ""
"Users of this trait will need access to the haystack in order for the "
"individual match results to be useful."
msgstr ""

#: src/0528-string-patterns.md:159
msgid ""
"`ReverseSearcher<'a>` adds an `next_back()` method, for also allowing to "
"efficiently search in reverse (starting from the right). However, the "
"results are not required to be equal to the results of `next()` in reverse, "
"(as would be the case for the `DoubleEndedIterator` trait) because that can "
"not be efficiently guaranteed for all searchers. (For an example, see "
"further below)"
msgstr ""

#: src/0528-string-patterns.md:164
msgid ""
"Instead `DoubleEndedSearcher<'a>` is provided as an marker trait for "
"expressing that guarantee - If a searcher implements this trait, all results "
"found from the left need to be equal to all results found from the right in "
"reverse order."
msgstr ""

#: src/0528-string-patterns.md:168
msgid ""
"As an important last detail, both `Searcher` and `ReverseSearcher` are "
"marked as `unsafe` traits, even though the actual methods aren't. This is "
"because every implementation of these traits need to ensure that all indices "
"returned by `next()` and `next_back()` lie on valid utf8 boundaries in the "
"haystack."
msgstr ""

#: src/0528-string-patterns.md:174
msgid ""
"Without that guarantee, every single match returned by a matcher would need "
"to be double-checked for validity, which would be unnecessary and most "
"likely unoptimizable work."
msgstr ""

#: src/0528-string-patterns.md:178
msgid ""
"This is in contrast to the current hardcoded implementations, which can make "
"use of such guarantees because the concrete types are known and all unsafe "
"code needed for such optimizations is contained inside a single safe impl."
msgstr ""

#: src/0528-string-patterns.md:182
msgid ""
"Given that most implementations of these traits will likely live in the std "
"library anyway, and are thoroughly tested, marking these traits `unsafe` "
"doesn't seem like a huge burden to bear for good, optimizable performance."
msgstr ""

#: src/0528-string-patterns.md:186
msgid "The role of the additional default methods"
msgstr ""

#: src/0528-string-patterns.md:188
msgid ""
"`Pattern`, `Searcher` and `ReverseSearcher` each offer a few additional "
"default methods that give better optimization opportunities."
msgstr ""

#: src/0528-string-patterns.md:191
msgid ""
"Most consumers of the pattern API will use them to more narrowly constraint "
"how they are looking for a pattern, which given an optimized "
"implementantion, should lead to mostly optimal code being generated."
msgstr ""

#: src/0528-string-patterns.md:195
msgid "Example for the issue with double-ended searching"
msgstr ""

#: src/0528-string-patterns.md:197
msgid ""
"Let the haystack be the string `\"fooaaaaabar\"`, and let the pattern be the "
"string `\"aa\"`."
msgstr ""

#: src/0528-string-patterns.md:199
msgid ""
"Then a efficient, lazy implementation of the matcher searching from the left "
"would find these matches:"
msgstr ""

#: src/0528-string-patterns.md:202
msgid "`\"foo[aa][aa]abar\"`"
msgstr ""

#: src/0528-string-patterns.md:204
msgid ""
"However, the same algorithm searching from the right would find these "
"matches:"
msgstr ""

#: src/0528-string-patterns.md:206
msgid "`\"fooa[aa][aa]bar\"`"
msgstr ""

#: src/0528-string-patterns.md:208
msgid ""
"This discrepancy can not be avoided without additional overhead or even "
"allocations for caching in the reverse matcher, and thus \"matching from the "
"front\" needs to be considered a different operation than \"matching from "
"the back\"."
msgstr ""

#: src/0528-string-patterns.md:212
msgid "Why `(uint, uint)` instead of `&str`"
msgstr ""

#: src/0528-string-patterns.md:214
msgid "Note: This section is a bit outdated now"
msgstr ""

#: src/0528-string-patterns.md:216
msgid ""
"It would be possible to define `next` and `next_back` to return `&str`s "
"instead of `(uint, uint)` tuples."
msgstr ""

#: src/0528-string-patterns.md:218
msgid ""
"A concrete searcher impl could then make use of unsafe code to construct "
"such an slice cheaply, and by its very nature it is guaranteed to lie on "
"utf8 boundaries, which would also allow not marking the traits as unsafe."
msgstr ""

#: src/0528-string-patterns.md:222
msgid ""
"However, this approach has a couple of issues. For one, not every consumer "
"of this API cares about only the matched slice itself:"
msgstr ""

#: src/0528-string-patterns.md:225
msgid ""
"The `split()` family of operations cares about the slices _between_ matches."
msgstr ""

#: src/0528-string-patterns.md:226
msgid ""
"Operations like `match_indices()` and `find()` need to actually return the "
"offset to the start of the string as part of their definition."
msgstr ""

#: src/0528-string-patterns.md:228
msgid ""
"The `trim()` and `Xs_with()` family of operations need to compare individual "
"match offsets with each other and the start and end of the string."
msgstr ""

#: src/0528-string-patterns.md:231
msgid ""
"In order for these use cases to work with a `&str` match, the concrete "
"adapters would need to unsafely calculate the offset of a match `&str` to "
"the start of the haystack `&str`."
msgstr ""

#: src/0528-string-patterns.md:234
msgid ""
"But that in turn would require matcher implementors to only return actual "
"sub slices into the haystack, and not random `static` string slices, as the "
"API defined with `&str` would allow."
msgstr ""

#: src/0528-string-patterns.md:237
msgid "In order to resolve that issue, you'd have to do one of:"
msgstr ""

#: src/0528-string-patterns.md:239
msgid ""
"Add the uncheckable API constraint of only requiring true subslices, which "
"would make the traits unsafe again, negating much of the benefit."
msgstr ""

#: src/0528-string-patterns.md:241
msgid ""
"Return a more complex custom slice type that still contains the haystack "
"offset. (This is listed as an alternative at the end of this RFC.)"
msgstr ""

#: src/0528-string-patterns.md:244
msgid ""
"In both cases, the API does not really improve significantly, so `uint` "
"indices have been chosen as the \"simple\" default design."
msgstr ""

#: src/0528-string-patterns.md:247
msgid "New methods on `StrExt`"
msgstr ""

#: src/0528-string-patterns.md:249
msgid ""
"With the `Pattern` and `Searcher` traits defined and implemented, the actual "
"`str` methods will be changed to make use of them:"
msgstr ""

#: src/0528-string-patterns.md:286
msgid ""
"These are mainly the same pattern-using methods as currently existing, only "
"changed to uniformly use the new pattern API. The main differences are:"
msgstr ""

#: src/0528-string-patterns.md:289
msgid ""
"Duplicates like `contains(char)` and `contains_str(&str)` got merged into "
"single generic methods."
msgstr ""

#: src/0528-string-patterns.md:290
msgid ""
"`CharEq`\\-centric naming got changed to `Pattern`\\-centric naming by "
"changing `chars` to `matches` in a few method names."
msgstr ""

#: src/0528-string-patterns.md:292
msgid ""
"A `Matches` iterator has been added, that just returns the pattern matches "
"as `&str` slices. Its uninteresting for patterns that look for a single "
"string fragment, like the `char` and `&str` matcher, but useful for advanced "
"patterns like predicates over codepoints, or regular expressions."
msgstr ""

#: src/0528-string-patterns.md:295
msgid ""
"All operations that can work from both the front and the back consistently "
"exist in two versions, the regular front version, and a `r` prefixed reverse "
"versions. As explained above, this is because both represent different "
"operations, and thus need to be handled as such. To be more precise, the two "
"can **not** be abstracted over by providing a `DoubleEndedIterator` "
"implementations, as the different results would break the requirement for "
"double ended iterators to behave like a double ended queues where you just "
"pop elements from both sides."
msgstr ""

#: src/0528-string-patterns.md:302
msgid ""
"_However_, all iterators will still implement `DoubleEndedIterator` if the "
"underlying matcher implements `DoubleEndedSearcher`, to keep the ability to "
"do things like `foo.split('a').rev()`."
msgstr ""

#: src/0528-string-patterns.md:305
msgid "Transition and deprecation plans"
msgstr ""

#: src/0528-string-patterns.md:307
msgid ""
"Most changes in this RFC can be made in such a way that code using the old "
"hardcoded or `CharEq`\\-using methods will still compile, or give "
"deprecation warning."
msgstr ""

#: src/0528-string-patterns.md:310
msgid ""
"It would even be possible to generically implement `Pattern` for all "
"`CharEq` types, making the transition more painless."
msgstr ""

#: src/0528-string-patterns.md:313
msgid ""
"Long-term, post 1.0, it would be possible to define new sets of `Pattern` "
"and `Searcher` without a lifetime parameter by making use of higher kinded "
"types in order to simplify the string APIs. Eg, instead of `fn "
"starts_with<'a, P>(&'a self, pat: P) -> bool where P: Pattern<'a>;` you'd "
"have `fn starts_with<P>(&self, pat: P) -> bool where P: Pattern;`."
msgstr ""

#: src/0528-string-patterns.md:318
msgid ""
"In order to not break backwards-compatibility, these can use the same "
"generic-impl trick to forward to the old traits, which would roughly look "
"like this:"
msgstr ""

#: src/0528-string-patterns.md:351
msgid ""
"Based on coherency experiments and assumptions about how future HKT will "
"work, the author is assuming that the above implementation will work, but "
"can not experimentally prove it."
msgstr ""

#: src/0528-string-patterns.md:354
msgid ""
"Note: There might be still an issue with this upgrade path on the concrete "
"iterator types. That is, `Split<P>` might turn into `Split<'a, P>`... Maybe "
"require the `'a` from the beginning?"
msgstr ""

#: src/0528-string-patterns.md:357
msgid ""
"In order for these new traits to fully replace the old ones without getting "
"in their way, the old ones need to not be defined in a way that makes them "
"\"final\". That is, they should be defined in their own submodule, like "
"`str::pattern` that can grow a sister module like `str::newpattern`, and not "
"be exported in a global place like `str` or even the `prelude` (which would "
"be unneeded anyway)."
msgstr ""

#: src/0528-string-patterns.md:363
msgid "Drawbacks"
msgstr ""

#: src/0528-string-patterns.md:365
msgid ""
"It complicates the whole machinery and API behind the implementation of "
"matching on string patterns."
msgstr ""

#: src/0528-string-patterns.md:366
msgid ""
"The no-HKT-lifetime-workaround wart might be to confusing for something as "
"commonplace as the string API."
msgstr ""

#: src/0528-string-patterns.md:367
msgid ""
"This add a few layers of generics, so compilation times and micro "
"optimizations might suffer."
msgstr ""

#: src/0528-string-patterns.md:369
msgid "Alternatives"
msgstr "替代方案"

#: src/0528-string-patterns.md:371
msgid "Note: This section is not updated to the new naming scheme"
msgstr ""

#: src/0528-string-patterns.md:373
msgid "In general:"
msgstr ""

#: src/0528-string-patterns.md:375
msgid "Keep status quo, with all issues listed at the beginning."
msgstr ""

#: src/0528-string-patterns.md:376
msgid ""
"Stabilize on hardcoded variants, eg providing both `contains` and "
"`contains_str`. Similar to status quo, but no `CharEq` and thus no generics."
msgstr ""

#: src/0528-string-patterns.md:379
msgid ""
"Under the assumption that the lifetime parameter on the traits in this "
"proposal is too big a wart to have in the release string API, there is an "
"primary alternative that would avoid it:"
msgstr ""

#: src/0528-string-patterns.md:383
msgid ""
"Stabilize on a variant around `CharEq` - This would mean hardcoded `_str` "
"methods, generic `CharEq` methods, and no extensibility to types like "
"`Regex`, but has a upgrade path for later upgrading `CharEq` to a full-"
"fledged, HKT-using `Pattern` API, by providing back-comp generic impls."
msgstr ""

#: src/0528-string-patterns.md:388
msgid ""
"Next, there are alternatives that might make a positive difference in the "
"authors opinion, but still have some negative trade-offs:"
msgstr ""

#: src/0528-string-patterns.md:391
msgid ""
"With the `Matcher` traits having the unsafe constraint of returning results "
"unique to the current haystack already, they could just directly return a "
"`(*const u8, *const u8)` pointing into it. This would allow a few more micro-"
"optimizations, as now the `matcher -> match -> final slice` pipeline would "
"no longer need to keep adding and subtracting the start address of the "
"haystack for immediate results."
msgstr ""

#: src/0528-string-patterns.md:396
msgid ""
"Extend `Pattern` into `Pattern` and `ReversePattern`, starting the forward-"
"reverse split at the level of patterns directly. The two would still be in a "
"inherits-from relationship like `Matcher` and `ReverseSearcher`, and be "
"interchangeable if the later also implement `DoubleEndedSearcher`, but on "
"the `str` API where clauses like `where P: Pattern<'a>, P::Searcher: "
"ReverseSearcher<'a>` would turn into `where P: ReversePattern<'a>`."
msgstr ""

#: src/0528-string-patterns.md:402
msgid ""
"Lastly, there are alternatives that don't seem very favorable, but are "
"listed for completeness sake:"
msgstr ""

#: src/0528-string-patterns.md:404
msgid ""
"Remove `unsafe` from the API by returning a special `SubSlice<'a>` type "
"instead of `(uint, uint)` in each match, that wraps the haystack and the "
"current match as a `(*start, *match_start, *match_end, *end)` pointer quad. "
"It is unclear whether those two additional words per match end up being an "
"issue after monomorphization, but two of them will be constant for the "
"duration of the iteration, so changes are they won't matter. The "
"`haystack()` could also be removed that way, as each match already returns "
"the haystack. However, this still prevents removal of the lifetime "
"parameters without HKT."
msgstr ""

#: src/0528-string-patterns.md:411
msgid ""
"Remove the lifetimes on `Matcher` and `Pattern` by requiring users of the "
"API to store the haystack slice themselves, duplicating it in the in-memory "
"representation. However, this still runs into HKT issues with the impl of "
"`Pattern`."
msgstr ""

#: src/0528-string-patterns.md:414
msgid ""
"Remove the lifetime parameter on `Pattern` and `Matcher` by making them "
"fully unsafe API's, and require implementations to unsafely transmuting back "
"the lifetime of the haystack slice."
msgstr ""

#: src/0528-string-patterns.md:416
msgid ""
"Remove `unsafe` from the API by not marking the `Matcher` traits as "
"`unsafe`, requiring users of the API to explicitly check every match on "
"validity in regard to utf8 boundaries."
msgstr ""

#: src/0528-string-patterns.md:418
msgid ""
"Allow to opt-in the `unsafe` traits by providing parallel safe and unsafe "
"`Matcher` traits or methods, with the one per default implemented in terms "
"of the other."
msgstr ""

#: src/0528-string-patterns.md:421
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/0528-string-patterns.md:423
msgid "Concrete performance is untested compared to the current situation."
msgstr ""

#: src/0528-string-patterns.md:424
msgid ""
"Should the API split in regard to forward-reverse matching be as symmetrical "
"as possible, or as minimal as possible? In the first case, iterators like "
"`Matches` and `RMatches` could both implement `DoubleEndedIterator` if a "
"`DoubleEndedSearcher` exists, in the latter only `Matches` would, with "
"`RMatches` only providing the minimum to support reverse operation. A ruling "
"in favor of symmetry would also speak for the `ReversePattern` alternative."
msgstr ""

#: src/0528-string-patterns.md:431
msgid "Additional extensions"
msgstr ""

#: src/0528-string-patterns.md:433
msgid ""
"A similar abstraction system could be implemented for `String` APIs, so that "
"for example `string.push(\"foo\")`, `string.push('f')`, `string.push('f'."
"to_ascii())` all work by using something like a `StringSource` trait."
msgstr ""

#: src/0528-string-patterns.md:436
msgid ""
"This would allow operations like `s.replace(&regex!(...), \"foo\")`, which "
"would be a method generic over both the pattern matched and the string "
"fragment it gets replaced with:"
msgstr ""
