msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:03Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1212-line-endings.md:1
msgid "Feature Name: `line_endings`"
msgstr ""

#: src/1212-line-endings.md:2
msgid "Start Date: 2015-07-10"
msgstr ""

#: src/1212-line-endings.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1212](https://github.com/rust-lang/rfcs/pull/1212)"
msgstr ""

#: src/1212-line-endings.md:4
msgid ""
"Rust Issue: [rust-lang/rust#28032](https://github.com/rust-lang/rust/"
"issues/28032)"
msgstr ""

#: src/1212-line-endings.md:6
msgid "Summary"
msgstr "摘要"

#: src/1212-line-endings.md:8
msgid ""
"Change all functions dealing with reading \"lines\" to treat both '\\n' and "
"'\\r\\n' as a valid line-ending."
msgstr ""

#: src/1212-line-endings.md:11
msgid "Motivation"
msgstr "動機"

#: src/1212-line-endings.md:13
msgid ""
"The current behavior of these functions is to treat only '\\n' as line-"
"ending. This is surprising for programmers experienced in other languages. "
"Many languages open files in a \"text-mode\" per default, which means when "
"they iterate over the lines, they don't have to worry about the two kinds of "
"line-endings. Such programmers will be surprised to learn that they have to "
"take care of such details themselves in Rust. Some may not even have heard "
"of the distinction between two styles of line-endings."
msgstr ""

#: src/1212-line-endings.md:21
msgid ""
"The current design also violates the \"do what I mean\" principle. Both "
"'\\r\\n' and '\\n' are widely used as line-separators. By talking about the "
"concept of \"lines\", it is clear that the current file (or buffer, really) "
"is considered to be in text format. It is thus very reasonable to expect "
"\"lines\" to apply to both kinds of encoding lines in binary format."
msgstr ""

#: src/1212-line-endings.md:27
msgid ""
"In particular, if the crate is developed on Linux or Mac, the programmer "
"will probably have most of his input encoded with only '\\n' for the line-"
"endings. He may use the functions talking about \"lines\", and they will "
"work all right. It is only when someone runs this crate on input that "
"contains '\\r\\n' that the bug will be uncovered. The editor has personally "
"run into this issue when reading line-by-line from stdin, with the program "
"suddenly failing on Windows."
msgstr ""

#: src/1212-line-endings.md:34
msgid "Detailed design"
msgstr "詳細設計"

#: src/1212-line-endings.md:36
msgid ""
"The following functions will have to be changed: `BufRead::lines` and `str::"
"lines`. They both should treat '\\r\\n' as marking the end of a line. This "
"can be implemented, for example, by first splitting at '\\n' like now and "
"then removing a trailing '\\r' right before returning data to the caller."
msgstr ""

#: src/1212-line-endings.md:41
msgid ""
"Furthermore, `str::lines_any` (the only function currently dealing with both "
"kinds of line-endings) is deprecated, as it is then functionally equivalent "
"with `str::lines`."
msgstr ""

#: src/1212-line-endings.md:45
msgid "Drawbacks"
msgstr ""

#: src/1212-line-endings.md:47
msgid ""
"This is a semantics-breaking change, changing the behavior of released, "
"stable API. However, as argued above, the new behavior is much less "
"surprising than the old one - so one could consider this fixing a bug in the "
"original implementation. There are alternatives available for the case that "
"one really wants to split at '\\n' only, namely `BufRead::split` and `str::"
"split`. However, `BufRead:split` does not iterate over `String`, but rather "
"over `Vec<u8>`, so users have to insert an additional explicit call to "
"`String::from_utf8`."
msgstr ""

#: src/1212-line-endings.md:55
msgid "Alternatives"
msgstr ""

#: src/1212-line-endings.md:57
msgid ""
"There's the obvious alternative of not doing anything. This leaves a gap in "
"the features Rust provides to deal with text files, making it hard to treat "
"both kinds of line-endings uniformly."
msgstr ""

#: src/1212-line-endings.md:61
msgid ""
"The second alternative is to add `BufRead::lines_any` which works similar to "
"`str::lines_any` in that it deals with both '\\n' and '\\r\\n'. This "
"provides all the necessary functionality, but it still leaves people with "
"the need to choose one of the two functions - and potentially choosing the "
"wrong one. In particular, the functions with the shorter, nicer name (the "
"existing ones) will almost always _not_ be the right choice."
msgstr ""

#: src/1212-line-endings.md:68
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/1212-line-endings.md:70
msgid "None I can think of."
msgstr ""
