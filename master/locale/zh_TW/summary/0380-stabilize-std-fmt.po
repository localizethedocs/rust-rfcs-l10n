msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0380-stabilize-std-fmt.md:1
msgid "Start Date: 2014-11-12"
msgstr ""

#: src/0380-stabilize-std-fmt.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#380](https://github.com/rust-lang/rfcs/pull/380)"
msgstr ""

#: src/0380-stabilize-std-fmt.md:3
msgid ""
"Rust Issue: [rust-lang/rust#18904](https://github.com/rust-lang/rust/"
"issues/18904)"
msgstr ""

#: src/0380-stabilize-std-fmt.md:5
msgid "Summary"
msgstr ""

#: src/0380-stabilize-std-fmt.md:7
msgid ""
"Stabilize the `std::fmt` module, in addition to the related macros and "
"formatting language syntax. As a high-level summary:"
msgstr ""

#: src/0380-stabilize-std-fmt.md:10
msgid "Leave the format syntax as-is."
msgstr ""

#: src/0380-stabilize-std-fmt.md:11
msgid ""
"Remove a number of superfluous formatting traits (renaming a few in the "
"process)."
msgstr ""

#: src/0380-stabilize-std-fmt.md:14
msgid "Motivation"
msgstr ""

#: src/0380-stabilize-std-fmt.md:16
msgid ""
"This RFC is primarily motivated by the need to stabilize `std::fmt`. In the "
"past stabilization has not required RFCs, but the changes envisioned for "
"this module are far-reaching and modify some parts of the language (format "
"syntax), leading to the conclusion that this stabilization effort required "
"an RFC."
msgstr ""

#: src/0380-stabilize-std-fmt.md:21
msgid "Detailed design"
msgstr ""

#: src/0380-stabilize-std-fmt.md:23
msgid ""
"The `std::fmt` module encompasses more than just the actual structs/traits/"
"functions/etc defined within it, but also a number of macros and the "
"formatting language syntax for describing format strings. Each of these "
"features of the module will be described in turn."
msgstr ""

#: src/0380-stabilize-std-fmt.md:28
msgid "Formatting Language Syntax"
msgstr ""

#: src/0380-stabilize-std-fmt.md:30
msgid ""
"The [documented syntax](http://doc.rust-lang.org/std/fmt/#syntax) will not "
"be changing as-written. All of these features will be accepted wholesale "
"(considered stable):"
msgstr ""

#: src/0380-stabilize-std-fmt.md:34
msgid "Usage of `{}` for \"format something here\" placeholders"
msgstr ""

#: src/0380-stabilize-std-fmt.md:35
msgid "`{{` as an escape for `{` (and vice-versa for `}`)"
msgstr ""

#: src/0380-stabilize-std-fmt.md:36
msgid "Various format specifiers"
msgstr ""

#: src/0380-stabilize-std-fmt.md:37
msgid "fill character for alignment"
msgstr ""

#: src/0380-stabilize-std-fmt.md:38
msgid "actual alignment, left (`<`), center (`^`), and right (`>`)."
msgstr ""

#: src/0380-stabilize-std-fmt.md:39
msgid "sign to print (`+` or `-`)"
msgstr ""

#: src/0380-stabilize-std-fmt.md:40
msgid "minimum width for text to be printed"
msgstr ""

#: src/0380-stabilize-std-fmt.md:41
msgid "both a literal count and a runtime argument to the format string"
msgstr ""

#: src/0380-stabilize-std-fmt.md:42
msgid "precision or maximum width"
msgstr ""

#: src/0380-stabilize-std-fmt.md:43
msgid ""
"all of a literal count, a specific runtime argument to the format string, "
"and \"the next\" runtime argument to the format string."
msgstr ""

#: src/0380-stabilize-std-fmt.md:45
msgid "\"alternate formatting\" (`#`)"
msgstr ""

#: src/0380-stabilize-std-fmt.md:46
msgid "leading zeroes (`0`)"
msgstr ""

#: src/0380-stabilize-std-fmt.md:47
msgid "Integer specifiers of what to format (`{0}`)"
msgstr ""

#: src/0380-stabilize-std-fmt.md:48
msgid "Named arguments (`{foo}`)"
msgstr ""

#: src/0380-stabilize-std-fmt.md:50
msgid "Using Format Specifiers"
msgstr ""

#: src/0380-stabilize-std-fmt.md:52
msgid ""
"While quite useful occasionally, there is no static guarantee that any "
"implementation of a formatting trait actually respects the format specifiers "
"passed in. For example, this code does not necessarily work as expected:"
msgstr ""

#: src/0380-stabilize-std-fmt.md:60
msgid "\"{:10}\""
msgstr ""

#: src/0380-stabilize-std-fmt.md:63
msgid ""
"All of the primitives for rust (strings, integers, etc) have implementations "
"of `Show` which respect these formatting flags, but almost no other "
"implementations do (notably those generated via `deriving`)."
msgstr ""

#: src/0380-stabilize-std-fmt.md:67
msgid ""
"This RFC proposes stabilizing the formatting flags, despite this current "
"state of affairs. There are in theory possible alternatives in which there "
"is a static guarantee that a type does indeed respect format specifiers when "
"one is provided, generating a compile-time error when a type doesn't respect "
"a specifier. These alternatives, however, appear to be too heavyweight and "
"are considered somewhat overkill."
msgstr ""

#: src/0380-stabilize-std-fmt.md:74
msgid ""
"In general it's trivial to respect format specifiers if an implementation "
"delegates to a primitive or somehow has a buffer of what's to be formatted. "
"To cover these two use cases, the `Formatter` structure passed around has "
"helper methods to assist in formatting these situations. This is, however, "
"quite rare to fall into one of these two buckets, so the specifiers are "
"largely ignored (and the formatter is `write!`\\-n to directly)."
msgstr ""

#: src/0380-stabilize-std-fmt.md:81
msgid "Named Arguments"
msgstr ""

#: src/0380-stabilize-std-fmt.md:83
msgid ""
"Currently Rust does not support named arguments anywhere _except_ for format "
"strings. Format strings can get away with it because they're all part of a "
"macro invocation (unlike the rest of Rust syntax)."
msgstr ""

#: src/0380-stabilize-std-fmt.md:87
msgid ""
"The worry for stabilizing a named argument syntax for the formatting "
"language is that if Rust ever adopts named arguments with a _different_ "
"syntax, it would be quite odd having two systems."
msgstr ""

#: src/0380-stabilize-std-fmt.md:91
msgid ""
"The most recently proposed [keyword argument RFC](https://github.com/rust-"
"lang/rfcs/pull/257) used `:` for the invocation syntax rather than `=` as "
"formatting does today. Additionally, today `foo = bar` is a valid "
"expression, having a value of type `()`."
msgstr ""

#: src/0380-stabilize-std-fmt.md:96
msgid "With these worries, there are one of two routes that could be pursued:"
msgstr ""

#: src/0380-stabilize-std-fmt.md:98
msgid ""
"The `expr = expr` syntax could be disallowed on the language level. This "
"could happen both in a total fashion or just allowing the expression "
"appearing as a function argument. For both cases, this will probably be "
"considered a \"wart\" of Rust's grammar."
msgstr ""

#: src/0380-stabilize-std-fmt.md:102
msgid ""
"The `foo = bar` syntax could be allowed in the macro with prior knowledge "
"that the default argument syntax for Rust, if one is ever developed, will "
"likely be different. This would mean that the `foo = bar` syntax in "
"formatting macros will likely be considered a wart in the future."
msgstr ""

#: src/0380-stabilize-std-fmt.md:107
msgid ""
"Given these two cases, the clear choice seems to be accepting a wart in the "
"formatting macros themselves. It will likely be possible to extend the macro "
"in the future to support whatever named argument syntax is developed as "
"well, and the old syntax could be accepted for some time."
msgstr ""

#: src/0380-stabilize-std-fmt.md:112
msgid "Formatting Traits"
msgstr ""

#: src/0380-stabilize-std-fmt.md:114
msgid ""
"Today there are 16 formatting traits. Each trait represents a \"type\" of "
"formatting, corresponding to the `[type]` production in the formatting "
"syntax. As a bit of history, the original intent was for each trait to "
"declare what specifier it used, allowing users to add more specifiers in "
"newer crates. For example the `time` crate could provide the `{:time}` "
"formatting trait. This design was seen as too complicated, however, so it "
"was not landed. It does, however, partly motivate why there is one trait per "
"format specifier today."
msgstr ""

#: src/0380-stabilize-std-fmt.md:122
msgid "The 16 formatting traits and their format specifiers are:"
msgstr ""

#: src/0380-stabilize-std-fmt.md:124
msgid "_nothing_ ⇒ `Show`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:125
msgid "`d` ⇒ `Signed`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:126
msgid "`i` ⇒ `Signed`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:127
msgid "`u` ⇒ `Unsigned`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:128
msgid "`b` ⇒ `Bool`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:129
msgid "`c` ⇒ `Char`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:130
msgid "`o` ⇒ `Octal`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:131
msgid "`x` ⇒ `LowerHex`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:132
msgid "`X` ⇒ `UpperHex`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:133
msgid "`s` ⇒ `String`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:134
msgid "`p` ⇒ `Pointer`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:135
msgid "`t` ⇒ `Binary`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:136
msgid "`f` ⇒ `Float`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:137
msgid "`e` ⇒ `LowerExp`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:138
msgid "`E` ⇒ `UpperExp`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:139
msgid "`?` ⇒ `Poly`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:141
msgid "This RFC proposes removing the following traits:"
msgstr ""

#: src/0380-stabilize-std-fmt.md:143
msgid "`Signed`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:144
msgid "`Unsigned`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:145
msgid "`Bool`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:146
msgid "`Char`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:147
msgid "`String`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:148
msgid "`Float`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:150
msgid ""
"Note that this RFC would like to remove `Poly`, but that is covered by [a "
"separate RFC](https://github.com/rust-lang/rfcs/pull/379)."
msgstr ""

#: src/0380-stabilize-std-fmt.md:153
msgid ""
"Today by far the most common formatting trait is `Show`, and over time the "
"usefulness of these formatting traits has been reduced. The traits this RFC "
"proposes to remove are only assertions that the type provided actually "
"implements the trait, there are few known implementations of the traits "
"which diverge on how they are implemented."
msgstr ""

#: src/0380-stabilize-std-fmt.md:159
msgid "Additionally, there are a two of oddities inherited from ancient C:"
msgstr ""

#: src/0380-stabilize-std-fmt.md:161
msgid "Both `d` and `i` are wired to `Signed`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:162
msgid ""
"One may reasonable expect the `Binary` trait to use `b` as its specifier."
msgstr ""

#: src/0380-stabilize-std-fmt.md:164
msgid ""
"The remaining traits this RFC recommends leaving. The rationale for this is "
"that they represent alternate representations of primitive types in general, "
"and are also quite often expected when coming from other format syntaxes "
"such as C/Python/Ruby/etc."
msgstr ""

#: src/0380-stabilize-std-fmt.md:169
msgid ""
"It would, of course, be possible to re-add any of these traits in a "
"backwards-compatible fashion."
msgstr ""

#: src/0380-stabilize-std-fmt.md:172
msgid "Format type for `Binary`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:174
msgid ""
"With the removal of the `Bool` trait, this RFC recommends renaming the "
"specifier for `Binary` to `b` instead of `t`."
msgstr ""

#: src/0380-stabilize-std-fmt.md:177
msgid "Combining all traits"
msgstr ""

#: src/0380-stabilize-std-fmt.md:179
msgid ""
"A possible alternative to having many traits is to instead have one trait, "
"such as:"
msgstr ""

#: src/0380-stabilize-std-fmt.md:191
msgid "There are a number of pros to this design:"
msgstr ""

#: src/0380-stabilize-std-fmt.md:193
msgid ""
"Instead of having to consider many traits, only one trait needs to be "
"considered."
msgstr ""

#: src/0380-stabilize-std-fmt.md:195
msgid ""
"All types automatically implement all format types or zero format types."
msgstr ""

#: src/0380-stabilize-std-fmt.md:196
msgid ""
"In a hypothetical world where a format string could be constructed at "
"runtime, this would alleviate the signature of such a function. The concrete "
"type taken for all its arguments would be `&Show` and then if the format "
"string supplied `:x` or `:o` the runtime would simply delegate to the "
"relevant trait method."
msgstr ""

#: src/0380-stabilize-std-fmt.md:201
msgid ""
"There are also a number of cons to this design, which motivate this RFC "
"recommending the remaining separation of these traits."
msgstr ""

#: src/0380-stabilize-std-fmt.md:204
msgid ""
"The \"static assertion\" that a type implements a relevant format trait "
"becomes almost nonexistent because all types either implement none or all "
"formatting traits."
msgstr ""

#: src/0380-stabilize-std-fmt.md:207
msgid ""
"The documentation for the `Show` trait becomes somewhat overwhelming because "
"it's no longer immediately clear which method should be overridden for what."
msgstr ""

#: src/0380-stabilize-std-fmt.md:209
msgid ""
"A hypothetical world with runtime format string construction could find a "
"different system for taking arguments."
msgstr ""

#: src/0380-stabilize-std-fmt.md:212
msgid "Method signature"
msgstr ""

#: src/0380-stabilize-std-fmt.md:214
msgid "Currently, each formatting trait has a signature as follows:"
msgstr ""

#: src/0380-stabilize-std-fmt.md:220
msgid ""
"This implies that all formatting is considered to be a stream-oriented "
"operation where `f` is a sink to write bytes to. The `fmt::Result` type "
"indicates that some form of \"write error\" happened, but conveys no extra "
"information."
msgstr ""

#: src/0380-stabilize-std-fmt.md:224
msgid "This API has a number of oddities:"
msgstr ""

#: src/0380-stabilize-std-fmt.md:226
msgid ""
"The type `Formatter` has inherent `write` and `write_fmt` methods to be used "
"in conjunction with the `write!` macro return an instance of `fmt::Result`."
msgstr ""

#: src/0380-stabilize-std-fmt.md:228
msgid ""
"The `Formatter` type also implements the `std::io::Writer` trait in order to "
"be able to pass around a `&mut Writer`."
msgstr ""

#: src/0380-stabilize-std-fmt.md:230
msgid ""
"This relies on the duck-typing of macros and for the inherent `write_fmt` "
"method to trump the `Writer`'s `write_fmt` method in order to return an "
"error of the correct type."
msgstr ""

#: src/0380-stabilize-std-fmt.md:233
msgid ""
"The `Result` return type is an enumeration with precisely one variant, "
"`FormatError`."
msgstr ""

#: src/0380-stabilize-std-fmt.md:236
msgid ""
"Overall, this signature seems to be appropriate in terms of \"give me a sink "
"of bytes to write myself to, and let me return an error if one happens\". "
"Due to this, this RFC recommends that all formatting traits be marked "
"`#[unstable]`."
msgstr ""

#: src/0380-stabilize-std-fmt.md:240
msgid "Macros"
msgstr ""

#: src/0380-stabilize-std-fmt.md:242
msgid ""
"There are a number of prelude macros which interact with the format syntax:"
msgstr ""

#: src/0380-stabilize-std-fmt.md:244
msgid "`format_args`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:245
msgid "`format_args_method`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:246
msgid "`write`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:247
msgid "`writeln`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:248
msgid "`print`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:249
msgid "`println`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:250
msgid "`format`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:251
msgid "`fail`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:252
msgid "`assert`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:253
msgid "`debug_assert`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:255
msgid ""
"All of these are `macro_rules!`\\-defined macros, except for `format_args` "
"and `format_args_method`."
msgstr ""

#: src/0380-stabilize-std-fmt.md:258
msgid "Common syntax"
msgstr ""

#: src/0380-stabilize-std-fmt.md:260
msgid ""
"All of these macros take some form of prefix, while the trailing suffix is "
"always some instantiation of the formatting syntax. The suffix portion is "
"recommended to be considered `#[stable]`, and the sections below will "
"discuss each macro in detail with respect to its prefix and semantics."
msgstr ""

#: src/0380-stabilize-std-fmt.md:265
msgid "format_args"
msgstr ""

#: src/0380-stabilize-std-fmt.md:267
msgid ""
"The fundamental purpose of this macro is to generate a value of type `&fmt::"
"Arguments` which represents a pending format computation. This structure can "
"then be passed at some point to the methods in `std::fmt` to actually "
"perform the format."
msgstr ""

#: src/0380-stabilize-std-fmt.md:272
msgid ""
"The prefix of this macro is some \"callable thing\", be it a top-level "
"function or a closure. It cannot invoke a method because `foo.bar` is not a "
"\"callable thing\" to call the `bar` method on `foo`."
msgstr ""

#: src/0380-stabilize-std-fmt.md:276
msgid "Ideally, this macro would have no prefix, and would be callable like:"
msgstr ""

#: src/0380-stabilize-std-fmt.md:281
msgid "\"Hello {}!\""
msgstr ""

#: src/0380-stabilize-std-fmt.md:281 src/0380-stabilize-std-fmt.md:305
msgid "\"world\""
msgstr ""

#: src/0380-stabilize-std-fmt.md:285
msgid ""
"Unfortunately, without an implementation of [RFC 31](https://github.com/rust-"
"lang/rfcs/blob/master/active/0031-better-temporary-lifetimes.md) this is not "
"possible. As a result, this RFC proposes a `#[stable]` consideration of this "
"macro and its syntax."
msgstr ""

#: src/0380-stabilize-std-fmt.md:291
msgid "format_args_method"
msgstr ""

#: src/0380-stabilize-std-fmt.md:293
msgid ""
"The purpose of this macro is to solve the \"call this method\" case not "
"covered with the `format_args` macro. This macro was introduced fairly late "
"in the game to solve the problem that `&*trait_object` was not allowed. This "
"is currently allowed, however (due to DST)."
msgstr ""

#: src/0380-stabilize-std-fmt.md:298
msgid ""
"This RFC proposes immediately removing this macro. The primary user of this "
"macro is `write!`, meaning that the following code, which compiles today, "
"would need to be rewritten:"
msgstr ""

#: src/0380-stabilize-std-fmt.md:303
msgid "// note the lack of `&mut` in front\n"
msgstr ""

#: src/0380-stabilize-std-fmt.md:305
msgid "\"hello {}\""
msgstr ""

#: src/0380-stabilize-std-fmt.md:308
msgid "The `write!` macro would be redefined as:"
msgstr ""

#: src/0380-stabilize-std-fmt.md:319
msgid ""
"The purpose here is to borrow `$dst` _outside_ of the closure to ensure that "
"the closure doesn't borrow too many of its contents. Otherwise, code such as "
"this would be disallowed"
msgstr ""

#: src/0380-stabilize-std-fmt.md:324 src/0380-stabilize-std-fmt.md:383
msgid "\"{}\""
msgstr ""

#: src/0380-stabilize-std-fmt.md:327
msgid "write/writeln"
msgstr ""

#: src/0380-stabilize-std-fmt.md:329
msgid ""
"These two macros take the prefix of \"some pointer to a writer\" as an "
"argument, and then format data into the write (returning whatever "
"`write_fmt` returns). These macros were originally designed to require a "
"`&mut T` as the first argument, but today, due to the usage of "
"`format_args_method`, they can take any `T` which responds to `write_fmt`."
msgstr ""

#: src/0380-stabilize-std-fmt.md:335
msgid ""
"This RFC recommends marking these two macros `#[stable]` with the "
"modification above (removing `format_args_method`). The `ln` suffix to "
"`writeln` will be discussed shortly."
msgstr ""

#: src/0380-stabilize-std-fmt.md:339
msgid "print/println"
msgstr ""

#: src/0380-stabilize-std-fmt.md:341
msgid ""
"These two macros take no prefix, and semantically print to a _task-local_ "
"stdout stream. The purpose of a task-local stream is provide some form of "
"buffering to make stdout printing at all performant."
msgstr ""

#: src/0380-stabilize-std-fmt.md:345
msgid "This RFC recommends marking these two macros a `#[stable]`."
msgstr ""

#: src/0380-stabilize-std-fmt.md:347
msgid "The `ln` suffix"
msgstr ""

#: src/0380-stabilize-std-fmt.md:349
msgid ""
"The name `println` is one of the few locations in Rust where a short C-like "
"abbreviation is accepted rather than the more verbose, but clear, "
"`print_line` (for example). Due to the overwhelming precedent of other "
"languages (even Java uses `println`!), this is seen as an acceptable special "
"case to the rule."
msgstr ""

#: src/0380-stabilize-std-fmt.md:354
msgid "format"
msgstr ""

#: src/0380-stabilize-std-fmt.md:356
msgid "This macro takes no prefix and returns a `String`."
msgstr ""

#: src/0380-stabilize-std-fmt.md:358
msgid ""
"In ancient rust this macro was called its shorter name, `fmt`. Additionally, "
"the name `format` is somewhat inconsistent with the module name of `fmt`. "
"Despite this, this RFC recommends considering this macro `#[stable]` due to "
"its delegation to the `format` method in the `std::fmt` module, similar to "
"how the `write!` macro delegates to the `fmt::write`."
msgstr ""

#: src/0380-stabilize-std-fmt.md:364
msgid "fail/assert/debug_assert"
msgstr ""

#: src/0380-stabilize-std-fmt.md:366
msgid ""
"The format string portions of these macros are recommended to be considered "
"as `#[stable]` as part of this RFC. The actual stability of the macros is "
"not considered as part of this RFC."
msgstr ""

#: src/0380-stabilize-std-fmt.md:370
msgid "Freestanding Functions"
msgstr ""

#: src/0380-stabilize-std-fmt.md:372
msgid ""
"There are a number of [freestanding functions](http://doc.rust-lang.org/std/"
"fmt/index.html#functions) to consider in the `std::fmt` module for "
"stabilization."
msgstr ""

#: src/0380-stabilize-std-fmt.md:376
msgid "`fn format(args: &Arguments) -> String`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:378
msgid ""
"This RFC recommends `#[experimental]`. This method is largely an "
"implementation detail of this module, and should instead be used via:"
msgstr ""

#: src/0380-stabilize-std-fmt.md:386
msgid "`fn write(output: &mut FormatWriter, args: &Arguments) -> Result`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:388
msgid ""
"This is somewhat surprising in that the argument to this function is not a "
"`Writer`, but rather a `FormatWriter`. This is technically speaking due to "
"the core/std separation and how this function is defined in core and "
"`Writer` is defined in std."
msgstr ""

#: src/0380-stabilize-std-fmt.md:393
msgid ""
"This RFC recommends marking this function `#[experimental]` as the "
"`write_fmt` exists on `Writer` to perform the corresponding operation. "
"Consequently we may wish to remove this function in favor of the `write_fmt` "
"method on `FormatWriter`."
msgstr ""

#: src/0380-stabilize-std-fmt.md:398
msgid ""
"Ideally this method would be removed from the public API as it is just an "
"implementation detail of the `write!` macro."
msgstr ""

#: src/0380-stabilize-std-fmt.md:401
msgid "`fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix>`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:403
msgid ""
"This function is a bit of an odd-man-out in that it is a constructor, but "
"does not follow the existing conventions of `Type::new`. The purpose of this "
"function is to expose the ability to format a number for any radix. The "
"default format specifiers `:o`, `:x`, and `:t` are essentially shorthands "
"for this function, except that the format types have specialized "
"implementations per radix instead of a generic implementation."
msgstr ""

#: src/0380-stabilize-std-fmt.md:410
msgid ""
"This RFC proposes that this function be considered `#[unstable]` as its "
"location and naming are a bit questionable, but the functionality is desired."
msgstr ""

#: src/0380-stabilize-std-fmt.md:413
msgid "Miscellaneous items"
msgstr ""

#: src/0380-stabilize-std-fmt.md:415
msgid "`trait FormatWriter`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:417
msgid ""
"This trait is currently the actual implementation strategy of formatting, "
"and is defined specially in libcore. It is rarely used outside of libcore. "
"It is recommended to be `#[experimental]`."
msgstr ""

#: src/0380-stabilize-std-fmt.md:421
msgid ""
"There are possibilities in moving `Reader` and `Writer` to libcore with the "
"error type as an associated item, allowing the `FormatWriter` trait to be "
"eliminated entirely. Due to this possibility, the trait will be experimental "
"for now as alternative solutions are explored."
msgstr ""

#: src/0380-stabilize-std-fmt.md:426
msgid ""
"`struct Argument`, `mod rt`, `fn argument`, `fn argumentstr`, `fn "
"argumentuint`, `Arguments::with_placeholders`, `Arguments::new`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:429
msgid ""
"These are implementation details of the `Arguments` structure as well as the "
"expansion of the `format_args!` macro. It's recommended to mark these as "
"`#[experimental]` and `#[doc(hidden)]`. Ideally there would be some form of "
"macro-based privacy hygiene which would allow these to be truly private, but "
"it will likely be the case that these simply become stable and we must live "
"with them forever."
msgstr ""

#: src/0380-stabilize-std-fmt.md:436
msgid "`struct Arguments`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:438
msgid ""
"This is a representation of a \"pending format string\" which can be used to "
"safely execute a `Formatter` over it. This RFC recommends `#[stable]`."
msgstr ""

#: src/0380-stabilize-std-fmt.md:441
msgid "`struct Formatter`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:443
msgid ""
"This instance is passed to all formatting trait methods and contains helper "
"methods for respecting formatting flags. This RFC recommends `#[unstable]`."
msgstr ""

#: src/0380-stabilize-std-fmt.md:446
msgid ""
"This RFC also recommends deprecating all public fields in favor of accessor "
"methods. This should help provide future extensibility as well as preventing "
"unnecessary mutation in the future."
msgstr ""

#: src/0380-stabilize-std-fmt.md:450
msgid "`enum FormatError`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:452
msgid ""
"This enumeration only has one instance, `WriteError`. It is recommended to "
"make this a `struct` instead and rename it to just `Error`. The purpose of "
"this is to signal that an error has occurred as part of formatting, but it "
"does not provide a generic method to transmit any other information other "
"than \"an error happened\" to maintain the ergonomics of today's usage. It's "
"strongly recommended that implementations of `Show` and friends are "
"infallible and only generate an error if the underlying `Formatter` returns "
"an error itself."
msgstr ""

#: src/0380-stabilize-std-fmt.md:460
msgid "`Radix`/`RadixFmt`"
msgstr ""

#: src/0380-stabilize-std-fmt.md:462
msgid ""
"Like the `radix` function, this RFC recommends `#[unstable]` for both of "
"these pieces of functionality."
msgstr ""

#: src/0380-stabilize-std-fmt.md:465
msgid "Drawbacks"
msgstr ""

#: src/0380-stabilize-std-fmt.md:467
msgid ""
"Today's macro system necessitates exporting many implementation details of "
"the formatting system, which is unfortunate."
msgstr ""

#: src/0380-stabilize-std-fmt.md:470
msgid "Alternatives"
msgstr ""

#: src/0380-stabilize-std-fmt.md:472
msgid ""
"A number of alternatives were laid out in the detailed description for "
"various aspects."
msgstr ""

#: src/0380-stabilize-std-fmt.md:475
msgid "Unresolved questions"
msgstr ""

#: src/0380-stabilize-std-fmt.md:477
msgid ""
"How feasible and/or important is it to construct a format string at runtime "
"given the recommend stability levels in this RFC?"
msgstr ""
