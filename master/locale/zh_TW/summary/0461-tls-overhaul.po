msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:42Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0461-tls-overhaul.md:1
msgid "Start Date: 2014-11-11"
msgstr ""

#: src/0461-tls-overhaul.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#461](https://github.com/rust-lang/rfcs/pull/461)"
msgstr ""

#: src/0461-tls-overhaul.md:3
msgid ""
"Rust Issue: [rust-lang/rust#19175](https://github.com/rust-lang/rust/"
"issues/19175)"
msgstr ""

#: src/0461-tls-overhaul.md:5
msgid "Summary"
msgstr "摘要"

#: src/0461-tls-overhaul.md:7
msgid ""
"Introduce a new thread local storage module to the standard library, `std::"
"tls`, providing:"
msgstr ""

#: src/0461-tls-overhaul.md:10
msgid "Scoped TLS, a non-owning variant of TLS for any value."
msgstr ""

#: src/0461-tls-overhaul.md:11
msgid ""
"Owning TLS, an owning, dynamically initialized, dynamically destructed "
"variant, similar to `std::local_data` today."
msgstr ""

#: src/0461-tls-overhaul.md:14
msgid "Motivation"
msgstr "動機"

#: src/0461-tls-overhaul.md:16
msgid ""
"In the past, the standard library's answer to thread local storage was the "
"`std::local_data` module. This module was designed based on the Rust task "
"model where a task could be either a 1:1 or M:N task. This design constraint "
"has [since been lifted](https://github.com/rust-lang/rfcs/blob/master/"
"text/0230-remove-runtime.md), allowing for easier solutions to some of the "
"current drawbacks of the module. While redesigning `std::local_data`, it can "
"also be scrutinized to see how it holds up to modern-day Rust style, "
"guidelines, and conventions."
msgstr ""

#: src/0461-tls-overhaul.md:26
msgid ""
"In general the amount of work being scheduled for 1.0 is being trimmed down "
"as much as possible, especially new work in the standard library that isn't "
"focused on cutting back what we're shipping. Thread local storage, however, "
"is such a critical part of many applications and opens many doors to "
"interesting sets of functionality that this RFC sees fit to try and wedge it "
"into the schedule. The current `std::local_data` module simply doesn't meet "
"the requirements of what one may expect out of a TLS implementation for a "
"language like Rust."
msgstr ""

#: src/0461-tls-overhaul.md:34
msgid "Current Drawbacks"
msgstr ""

#: src/0461-tls-overhaul.md:36
msgid ""
"Today's implementation of thread local storage, `std::local_data`, suffers "
"from a few drawbacks:"
msgstr ""

#: src/0461-tls-overhaul.md:39
msgid ""
"The implementation is not super speedy, and it is unclear how to enhance the "
"existing implementation to be on par with OS-based TLS or `#[thread_local]` "
"support. As an example, today a lookup takes `O(log N)` time where N is the "
"number of set TLS keys for a task."
msgstr ""

#: src/0461-tls-overhaul.md:44
msgid ""
"This drawback is also not to be taken lightly. TLS is a fundamental building "
"block for rich applications and libraries, and an inefficient implementation "
"will only deter usage of an otherwise quite useful construct."
msgstr ""

#: src/0461-tls-overhaul.md:48
msgid ""
"The types which can be stored into TLS are not maximally flexible. Currently "
"only types which ascribe to `'static` can be stored into TLS. It's often the "
"case that a type with references needs to be placed into TLS for a short "
"period of time, however."
msgstr ""

#: src/0461-tls-overhaul.md:53
msgid ""
"The interactions between TLS destructors and TLS itself is not currently "
"very well specified, and it can easily lead to difficult-to-debug runtime "
"panics or undocumented leaks."
msgstr ""

#: src/0461-tls-overhaul.md:57
msgid ""
"The implementation currently assumes a local `Task` is available. Once the "
"runtime removal is complete, this will no longer be a valid assumption."
msgstr ""

#: src/0461-tls-overhaul.md:60
msgid "Current Strengths"
msgstr ""

#: src/0461-tls-overhaul.md:62
msgid ""
"There are, however, a few pros to the usage of the module today which should "
"be required for any replacement:"
msgstr ""

#: src/0461-tls-overhaul.md:65
msgid "All platforms are supported."
msgstr ""

#: src/0461-tls-overhaul.md:66
msgid ""
"`std::local_data` allows consuming ownership of data, allowing it to live "
"past the current stack frame."
msgstr ""

#: src/0461-tls-overhaul.md:69
msgid "Building blocks available"
msgstr ""

#: src/0461-tls-overhaul.md:71
msgid ""
"There are currently two primary building blocks available to Rust when "
"building a thread local storage abstraction, `#[thread_local]` and OS-based "
"TLS. Neither of these are currently used for `std::local_data`, but are "
"generally seen as \"adequately efficient\" implementations of TLS. For "
"example, an TLS access of a `#[thread_local]` global is simply a pointer "
"offset, which when compared to a `O(log N)` lookup is quite speedy!"
msgstr ""

#: src/0461-tls-overhaul.md:78
msgid ""
"With these available, this RFC is motivated in redesigning TLS to make use "
"of these primitives."
msgstr ""

#: src/0461-tls-overhaul.md:81
msgid "Detailed design"
msgstr "詳細設計"

#: src/0461-tls-overhaul.md:83
msgid "Three new modules will be added to the standard library:"
msgstr ""

#: src/0461-tls-overhaul.md:85
msgid ""
"The `std::sys::tls` module provides platform-agnostic bindings the OS-based "
"TLS support. This support is intended to only be used in otherwise unsafe "
"code as it supports getting and setting a `*mut u8` parameter only."
msgstr ""

#: src/0461-tls-overhaul.md:89
msgid ""
"The `std::tls` module provides a dynamically initialized and dynamically "
"destructed variant of TLS. This is very similar to the current `std::"
"local_data` module, except that the implicit `Option<T>` is not mandated as "
"an initialization expression is required."
msgstr ""

#: src/0461-tls-overhaul.md:94
msgid ""
"The `std::tls::scoped` module provides a flavor of TLS which can store a "
"reference to any type `T` for a scoped set of time. This is a variant of TLS "
"not provided today. The backing idea is that if a reference only lives in "
"TLS for a fixed set of time then there's no need for TLS to consume "
"ownership of the value itself."
msgstr ""

#: src/0461-tls-overhaul.md:100
msgid ""
"This pattern of TLS is quite common throughout the compiler's own usage of "
"`std::local_data` and often more expressive as no dances are required to "
"move a value into and out of TLS."
msgstr ""

#: src/0461-tls-overhaul.md:104
msgid ""
"The design described below can be found as an existing cargo package: "
"https://github.com/alexcrichton/tls-rs."
msgstr ""

#: src/0461-tls-overhaul.md:107
msgid "The OS layer"
msgstr ""

#: src/0461-tls-overhaul.md:109
msgid ""
"While LLVM has support for `#[thread_local]` statics, this feature is not "
"supported on all platforms that LLVM can target. Almost all platforms, "
"however, provide some form of OS-based TLS. For example Unix normally comes "
"with `pthread_key_create` while Windows comes with `TlsAlloc`."
msgstr ""

#: src/0461-tls-overhaul.md:114
msgid ""
"This RFC proposes introducing a `std::sys::tls` module which contains "
"bindings to the OS-based TLS mechanism. This corresponds to the `os` module "
"in the example implementation. While not currently public, the contents of "
"`sys` are slated to become public over time, and the API of the `std::sys::"
"tls` module will go under API stabilization at that time."
msgstr ""

#: src/0461-tls-overhaul.md:120
msgid ""
"This module will support \"statically allocated\" keys as well as "
"dynamically allocated keys. A statically allocated key will actually "
"allocate a key on first use."
msgstr ""

#: src/0461-tls-overhaul.md:124
msgid "Destructor support"
msgstr ""

#: src/0461-tls-overhaul.md:126
msgid ""
"The major difference between Unix and Windows TLS support is that Unix "
"supports a destructor function for each TLS slot while Windows does not. "
"When each Unix TLS key is created, an optional destructor is specified. If "
"any key has a non-NULL value when a thread exits, the destructor is then run "
"on that value."
msgstr ""

#: src/0461-tls-overhaul.md:131
msgid ""
"One possibility for this `std::sys::tls` module would be to not provide "
"destructor support at all (least common denominator), but this RFC proposes "
"implementing destructor support for Windows to ensure that functionality is "
"not lost when writing Unix-only code."
msgstr ""

#: src/0461-tls-overhaul.md:136
msgid ""
"Destructor support for Windows will be provided through a custom "
"implementation of tracking known destructors for TLS keys."
msgstr ""

#: src/0461-tls-overhaul.md:139
msgid "Scoped TLS"
msgstr ""

#: src/0461-tls-overhaul.md:141
msgid ""
"As discussed before, one of the motivations for this RFC is to provide a "
"method of inserting any value into TLS, not just those that ascribe to "
"`'static`. This provides maximal flexibility in storing values into TLS to "
"ensure any \"thread local\" pattern can be encompassed."
msgstr ""

#: src/0461-tls-overhaul.md:146
msgid ""
"Values which do not adhere to `'static` contain references with a "
"constrained lifetime, and can therefore not be moved into TLS. They can, "
"however, be _borrowed_ by TLS. This scoped TLS api provides the ability to "
"insert a reference for a particular period of time, and then a non-escaping "
"reference can be extracted at any time later on."
msgstr ""

#: src/0461-tls-overhaul.md:152
msgid ""
"In order to implement this form of TLS, a new module, `std::tls::scoped`, "
"will be added. It will be coupled with a `scoped_tls!` macro in the prelude. "
"The API looks like:"
msgstr ""

#: src/0461-tls-overhaul.md:157
msgid ""
"/// Declares a new scoped TLS key. The keyword `static` is required in front "
"to\n"
"/// emphasize that a `static` item is being created. There is no "
"initializer\n"
"/// expression because this key initially contains no value.\n"
"///\n"
"/// A `pub` variant is also provided to generate a public `static` item.\n"
msgstr ""

#: src/0461-tls-overhaul.md:163 src/0461-tls-overhaul.md:164
#: src/0461-tls-overhaul.md:171 src/0461-tls-overhaul.md:181
#: src/0461-tls-overhaul.md:188 src/0461-tls-overhaul.md:236
#: src/0461-tls-overhaul.md:237 src/0461-tls-overhaul.md:240
#: src/0461-tls-overhaul.md:251
msgid "/* ... */"
msgstr ""

#: src/0461-tls-overhaul.md:166
msgid ""
"/// A structure representing a scoped TLS key.\n"
"///\n"
"/// This structure cannot be created dynamically, and it is accessed via "
"its\n"
"/// methods.\n"
msgstr ""

#: src/0461-tls-overhaul.md:174
msgid ""
"/// Insert a value into this scoped TLS slot for a duration of a closure.\n"
"    ///\n"
"    /// While `cb` is running, the value `t` will be returned by `get` "
"unless\n"
"    /// this function is called recursively inside of cb.\n"
"    ///\n"
"    /// Upon return, this function will restore the previous TLS value, if "
"any\n"
"    /// was available.\n"
msgstr ""

#: src/0461-tls-overhaul.md:183
msgid ""
"/// Get a value out of this scoped TLS variable.\n"
"    ///\n"
"    /// This function takes a closure which receives the value of this TLS\n"
"    /// variable, if any is available. If this variable has not yet been "
"set,\n"
"    /// then None is yielded.\n"
msgstr ""

#: src/0461-tls-overhaul.md:192
msgid ""
"The purpose of this module is to enable the ability to insert a value into "
"TLS for a scoped period of time. While able to cover many TLS patterns, this "
"flavor of TLS is not comprehensive, motivating the owning variant of TLS."
msgstr ""

#: src/0461-tls-overhaul.md:196 src/0461-tls-overhaul.md:277
msgid "Variations"
msgstr ""

#: src/0461-tls-overhaul.md:198
msgid ""
"Specifically the `with` API can be somewhat unwieldy to use. The `with` "
"function takes a closure to run, yielding a value to the closure.  It is "
"believed that this is required for the implementation to be sound, but it "
"also goes against the \"use RAII everywhere\" principle found elsewhere in "
"the stdlib."
msgstr ""

#: src/0461-tls-overhaul.md:203
msgid ""
"Additionally, the `with` function is more commonly called `get` for "
"accessing a contained value in the stdlib. The name `with` is recommended "
"because it may be possible in the future to express a `get` function "
"returning a reference with a lifetime bound to the stack frame of the "
"caller, but it is not currently possible to do so."
msgstr ""

#: src/0461-tls-overhaul.md:209
msgid ""
"The `with` functions yields an `Option<&T>` instead of `&T`. This is to "
"cover the use case where the key has not been `set` before it used via "
"`with`. This is somewhat unergonomic, however, as it will almost always be "
"followed by `unwrap()`. An alternative design would be to provide a `is_set` "
"function and have `with` `panic!` instead."
msgstr ""

#: src/0461-tls-overhaul.md:215
msgid "Owning TLS"
msgstr ""

#: src/0461-tls-overhaul.md:217
msgid ""
"Although scoped TLS can store any value, it is also limited in the fact that "
"it cannot own a value. This means that TLS values cannot escape the stack "
"from which they originated from. This is itself another common usage pattern "
"of TLS, and to solve this problem the `std::tls` module will provided "
"support for placing owned values into TLS."
msgstr ""

#: src/0461-tls-overhaul.md:223
msgid ""
"These values must not contain references as that could trigger a use-after-"
"free, but otherwise there are no restrictions on placing statics into owned "
"TLS. The module will support dynamic initialization (run on first use of the "
"variable) as well as dynamic destruction (implementors of `Drop`)."
msgstr ""

#: src/0461-tls-overhaul.md:228
msgid ""
"The interface provided will be similar to what `std::local_data` provides "
"today, except that the `replace` function has no analog (it would be written "
"with a `RefCell<Option<T>>`)."
msgstr ""

#: src/0461-tls-overhaul.md:233
msgid ""
"/// Similar to the `scoped_tls!` macro, except allows for an initializer\n"
"/// expression as well.\n"
msgstr ""

#: src/0461-tls-overhaul.md:243
msgid ""
"/// Access this TLS variable, lazily initializing it if necessary.\n"
"    ///\n"
"    /// The first time this function is called on each thread the TLS key "
"will\n"
"    /// be initialized by having the specified init expression evaluated on "
"the\n"
"    /// current thread.\n"
"    ///\n"
"    /// This function can return `None` for the same reasons of static TLS\n"
"    /// returning `None` (destructors are running or may have run).\n"
msgstr ""

#: src/0461-tls-overhaul.md:255
msgid "Destructors"
msgstr ""

#: src/0461-tls-overhaul.md:257
msgid ""
"One of the major points about this implementation is that it allows for "
"values with destructors, meaning that destructors must be run when a thread "
"exits. This is similar to placing a value with a destructor into `std::"
"local_data`. This RFC attempts to refine the story around destructors:"
msgstr ""

#: src/0461-tls-overhaul.md:262
msgid ""
"A TLS key cannot be accessed while its destructor is running. This is "
"currently manifested with the `Option` return value."
msgstr ""

#: src/0461-tls-overhaul.md:264
msgid "A TLS key _may_ not be accessible after its destructor has run."
msgstr ""

#: src/0461-tls-overhaul.md:265
msgid ""
"Re-initializing TLS keys during destruction may cause memory leaks (e.g. "
"setting the key FOO during the destructor of BAR, and initializing BAR in "
"the destructor of FOO). An implementation will strive to destruct "
"initialized keys whenever possible, but it may also result in a memory leak."
msgstr ""

#: src/0461-tls-overhaul.md:269
msgid ""
"A `panic!` in a TLS destructor will result in a process abort. This is "
"similar to a double-failure."
msgstr ""

#: src/0461-tls-overhaul.md:272
msgid ""
"These semantics are still a little unclear, and the final behavior may still "
"need some more hammering out. The sample implementation suffers from a few "
"extra drawbacks, but it is believed that some more implementation work can "
"overcome some of the minor downsides."
msgstr ""

#: src/0461-tls-overhaul.md:279
msgid ""
"Like the scoped TLS variation, this key has a `with` function instead of the "
"normally expected `get` function (returning a reference). One possible "
"alternative would be to yield `&T` instead of `Option<&T>` and `panic!` if "
"the variable has been destroyed. Another possible alternative is to have a "
"`get` function returning a `Ref<T>`. Currently this is unsafe, however, as "
"there is no way to ensure that `Ref<T>` does not satisfy `'static`. If the "
"returned reference satisfies `'static`, then it's possible for TLS values to "
"reference each other after one has been destroyed, causing a use-after-free."
msgstr ""

#: src/0461-tls-overhaul.md:288
msgid "Drawbacks"
msgstr ""

#: src/0461-tls-overhaul.md:290
msgid ""
"There is no variant of TLS for statically initialized data. Currently the "
"`std::tls` module requires dynamic initialization, which means a slight "
"penalty is paid on each access (a check to see if it's already initialized)."
msgstr ""

#: src/0461-tls-overhaul.md:293
msgid ""
"The specification of destructors on owned TLS values is still somewhat shaky "
"at best. It's possible to leak resources in unsafe code, and it's also "
"possible to have different behavior across platforms."
msgstr ""

#: src/0461-tls-overhaul.md:296
msgid ""
"Due to the usage of macros for initialization, all fields of `Key` in all "
"scenarios must be public. Note that `os` is excepted because its "
"initializers are a `const`."
msgstr ""

#: src/0461-tls-overhaul.md:299
msgid ""
"This implementation, while declared safe, is not safe for systems that do "
"any form of multiplexing of many threads onto one thread (aka green tasks or "
"greenlets). This RFC considers it the multiplexing systems' responsibility "
"to maintain native TLS if necessary, or otherwise strongly recommend not "
"using native TLS."
msgstr ""

#: src/0461-tls-overhaul.md:305
msgid "Alternatives"
msgstr "替代方案"

#: src/0461-tls-overhaul.md:307
msgid ""
"Alternatives on the API can be found in the \"Variations\" sections above."
msgstr ""

#: src/0461-tls-overhaul.md:309
msgid "Some other alternatives might include:"
msgstr ""

#: src/0461-tls-overhaul.md:311
msgid ""
"A 0-cost abstraction over `#[thread_local]` and OS-based TLS which does not "
"have support for destructors but requires static initialization. Note that "
"this variant still needs destructor support _somehow_ because OS-based TLS "
"values must be pointer-sized, implying that the rust value must itself be "
"boxed (whereas `#[thread_local]` can support any type of any size)."
msgstr ""

#: src/0461-tls-overhaul.md:317
msgid ""
"A variant of the `tls!` macro could be used where dynamic initialization is "
"opted out of because it is not necessary for a particular use case."
msgstr ""

#: src/0461-tls-overhaul.md:320
msgid ""
"A [previous PR](https://github.com/rust-lang/rust/pull/17583) from "
"@thestinger leveraged macros more heavily than this RFC and provided "
"statically constructible Cell and RefCell equivalents via the usage of "
"`transmute`. The implementation provided did not, however, include the "
"scoped form of this RFC."
msgstr ""

#: src/0461-tls-overhaul.md:327
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/0461-tls-overhaul.md:329
msgid ""
"Are the questions around destructors vague enough to warrant the `get` "
"method being `unsafe` on owning TLS?"
msgstr ""

#: src/0461-tls-overhaul.md:331
msgid ""
"Should the APIs favor `panic!`\\-ing internally, or exposing an `Option`?"
msgstr ""
