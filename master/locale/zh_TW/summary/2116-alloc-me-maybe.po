msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:04Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2116-alloc-me-maybe.md:1
msgid "Feature Name: fallible_collection_alloc"
msgstr ""

#: src/2116-alloc-me-maybe.md:2
msgid "Start Date: 2017-08-18"
msgstr ""

#: src/2116-alloc-me-maybe.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2116](https://github.com/rust-lang/rfcs/pull/2116)"
msgstr ""

#: src/2116-alloc-me-maybe.md:4
msgid ""
"Rust Issue: [rust-lang/rust#48043](https://github.com/rust-lang/rust/"
"issues/48043)"
msgstr ""

#: src/2116-alloc-me-maybe.md:6
msgid "Summary"
msgstr ""

#: src/2116-alloc-me-maybe.md:9
msgid ""
"Add minimal support for fallible allocations to the standard collection "
"APIs. This is done in two ways:"
msgstr ""

#: src/2116-alloc-me-maybe.md:11
msgid ""
"For users with unwinding, an `oom=panic` configuration is added to make "
"global allocators panic on oom."
msgstr ""

#: src/2116-alloc-me-maybe.md:12
msgid ""
"For users without unwinding, a `try_reserve() -> Result<(), "
"CollectionAllocErr>` method is added."
msgstr ""

#: src/2116-alloc-me-maybe.md:14
msgid ""
"The former is sufficient to unwinding users, but the latter is insufficient "
"for the others (although it is a decent 80/20 solution). Completing the no-"
"unwinding story is left for future work."
msgstr ""

#: src/2116-alloc-me-maybe.md:17
msgid "Motivation"
msgstr ""

#: src/2116-alloc-me-maybe.md:20
msgid ""
"Many collection methods may decide to allocate (push, insert, extend, entry, "
"reserve, with_capacity, ...) and those allocations may fail. Early on in "
"Rust's history we made a policy decision not to expose this fact at the API "
"level, preferring to abort. This is because most developers aren't prepared "
"to handle it, or interested. Handling allocation failure haphazardly is "
"likely to lead to many never-tested code paths and therefore bugs. We call "
"this approach _infallible_ collection allocation, because the developer "
"model is that allocations just don't fail."
msgstr ""

#: src/2116-alloc-me-maybe.md:22
msgid ""
"Unfortunately, this stance is unsustainable in several of the contexts Rust "
"is designed for. This RFC seeks to establish a basic _fallible_ collection "
"allocation API, which allows our users to handle allocation failures where "
"desirable. This RFC does not attempt to perfectly address all use cases, but "
"does intend to establish the goals and constraints of those use cases, and "
"sketches a path forward for addressing them all."
msgstr ""

#: src/2116-alloc-me-maybe.md:25
msgid "There are 4 user profiles we will be considering in this RFC:"
msgstr ""

#: src/2116-alloc-me-maybe.md:27
msgid "embedded: task-oriented, robust, pool-based, no unwinding"
msgstr ""

#: src/2116-alloc-me-maybe.md:28
msgid "gecko: semi-task-oriented, best-effort, global, no unwinding"
msgstr ""

#: src/2116-alloc-me-maybe.md:29
msgid "server: task-oriented, semi-robust, global, unwinding"
msgstr ""

#: src/2116-alloc-me-maybe.md:30
msgid "runtime: whole-system, robust, global, no unwinding"
msgstr ""

#: src/2116-alloc-me-maybe.md:35
msgid "User Profile: Embedded"
msgstr ""

#: src/2116-alloc-me-maybe.md:37
msgid ""
"Embedded devs are primarily well-aligned with Rust's current strategy. First "
"and foremost, embedded devs just try to _not_ dynamically allocate. Memory "
"should ideally all be allocated at startup. In cases where this isn't "
"practical, simply aborting the process is often the next-best choice. Robust "
"embedded systems need to be able to recover from a crash anyway, and "
"aborting is completely fool-proof."
msgstr ""

#: src/2116-alloc-me-maybe.md:39
msgid ""
"However, sometimes the embedded system needs to process some user-defined "
"tasks with unpredictable allocations, and completely crashing on OOM would "
"be inappropriate. In those cases handling allocation failure is the right "
"solution. In the case of a failure, the entire task usually reports a "
"failure and is torn down. To make this robust, all allocations for a task "
"are usually isolated to a single pool that can easily be torn down. This "
"ensures nothing leaks, and helps avoid fragmentation. The important thing to "
"note is that the embedded developers are ready and willing to take control "
"of all allocations to do this properly."
msgstr ""

#: src/2116-alloc-me-maybe.md:41
msgid ""
"Some embedded systems do use unwinding, but this is very rare, so it cannot "
"be assumed."
msgstr ""

#: src/2116-alloc-me-maybe.md:43 src/2116-alloc-me-maybe.md:56
msgid ""
"It seems they would be happy to have some system to prevent infallible "
"allocations from ever being used."
msgstr ""

#: src/2116-alloc-me-maybe.md:48
msgid "User Profile: Gecko"
msgstr ""

#: src/2116-alloc-me-maybe.md:50
msgid ""
"Gecko is also primarily well-aligned with Rust's current strategy. For the "
"most part, they liberally allocate and are happy to crash on OOM. This is "
"especially palatable now that firefox is multiprocess. However as a _quality "
"of implementation_ matter, they occasionally make some subroutines fallible. "
"For instance, it would be unfortunate if a single giant image prevented a "
"page from loading. Similarly, running out of memory while processing a style "
"sheet isn't significantly different from failing to download it."
msgstr ""

#: src/2116-alloc-me-maybe.md:52
msgid ""
"However in contrast to the embedded case, this isn't done in a particularly "
"principled way. Some parts might be fallible, some might be infallible. "
"Nothing is pooled to isolate tasks. It's just a best-effort affair."
msgstr ""

#: src/2116-alloc-me-maybe.md:54
msgid "Gecko is built without unwinding."
msgstr ""

#: src/2116-alloc-me-maybe.md:58
msgid ""
"Gecko's need for this API as soon as possible will result in it temporarily "
"forking several of the std collections, which is the primary impetus for "
"this RFC."
msgstr ""

#: src/2116-alloc-me-maybe.md:64
msgid "User Profile: Server"
msgstr ""

#: src/2116-alloc-me-maybe.md:66
msgid ""
"This represents a commodity server which handles tasks using threads or "
"futures."
msgstr ""

#: src/2116-alloc-me-maybe.md:68
msgid ""
"Similar to the embedded case, handling allocation failure at the granularity "
"of tasks is ideal for quality-of-implementation purposes. However, unlike "
"embedded development, it isn't considered practical (in terms of cost) to "
"properly take control of everything and ensure allocation failure is handled "
"robustly."
msgstr ""

#: src/2116-alloc-me-maybe.md:70
msgid ""
"Here unwinding is available, and seems to be the preferred solution, as it "
"maximizes the chances of allocation failures bubbling out of whatever "
"libraries are used. This is unlikely to be totally robust, but that's ok."
msgstr ""

#: src/2116-alloc-me-maybe.md:72
msgid ""
"With unwinding there isn't any apparent use for an infallible allocation "
"checker."
msgstr ""

#: src/2116-alloc-me-maybe.md:78
msgid "User Profile: Runtime"
msgstr ""

#: src/2116-alloc-me-maybe.md:80
msgid ""
"A garbage-collected runtime (such as SpiderMonkey or the Microsoft CLR), is "
"generally expected to avoid crashing due to out-of-memory conditions. "
"Different strategies and allocators are used for different situations here. "
"Most notably, there are allocations on the GC heap for the running script, "
"and allocations on the global heap for the actual runtime's own processing "
"(e.g. performing a JIT compilation)."
msgstr ""

#: src/2116-alloc-me-maybe.md:82
msgid ""
"Allocations on the GC heap aren't particularly interesting for our purposes, "
"as these need to have a special format for tracing, and management by the "
"runtime. A runtime probably wouldn't ever want to build a native Vec backed "
"by the GC heap, but a Vec _might_ contain GC'd pointers that the runtime "
"must trace. Thankfully, this is unrelated to the process of allocating the "
"Vec itself."
msgstr ""

#: src/2116-alloc-me-maybe.md:84
msgid ""
"When performing a GC, allocating data structures may enable faster or more "
"responsive strategies, but the system must be ready to fall back to less "
"memory-intensive solution in the case of allocation failure. In the limit, "
"very small allocations in critical sections may be infallible."
msgstr ""

#: src/2116-alloc-me-maybe.md:86
msgid ""
"When performing a JIT, running out of memory can generally be gracefully "
"handled by failing the compilation and remaining in a less-optimized mode "
"(such as the interpreter). For the most part fallible allocation is used "
"here. However SpiderMonkey occasionally uses an interesting mix of fallible "
"and infallible allocations to avoid threading errors through some "
"particularly complex subroutines. Essentially, a chunk of memory is reserved "
"that is supposed to be statically guaranteed to be sufficient for the "
"subroutine to complete its task, and all allocations in the subroutine are "
"subsequently treated as infallible. In debug builds, running out of memory "
"will trigger an abort. In release builds they will first try to just get "
"more memory and proceed, but abort if this fails."
msgstr ""

#: src/2116-alloc-me-maybe.md:88
msgid ""
"Although the language the runtime hosts may have an unwinding/exceptions for "
"OOM conditions when the GC heap runs out of space, the runtime itself "
"generally doesn't use unwinding to handle its own allocation failures."
msgstr ""

#: src/2116-alloc-me-maybe.md:90
msgid ""
"Due to mixed fallible/infallible allocation use, tools which prevent the use "
"of infallible allocation may not be appropriate."
msgstr ""

#: src/2116-alloc-me-maybe.md:92
msgid ""
"The Runtime dev profile seems to closely reflect that of Database dev (which "
"wasn't seriously researched for this RFC). A database is in some sense just "
"a runtime for its query language (e.g. SQL), with similar reliability "
"constraints."
msgstr ""

#: src/2116-alloc-me-maybe.md:94
msgid ""
"Aside: many devs in this space have a testing feature which can repeatedly "
"run test cases with OOMs injected at the allocator level. This doesn't "
"really effect our constraints, but it's something to keep in mind to address "
"the \"many untested paths\" issue."
msgstr ""

#: src/2116-alloc-me-maybe.md:99
msgid "Additional Background: How Collections Handle Allocation Now"
msgstr ""

#: src/2116-alloc-me-maybe.md:101
msgid "All of our collections consider there to be two interesting cases:"
msgstr ""

#: src/2116-alloc-me-maybe.md:103
msgid ""
"The capacity got too big (>`isize::MAX`), which is handled by `panic!"
"(\"capacity overflow\")`"
msgstr ""

#: src/2116-alloc-me-maybe.md:104
msgid ""
"The allocator returned an err (even Unsupported), which is handled by "
"calling `allocator.oom()`"
msgstr ""

#: src/2116-alloc-me-maybe.md:106
msgid ""
"To make matters more complex, on 64-bit platforms we don't check the `isize::"
"MAX` condition directly, instead relying on the allocator to "
"deterministically fail on any request that far exceeds a quantity the page "
"table can even support (no 64-bit system we support uses all 64 bits of the "
"pointer, even with new-fangled 5-level page tables). This means that 64-bit "
"platforms behave slightly different on catastrophically large allocations "
"(abort instead of panic)."
msgstr ""

#: src/2116-alloc-me-maybe.md:108
msgid ""
"These behaviours were purposefully designed, but probably not particularly "
"well-motivated, [as discussed here](https://github.com/rust-lang/rust/"
"issues/42808). Some of these details are documented, although not correctly "
"or in sufficient detail. For instance `Vec::reserve` only mentions panicking "
"when overflowing `usize`, which is accurate for 64-bit but not 32-bit or 16-"
"bit. Oddly no mention of out-of-memory conditions or aborts can be found "
"anywhere in Vec's documentation."
msgstr ""

#: src/2116-alloc-me-maybe.md:110
msgid ""
"To make matters more complex, the (unstable) `heap::Alloc` trait currently "
"documents that any oom impl can panic _or_ abort, so collection users need "
"to assume that can happen anyway. This is intended insofar as it was "
"considered desirable for local allocators, but is considered an oversight in "
"the global case. This is because Alloc is mostly designed around local "
"allocators."
msgstr ""

#: src/2116-alloc-me-maybe.md:112
msgid ""
"This is enough of a mess (which to be clear can be significantly blamed on "
"the author) that the author expects no one is relying on the specific "
"behaviours here, and they could be changed pretty liberally. That said, the "
"primary version of this proposal doesn't attempt to change any of these "
"behaviours. It's certainly a plausible alternative, though."
msgstr ""

#: src/2116-alloc-me-maybe.md:117
msgid "Additional Background: Allocation Failure in C(++)"
msgstr ""

#: src/2116-alloc-me-maybe.md:119
msgid ""
"There are two ways that collection allocation failure is handled in C(++): "
"with error return values, and with unwinding (C++ only). The C++ standard "
"library (STL) only provides fallible allocations through exceptions, but the "
"broader ecosystem also uses return values. For example, mozilla's own "
"standard library (MFBT) only uses return values."
msgstr ""

#: src/2116-alloc-me-maybe.md:121
msgid ""
"Unfortunately, attempting to handle allocation failure in C(++) has been a "
"historical source of critical vulnerabilities. For instance, if reallocating "
"an array fails but isn't noticed, the user of the array can end up thinking "
"it has more space than it actually does and writing past the end of the "
"allocation."
msgstr ""

#: src/2116-alloc-me-maybe.md:123
msgid ""
"The return-value-based approach is problematic because neither language has "
"good facilities for mandating that a result is actually _checked_. There are "
"two notable cases here: when the result of the allocation is some kind of "
"error code (e.g. a bool), or the result is a pointer into the allocation (or "
"a specific pointer indicating failure)."
msgstr ""

#: src/2116-alloc-me-maybe.md:125
msgid ""
"In the error code case, neither language provides a native facility to "
"mandate that error codes must be checked. However compiler-specific "
"attributes like GCC's warn_unused_result can be used here. Unfortunately "
"nothing mandates that the error code is used _correctly_. In the pointer "
"case, blindly dereferencing is considered a valid use, fooling basic lints."
msgstr ""

#: src/2116-alloc-me-maybe.md:127
msgid ""
"Unwinding is better than error codes in this regard, because completely "
"ignoring an exception aborts the process. The author's understanding is that "
"problems arise from the complicated exception-safety rules C++ collections "
"have."
msgstr ""

#: src/2116-alloc-me-maybe.md:129
msgid ""
"Both of these concerns are partially mitigated in Rust. For return values, "
"Result and bool have proper on-by-default must-use checks. However again "
"nothing mandates they are used properly. In the pointer case, we can however "
"prevent you from ever getting the pointer if the Result is an `Err`. For "
"unwinding, it's much harder to run afoul of exception-safety in Rust, "
"especially since copy/move can't be overloaded. However unsafe code may have "
"trouble."
msgstr ""

#: src/2116-alloc-me-maybe.md:134
msgid "Additional Background: Overcommit and Killers"
msgstr ""

#: src/2116-alloc-me-maybe.md:136
msgid ""
"Some operating systems can be configured to pretend there's more memory than "
"there actually is. Generally this is the result of pretending to allocate "
"physical pages of memory, but only actually doing so when the page is "
"accessed. For instance, forking a process is supposed to create two separate "
"copies of the process's memory, but this can be avoided by simply marking "
"all the pages as _copy on write_ and having the processes share the same "
"physical memory. The first process to mutate the shared page triggers a page "
"fault, which the OS handles by properly allocating a new physical page for "
"it. Similarly, to postpone zeroing fresh pages of memory, the OS may use a "
"copy-on-write zero page."
msgstr ""

#: src/2116-alloc-me-maybe.md:138
msgid ""
"The result of this is that allocation failure may happen when memory is "
"first _accessed_ and not when it's actually requested. If this happens, "
"someone needs to give up their memory, which can mean the OS killing your "
"process (or another random one!)."
msgstr ""

#: src/2116-alloc-me-maybe.md:140
msgid ""
"This strategy is used on many \\*nix variants/descendants, including "
"Android, iOS, MacOS, and Ubuntu."
msgstr ""

#: src/2116-alloc-me-maybe.md:142
msgid ""
"Some developers will try to use this as an argument for never _trying_ to "
"handle allocation failure. This RFC does not consider this to be a "
"reasonable stance. First and foremost: Windows doesn't do it. So anything "
"that's used a lot on windows (e.g. Firefox) can reasonably try to handle "
"allocation failure there. Similarly, overcommit can be disabled completely "
"or partially on many OSes. For instance the default for Linux is to actually "
"fail on allocations that are \"obviously\" too large to handle."
msgstr ""

#: src/2116-alloc-me-maybe.md:148
msgid ""
"Additional Background: Recovering From Allocation Failure Without Data Loss"
msgstr ""

#: src/2116-alloc-me-maybe.md:150
msgid ""
"The most common collection interfaces in Rust expect you to move data into "
"them, and may fail to allocate in the middle of processing this data. As a "
"basic example, `push` consumes a T. To avoid data loss, this T should be "
"returned, so a fallible `push` would need a signature like:"
msgstr ""

#: src/2116-alloc-me-maybe.md:153
msgid ""
"/// Inserts the given item at the end of the Vec.\n"
"///\n"
"/// If allocating space fails, the item is returned.\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:159
msgid ""
"More difficult is an API like `extend`, which in general cannot predict "
"allocation size and so must continually reallocate while processing. It also "
"cannot know if it needs space for an element until its been yielded by the "
"iterator. As such extend might have a signature like:"
msgstr ""

#: src/2116-alloc-me-maybe.md:162
msgid ""
"/// Inserts all the items in the given iterator at the end of the Vec.\n"
"///\n"
"/// If allocating space fails, the collection will contain all the elements\n"
"/// that it managed to insert until the failure. The result will contain\n"
"/// the iterator, having been run up until the failure point. If the "
"iterator\n"
"/// has been run at all, the last element yielded will also be returned.\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:172
msgid ""
"Note that this API only even works because Iterator's signature currently "
"guarantees that the yielded elements outlive the iterator. This would not be "
"the case if we ever moved to support so-called \"streaming iterators\", "
"which yield elements that point into themselves."
msgstr ""

#: src/2116-alloc-me-maybe.md:178
msgid "Guide-level explanation"
msgstr ""

#: src/2116-alloc-me-maybe.md:181
msgid ""
"Due to the diversity of requirements between our user profiles, there isn't "
"any one-size fits all solution. This RFC proposes two solutions which will "
"require minimal work for maximal impact:"
msgstr ""

#: src/2116-alloc-me-maybe.md:183
msgid ""
"For the server users, an `oom=panic` configuration, in the same vein as the "
"`panic=abort`."
msgstr ""

#: src/2116-alloc-me-maybe.md:184
msgid ""
"For everyone else, add `try_reserve` and `try_reserve_exact` as standard "
"collection APIs."
msgstr ""

#: src/2116-alloc-me-maybe.md:188 src/2116-alloc-me-maybe.md:295
msgid "oom=panic"
msgstr ""

#: src/2116-alloc-me-maybe.md:190
msgid ""
"Applying this configuration in a Cargo.toml would change the behaviour of "
"the global allocator's `oom()` function, which currently aborts, to instead "
"panic. As discussed in the Server user profile, this would allow OOM to be "
"handled at task boundaries with minimal effort for server developers, and no "
"effort from library maintainers."
msgstr ""

#: src/2116-alloc-me-maybe.md:192
msgid ""
"If using a thread-per-task model, OOMs will be naturally caught at the "
"thread boundary. If using a different model, tasks can be isolated using the "
"`thread::catch_unwind` or `Future::catch_unwind` APIs."
msgstr ""

#: src/2116-alloc-me-maybe.md:194
msgid ""
"We expose a flag, rather than changing the default, because we maintain that "
"_by default_ Rust programmers should not be trying to recover from "
"allocation failures."
msgstr ""

#: src/2116-alloc-me-maybe.md:196
msgid ""
"For instance, a project which desires to work this way would add this to "
"their Cargo.toml:"
msgstr ""

#: src/2116-alloc-me-maybe.md:198
msgid ""
"```toml\n"
"[profile]\n"
"oom = \"panic\"\n"
"```"
msgstr ""

#: src/2116-alloc-me-maybe.md:203
msgid "And then in their application, do something like this:"
msgstr ""

#: src/2116-alloc-me-maybe.md:216 src/2116-alloc-me-maybe.md:218
msgid "\"Task crashed: {}\""
msgstr ""

#: src/2116-alloc-me-maybe.md:220
msgid "\"Task crashed (unknown cause)\""
msgstr ""

#: src/2116-alloc-me-maybe.md:223
msgid "// Handle failure...\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:232 src/2116-alloc-me-maybe.md:307
msgid "try_reserve"
msgstr ""

#: src/2116-alloc-me-maybe.md:234
msgid ""
"`try_reserve` and `try_reserve_exact` would be added to `HashMap`, `Vec`, "
"`String`, and `VecDeque`. These would have the exact same APIs as their "
"infallible counterparts, except that OOM would be exposed as an error case, "
"rather than a call to `Alloc::oom()`. They would have the following "
"signatures:"
msgstr ""

#: src/2116-alloc-me-maybe.md:237
msgid ""
"/// Tries to reserve capacity for at least `additional` more elements to be "
"inserted\n"
"/// in the given `Vec<T>`. The collection may reserve more space to avoid\n"
"/// frequent reallocations. After calling `reserve`, capacity will be\n"
"/// greater than or equal to `self.len() + additional`. Does nothing if\n"
"/// capacity is already sufficient.\n"
"///\n"
"/// # Errors\n"
"///\n"
"/// If the capacity overflows, or the allocator reports a failure, then an "
"error\n"
"/// is returned. The Vec is unmodified if this occurs.\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:248
msgid "/// Ditto, but has reserve_exact's behaviour\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:251
msgid "/// Augments `AllocErr` with a CapacityOverflow variant.\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:254
msgid ""
"/// Error due to the computed capacity exceeding the collection's maximum\n"
"    /// (usually `isize::MAX` bytes).\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:257
msgid "/// Error due to the allocator (see the `AllocErr` type's docs).\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:262
msgid ""
"We propose only these methods because they represent a minimal building "
"block that third parties can develop fallible allocation APIs on top of. For "
"instance, here are some basic implementations:"
msgstr ""

#: src/2116-alloc-me-maybe.md:273
msgid "// note this!\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:284
msgid ""
"Note that iterator-consuming implementations are limited to "
"ExactSizeIterator, as this lets us perfectly predict how much space we need. "
"In practice this shouldn't be much of a constraint, as most uses of these "
"APIs just feed arrays into arrays or maps into maps. Only things like "
"`filter` produce unpredictable iterator sizes."
msgstr ""

#: src/2116-alloc-me-maybe.md:290
msgid "Reference-level explanation"
msgstr ""

#: src/2116-alloc-me-maybe.md:297
msgid ""
"Disclaimer: not super familiar with all the mechanics here, so this is a "
"sketch that hopefully someone whose worked on these details can help flesh "
"out."
msgstr ""

#: src/2116-alloc-me-maybe.md:299
msgid ""
"We add a `-C oom=abort|panic` flag to rustc, which changes the impl of "
"`__rust_oom` that's linked in to either panic or abort. It's possible that "
"this should just change the value of a `extern static bool` in libcore "
"(liballoc?) that `__rust_oom` impls are expected to check?"
msgstr ""

#: src/2116-alloc-me-maybe.md:301
msgid ""
"Unlike the `panic=abort` flag, this shouldn't make your crate incompatible "
"with crates with a different choice. Only a subset of target types should be "
"able to set this, e.g. it's a bin-level decision?"
msgstr ""

#: src/2116-alloc-me-maybe.md:303
msgid ""
"Cargo would also add a `oom=abort=panic` profile configuration, to set the "
"rustc flag. Its value should be ignored in dependencies?"
msgstr ""

#: src/2116-alloc-me-maybe.md:309
msgid ""
"[An implementation of try_reserve for Vec can be found for here](https://"
"github.com/rust-lang/rust/pull/43890)"
msgstr ""

#: src/2116-alloc-me-maybe.md:311
msgid ""
"The guide-level explanation otherwise covers all the interesting details."
msgstr ""

#: src/2116-alloc-me-maybe.md:316
msgid "Drawbacks"
msgstr ""

#: src/2116-alloc-me-maybe.md:319
msgid ""
"There doesn't seem to be any drawback for adding support for `oom=panic`."
msgstr ""

#: src/2116-alloc-me-maybe.md:321
msgid ""
"`try_reserve`'s only serious drawback is that it isn't a complete solution, "
"and it may not idiomatically match future \"complete\" solutions to the "
"problem."
msgstr ""

#: src/2116-alloc-me-maybe.md:327
msgid "Rationale and Alternatives"
msgstr ""

#: src/2116-alloc-me-maybe.md:332
msgid "Always panic on OOM"
msgstr ""

#: src/2116-alloc-me-maybe.md:334
msgid ""
"We probably shouldn't mandate this in the actual Alloc trait, but certainly "
"we could change how our global Alloc impls behave. This RFC doesn't propose "
"this for two reasons."
msgstr ""

#: src/2116-alloc-me-maybe.md:336
msgid ""
"The first is basically on the grounds of \"not rocking the boat\". Notably "
"unsafe code might be relying on global OOM not unwinding for exception "
"safety reasons. The author expects such code could very easily be changed to "
"be exception-safe if we decided to do this."
msgstr ""

#: src/2116-alloc-me-maybe.md:338
msgid ""
"The second is that the author still considers it legitimately correct to "
"discourage handling OOM by default, for the reasons stated in earlier "
"sections."
msgstr ""

#: src/2116-alloc-me-maybe.md:343
msgid "Eliminate the CapacityOverflow distinction"
msgstr ""

#: src/2116-alloc-me-maybe.md:345
msgid ""
"Collections could potentially just create an `AllocErr::"
"Unsupported(\"capacity overflow\")` and feed it to their allocator. "
"Presumably this wouldn't do something bad to the allocator? Then the "
"oom=abort flag could be used to completely control whether allocation "
"failure is a panic or abort (for participating allocators)."
msgstr ""

#: src/2116-alloc-me-maybe.md:347
msgid ""
"Again this is avoided simply to leave things \"as they are\". In this case "
"it would be a change to a legitimately documented API behaviour (panic on "
"overflow of usize), but again that documentation isn't even totally accurate."
msgstr ""

#: src/2116-alloc-me-maybe.md:352
msgid "Eliminate the 64-bit difference"
msgstr ""

#: src/2116-alloc-me-maybe.md:354
msgid ""
"This difference literally exists to save a single perfectly-predictable "
"compare-and-branch on 64-bit platforms when allocating collections, which is "
"probably insignificant considering how expensive the success path is. Also "
"the difference here would be a bit exacerbated by exposing the "
"CapacityOverflow variant here."
msgstr ""

#: src/2116-alloc-me-maybe.md:356
msgid "Again, not proposed to avoid rocking the boat."
msgstr ""

#: src/2116-alloc-me-maybe.md:361
msgid "CollectionAllocErr"
msgstr ""

#: src/2116-alloc-me-maybe.md:363
msgid "There were a few different possible designs for CollectionAllocErr:"
msgstr ""

#: src/2116-alloc-me-maybe.md:365
msgid "Just make it AllocErr"
msgstr ""

#: src/2116-alloc-me-maybe.md:366
msgid "Remove the payload from the AllocErr variant"
msgstr ""

#: src/2116-alloc-me-maybe.md:367
msgid "Just make it a `()` (so try_reserve basically returns a bool)"
msgstr ""

#: src/2116-alloc-me-maybe.md:369
msgid ""
"AllocErr already has an `Unsupported(&'static str)` variant to capture any "
"miscellaneous allocation problems, so CapacityOverflow could plausibly just "
"be stuffed in there. We opted to keep it separate to most accurately reflect "
"the way collections think about these problems today -- CapacityOverflow "
"goes to panic and AllocErr goes to `oom()`. It's possible end users simply "
"don't care, in much the same way that collections don't actually care if an "
"AllocErr is `Exhausted` or `Unsupported`."
msgstr ""

#: src/2116-alloc-me-maybe.md:371
msgid ""
"It's also possible we should suppress the AllocErr details to \"hide\" how "
"collections are interpreting the requests they receive. This just didn't "
"seem that important, and has the possibility to get in the way of someone "
"using their own local allocator."
msgstr ""

#: src/2116-alloc-me-maybe.md:373
msgid ""
"The most extreme version of this would be to just say \"there was an error\" "
"without any information. The only reason to really prefer this is for bloat "
"reasons; the current Rust compiler really doesn't handle Result payloads "
"very efficiently. This should presumably be fixed _eventually_, since "
"Results are pretty important?"
msgstr ""

#: src/2116-alloc-me-maybe.md:375
msgid ""
"We simply opted for the version that had maximum information, on the off-"
"chance this was useful."
msgstr ""

#: src/2116-alloc-me-maybe.md:380
msgid "Future Work: Infallible Allocation Effect System (w/ Portability Lints)"
msgstr ""

#: src/2116-alloc-me-maybe.md:382
msgid ""
"Several of our users have expressed desire for some kind of system to "
"prevent a function from ever infallibly allocating. This is ultimately an "
"effect system."
msgstr ""

#: src/2116-alloc-me-maybe.md:384
msgid ""
"One possible way to implement this would be to use the _portability lint_ "
"system. In particular, the \"subsetting\" portability lints that were "
"proposed as future work in [RFC-1868](https://github.com/rust-lang/rfcs/blob/"
"master/text/1868-portability-lint.md#subsetting-std)."
msgstr ""

#: src/2116-alloc-me-maybe.md:386
msgid ""
"This system is supposed to handle things like \"I don't have float support\" "
"or \"I don't have AtomicU64\". \"I don't have infallible allocation "
"support\" is much the same idea. This could be scoped to modules or "
"functions."
msgstr ""

#: src/2116-alloc-me-maybe.md:389
msgid "Future Work: Complete Result APIs"
msgstr ""

#: src/2116-alloc-me-maybe.md:391
msgid ""
"Although this RFC handles the \"wants to unwind\" case pretty cleanly and "
"completely, it leaves no-unwind world with an imperfect one. In particular, "
"it's completely useless for collections which have unpredictable allocations "
"like BTreeMap. This proposal punts on this problem because solving it will "
"be a big change which will likely make a bunch of people mad no matter what."
msgstr ""

#: src/2116-alloc-me-maybe.md:393
msgid ""
"The author would prefer that we don't spend much time focusing on these "
"solutions, but will document them here just for informational purposes. Also "
"for these purposes we will only be discussing the `push` method on Vec, "
"since any solution for that generalizes cleanly to everything else."
msgstr ""

#: src/2116-alloc-me-maybe.md:395
msgid ""
"Broadly speaking, there's two schools of thought here: fallible operations "
"should just be methods, and fallible operations should be distinguished at "
"the type-level. Basically, should you be able to do: `vec.push(x); vec."
"try_push(y)`, or will you somehow obtain a special kind of Vec and `vec."
"push(x)` will then return a `Result`."
msgstr ""

#: src/2116-alloc-me-maybe.md:397
msgid ""
"It should be noted that this appears to be a source of massive disagreement. "
"Even within the gecko codebase, there are supporters of both approaches, and "
"so it actually supports both. This is probably not a situation we should "
"strive to emulate."
msgstr ""

#: src/2116-alloc-me-maybe.md:399
msgid "There are a few motivations for a type-level distinction:"
msgstr ""

#: src/2116-alloc-me-maybe.md:401
msgid ""
"If it's done through a default generic parameter, then code can be written "
"generically over doing something fallibly or infallibly"
msgstr ""

#: src/2116-alloc-me-maybe.md:402
msgid ""
"If it's done through a default generic parameter, it potentially enables "
"code reuse in implementations"
msgstr ""

#: src/2116-alloc-me-maybe.md:403
msgid ""
"It can allow you to enforce that all operations on a Vec are performed "
"fallibly"
msgstr ""

#: src/2116-alloc-me-maybe.md:404
msgid ""
"It can make usage more ergonomic (no need for `try_` in front of everything)"
msgstr ""

#: src/2116-alloc-me-maybe.md:406
msgid ""
"The first doesn't appear to actually do much semantically. Code that's "
"generic over fallibility is literally the exact same as code that only uses "
"the fallible APIs, at which point you might as well just toss an `expect` at "
"the end if you want to crash on OOM. The only difference seems to be the "
"performance difference between propagating Results vs immediately unwinding/"
"aborting. This can certainly be significant in code that's doing a lot of "
"allocations, but it's not really clear how much this matters. Especially if "
"Result-based codegen improves (which there's a lot of room for)."
msgstr ""

#: src/2116-alloc-me-maybe.md:408
msgid ""
"The second is interesting, but mostly effects collection implementors. "
"Making users deal with additional generic parameters to make implementations "
"easier doesn't seem very compelling."
msgstr ""

#: src/2116-alloc-me-maybe.md:410
msgid ""
"Also these two benefits must be weighed against the cost of default generic "
"parameters: they don't work very well (and may never?), and most people "
"won't bother to support them so using a non-default just makes you "
"incompatible with a bunch of the ecosystem."
msgstr ""

#: src/2116-alloc-me-maybe.md:412
msgid ""
"The third is a bit more compelling, but has a few issues. First, it doesn't "
"actually enforce that a function handles all allocation failures. One can "
"create a fresh Vec, Box, or just call into a routine that allocates like "
"`slice::sort()` and types won't do anything to prevent this. Second, it's a "
"fairly common pattern to fallibly reserve space, and then infallibly insert "
"data. For instance, code like the following can be found in many places in "
"Gecko's codebase:"
msgstr ""

#: src/2116-alloc-me-maybe.md:421
msgid "// Wait, is this fallible or not?\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:426
msgid ""
"Mandating all operations be fallible can be confusing in that case (and has "
"similar inefficiencies to the ones discussed in the previous point). "
"Although admittedly this is a lot better in Rust with must-be-unwrapped-"
"Results. In Gecko, \"unwrapping\" is often just blindly dereferencing a "
"pointer, which is Undefined Behaviour if the allocation actually fails."
msgstr ""

#: src/2116-alloc-me-maybe.md:428
msgid ""
"The fourth is certainly nice-to-have, but probably not a high enough "
"priority to create an entire separate Vec type."
msgstr ""

#: src/2116-alloc-me-maybe.md:430
msgid ""
"All of the type-based solutions also suffer from a fairly serious problem: "
"they can't implement many core traits in the fallible state. For instance, "
"Extend::extend and Display::to_string require allocation and don't support "
"fallibility."
msgstr ""

#: src/2116-alloc-me-maybe.md:432
msgid "With all that said, these are the proposed solutions:"
msgstr ""

#: src/2116-alloc-me-maybe.md:435
msgid "Method-Based"
msgstr ""

#: src/2116-alloc-me-maybe.md:437
msgid ""
"Fairly straight-forward, but a bunch of duplicate code. Probably we would "
"either end up implementing `push` in terms of `try_push` (which would be "
"inefficient but easy), or with macros."
msgstr ""

#: src/2116-alloc-me-maybe.md:448 src/2116-alloc-me-maybe.md:508
msgid "// ... do actual push normally ...\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:454
msgid "Generic (on Vec)"
msgstr ""

#: src/2116-alloc-me-maybe.md:456
msgid ""
"This is a sketch, didn't want to put enough effort in to crack this puzzle."
msgstr ""

#: src/2116-alloc-me-maybe.md:458
msgid ""
"The most notable thing is that it relies on generic associated types, which "
"don't actually exist yet, and probably won't be stable until ~late 2018 "
"(optimistically)."
msgstr ""

#: src/2116-alloc-me-maybe.md:467
msgid "// ... probably some other stuff here...?\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:489
msgid "// ??? maybe ???\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:499
msgid ""
"// ??? How do I match on this in generic code ???\n"
"            // (can't use Carrier since we need to add `elem` payload?)\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:502
msgid ""
"// Have to move elem into closure,\n"
"                // so can only map_err conditionally\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:515
msgid "Generic (on Alloc)"
msgstr ""

#: src/2116-alloc-me-maybe.md:517
msgid ""
"Same basic idea as the previous design, but the Fallibility trait is folded "
"into the Alloc trait. Then one would use `FallibleHeap` or `InfallibleHeap`, "
"or maybe `Infallible<Heap>`? This forces anyone who wants to support generic "
"allocators to support generic fallibility. It would require a complete "
"redesign of the allocator API, blocking it on generic associated types."
msgstr ""

#: src/2116-alloc-me-maybe.md:521
msgid "FallibleVec"
msgstr ""

#: src/2116-alloc-me-maybe.md:523
msgid ""
"Just make a completely separate type. Includes an `into_fallible(self)`/"
"`into_infallible(self)` conversion which is free since there's no actual "
"representation change. Makes it possible to change \"phases\" between "
"fallibility/infallibly for different parts of the program if that's "
"valuable. Implementation-wise, basically identical to the method approach, "
"but we also need to duplicate non-allocating methods just to mirror the API."
msgstr ""

#: src/2116-alloc-me-maybe.md:525
msgid ""
"Alternatively we could make `FallibleVec<'a, T>` and `as_fallible(&mut "
"self)`, which is a temporary view like Iterator/Entry. This is probably a "
"bit more consistent with how we do this sort of thing. This also makes "
"\"temporary\" fallibility easier, but at the cost of being able to "
"permanently become fallible:"
msgstr ""

#: src/2116-alloc-me-maybe.md:529
msgid "// vs\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:535
msgid "// but this actually works:\n"
msgstr ""

#: src/2116-alloc-me-maybe.md:543
msgid "Unresolved questions"
msgstr ""

#: src/2116-alloc-me-maybe.md:546
msgid "How exactly should oom=panic be implemented in the compiler?"
msgstr ""

#: src/2116-alloc-me-maybe.md:547
msgid "How exactly should oom=panic behave for dependencies?"
msgstr ""
