msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:05Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/3348-c-str-literal.md:1
msgid "Feature Name: `c_str_literal`"
msgstr ""

#: src/3348-c-str-literal.md:2
msgid "Start Date: 2022-11-15"
msgstr ""

#: src/3348-c-str-literal.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#3348](https://github.com/rust-lang/rfcs/pull/3348)"
msgstr ""

#: src/3348-c-str-literal.md:4
msgid ""
"Rust Issue: [rust-lang/rust#105723](https://github.com/rust-lang/rust/"
"issues/105723)"
msgstr ""

#: src/3348-c-str-literal.md:6
msgid "Summary"
msgstr "ÊëòË¶Å"

#: src/3348-c-str-literal.md:9
msgid "`c\"‚Ä¶\"` string literals."
msgstr ""

#: src/3348-c-str-literal.md:11
msgid "Motivation"
msgstr "ÂãïÊ©ü"

#: src/3348-c-str-literal.md:14
msgid ""
"Looking at the [amount of `cstr!()` invocations just on GitHub](https://cs."
"github.com/?scopeName=All+repos&scope=&q=cstr%21+lang%3Arust) (about 3.2k "
"files with matches) it seems like C string literals are a widely used "
"feature. Implementing `cstr!()` as a `macro_rules` or `proc_macro` requires "
"non-trivial code to get it completely right (e.g. refusing embedded nul "
"bytes), and is still less flexible than it should be (e.g. in terms of "
"accepted escape codes)."
msgstr ""

#: src/3348-c-str-literal.md:18
msgid ""
"In Rust 2021, we reserved prefixes for (string) literals, so let's make use "
"of that."
msgstr ""

#: src/3348-c-str-literal.md:20
msgid "Guide-level explanation"
msgstr ""

#: src/3348-c-str-literal.md:23
msgid ""
"`c\"abc\"` is a [`&CStr`](https://doc.rust-lang.org/stable/core/ffi/struct."
"CStr.html). A nul byte (`b'\\0'`) is appended to it in memory and the result "
"is a `&CStr`."
msgstr ""

#: src/3348-c-str-literal.md:25
msgid ""
"All escape codes and characters accepted by `\"\"` and `b\"\"` literals are "
"accepted, except nul bytes. So, both UTF-8 and non-UTF-8 data can co-exist "
"in a C string. E.g. `c\"hello\\x80ÊàëÂè´\\u{1F980}\"`."
msgstr ""

#: src/3348-c-str-literal.md:28
msgid ""
"The raw string literal variant is prefixed with `cr`. For example, `cr\"\\"
"\"` and `cr##\"Hello \"world\"!\"##`. (Just like `r\"\"` and `br\"\"`.)"
msgstr ""

#: src/3348-c-str-literal.md:30
msgid "Reference-level explanation"
msgstr ""

#: src/3348-c-str-literal.md:33
msgid ""
"Two new [string literal types](https://doc.rust-lang.org/reference/tokens."
"html#characters-and-strings): `c\"‚Ä¶\"` and `cr#\"‚Ä¶\"#`."
msgstr ""

#: src/3348-c-str-literal.md:35
msgid ""
"Accepted escape codes: [Quote](https://doc.rust-lang.org/reference/tokens."
"html#quote-escapes) & [Unicode](https://doc.rust-lang.org/reference/tokens."
"html#unicode-escapes) & [Byte](https://doc.rust-lang.org/reference/tokens."
"html#byte-escapes)."
msgstr ""

#: src/3348-c-str-literal.md:37
msgid ""
"Nul bytes are disallowed, whether as escape code or source character (e.g. "
"`\"\\0\"`, `\"\\x00\"`, `\"\\u{0}\"` or `\"‚êÄ\"`)."
msgstr ""

#: src/3348-c-str-literal.md:39
msgid ""
"Unicode characters are accepted and encoded as UTF-8. That is, `c\"ü¶Ä\"`, "
"`c\"\\u{1F980}\"` and `c\"\\xf0\\x9f\\xa6\\x80\"` are all accepted and "
"equivalent."
msgstr ""

#: src/3348-c-str-literal.md:41
msgid ""
"The type of the expression is [`&core::ffi::CStr`](https://doc.rust-lang.org/"
"stable/core/ffi/struct.CStr.html). So, the `CStr` type will have to become a "
"lang item. (`no_core` programs that don't use `c\"\"` string literals won't "
"need to define this lang item.)"
msgstr ""

#: src/3348-c-str-literal.md:44
msgid "Interactions with string related macros:"
msgstr ""

#: src/3348-c-str-literal.md:46
msgid ""
"The [`concat` macro](https://doc.rust-lang.org/stable/std/macro.concat.html) "
"will _not_ accept these literals, just like it doesn't accept byte string "
"literals."
msgstr ""

#: src/3348-c-str-literal.md:47
msgid ""
"The [`format_args` macro](https://doc.rust-lang.org/stable/std/macro."
"format_args.html) will _not_ accept such a literal as the format string, "
"just like it doesn't accept a byte string literal."
msgstr ""

#: src/3348-c-str-literal.md:49
msgid ""
"(This might change in the future. E.g. `format_args!(c\"‚Ä¶\")` would be cool, "
"but that would require generalizing the macro and `fmt::Arguments` to work "
"for other kinds of strings. (Ideally also for `b\"‚Ä¶\"`.))"
msgstr ""

#: src/3348-c-str-literal.md:51
msgid "Rationale and alternatives"
msgstr ""

#: src/3348-c-str-literal.md:54
msgid ""
"No `c\"\"` literal, but just a `cstr!()` macro. (Possibly as part of the "
"standard library.)"
msgstr ""

#: src/3348-c-str-literal.md:56
msgid ""
"This requires [complicated machinery](https://github.com/rust-lang/rust/"
"pull/101607/files) to implement correctly."
msgstr ""

#: src/3348-c-str-literal.md:58
msgid ""
"The trivial implementation of using `concat!($s, \"\\0\")` is problematic "
"for several reasons, including non-string input and embedded nul bytes. (The "
"unstable `concat_bytes!()` solves some of the problems.)"
msgstr ""

#: src/3348-c-str-literal.md:61
msgid ""
"The popular [`cstr` crate](https://crates.io/crates/cstr) is a proc macro to "
"work around the limitations of a `macro_rules` implementation, but that also "
"has many downsides."
msgstr ""

#: src/3348-c-str-literal.md:63
msgid ""
"Even if we had the right language features for a trivial correct "
"implementation, there are many code bases where C strings are the primary "
"form of string, making `cstr!(\"..\")` syntax quite cumbersome."
msgstr ""

#: src/3348-c-str-literal.md:66
msgid ""
"No `c\"\"` literal, but make it possible for `\"\"` to implicitly become a "
"`&CStr` through magic."
msgstr ""

#: src/3348-c-str-literal.md:68
msgid ""
"We already allow integer literals (e.g. `123`) to become one of many types, "
"so perhaps we could do the same to string literals."
msgstr ""

#: src/3348-c-str-literal.md:70
msgid ""
"(It could be a built-in fixed set of types (e.g. just `str`, `[u8]`, and "
"`CStr`), or it could be something extensible through something like a `const "
"trait FromStringLiteral`. Not sure how that would exactly work, but it "
"sounds cool.)"
msgstr ""

#: src/3348-c-str-literal.md:74
msgid ""
"Allowing only valid UTF-8 and unicode-oriented escape codes (like in `\"‚Ä¶"
"\"`, e.g. `ËûÉËüπ` or `\\u{1F980}` but not `\\xff`)."
msgstr ""

#: src/3348-c-str-literal.md:76
msgid ""
"For regular string literals, we have this restriction because `&str` is "
"required to be valid UTF-8. However, C literals (and objects of our `&CStr` "
"type) aren't necessarily valid UTF-8."
msgstr ""

#: src/3348-c-str-literal.md:79
msgid ""
"Allowing only ASCII characters and byte-oriented escape codes (like in `b\"‚Ä¶"
"\"`, e.g. `\\xff` but not `ËûÉËüπ` or `\\u{1F980}`)."
msgstr ""

#: src/3348-c-str-literal.md:81
msgid ""
"While C literals (and  `&CStr`) aren't necessarily valid UTF-8, they often "
"do contain UTF-8 data. Refusing to put UTF-8 in it would make the feature "
"less useful and would unnecessarily make it harder to use unicode in "
"programs that mainly use C strings."
msgstr ""

#: src/3348-c-str-literal.md:84
msgid ""
"Having separate `c\"‚Ä¶\"` and `bc\"‚Ä¶\"` string literal prefixes for UTF-8 and "
"non-UTF8."
msgstr ""

#: src/3348-c-str-literal.md:86
msgid ""
"Both of those would be the same type (`&CStr`). Unless we add a special "
"\"always valid UTF-8 C string\" type, there's not much use in separating "
"them."
msgstr ""

#: src/3348-c-str-literal.md:88
msgid ""
"Use `z` instead of `c` (`z\"‚Ä¶\"`), for \"zero terminated\" instead of \"C "
"string\"."
msgstr ""

#: src/3348-c-str-literal.md:90
msgid "We already have a type called `CStr` for this, so `c` seems consistent."
msgstr ""

#: src/3348-c-str-literal.md:92
msgid ""
"Also add `c'‚Ä¶'` as [`c_char`](https://doc.rust-lang.org/stable/core/ffi/type."
"c_char.html) literal."
msgstr ""

#: src/3348-c-str-literal.md:94
msgid "It'd be identical to `b'‚Ä¶'`, except it'd be a `c_char` instead of `u8`."
msgstr ""

#: src/3348-c-str-literal.md:96
msgid ""
"This would easily lead to unportable code, since `c_char` is `i8` or `u8` "
"depending on the platform. (Not a wrapper type, but a direct type alias.) E."
"g. `fn f(_: i8) {} f(c'a');` would compile only on some platforms."
msgstr ""

#: src/3348-c-str-literal.md:99
msgid ""
"An alternative is to allow `c'‚Ä¶'` to implicitly be either a `u8` or `i8`. "
"(Just like integer literals can implicitly become one of many types.)"
msgstr ""

#: src/3348-c-str-literal.md:101
msgid "Drawbacks"
msgstr ""

#: src/3348-c-str-literal.md:104
msgid ""
"The `CStr` type needs some work. `&CStr` is currently a wide pointer, but "
"it's supposed to be a thin pointer. See https://doc.rust-lang.org/1.65.0/src/"
"core/ffi/c_str.rs.html#87"
msgstr ""

#: src/3348-c-str-literal.md:106
msgid ""
"It's not a blocker, but we might want to try to fix that before stabilizing "
"`c\"‚Ä¶\"`."
msgstr ""

#: src/3348-c-str-literal.md:108
msgid "Prior art"
msgstr ""

#: src/3348-c-str-literal.md:111
msgid "C has C string literals (`\"‚Ä¶\"`). :)"
msgstr ""

#: src/3348-c-str-literal.md:112
msgid "Nim has `cstring\"‚Ä¶\"`."
msgstr ""

#: src/3348-c-str-literal.md:113
msgid "COBOL has `Z\"‚Ä¶\"`."
msgstr ""

#: src/3348-c-str-literal.md:114
msgid "Probably a lot more languages, but it's hard to search for. :)"
msgstr ""

#: src/3348-c-str-literal.md:116
msgid "Unresolved questions"
msgstr "Êú™Ëß£Ê±∫ÁöÑÂïèÈ°å"

#: src/3348-c-str-literal.md:119
msgid ""
"Also add `c'‚Ä¶'` C character literals? (`u8`, `i8`, `c_char`, or something "
"more flexible?)"
msgstr ""

#: src/3348-c-str-literal.md:121
msgid ""
"Should we make `&CStr` a thin pointer before stabilizing this? (If so, how?)"
msgstr ""

#: src/3348-c-str-literal.md:123
msgid ""
"Should the (unstable) [`concat_bytes` macro](https://github.com/rust-lang/"
"rust/issues/87555) accept C string literals? (If so, should it evaluate to a "
"C string or byte string?)"
msgstr ""

#: src/3348-c-str-literal.md:125
msgid "Future possibilities"
msgstr ""

#: src/3348-c-str-literal.md:128
msgid "(These aren't necessarily all good ideas.)"
msgstr ""

#: src/3348-c-str-literal.md:130
msgid "Make `concat!()` or `concat_bytes!()` work with `c\"‚Ä¶\"`."
msgstr ""

#: src/3348-c-str-literal.md:131
msgid "Make `format_args!(c\"‚Ä¶\")` (and `format_args!(b\"‚Ä¶\")`) work."
msgstr ""

#: src/3348-c-str-literal.md:132
msgid "Improve the `&CStr` type, and make it FFI safe."
msgstr ""

#: src/3348-c-str-literal.md:133
msgid ""
"Accept unicode characters and escape codes in `b\"\"` literals too: [RFC "
"3349](https://github.com/rust-lang/rfcs/pull/3349)."
msgstr ""

#: src/3348-c-str-literal.md:134
msgid ""
"More prefixes! `w\"\"`, `os\"\"`, `path\"\"`, `utf16\"\"`, "
"`brokenutf16\"\"`, `utf32\"\"`, `wtf8\"\"`, `ebcdic\"\"`, ‚Ä¶"
msgstr ""

#: src/3348-c-str-literal.md:135
msgid ""
"No more prefixes! Have `let a: &CStr = \"‚Ä¶\";` work through magic, removing "
"the need for prefixes. (That won't happen any time soon probably, so that "
"shouldn't block `c\"‚Ä¶\"` now.)"
msgstr ""
