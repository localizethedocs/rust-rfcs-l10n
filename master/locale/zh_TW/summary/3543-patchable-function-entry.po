msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:05Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/3543-patchable-function-entry.md:1
msgid "Feature Name: `patchable_function_entry`"
msgstr ""

#: src/3543-patchable-function-entry.md:2
msgid "Start Date: 2023-12-12"
msgstr ""

#: src/3543-patchable-function-entry.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#3543](https://github.com/rust-lang/rfcs/pull/3543)"
msgstr ""

#: src/3543-patchable-function-entry.md:4
msgid ""
"Tracking Issue: [rust-lang/rust#123115](https://github.com/rust-lang/rust/"
"issues/123115)"
msgstr ""

#: src/3543-patchable-function-entry.md:6
msgid "Summary"
msgstr ""

#: src/3543-patchable-function-entry.md:9
msgid ""
"This RFC proposes support for `patchable-function-entry` as present in "
"[`clang`](https://clang.llvm.org/docs/ClangCommandLineReference."
"html#cmdoption-clang-fpatchable-function-entry) and [`gcc`](https://gcc.gnu."
"org/onlinedocs/gcc/Instrumentation-Options.html#index-fpatchable-function-"
"entry). This feature is generally used to allow hotpatching and "
"instrumentation of code."
msgstr ""

#: src/3543-patchable-function-entry.md:11
msgid "Motivation"
msgstr ""

#: src/3543-patchable-function-entry.md:14
msgid ""
"The Linux kernel uses `-fpatchable-function-entry` heavily, including for "
"[`ftrace`](https://www.kernel.org/doc/html/v6.6/trace/ftrace.html) and "
"[`FINEIBT` for x86](https://github.com/torvalds/linux/"
"blob/26aff849438cebcd05f1a647390c4aa700d5c0f1/arch/x86/Kconfig#L2464). "
"Today, enabling these features alongside Rust will lead to confusing or "
"broken behavior (`ftrace` will fail to trace Rust functions when developing, "
"`FINEIBT` will conflict with the `kcfi` sanitizer, etc.). It also uses the "
"`clang` and `gcc` attribute `patchable_function_entry` to disable this "
"padding on fragile functions or those used for instrumentation."
msgstr ""

#: src/3543-patchable-function-entry.md:16
msgid ""
"Integrating Rust code into this and other large projects which expect all "
"native code to have these nop buffers will be made easier by allowing them "
"to request the same treatment of native functions they get in C and C++."
msgstr ""

#: src/3543-patchable-function-entry.md:18
msgid "Guide-level explanation"
msgstr ""

#: src/3543-patchable-function-entry.md:21
#: src/3543-patchable-function-entry.md:40
msgid ""
"`patchable-function-entry` provides configurable nop padding before function "
"symbols and after function symbols but before any generated code. We refer "
"to the former as `prefix` padding and the latter as `entry` padding. For "
"example, if we had a function `f` with `prefix_nops` set to 3 and "
"`entry_nops` to 2, we'd expect to see:"
msgstr ""

#: src/3543-patchable-function-entry.md:23
msgid ""
"```\n"
"nop\n"
"nop\n"
"nop\n"
"f:\n"
"nop\n"
"nop\n"
"// Code goes here\n"
"```"
msgstr ""

#: src/3543-patchable-function-entry.md:33
msgid ""
"To set this for all functions in a crate, use `-C patchable-function-"
"entry=total_nops=m,prefix_nops=n` where `total_nops = prefix_nops + "
"entry_nops`. Usually, you'll want to copy this value from a corresponding `-"
"fpatchable-function-entry=` being passed to the C compiler in your project - "
"`total_nops` will match the first parameter used by your C compiler, and the "
"optional `offset` parameter passed to the C compiler will match "
"`prefix_nops`."
msgstr ""

#: src/3543-patchable-function-entry.md:35
msgid ""
"To set this for a specific function, use "
"`#[patchable_function_entry(prefix_nops = m, entry_nops = n)]` to pad with m "
"nops before the symbol and n after the symbol, but before the prelude. This "
"will override the flag value. To disable padding for a specific function, "
"for example because it is part of the instrumentation framework, use "
"`#[patchable_function_entry(entry_nops = 0, prefix_nops = 0)]`."
msgstr ""

#: src/3543-patchable-function-entry.md:37
msgid "Reference-level explanation"
msgstr ""

#: src/3543-patchable-function-entry.md:42
msgid ""
"```\n"
"f_pad:\n"
"nop\n"
"nop\n"
"nop\n"
"f:\n"
"nop\n"
"nop\n"
"// Code goes here\n"
"```"
msgstr ""

#: src/3543-patchable-function-entry.md:53
msgid ""
"Nop padding may not be supported on all architectures. As of the time of "
"writing, support includes:"
msgstr ""

#: src/3543-patchable-function-entry.md:55
msgid "aarch64"
msgstr ""

#: src/3543-patchable-function-entry.md:56
msgid "aarch64\\_be"
msgstr ""

#: src/3543-patchable-function-entry.md:57
msgid "loongarch32"
msgstr ""

#: src/3543-patchable-function-entry.md:58
msgid "loongarch64"
msgstr ""

#: src/3543-patchable-function-entry.md:59
msgid "riscv32"
msgstr ""

#: src/3543-patchable-function-entry.md:60
msgid "riscv64"
msgstr ""

#: src/3543-patchable-function-entry.md:61
msgid "i686"
msgstr ""

#: src/3543-patchable-function-entry.md:62
msgid "x86\\_64"
msgstr ""

#: src/3543-patchable-function-entry.md:64
msgid ""
"`f_pad` addresses for every padded symbol are aggregated in the "
"`__patchable_function_entries` section of the resulting object. This is not "
"a real symbol, just a collected location."
msgstr ""

#: src/3543-patchable-function-entry.md:67
msgid "Compiler flag `-C patchable-function-entry`"
msgstr ""

#: src/3543-patchable-function-entry.md:69
msgid "This flag comes in two forms:"
msgstr ""

#: src/3543-patchable-function-entry.md:71
msgid "`-C patchable-function-entry=total_nops=m,prefix_nops=n`"
msgstr ""

#: src/3543-patchable-function-entry.md:72
msgid "`-C patchable-function-entry=total_nops=m`"
msgstr ""

#: src/3543-patchable-function-entry.md:74
msgid ""
"In the latter, `prefix_nops` is assumed to be zero. `total_nops` must be "
"greater than or equal to `prefix_nops`, or it will be rejected."
msgstr ""

#: src/3543-patchable-function-entry.md:76
msgid ""
"If unspecified, the current behavior is maintained, which is equivalent to "
"`total_nops=0` here."
msgstr ""

#: src/3543-patchable-function-entry.md:78
msgid ""
"This flag sets the default nop padding for all functions in the crate. In "
"most cases, all crates in a compilation should use the same value of `-C "
"patchable-function-entry` to reduce confusion. If not all crates in the "
"compilation graph share the same `patchable-function-entry` configuration, "
"the compiler may produce an error _or_ use any patchability specification "
"present in the graph as the default for any function."
msgstr ""

#: src/3543-patchable-function-entry.md:80
msgid ""
"`entry_nops` is calculated as `total_nops - prefix_nops`. This unusual mode "
"of specification is intended to mimic the compiler flags of `clang` and "
"`gcc` for ease of build system integration. The first mandatory parameter to "
"their flags matches `total_nops`, and the optional parameter matches "
"`prefix_nops`."
msgstr ""

#: src/3543-patchable-function-entry.md:82
msgid ""
"Specifying the compiler flag for a backend or architecture which does not "
"support this feature will result in an error. Some backend / architecture "
"combinations may only support some values of `entry_nops` and `prefix_nops`, "
"in which case an error will also be generated for invalid values."
msgstr ""

#: src/3543-patchable-function-entry.md:84
msgid "Attribute `#[patchable_function_entry]`"
msgstr ""

#: src/3543-patchable-function-entry.md:86
msgid ""
"This attribute allows specification of either the `prefix_nops` or "
"`entry_nops` values or both, using the format "
"`#[patchable_function_entry(prefix_nops = m, entry_nops = n)]`. If either is "
"left unspecified, it overrides them to a default value of 0. Specifying "
"neither `prefix_nops` nor `entry_nops` is an error, but explicitly setting "
"them both to 0 is allowed."
msgstr ""

#: src/3543-patchable-function-entry.md:88
msgid ""
"As this is specified via an attribute, it will persist across crate "
"boundaries unlike the compiler flag."
msgstr ""

#: src/3543-patchable-function-entry.md:90
msgid ""
"Specifying any amount of padding other than 0 in an attribute will result in "
"an error on backends or architectures which do not support this feature. "
"Some architecture/backend combinations may only support a subset of prefix "
"and entry nop counts, and may generate errors when other counts are "
"requested."
msgstr ""

#: src/3543-patchable-function-entry.md:92
msgid "Optimization Notes"
msgstr ""

#: src/3543-patchable-function-entry.md:94
msgid ""
"Neither `#[patchable]` nor `-C patchable-function-entry` imply any "
"restriction on inlining by themselves. If it is critical that patched code "
"in the `entry` section be executed on _every_ function invocation, not only "
"in an advisory capacity, annotate the relevant functions with "
"`#[inline(never)]` in addition."
msgstr ""

#: src/3543-patchable-function-entry.md:96
msgid "Drawbacks"
msgstr ""

#: src/3543-patchable-function-entry.md:99
msgid ""
"Not currently aware of any other than the complexity that comes from adding "
"anything."
msgstr ""

#: src/3543-patchable-function-entry.md:101
msgid "Rationale and alternatives"
msgstr ""

#: src/3543-patchable-function-entry.md:104
msgid "Implementation Levels"
msgstr ""

#: src/3543-patchable-function-entry.md:105
msgid "Status Quo"
msgstr ""

#: src/3543-patchable-function-entry.md:106
msgid ""
"If we keep to the status quo, we need to go through the Linux kernel making "
"Rust support disable a variety of features which depend on this codegen "
"feature. While I have not taken a complete inventory, this includes "
"debugging features (e.g. `ftrace`) and hardening features (e.g. `FINEIBT`)."
msgstr ""

#: src/3543-patchable-function-entry.md:108
msgid ""
"This alternative runs the risk of the Rust-for-Linux experiment not leaving "
"experiment status, and similar systems with introspection considering Rust "
"unsuitable."
msgstr ""

#: src/3543-patchable-function-entry.md:110
msgid ""
"The primary advantage of this design is that it does not require us to do "
"anything."
msgstr ""

#: src/3543-patchable-function-entry.md:112
msgid "Only compiler flag"
msgstr ""

#: src/3543-patchable-function-entry.md:113
msgid ""
"In this design, we only add the `-C patchable-function-entry` flag and not "
"the attribute. This is enough for today - it would allow Rust to participate "
"in these schemes, and in the event that a user _deeply_ needed an "
"uninstrumented function, they could build it as a separate crate."
msgstr ""

#: src/3543-patchable-function-entry.md:115
msgid "This design has two drawbacks:"
msgstr ""

#: src/3543-patchable-function-entry.md:117
msgid ""
"It requires users to artificially structure their code as a form of "
"annotation."
msgstr ""

#: src/3543-patchable-function-entry.md:118
msgid ""
"The caveats around polymorphic functions using their codegen environment's "
"flags could be tricky or surprising."
msgstr ""

#: src/3543-patchable-function-entry.md:120
msgid ""
"The primary advantage of this design is that it is purely a compiler "
"feature, with no change to the language."
msgstr ""

#: src/3543-patchable-function-entry.md:122
msgid "Compiler flag and no-padding attribute"
msgstr ""

#: src/3543-patchable-function-entry.md:123
msgid ""
"In this design, we add the compiler flag and an attribute that zeroes out "
"padding for a function. This covers all the use cases I see in the Linux "
"kernel today, so the only real downside is missing the opportunity to match "
"`gcc` and `clang`'s capabilities with only a small bit more code."
msgstr ""

#: src/3543-patchable-function-entry.md:125
msgid ""
"Some other project might use explicit padding configuration per-function, "
"but a quick search across github only finds the `patchable_function_entry` "
"attribute set to `(0, 0)` other than in compiler tests."
msgstr ""

#: src/3543-patchable-function-entry.md:127
msgid "Everything (proposed design)"
msgstr ""

#: src/3543-patchable-function-entry.md:128
msgid ""
"The only real downside I see here is the complexity of adding one more thing "
"to the language."
msgstr ""

#: src/3543-patchable-function-entry.md:130
msgid "Argument style"
msgstr ""

#: src/3543-patchable-function-entry.md:132
msgid "There are two basic ways being used today to specify this nop padding:"
msgstr ""

#: src/3543-patchable-function-entry.md:134
msgid ""
"`nop_count`,`offset`, used by the attributes and flags in `gcc` and `clang`."
msgstr ""

#: src/3543-patchable-function-entry.md:135
msgid ""
"`prefix`, `entry`, used by the _LLVM_ attributes after translation from the "
"language level attributes and flags."
msgstr ""

#: src/3543-patchable-function-entry.md:137
msgid ""
"The primary advantage of the first format is that it is used in `gcc` and "
"`clang`. This means that existing documentation will not mislead users and "
"tooling will have an easier time feeding the correct flag to Rust."
msgstr ""

#: src/3543-patchable-function-entry.md:139
msgid ""
"The advantage of the second style is that `prefix` and `entry` don't have "
"validity constraints (`nop_count` must be greater than `offset`) and it's "
"more obvious what the user is asking for."
msgstr ""

#: src/3543-patchable-function-entry.md:141
msgid "Copy `gcc`/`clang` everywhere"
msgstr ""

#: src/3543-patchable-function-entry.md:143
msgid ""
"This approach has the advantage of matching all existing docs and "
"programmers coming over not being confused."
msgstr ""

#: src/3543-patchable-function-entry.md:145
msgid "Use LLVM-style everywhere"
msgstr ""

#: src/3543-patchable-function-entry.md:147
msgid ""
"This format doesn't require validation and is likely easier to understand "
"for users not already exposed to this concept."
msgstr ""

#: src/3543-patchable-function-entry.md:149
msgid "Use `gcc`/`clang` for flags, LLVM-style for arguments (proposed)"
msgstr ""

#: src/3543-patchable-function-entry.md:151
msgid ""
"Build systems tend to interact with our flag interface, and they already "
"have `nop_count,offset` format flags constructed for their C compilers, so "
"this is likely the easiest way for them to interface."
msgstr ""

#: src/3543-patchable-function-entry.md:153
msgid ""
"Users are unlikely to be directly copying code with a manual attribute, and "
"usually are just going to be disabling padding per a github search for the "
"attribute. Setting padding to `(0, 0)` is compatible across both styles, and "
"setting `prefix` and `entry` manually is likely to be more understandable "
"for a new user."
msgstr ""

#: src/3543-patchable-function-entry.md:155
msgid "Use `gcc`/`clang` for flags, Support both styles for arguments"
msgstr ""

#: src/3543-patchable-function-entry.md:157
msgid ""
"Our attribute system is more powerful than `clang` and `gcc`, so we have the "
"option to support:"
msgstr ""

#: src/3543-patchable-function-entry.md:159
msgid "`prefix = n`"
msgstr ""

#: src/3543-patchable-function-entry.md:160
msgid "`entry = n`"
msgstr ""

#: src/3543-patchable-function-entry.md:161
msgid "`nop_count = n`"
msgstr ""

#: src/3543-patchable-function-entry.md:162
msgid "`offset = n`"
msgstr ""

#: src/3543-patchable-function-entry.md:164
msgid ""
"as modifiers to the attribute. We could make `prefix`/`entry` vs `nop_count`/"
"`offset` an exclusive choice, and support both. This would provide the "
"advantage of allowing users copying from or familiar with the other "
"specification system to continue using it. The disadvantages would be more "
"complex attribute parsing and potential confusion for people reading code."
msgstr ""

#: src/3543-patchable-function-entry.md:166
msgid "Support both styles for flags and arguments"
msgstr ""

#: src/3543-patchable-function-entry.md:168
msgid ""
"In addition to supporting `nop_count`/`offset` for attributes, we could "
"support this on the command line as well. This would have two forms:"
msgstr ""

#: src/3543-patchable-function-entry.md:170
msgid ""
"`-C patchable-function-entry=nop_count=m,offset=n` (`nop_count=m`, "
"`offset=n`, modern format, offset optional)"
msgstr ""

#: src/3543-patchable-function-entry.md:171
msgid ""
"`-C patchable-function-entry=prefix=m,entry=n` (`prefix=m`, `entry=n`, "
"modern format, either optional)"
msgstr ""

#: src/3543-patchable-function-entry.md:173
msgid ""
"This would have the benefit of making it more clear what's being specified "
"and allowing users to employ the simpler format on the command line if not "
"integrating with an existing build."
msgstr ""

#: src/3543-patchable-function-entry.md:175
msgid ""
"The primary disadvantage of this is having many ways to say the same thing."
msgstr ""

#: src/3543-patchable-function-entry.md:177
msgid "Use LLVM-style for flags, `gcc`/`clang` for arguments"
msgstr ""

#: src/3543-patchable-function-entry.md:179
msgid "I'm not sure why we would do this."
msgstr ""

#: src/3543-patchable-function-entry.md:181
msgid "Inlining"
msgstr ""

#: src/3543-patchable-function-entry.md:183
msgid ""
"Inlining a function will prevent code in the `entry` patchable section from "
"being executed. This raises the question of whether we should suppress or "
"lint about inlining around this attribute or flag."
msgstr ""

#: src/3543-patchable-function-entry.md:185
msgid ""
"Existing support in `gcc` and `clang` does not suppress inlining at all, but "
"`rustc` makes much heavier use of inlining than they do by default, making "
"it possible that we might want to make a different call."
msgstr ""

#: src/3543-patchable-function-entry.md:187
msgid ""
"Linux's usage of this flag does not consider inlining suppression to be "
"desirable. The two primary usages are:"
msgstr ""

#: src/3543-patchable-function-entry.md:189
msgid ""
"Hardening, where only indirect calls are considered, and so inlining is a "
"non-issue"
msgstr ""

#: src/3543-patchable-function-entry.md:190
msgid ""
"Tracing, where inlined calls are explicitly out of scope, and `noinline` is "
"already explicitly added to C code which should be traced."
msgstr ""

#: src/3543-patchable-function-entry.md:192
msgid ""
"Possible signals we could consider include beyond whether any padding is "
"present:"
msgstr ""

#: src/3543-patchable-function-entry.md:194
msgid ""
"Whether the `entry` padding is nonzero, not considering `prefix` - `prefix` "
"padding would not be executed by a direct call anyways"
msgstr ""

#: src/3543-patchable-function-entry.md:195
msgid "Whether the padding was specified by an attribute or a flag"
msgstr ""

#: src/3543-patchable-function-entry.md:196
msgid "Whether an explicit inlining annotation is present"
msgstr ""

#: src/3543-patchable-function-entry.md:198
msgid "Possible actions we could take include:"
msgstr ""

#: src/3543-patchable-function-entry.md:200
msgid "Nothing"
msgstr ""

#: src/3543-patchable-function-entry.md:201
msgid "Warning/linting"
msgstr ""

#: src/3543-patchable-function-entry.md:202
msgid "Suppress inlining implicitly"
msgstr ""

#: src/3543-patchable-function-entry.md:204
msgid ""
"Since we don't have a way to \"reset\" inlining to default, any plan "
"involving suppression of inlining also needs to come with additional "
"configuration to suppress the suppression."
msgstr ""

#: src/3543-patchable-function-entry.md:206
msgid "Inline suppression"
msgstr ""

#: src/3543-patchable-function-entry.md:207
msgid "If the function has nonzero `entry` padding, prevent inlining."
msgstr ""

#: src/3543-patchable-function-entry.md:209
msgid "Add `-C allow-patchable-function-inlining` to disable this behavior."
msgstr ""

#: src/3543-patchable-function-entry.md:211
msgid ""
"Add `#[patchable(inlinable = yes)]` to suppress inline suppression in the "
"attribute."
msgstr ""

#: src/3543-patchable-function-entry.md:213
msgid ""
"The advantage of this approach is that any instrumentation will always "
"trigger when the function is called."
msgstr ""

#: src/3543-patchable-function-entry.md:215
#: src/3543-patchable-function-entry.md:230
#: src/3543-patchable-function-entry.md:241
msgid "Disadvantages:"
msgstr ""

#: src/3543-patchable-function-entry.md:217
msgid ""
"When the flag is passed, we will disable inlining _nearly everywhere_. This "
"would be disastrous for performance, given the number of functions Rust "
"depends on inlining to optimize."
msgstr ""

#: src/3543-patchable-function-entry.md:218
msgid ""
"This does not match C/C++ behavior, which means most existing use cases will "
"be surprised."
msgstr ""

#: src/3543-patchable-function-entry.md:219
msgid "We need to add flag complexity to match existing use cases."
msgstr ""

#: src/3543-patchable-function-entry.md:221
msgid ""
"We could mitigate a portion of the disadvantages of this approach by only "
"suppressing for the attribute rather than the flag. This would prevent the "
"use of a flag to trace all function invocations."
msgstr ""

#: src/3543-patchable-function-entry.md:223
msgid "Lint on attribute"
msgstr ""

#: src/3543-patchable-function-entry.md:224
msgid ""
"If the function has nonzero `entry` padding specified via attribute, and "
"`#[inline]` is not explicitly set, trigger a lint."
msgstr ""

#: src/3543-patchable-function-entry.md:226
msgid "Use `#[allow]` to accept the inlinability, the same as any other lint."
msgstr ""

#: src/3543-patchable-function-entry.md:228
msgid ""
"The advantage of this approach is that if the attribute is explicitly set, "
"it will surface to the user to think about inlining. By using a lint, we "
"avoid introducing new syntax, allow it to be ignored crate-wide if needed, "
"and avoid user surprise."
msgstr ""

#: src/3543-patchable-function-entry.md:232
msgid ""
"There are no instances of the C/C++ side variants of this attribute in the "
"wild being used with nonzero entry padding, so we don't know if this "
"behavior would actually be unexpected."
msgstr ""

#: src/3543-patchable-function-entry.md:233
#: src/3543-patchable-function-entry.md:243
msgid ""
"There is no way for a user to use load-bearing entry padding on the whole "
"program without annotating every function."
msgstr ""

#: src/3543-patchable-function-entry.md:234
msgid ""
"The user would not be informed when patchability was triggered via a "
"compilation flag."
msgstr ""

#: src/3543-patchable-function-entry.md:236
msgid "Do not suppress inlining (proposed)"
msgstr ""

#: src/3543-patchable-function-entry.md:237
msgid "Take no action on inlining other than mentioning it in the reference."
msgstr ""

#: src/3543-patchable-function-entry.md:239
msgid ""
"This approach mirrors what C/C++ does today. It doesn't close the door on "
"taking the lint approach in the future, but we wouldn't be able to do "
"suppression in the future without reversing the sense of the extra flags."
msgstr ""

#: src/3543-patchable-function-entry.md:244
msgid ""
"Users not familiar with the C/C++ usage of the flag might be surprised when "
"Rust's more aggressive inlining fails to run an `entry` prelude in some "
"scenarios."
msgstr ""

#: src/3543-patchable-function-entry.md:246
msgid "Prior art"
msgstr ""

#: src/3543-patchable-function-entry.md:249
msgid "Linux uses this flag and attribute extensively"
msgstr ""

#: src/3543-patchable-function-entry.md:250
msgid ""
"`clang` [implements the flag](https://clang.llvm.org/docs/"
"ClangCommandLineReference.html#cmdoption-clang-fpatchable-function-entry)"
msgstr ""

#: src/3543-patchable-function-entry.md:251
msgid ""
"`clang` [implements the attribute](https://clang.llvm.org/docs/"
"AttributeReference.html#patchable-function-entry)"
msgstr ""

#: src/3543-patchable-function-entry.md:252
msgid ""
"`gcc` [implements the flag](https://gcc.gnu.org/onlinedocs/gcc/"
"Instrumentation-Options.html#index-fpatchable-function-entry)"
msgstr ""

#: src/3543-patchable-function-entry.md:253
msgid ""
"`gcc` [implements the attribute](https://gcc.gnu.org/onlinedocs/gcc/Common-"
"Function-Attributes.html#index-patchable_005ffunction_005fentry-function-"
"attribute)"
msgstr ""

#: src/3543-patchable-function-entry.md:255
msgid "Unresolved questions"
msgstr ""

#: src/3543-patchable-function-entry.md:258
msgid ""
"Should we use LLVM or `gcc`/`clang` style for a per-function attribute? "
"Should we support both styles?"
msgstr ""

#: src/3543-patchable-function-entry.md:259
msgid "Should we support a more explicit command line argument style?"
msgstr ""

#: src/3543-patchable-function-entry.md:260
msgid ""
"Should we reject linking crates with different default padding "
"configurations?"
msgstr ""

#: src/3543-patchable-function-entry.md:262
msgid "Future possibilities"
msgstr ""

#: src/3543-patchable-function-entry.md:265
msgid ""
"We could potentially use these for dynamic tracing of rust programs, similar "
"to `#[instrument]` in the `tracing` crate today, but with more configurable "
"behavior and even lower overhead (since there will be no conditionals to "
"check, just a nop sled to go down)."
msgstr ""

#: src/3543-patchable-function-entry.md:267
msgid ""
"We could consider adding `#[unpatchable]` as a shorthand for "
"`#[patchable_function_entry(entry_nops = 0, prefix-nops = 0)]`."
msgstr ""

#: src/3543-patchable-function-entry.md:269
msgid ""
"We could define the behavior around differing default patchability in the "
"crate graph more narrowly (either require a hard error, or require that the "
"compiler follows the declaring crate's padding spec)."
msgstr ""
