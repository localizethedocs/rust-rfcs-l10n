msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:03Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1192-inclusive-ranges.md:1
msgid "Feature Name: inclusive_range_syntax"
msgstr ""

#: src/1192-inclusive-ranges.md:2
msgid "Start Date: 2015-07-07"
msgstr ""

#: src/1192-inclusive-ranges.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1192](https://github.com/rust-lang/rfcs/pull/1192)"
msgstr ""

#: src/1192-inclusive-ranges.md:4
msgid ""
"Rust Issue: [rust-lang/rust#28237](https://github.com/rust-lang/rust/"
"issues/28237)"
msgstr ""

#: src/1192-inclusive-ranges.md:6
msgid "Summary"
msgstr "摘要"

#: src/1192-inclusive-ranges.md:8
msgid "Allow a `x...y` expression to create an inclusive range."
msgstr ""

#: src/1192-inclusive-ranges.md:10
msgid "Motivation"
msgstr "動機"

#: src/1192-inclusive-ranges.md:12
msgid ""
"There are several use-cases for inclusive ranges, that semantically include "
"both end-points. For example, iterating from `0_u8` up to and including some "
"number `n` can be done via `for _ in 0..n + 1` at the moment, but this will "
"fail if `n` is `255`. Furthermore, some iterable things only have a "
"successor operation that is sometimes sensible, e.g., `'a'..'{'` is "
"equivalent to the inclusive range `'a'...'z'`: there's absolutely no reason "
"that `{` is after `z` other than a quirk of the representation."
msgstr ""

#: src/1192-inclusive-ranges.md:21
msgid ""
"The `...` syntax mirrors the current `..` used for exclusive ranges: more "
"dots means more elements."
msgstr ""

#: src/1192-inclusive-ranges.md:24
msgid "Detailed design"
msgstr "詳細設計"

#: src/1192-inclusive-ranges.md:26
msgid "`std::ops` defines"
msgstr ""

#: src/1192-inclusive-ranges.md:39
msgid ""
"Writing `a...b` in an expression desugars to `std::ops::RangeInclusive "
"{ start: a, end: b }`. Writing `...b` in an expression desugars to `std::"
"ops::RangeToInclusive { end: b }`."
msgstr ""

#: src/1192-inclusive-ranges.md:43
msgid ""
"`RangeInclusive` implements the standard traits (`Clone`, `Debug` etc.), and "
"implements `Iterator`."
msgstr ""

#: src/1192-inclusive-ranges.md:46
msgid ""
"The use of `...` in a pattern remains as testing for inclusion within that "
"range, _not_ a struct match."
msgstr ""

#: src/1192-inclusive-ranges.md:49
msgid ""
"The author cannot forsee problems with breaking backward compatibility. In "
"particular, one tokenisation of syntax like `1...` now would be `1. ..` i.e. "
"a floating point number on the left, however, fortunately, it is actually "
"tokenised like `1 ...`, and is hence an error with the current compiler."
msgstr ""

#: src/1192-inclusive-ranges.md:55
msgid ""
"This `struct` definition is maximally consistent with the existing `Range`. "
"`a..b` and `a...b` are the same size and have the same fields, just with the "
"expected difference in semantics."
msgstr ""

#: src/1192-inclusive-ranges.md:59
msgid ""
"The range `a...b` contains all `x` where `a <= x && x <= b`.  As such, an "
"inclusive range is non-empty _iff_ `a <= b`.  When the range is iterable, a "
"non-empty range will produce at least one item when iterated.  Because `T::"
"MAX...T::MAX` is a non-empty range, the iteration needs extra handling "
"compared to a half-open `Range`.  As such, `.next()` on an empty range `y..."
"y` will produce the value `y` and adjust the range such that `!(start <= "
"end)`.  Providing such a range is not a burden on the `T` type as any such "
"range is acceptable, and only `PartialOrd` is required so it can be "
"satisfied with an incomparable value `n` with `!(n <= n)`. A caller must "
"not, in general, expect any particular `start` or `end` after iterating, and "
"is encouraged to detect empty ranges with `ExactSizeIterator::is_empty` "
"instead of by observing fields directly."
msgstr ""

#: src/1192-inclusive-ranges.md:72
msgid ""
"Note that because ranges are not required to be well-formed, they have a "
"much stronger bound than just needing successor function: they require a `b "
"is-reachable-from a` predicate (as `a <= b`). Providing that efficiently for "
"a DAG walk, or even a simpler forward list walk, is a substantially harder "
"thing to do than providing a pair `(x, y)` such that `!(x <= y)`."
msgstr ""

#: src/1192-inclusive-ranges.md:78
msgid ""
"Implementation note: For currently-iterable types, the initial "
"implementation of this will have the range become `1...0` after yielding the "
"final value, as that can be done using the `replace_one` and `replace_zero` "
"methods on the existing (but unstable) [`Step` trait](https://github.com/"
"rust-lang/rust/issues/27741).  It's expected, however, that the trait will "
"change to allow more type-appropriate `impl`s. For example, a `num::BigInt` "
"may rather become empty by incrementing `start`, as `Range` does, since it "
"doesn't to need to worry about overflow.  Even for primitives, it could be "
"advantageous to choose a different implementation, perhaps using `."
"overflowing_add(1)` and swapping on overflow, or `a...a` could become "
"`(a+1)...a` where possible and `a...(a-1)` otherwise."
msgstr ""

#: src/1192-inclusive-ranges.md:91
msgid "Drawbacks"
msgstr ""

#: src/1192-inclusive-ranges.md:93
msgid ""
"There's a mismatch between pattern-`...` and expression-`...`, in that the "
"former doesn't undergo the same desugaring as the latter. (Although they "
"represent essentially the same thing semantically.)"
msgstr ""

#: src/1192-inclusive-ranges.md:98
msgid "The `...` vs. `..` distinction is the exact inversion of Ruby's syntax."
msgstr ""

#: src/1192-inclusive-ranges.md:100
msgid ""
"This proposal makes the post-iteration values of the `start` and `end` "
"fields constant, and thus useless.  Some of the alternatives would expose "
"the last value returned from the iteration, through a more complex interface."
msgstr ""

#: src/1192-inclusive-ranges.md:104
msgid "Alternatives"
msgstr "替代方案"

#: src/1192-inclusive-ranges.md:106
msgid ""
"An alternate syntax could be used, like `..=`. [There has been discussion]"
"(https://internals.rust-lang.org/t/vs-for-inclusive-ranges/1539), but there "
"wasn't a clear winner."
msgstr ""

#: src/1192-inclusive-ranges.md:112
msgid ""
"This RFC proposes single-ended syntax with only an end, `...b`, but not with "
"only a start (`a...`) or unconstrained `...`. This balance could be "
"reevaluated for usefulness and conflicts with other proposed syntax."
msgstr ""

#: src/1192-inclusive-ranges.md:116
msgid ""
"`RangeInclusive` could be a struct including a `finished` field. This makes "
"it easier for the struct to always be iterable, as the extra field is set "
"once the ends match.  But having the extra field in a language-level "
"desugaring, catering to one library use-case is a little non-\"hygienic\". "
"It is especially strange that the field isn't consistent across the "
"different `...` desugarings.  And the presence of the public field "
"encourages checkinging it, which can be misleading as `r.finished == false` "
"does not guarantee that `r.count() > 0`."
msgstr ""

#: src/1192-inclusive-ranges.md:124
msgid ""
"`RangeInclusive` could be an enum with `Empty` and `NonEmpty` variants. This "
"is cleaner than the `finished` field, but still has the problem that there's "
"no invariant maintained: while an `Empty` range is definitely empty, a "
"`NonEmpty` range might actually be empty.  And requiring matching on every "
"use of the type is less ergonomic.  For example, the clamp RFC would "
"naturally use a `RangeInclusive` parameter, but because it still needs to "
"`assert!(start <= end)` in the `NonEmpty` arm, the noise of the `Empty` vs "
"`NonEmpty` match provides it no value."
msgstr ""

#: src/1192-inclusive-ranges.md:132
msgid ""
"`a...b` only implements `IntoIterator`, not `Iterator`, by converting to a "
"different type that does have the field. However, this means that `a.. .b` "
"behaves differently to `a..b`, so `(a...b).map(|x| ...)` doesn't work (the "
"`..` version of that is used reasonably often, in the author's experience)"
msgstr ""

#: src/1192-inclusive-ranges.md:137
msgid ""
"The name of the `end` field could be different, perhaps `last`, to reflect "
"its different (inclusive) semantics from the `end` (exclusive) field on the "
"other ranges."
msgstr ""

#: src/1192-inclusive-ranges.md:141
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/1192-inclusive-ranges.md:143
msgid "None so far."
msgstr ""

#: src/1192-inclusive-ranges.md:145
msgid "Amendments"
msgstr ""

#: src/1192-inclusive-ranges.md:147
msgid ""
"In rust-lang/rfcs#1320, this RFC was amended to change the `RangeInclusive` "
"type from a struct with a `finished` field to an enum."
msgstr ""

#: src/1192-inclusive-ranges.md:149
msgid ""
"In rust-lang/rfcs#1980, this RFC was amended to change the `RangeInclusive` "
"type from an enum to a struct with just `start` and `end` fields."
msgstr ""
