msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0439-cmp-ops-reform.md:1
msgid "Start Date: 2014-11-03"
msgstr ""

#: src/0439-cmp-ops-reform.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#439](https://github.com/rust-lang/rfcs/pull/439)"
msgstr ""

#: src/0439-cmp-ops-reform.md:3
msgid ""
"Rust Issue: [rust-lang/rfcs#19148](https://github.com/rust-lang/rust/"
"issues/19148)"
msgstr ""

#: src/0439-cmp-ops-reform.md:5
msgid "Summary"
msgstr "摘要"

#: src/0439-cmp-ops-reform.md:7
msgid ""
"This RFC proposes a number of design improvements to the `cmp` and `ops` "
"modules in preparation for 1.0. The impetus for these improvements, besides "
"the need for stabilization, is that we've added several important language "
"features (like multidispatch) that greatly impact the design. Highlights:"
msgstr ""

#: src/0439-cmp-ops-reform.md:13
msgid ""
"Make basic unary and binary operators work by value and use associated types."
msgstr ""

#: src/0439-cmp-ops-reform.md:14
msgid ""
"Generalize comparison operators to work across different types; drop `Equiv`."
msgstr ""

#: src/0439-cmp-ops-reform.md:15
msgid ""
"Refactor slice notation in favor of _range notation_ so that special traits "
"are no longer needed."
msgstr ""

#: src/0439-cmp-ops-reform.md:17
msgid "Add `IndexSet` to better support maps."
msgstr ""

#: src/0439-cmp-ops-reform.md:18
msgid "Clarify ownership semantics throughout."
msgstr ""

#: src/0439-cmp-ops-reform.md:20
msgid "Motivation"
msgstr "動機"

#: src/0439-cmp-ops-reform.md:22
msgid ""
"The operator and comparison traits play a double role: they are lang items "
"known to the compiler, but are also library APIs that need to be stabilized."
msgstr ""

#: src/0439-cmp-ops-reform.md:26
msgid ""
"While the traits have been fairly stable, a lot has changed in the language "
"recently, including the addition of multidispatch, associated types, and "
"changes to method resolution (especially around smart pointers). These are "
"all things that impact the ideal design of the traits."
msgstr ""

#: src/0439-cmp-ops-reform.md:31
msgid ""
"Since it is now relatively clear how these language features will work at "
"1.0, there is enough information to make final decisions about the "
"construction of the comparison and operator traits. That's what this RFC "
"aims to do."
msgstr ""

#: src/0439-cmp-ops-reform.md:36
msgid "Detailed design"
msgstr "詳細設計"

#: src/0439-cmp-ops-reform.md:38
msgid ""
"The traits in `cmp` and `ops` can be broken down into several categories, "
"and to keep things manageable this RFC discusses each category separately:"
msgstr ""

#: src/0439-cmp-ops-reform.md:42
msgid "Basic operators:"
msgstr ""

#: src/0439-cmp-ops-reform.md:43
msgid "Unary: `Neg`, `Not`"
msgstr ""

#: src/0439-cmp-ops-reform.md:44
msgid ""
"Binary: `Add`, `Sub`, `Mul`, `Div`, `Rem`, `Shl`, `Shr`, `BitAnd`, `BitOr`, "
"`BitXor`,"
msgstr ""

#: src/0439-cmp-ops-reform.md:45
msgid "Comparison: `PartialEq`, `PartialOrd`, `Eq`, `Ord`, `Equiv`"
msgstr ""

#: src/0439-cmp-ops-reform.md:46
msgid "Indexing and slicing: `Index`, `IndexMut`, `Slice`, `SliceMut`"
msgstr ""

#: src/0439-cmp-ops-reform.md:47
msgid "Special traits: `Deref`, `DerefMut`, `Drop`, `Fn`, `FnMut`, `FnOnce`"
msgstr ""

#: src/0439-cmp-ops-reform.md:49
msgid "Basic operators"
msgstr ""

#: src/0439-cmp-ops-reform.md:51
msgid ""
"The basic operators include arithmetic and bitwise notation with both unary "
"and binary operators."
msgstr ""

#: src/0439-cmp-ops-reform.md:54 src/0439-cmp-ops-reform.md:151
msgid "Current design"
msgstr ""

#: src/0439-cmp-ops-reform.md:56
msgid ""
"Here are two example traits, one unary and one binary, for basic operators:"
msgstr ""

#: src/0439-cmp-ops-reform.md:68
msgid ""
"The rest of the operators follow the same pattern. Note that `self` and "
"`rhs` are taken by reference, and the compiler introduce _silent_ uses of "
"`&` for the operands."
msgstr ""

#: src/0439-cmp-ops-reform.md:72
msgid ""
"The traits also take `Result` as an [_input_](https://github.com/rust-lang/"
"rfcs/pull/195) type."
msgstr ""

#: src/0439-cmp-ops-reform.md:75 src/0439-cmp-ops-reform.md:196
#: src/0439-cmp-ops-reform.md:279
msgid "Proposed design"
msgstr ""

#: src/0439-cmp-ops-reform.md:77
msgid ""
"This RFC proposes to make `Result` an associated (output) type, and to make "
"the traits work by value:"
msgstr ""

#: src/0439-cmp-ops-reform.md:92
msgid ""
"The reason to make `Result` an associated type is straightforward: it should "
"be uniquely determined given `Self` and other input types, and making it an "
"associated type is better for both type inference and for keeping things "
"concise when using these traits in bounds."
msgstr ""

#: src/0439-cmp-ops-reform.md:97
msgid ""
"Making these traits work by value is motivated by cases like `DList` "
"concatenation, where you may want the operator to actually consume the "
"operands in producing its output (by welding the two lists together)."
msgstr ""

#: src/0439-cmp-ops-reform.md:101
msgid ""
"It also means that the compiler does not have to introduce a silent `&` for "
"the operands, which means that the ownership semantics when using these "
"operators is much more clear."
msgstr ""

#: src/0439-cmp-ops-reform.md:105
msgid ""
"Fortunately, there is no loss in expressiveness, since you can always "
"implement the trait on reference types. However, for types that _do_ need to "
"be taken by reference, there is a slight loss in ergonomics since you may "
"need to explicitly borrow the operands with `&`. The upside is that the "
"ownership semantics become clearer: they more closely resemble normal "
"function arguments."
msgstr ""

#: src/0439-cmp-ops-reform.md:112
msgid ""
"By keeping `Rhs` as an input trait on the trait, you can overload on the "
"types of both operands via [multidispatch](https://github.com/rust-lang/rfcs/"
"pull/195).  By defaulting `Rhs` to `Self`, in [the future](https://github."
"com/rust-lang/rfcs/pull/213) it will be possible to simply say `T: Add` as "
"shorthand for `T: Add<T>`, which is the common case."
msgstr ""

#: src/0439-cmp-ops-reform.md:120
msgid "Examples:"
msgstr ""

#: src/0439-cmp-ops-reform.md:123
msgid "// Basic setup for Copy types:\n"
msgstr ""

#: src/0439-cmp-ops-reform.md:128
msgid "// Overloading on the Rhs:\n"
msgstr ""

#: src/0439-cmp-ops-reform.md:139
msgid "// Recovering by-ref semantics:\n"
msgstr ""

#: src/0439-cmp-ops-reform.md:147 src/0439-cmp-ops-reform.md:449
msgid "Comparison traits"
msgstr ""

#: src/0439-cmp-ops-reform.md:149
msgid ""
"The comparison traits provide overloads for operators like `==` and `>`."
msgstr ""

#: src/0439-cmp-ops-reform.md:153
msgid ""
"Comparisons are subtle, because some types (notably `f32` and `f64`) do not "
"actually provide full equivalence relations or total orderings. The current "
"design therefore splits the comparison traits into \"partial\" variants that "
"do not promise full equivalence relations/ordering, and \"total\" variants "
"which inherit from them but make stronger semantic guarantees. The floating "
"point types implement the partial variants, and the operators defer to them. "
"But certain collection types require e.g. total rather than partial "
"orderings:"
msgstr ""

#: src/0439-cmp-ops-reform.md:188
msgid ""
"In addition there is an `Equiv` trait that can be used to compare values of "
"_different_ types for equality, but does not correspond to any operator "
"sugar. (It was introduced in part to help solve some problems in map APIs, "
"which are now resolved in a different way.)"
msgstr ""

#: src/0439-cmp-ops-reform.md:193
msgid ""
"The comparison traits all work by reference, and the compiler inserts "
"implicit uses of `&` to make this ergonomic."
msgstr ""

#: src/0439-cmp-ops-reform.md:198
msgid ""
"This RFC proposes to follow largely the same design strategy, but to remove "
"`Equiv` and instead generalize the traits via multidispatch:"
msgstr ""

#: src/0439-cmp-ops-reform.md:223
msgid ""
"Due to the use of defaulting, this generalization loses no ergonomics. "
"However, it makes it _possible_ to overload notation like `==` to compare "
"different types without needing an explicit conversion. (Precisely _which_ "
"overloadings we provide in `std` will be subject to API stabilization.) This "
"more general design will allow us to eliminate the `iter::order` submodule "
"in favor of comparison notation, for example."
msgstr ""

#: src/0439-cmp-ops-reform.md:231
msgid ""
"This design suffers from the problem that it is somewhat painful to "
"implement or derive `Eq`/`Ord`, which is the common case. We can likely "
"improve e.g. `#[deriving(Ord)]` to automatically derive `PartialOrd`. See "
"Alternatives for a more radical design (and the reasons that it's not "
"feasible right now.)"
msgstr ""

#: src/0439-cmp-ops-reform.md:237
msgid "Indexing and slicing"
msgstr ""

#: src/0439-cmp-ops-reform.md:239
msgid ""
"There are a few traits that support `[]` notation for indexing and slicing."
msgstr ""

#: src/0439-cmp-ops-reform.md:241
msgid "Current design:"
msgstr ""

#: src/0439-cmp-ops-reform.md:243
msgid "The current design is as follows:"
msgstr ""

#: src/0439-cmp-ops-reform.md:260
msgid "// and similar for SliceMut...\n"
msgstr ""

#: src/0439-cmp-ops-reform.md:264
msgid ""
"The index and slice traits work somewhat differently. For `Index`/"
"`IndexMut`, the return value is _implicitly_ dereferenced, so that notation "
"like `v[i] = 3` makes sense. If you want to get your hands on the actual "
"reference, you usually need an explicit `&`, for example `&v[i]` or `&mut "
"v[i]` (the compiler determines whether to use `Index` or `IndexMut` by "
"context). This follows the C notational tradition."
msgstr ""

#: src/0439-cmp-ops-reform.md:272
msgid ""
"Slice notation, on the other hand, does _not_ automatically dereference and "
"so requires a special `mut` marker: `v[mut 1..]`."
msgstr ""

#: src/0439-cmp-ops-reform.md:275
msgid ""
"For both of these traits, the indexes themselves are taken by reference, and "
"the compiler automatically introduces a `&` (so you write `v[3]` not "
"`v[&3]`)."
msgstr ""

#: src/0439-cmp-ops-reform.md:281
msgid ""
"This RFC proposes to refactor the slice design into more modular components, "
"which as a side-product will make slicing automatically dereference the "
"result (consistently with indexing). The latter is desirable because `&mut "
"v[1..]` is more consistent with the rest of the language than `v[mut 1..]` "
"(and also makes the borrowing semantics more explicit)."
msgstr ""

#: src/0439-cmp-ops-reform.md:288
msgid "Index revisions"
msgstr ""

#: src/0439-cmp-ops-reform.md:290
msgid ""
"In the new design, the index traits take the index by value and the compiler "
"no longer introduces a silent `&`. This follows the same design as for e.g. "
"`Add` above, and for much the same reasons. That means in particular that it "
"will be possible to write `map[\"key\"]` rather than `map[*\"key\"]` when "
"using a map with `String` keys, and will still be possible to write `v[3]` "
"for vectors. In addition, the `Result` becomes an associated type, again "
"following the same design outlined above:"
msgstr ""

#: src/0439-cmp-ops-reform.md:311
msgid ""
"In addition, this RFC proposes another trait, `IndexSet`, that is used for "
"`expr[i] = expr`:"
msgstr ""

#: src/0439-cmp-ops-reform.md:320
msgid ""
"(This idea is borrowed from [@sfackler's earlier RFC](https://github.com/"
"rust-lang/rfcs/pull/159/files).)"
msgstr ""

#: src/0439-cmp-ops-reform.md:323
msgid ""
"The motivation for this trait is cases like `map[\"key\"] = val`, which "
"should correspond to an _insertion_ rather than a mutable lookup. With "
"today's setup, that expression would result in a panic if \"key\" was not "
"already present in the map."
msgstr ""

#: src/0439-cmp-ops-reform.md:328
msgid ""
"Of course, `IndexSet` and `IndexMut` overlap, since `expr[i] = expr` could "
"be interpreted using either. Some types may implement `IndexSet` but not "
"`IndexMut` (for example, if it doesn't make sense to produce an interior "
"reference). But for types providing both, the compiler will use `IndexSet` "
"to interpret the `expr[i] = expr` syntax. (You can always get `IndexMut` by "
"instead writing `* &mut expr[i] = expr`, but this will likely be extremely "
"rare.)"
msgstr ""

#: src/0439-cmp-ops-reform.md:336
msgid "Slice revisions"
msgstr ""

#: src/0439-cmp-ops-reform.md:338
msgid ""
"The changes to slice notation are more radical: this RFC proposes to remove "
"the slice traits altogether! The replacement is to introduce _range "
"notation_ and overload indexing on it."
msgstr ""

#: src/0439-cmp-ops-reform.md:342
msgid ""
"The current slice notation allows you to write `v[i..j]`, `v[i..]`, `v[..j]` "
"and `v[]`. The idea for handling the first three is to add the following "
"desugaring:"
msgstr ""

#: src/0439-cmp-ops-reform.md:358
msgid ""
"Then, to implement slice notation, you just implement `Index`/`IndexMut` "
"with `Range`, `RangeFrom`, and `RangeTo` index types."
msgstr ""

#: src/0439-cmp-ops-reform.md:361
msgid ""
"This cuts down on the number of special traits and machinery. It makes "
"indexing and slicing more consistent (since both will implicitly deref their "
"result); you'll write `&mut v[1..]` to get a mutable slice. It also opens "
"the door to other uses of the range notation:"
msgstr ""

#: src/0439-cmp-ops-reform.md:370
msgid "because the refactored design is more modular."
msgstr ""

#: src/0439-cmp-ops-reform.md:372
msgid ""
"What about `v[]` notation? The proposal is to desugar this to `v[FullRange]` "
"where `struct FullRange;`."
msgstr ""

#: src/0439-cmp-ops-reform.md:375
msgid ""
"Note that `..` is already used in a few places in the grammar, notably fixed "
"length arrays and functional record update. The former is at the type level, "
"however, and the latter is not ambiguous: `Foo { a: x, .. bar}` since the "
"`.. bar` component will never be parsed as an expression."
msgstr ""

#: src/0439-cmp-ops-reform.md:381
msgid "Special traits"
msgstr ""

#: src/0439-cmp-ops-reform.md:383
msgid ""
"Finally, there are a few \"special\" traits that hook into the compiler in "
"various ways that go beyond basic operator overlaoding."
msgstr ""

#: src/0439-cmp-ops-reform.md:386
msgid "`Deref` and `DerefMut`"
msgstr ""

#: src/0439-cmp-ops-reform.md:388
msgid ""
"The `Deref` and `DerefMut` traits are used for overloading dereferencing, "
"typically for smart pointers."
msgstr ""

#: src/0439-cmp-ops-reform.md:391
msgid "The current traits look like so:"
msgstr ""

#: src/0439-cmp-ops-reform.md:399
msgid ""
"but the `Result` type should become an associated type, dictating that a "
"smart pointer can only deref to a single other type (which is also needed "
"for inference and other magic around deref):"
msgstr ""

#: src/0439-cmp-ops-reform.md:410
msgid "`Drop`"
msgstr ""

#: src/0439-cmp-ops-reform.md:412
msgid "This RFC proposes no changes to the `Drop` trait."
msgstr ""

#: src/0439-cmp-ops-reform.md:414
msgid "Closure traits"
msgstr ""

#: src/0439-cmp-ops-reform.md:416
msgid ""
"This RFC proposes no changes to the closure traits. The current design looks "
"like:"
msgstr ""

#: src/0439-cmp-ops-reform.md:424
msgid ""
"and, given the way that multidispatch has worked out, it is safe and more "
"flexible to keep both `Args` and `Result` as input types (which means that "
"custom implementations could overload on either). In particular, the sugar "
"for these traits requires writing all of these types anyway."
msgstr ""

#: src/0439-cmp-ops-reform.md:430
msgid ""
"These traits should _not_ be exposed as `#[stable]` for 1.0, meaning that "
"you will not be able to implement or use them directly from the [stable "
"release channel](http://blog.rust-lang.org/2014/10/30/Stability.html). There "
"are a few reasons for this. For one, when bounding by these traits you "
"generally want to use the sugar `Fn (T, U) -> V` instead, which will be "
"stable. Keeping the traits themselves unstable leaves us room to change "
"their definition to support [variadic generics](https://github.com/rust-lang/"
"rfcs/issues/376) in the future."
msgstr ""

#: src/0439-cmp-ops-reform.md:440
msgid "Drawbacks"
msgstr ""

#: src/0439-cmp-ops-reform.md:442
msgid ""
"The main drawback is that implementing the above will take a bit of time, "
"which is something we're currently very short on. However, stabilizing `cmp` "
"and `ops` has always been part of the plan, and has to be done for 1.0."
msgstr ""

#: src/0439-cmp-ops-reform.md:447
msgid "Alternatives"
msgstr ""

#: src/0439-cmp-ops-reform.md:451
msgid ""
"We could pursue a more aggressive change to the comparison traits by not "
"having `PartialOrd` be a super trait of `Ord`, but instead providing a "
"blanket `impl` for `PartialOrd` for any `T: Ord`. Unfortunately, this design "
"poses some problems when it comes to things like tuples, which want to "
"provide `PartialOrd` and `Ord` if all their components do: you would end up "
"with overlapping `PartialOrd` `impl`s. It's possible to work around this, "
"but at the expense of additional language features (like \"negative "
"bounds\", the ability to make an `impl` apply only when certain things are "
"_not_ true)."
msgstr ""

#: src/0439-cmp-ops-reform.md:462
msgid ""
"Since it's unlikely that these other changes can happen in time for 1.0, "
"this RFC takes a more conservative approach."
msgstr ""

#: src/0439-cmp-ops-reform.md:465
msgid "Slicing"
msgstr ""

#: src/0439-cmp-ops-reform.md:467
msgid ""
"We may want to drop the `[]` notation. This notation was introduced to "
"improve ergonomics (from `foo(v.as_slice())` to `foo(v[]`), but now that "
"[collections reform](https://github.com/rust-lang/rfcs/pull/235) is starting "
"to land we can instead write `foo(&*v)`. If we also had [deref coercions]"
"(https://github.com/rust-lang/rfcs/pull/241), that would be just `foo(&v)`."
msgstr ""

#: src/0439-cmp-ops-reform.md:474
msgid ""
"While `&*v` notation is more ergonomic than `v.as_slice()`, it is also "
"somewhat intimidating notation for a situation that newcomers to the "
"language are likely to face quickly."
msgstr ""

#: src/0439-cmp-ops-reform.md:478
msgid ""
"In the opinion of this RFC author, we should either keep `[]` notation, or "
"provide deref coercions so that you can just say `&v`."
msgstr ""

#: src/0439-cmp-ops-reform.md:481
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/0439-cmp-ops-reform.md:483
msgid ""
"In the long run, we should support overloading of operators like `+=` which "
"often have a more efficient implementation than desugaring into a `+` and an "
"`=`. However, this can be added backwards-compatibly and is not "
"significantly blocking library stabilization, so this RFC postpones "
"consideration until a later date."
msgstr ""
