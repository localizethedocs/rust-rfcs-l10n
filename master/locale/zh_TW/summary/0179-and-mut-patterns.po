msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0179-and-mut-patterns.md:1
msgid "Start Date: 23-07-2014"
msgstr ""

#: src/0179-and-mut-patterns.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#179](https://github.com/rust-lang/rfcs/pull/179)"
msgstr ""

#: src/0179-and-mut-patterns.md:3
msgid ""
"Rust Issue: [rust-lang/rust#20496](https://github.com/rust-lang/rust/"
"issues/20496)"
msgstr ""

#: src/0179-and-mut-patterns.md:5
msgid "Summary"
msgstr "摘要"

#: src/0179-and-mut-patterns.md:7
msgid ""
"Change pattern matching on an `&mut T` to `&mut <pat>`, away from its "
"current `&<pat>` syntax."
msgstr ""

#: src/0179-and-mut-patterns.md:10
msgid "Motivation"
msgstr "動機"

#: src/0179-and-mut-patterns.md:12
msgid ""
"Pattern matching mirrors construction for almost all types, _except_ `&mut`, "
"which is constructed with `&mut <expr>` but destructured with `&<pat>`. This "
"is almost certainly an unnecessary inconsistency."
msgstr ""

#: src/0179-and-mut-patterns.md:16
msgid ""
"This can and does lead to confusion, since people expect the pattern syntax "
"to match construction, but a pattern like `&mut (ref mut x, _)` is actually "
"currently a parse error:"
msgstr ""

#: src/0179-and-mut-patterns.md:33
msgid ""
"Another (rarer) way it can be confusing is the pattern `&mut x`. It is "
"expected that this binds `x` to the contents of `&mut T` pointer... which it "
"does, but as a mutable binding (it is parsed as `&(mut x)`), meaning "
"something like"
msgstr ""

#: src/0179-and-mut-patterns.md:40
msgid "\"{}\""
msgstr ""

#: src/0179-and-mut-patterns.md:44
msgid ""
"gives an unused mutability warning. NB. it's somewhat rare that one would "
"want to pattern match to directly bind a name to the contents of a `&mut` "
"(since the normal reason to have a `&mut` is to mutate the thing it points "
"at, but this pattern is (byte) copying the data out, both before and after "
"this change), but can occur if a type only offers a `&mut` iterator, i.e. "
"types for which a `&` one is no more flexible than the `&mut` one."
msgstr ""

#: src/0179-and-mut-patterns.md:52
msgid "Detailed design"
msgstr "詳細設計"

#: src/0179-and-mut-patterns.md:54
msgid ""
"Add `<pat> := &mut <pat>` to the pattern grammar, and require that it is "
"used when matching on a `&mut T`."
msgstr ""

#: src/0179-and-mut-patterns.md:57
msgid "Drawbacks"
msgstr ""

#: src/0179-and-mut-patterns.md:59
msgid ""
"It makes matching through a `&mut` more verbose: `for &mut (ref mut x, p_) "
"in v.mut_iter()` instead of `for &(ref mut x, _) in v.mut_iter()`."
msgstr ""

#: src/0179-and-mut-patterns.md:63
msgid ""
"Macros wishing to pattern match on either `&` or `&mut` need to handle each "
"case, rather than performing both with a single `&`. However, macros "
"handling these types already need special `mut` vs. not handling if they "
"ever name the types, or if they use `ref` vs. `ref mut` subpatterns."
msgstr ""

#: src/0179-and-mut-patterns.md:69
msgid ""
"It also makes obtaining the current behaviour (binding by-value the contents "
"of a reference to a mutable local) slightly harder. For a `&mut T` the "
"pattern becomes `&mut mut x`, and, at the moment, for a `&T`, it must be "
"matched with `&x` and then rebound with `let mut x = x;` (since "
"disambiguating like `&(mut x)` doesn't yet work). However, based on some "
"loose grepping of the Rust repo, both of these are very rare."
msgstr ""

#: src/0179-and-mut-patterns.md:77
msgid "Alternatives"
msgstr ""

#: src/0179-and-mut-patterns.md:79 src/0179-and-mut-patterns.md:83
msgid "None."
msgstr ""

#: src/0179-and-mut-patterns.md:81
msgid "Unresolved questions"
msgstr "未解決的問題"
