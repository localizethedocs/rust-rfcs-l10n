msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:06Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/3617-precise-capturing.md:1
msgid "Feature Name: `precise_capturing`"
msgstr ""

#: src/3617-precise-capturing.md:2
msgid "Start Date: 2024-04-03"
msgstr ""

#: src/3617-precise-capturing.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#3617](https://github.com/rust-lang/rfcs/pull/3617)"
msgstr ""

#: src/3617-precise-capturing.md:4
msgid ""
"Tracking Issue: [rust-lang/rust#123432](https://github.com/rust-lang/rust/"
"issues/123432)"
msgstr ""

#: src/3617-precise-capturing.md:6
msgid "Summary"
msgstr ""

#: src/3617-precise-capturing.md:9
msgid ""
"This RFC adds `use<..>` syntax for specifying which generic parameters "
"should be captured in an opaque RPIT-like `impl Trait` type, e.g. `impl "
"use<'t, T> Trait`.  This solves the problem of overcapturing and will allow "
"the Lifetime Capture Rules 2024 to be fully stabilized for RPIT in Rust 2024."
msgstr ""

#: src/3617-precise-capturing.md:11
msgid "Motivation"
msgstr ""

#: src/3617-precise-capturing.md:14
msgid "Background"
msgstr ""

#: src/3617-precise-capturing.md:16
msgid ""
"RPIT-like opaque `impl Trait` types in Rust _capture_ certain generic "
"parameters."
msgstr ""

#: src/3617-precise-capturing.md:18
msgid ""
"_Capturing_ a generic parameter means that parameter can be used in the "
"hidden type later registered for that opaque type.  Any generic parameters "
"not captured cannot be used."
msgstr ""

#: src/3617-precise-capturing.md:20
msgid ""
"However, captured generic parameters that are _not_ used by the hidden type "
"still affect borrow checking.  This leads to the phenomenon of "
"_overcapturing_.  Consider:"
msgstr ""

#: src/3617-precise-capturing.md:23
msgid ""
"//                 ^^^^^^^^^^\n"
"//                 ^ The returned opaque type captures `T`\n"
"//                   but the hidden type does not.\n"
msgstr ""

#: src/3617-precise-capturing.md:29 src/3617-precise-capturing.md:729
msgid ""
"//~^ ERROR returns a value referencing data owned by the\n"
"//~|       current function\n"
msgstr ""

#: src/3617-precise-capturing.md:35
msgid ""
"In this example, we would say that `foo` _overcaptures_ the type parameter "
"`T`.  The hidden type returned by `foo` does not _use_ `T`, however it (and "
"any lifetime components it contains) are part of the returned opaque type.  "
"This leads to the error we see above."
msgstr ""

#: src/3617-precise-capturing.md:37
msgid ""
"Overcapturing limits how callers can use returned opaque types in ways that "
"are often surprising and frustrating.  There's no good way to work around "
"this in Rust today."
msgstr ""

#: src/3617-precise-capturing.md:39
msgid "Lifetime Capture Rules 2024"
msgstr ""

#: src/3617-precise-capturing.md:41
msgid ""
"All type parameters in scope are implicitly captured in RPIT-like `impl "
"Trait` opaque types.  In Rust 2021 and earlier editions, for RPIT on bare "
"functions and on inherent functions and methods, lifetime parameters are not "
"implicitly captured unless named in the bounds of the opaque.  This "
"resulted, among other things, in the use of \"the `Captures` trick\".  See "
"[RFC 3498](https://github.com/rust-lang/rfcs/blob/master/text/3498-lifetime-"
"capture-rules-2024.md) for more details about this."
msgstr ""

#: src/3617-precise-capturing.md:43
msgid ""
"In RFC 3498, we decided to capture all in-scope generic parameters in RPIT-"
"like `impl Trait` opaque types, across all editions, for new features we "
"were stabilizing such as return position `impl Trait` in Trait (RPITIT) and "
"associated type position `impl Trait` (ATPIT), and to capture all in-scope "
"generic parameters for RPIT on bare functions and on inherent functions and "
"methods starting in the Rust 2024 edition.  Doing this made the language "
"more predictable and consistent, eliminated weird \"tricks\", and, by "
"solving key problems, allowed for the stabilization of RPITIT."
msgstr ""

#: src/3617-precise-capturing.md:45
msgid ""
"However, the expansion of the RPIT capture rules in Rust 2024 means that "
"some existing uses of RPIT, when migrated to Rust 2024, will now capture "
"lifetime parameters that were not previously captured, and this may result "
"in code failing to compile.  For example, consider:"
msgstr ""

#: src/3617-precise-capturing.md:48 src/3617-precise-capturing.md:504
#: src/3617-precise-capturing.md:633 src/3617-precise-capturing.md:647
msgid "//@ edition: 2021\n"
msgstr ""

#: src/3617-precise-capturing.md:56
msgid ""
"Under the Rust 2021 rules, this code is accepted because `'t` is not "
"implicitly captured in the returned opaque type.  When migrated to Rust "
"2024, the `'t` lifetime will be captured, and so this will fail to compile "
"just as with the similar earlier example that had overcaptured a type "
"parameter."
msgstr ""

#: src/3617-precise-capturing.md:58
msgid "We need some way to migrate this kind of code."
msgstr ""

#: src/3617-precise-capturing.md:62
msgid "Guide-level explanation"
msgstr ""

#: src/3617-precise-capturing.md:65
msgid ""
"In all editions, RPIT-like `impl Trait` opaque types may include `use<..>` "
"before any bounds to specify which in-scope generic parameters are captured "
"or that no in-scope generic parameters are captured (with `use<>`).  If "
"`use<..>` is provided, it entirely overrides the implicit rules for which "
"generic parameters are captured."
msgstr ""

#: src/3617-precise-capturing.md:67
msgid ""
"One way to think about `use<..>` is that, in Rust, `use` brings things _into "
"scope_, and here we are bringing certain generic parameters into scope for "
"the hidden type."
msgstr ""

#: src/3617-precise-capturing.md:69
msgid ""
"For example, we can solve the overcapturing in the original motivating "
"example by writing:"
msgstr ""

#: src/3617-precise-capturing.md:72
msgid ""
"//                 ^^^^^^^^^^^^^^^^\n"
"//                 ^ Captures nothing.\n"
msgstr ""

#: src/3617-precise-capturing.md:77
msgid ""
"Similarly, we can use this to avoid overcapturing a lifetime parameter so as "
"to migrate code to Rust 2024:;"
msgstr ""

#: src/3617-precise-capturing.md:80 src/3617-precise-capturing.md:623
msgid ""
"//                       ^^^^^^^^^^^^^^^^\n"
"//                       ^ Captures nothing.\n"
msgstr ""

#: src/3617-precise-capturing.md:85
msgid "We can use this to capture some generic parameters but not others:"
msgstr ""

#: src/3617-precise-capturing.md:88
msgid ""
"//                                         ^^^^^^^^^^^^^^^^^\n"
"//                                         ^ Captures `U` only.\n"
msgstr ""

#: src/3617-precise-capturing.md:93
msgid "Generic const parameters"
msgstr ""

#: src/3617-precise-capturing.md:95
msgid ""
"In addition to type and lifetime parameters, we can use this to capture "
"generic const parameters:"
msgstr ""

#: src/3617-precise-capturing.md:98
msgid ""
"//                                    ^^^^^^^^^^^^^^^^^\n"
"//                                    ^ Captures `C` only.\n"
msgstr ""

#: src/3617-precise-capturing.md:103
msgid "Capturing from outer inherent impl"
msgstr ""

#: src/3617-precise-capturing.md:105
msgid "We can capture generic parameters from an outer inherent impl:"
msgstr ""

#: src/3617-precise-capturing.md:112
msgid ""
"//                              ^^^^^^^^^^^^^^^^^^\n"
"    //                              ^ Captures `'a` only.\n"
msgstr ""

#: src/3617-precise-capturing.md:117
msgid "Capturing from outer trait impl"
msgstr ""

#: src/3617-precise-capturing.md:119
msgid "We can capture generic parameters from an outer trait impl:"
msgstr ""

#: src/3617-precise-capturing.md:129
msgid ""
"//         ^^^^^^^^^^^^^^^^^^\n"
"    //         ^ Captures `'a` only.\n"
msgstr ""

#: src/3617-precise-capturing.md:135
msgid "Capturing in trait definition"
msgstr ""

#: src/3617-precise-capturing.md:137
msgid "We can capture generic parameters from the trait definition:"
msgstr ""

#: src/3617-precise-capturing.md:142
msgid ""
"//                              ^^^^^^^^^^^^^^^^^^^^^^^^\n"
"    //                              ^ Captures `'a` and `Self` only.\n"
msgstr ""

#: src/3617-precise-capturing.md:147
msgid "Capturing elided lifetimes"
msgstr ""

#: src/3617-precise-capturing.md:149
msgid "We can capture elided lifetimes:"
msgstr ""

#: src/3617-precise-capturing.md:152
msgid ""
"//                ^^^^^^^^^^^^^^^^^^\n"
"//                ^ Captures `'_` only.\n"
msgstr ""

#: src/3617-precise-capturing.md:157
msgid "Combining with `for<..>`"
msgstr ""

#: src/3617-precise-capturing.md:159
msgid ""
"The `use<..>` specifier applies to the entire `impl Trait` opaque type.  In "
"contrast, a `for<..>` binder applies to an individual _bound_ within an "
"opaque type.  Therefore, when both are used within the same type, `use<..>` "
"always appears first.  E.g.:"
msgstr ""

#: src/3617-precise-capturing.md:165
msgid "Optional trailing comma"
msgstr ""

#: src/3617-precise-capturing.md:167
msgid ""
"As with other lists of generic arguments in Rust, a trailing comma is "
"optional in `use<..>` specifiers:"
msgstr ""

#: src/3617-precise-capturing.md:170 src/3617-precise-capturing.md:393
msgid "//~ OK.\n"
msgstr ""

#: src/3617-precise-capturing.md:171
msgid "//~ Also OK.\n"
msgstr ""

#: src/3617-precise-capturing.md:174
msgid "Reference-level explanation"
msgstr ""

#: src/3617-precise-capturing.md:177 src/3617-precise-capturing.md:747
msgid "Syntax"
msgstr ""

#: src/3617-precise-capturing.md:179
msgid ""
"The [syntax for `impl Trait`](https://doc.rust-lang.org/nightly/reference/"
"types/impl-trait.html) is revised and extended as follows:"
msgstr ""

#: src/3617-precise-capturing.md:183
msgid ""
"_ImplTraitType_ :    `impl` _UseCaptures_<sup>?</sup> [_TypeParamBounds_]"
"(https://doc.rust-lang.org/nightly/reference/trait-bounds.html)"
msgstr ""

#: src/3617-precise-capturing.md:186
msgid ""
"_ImplTraitTypeOneBound_ :    `impl` _UseCaptures_<sup>?</sup> [_TraitBound_]"
"(https://doc.rust-lang.org/nightly/reference/trait-bounds.html)"
msgstr ""

#: src/3617-precise-capturing.md:189
msgid ""
"_UseCaptures_ :  \n"
"   `use` _UseCapturesGenericArgs_"
msgstr ""

#: src/3617-precise-capturing.md:192
msgid ""
"_UseCapturesGenericArgs_ :  \n"
"      `<` `>`   \n"
"   | `<`   \n"
"      ( _UseCapturesGenericArg_ `,`)<sup>\\*</sup>   \n"
"      _UseCapturesGenericArg_ `,`<sup>?</sup>   \n"
"      `>`"
msgstr ""

#: src/3617-precise-capturing.md:199
msgid ""
"_UseCapturesGenericArg_ :  \n"
"      [LIFETIME_OR_LABEL](https://doc.rust-lang.org/nightly/reference/tokens."
"html#lifetimes-and-loop-labels)   \n"
"   | [IDENTIFIER](https://doc.rust-lang.org/nightly/reference/identifiers."
"html)"
msgstr ""

#: src/3617-precise-capturing.md:208
msgid "Reference desugarings"
msgstr ""

#: src/3617-precise-capturing.md:210
msgid ""
"The desugarings that follow can be used to answer questions about how `use<.."
">` is expected to work with respect to the capturing of generic parameters."
msgstr ""

#: src/3617-precise-capturing.md:212
msgid "Reference desugaring for `use<..>` in RPIT"
msgstr ""

#: src/3617-precise-capturing.md:214
msgid ""
"Associated type position `impl Trait` (ATPIT) can be used, more verbosely, "
"to control capturing of generic parameters in opaque types.  We can use this "
"to describe the semantics of `use<..>`.  If we consider the following code:"
msgstr ""

#: src/3617-precise-capturing.md:227
msgid ""
"//    ^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"        // This is the `use<..>` specifier to desugar.\n"
msgstr ""

#: src/3617-precise-capturing.md:234 src/3617-precise-capturing.md:289
msgid ""
"Then we can desugar this as follows, without the use of a `use<..>` "
"specifier, while preserving equivalent semantics with respect to the "
"capturing of generic parameters:"
msgstr ""

#: src/3617-precise-capturing.md:247
msgid ""
"//                     ^^^^^^^^^^^^^^^^^^^^\n"
"        // These are the arguments given to the `use<..>` specifier.\n"
"        //\n"
"        // Reducing what is captured by removing arguments from\n"
"        // `use<..>` is equivalent to removing arguments from this\n"
"        // list and as needed below.\n"
msgstr ""

#: src/3617-precise-capturing.md:276
msgid "Reference desugaring for `use<..>` in RPITIT"
msgstr ""

#: src/3617-precise-capturing.md:278
msgid ""
"Similarly, we can describe the semantics of `use<..>` in return position "
"`impl Trait` in trait (RPITIT) using anonymous associated types.  If we "
"consider the following code:"
msgstr ""

#: src/3617-precise-capturing.md:284
msgid ""
"//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"    // This is the `use<..>` specifier to desugar.\n"
msgstr ""

#: src/3617-precise-capturing.md:296
msgid ""
"//    ^^^^          ^^^^^^^^^       ^^^^^^^^^\n"
"    // These are the arguments given to the `use<..>` specifier.\n"
msgstr ""

#: src/3617-precise-capturing.md:301
msgid ""
"Note that this desugaring does not allow for removing from the `use<..>` "
"specifier `Self` or any generics that are input parameters to the trait.  "
"This is, in fact, an implementation restriction that is likely to be part of "
"initial rounds of stabilization."
msgstr ""

#: src/3617-precise-capturing.md:303
msgid "Avoiding capture of higher ranked lifetimes in nested opaques"
msgstr ""

#: src/3617-precise-capturing.md:305
msgid ""
"According to the Lifetime Capture Rules 2024, a nested `impl Trait` opaque "
"type _must_ capture all generic parameters in scope, including higher ranked "
"ones.  However, for implementation reasons, Rust does not yet support higher "
"ranked lifetime bounds on nested opaque types (see [\\#104288](https://"
"github.com/rust-lang/rust/issues/104288)).  Therefore, in Rust 2024, this "
"code, which is valid in Rust 2021, fails to compile:"
msgstr ""

#: src/3617-precise-capturing.md:308 src/3617-precise-capturing.md:640
#: src/3617-precise-capturing.md:654
msgid "//@ edition: 2024\n"
msgstr ""

#: src/3617-precise-capturing.md:313
msgid ""
"//~^ ERROR `impl Trait` cannot capture higher-ranked lifetime\n"
"    //~|        from outer `impl Trait`\n"
msgstr ""

#: src/3617-precise-capturing.md:320
msgid ""
"With `use<..>`, we can avoid capturing this higher ranked lifetime, allowing "
"compilation:"
msgstr ""

#: src/3617-precise-capturing.md:324
msgid ""
"//                                  ^^^^^^^^^^^^^^^^\n"
"    //                                  ^ Captures nothing.\n"
msgstr ""

#: src/3617-precise-capturing.md:333
msgid "Capturing higher ranked lifetimes in nested opaques"
msgstr ""

#: src/3617-precise-capturing.md:335
msgid ""
"Once higher ranked lifetime bounds on nested opaque types are supported in "
"Rust (see [\\#104288](https://github.com/rust-lang/rust/issues/104288)), "
"we'll be able to use `use<..>` specifiers to capture lifetime parameters "
"from higher ranked `for<..>` binders on outer opaque types:"
msgstr ""

#: src/3617-precise-capturing.md:342
msgid ""
"//                                  ^^^^^^^^^^^^^^^^^^\n"
"    //                                  ^ Captures `'a`.\n"
msgstr ""

#: src/3617-precise-capturing.md:349
msgid "Refinement"
msgstr ""

#: src/3617-precise-capturing.md:351
msgid "If we write a trait such as:"
msgstr ""

#: src/3617-precise-capturing.md:360
msgid ""
"...then an impl of this trait can provide a type for the associated type "
"`Foo` that uses the `&'_ self` lifetime:"
msgstr ""

#: src/3617-precise-capturing.md:365
msgid "// Or, e.g.: `impl use<'a> Sized`\n"
msgstr ""

#: src/3617-precise-capturing.md:370
msgid ""
"However, such an impl may also provide a type that does _not_ use the "
"lifetime:"
msgstr ""

#: src/3617-precise-capturing.md:375
msgid "// Or, e.g.: `impl use<> Sized`\n"
msgstr ""

#: src/3617-precise-capturing.md:380
msgid ""
"If we only know that the value is of some type that implements the trait, "
"then we must assume that the type returned by `foo` _might_ use the lifetime:"
msgstr ""

#: src/3617-precise-capturing.md:384
msgid "//~^ ERROR cannot return value referencing function parameter `x`\n"
msgstr ""

#: src/3617-precise-capturing.md:389
msgid ""
"However, if we know we have a value of type `B`, we can _rely_ on the fact "
"that the lifetime is not used:"
msgstr ""

#: src/3617-precise-capturing.md:397
msgid ""
"We would say that the impl for `B` is _refining_ in that it offers more to "
"or demands less of callers than the minimum the trait could offer or the "
"maximum it could demand.  Associated type definitions are always refining in "
"this way."
msgstr ""

#: src/3617-precise-capturing.md:399
msgid ""
"RPITIT desugars into associated types similar to those above, but here we've "
"currently decided to lint against this refinement, e.g.:"
msgstr ""

#: src/3617-precise-capturing.md:407 src/3617-precise-capturing.md:430
#: src/3617-precise-capturing.md:449 src/3617-precise-capturing.md:468
#: src/3617-precise-capturing.md:488
msgid ""
"//~^ WARN impl trait in impl method signature does not match\n"
"//~|      trait method signature\n"
"//~| NOTE add `#[allow(refining_impl_trait)]` if it is intended\n"
"//~|      for this to be part of the public API of this crate\n"
"//~| NOTE we are soliciting feedback, see issue #121718\n"
"//~|      <https://github.com/rust-lang/rust/issues/121718>\n"
"//~|      for more information\n"
msgstr ""

#: src/3617-precise-capturing.md:418
msgid ""
"Similarly, for consistency, we'll lint against RPITIT cases where less is "
"captured by RPIT in the impl as compared with the trait definition when "
"using `use<..>`."
msgstr ""

#: src/3617-precise-capturing.md:420
msgid "Examples of refinement"
msgstr ""

#: src/3617-precise-capturing.md:422
msgid ""
"In keeping with the rule above, we consider it refining if we don't capture "
"in the impl all of the generic parameters from the function signature that "
"are captured in the trait definition:"
msgstr ""

#: src/3617-precise-capturing.md:426
msgid "// Or: `impl use<'_, Self> Sized`\n"
msgstr ""

#: src/3617-precise-capturing.md:441
msgid ""
"Similarly, if we don't capture, in the impl, any generic parameter applied "
"as an argument to the trait in the impl header when the corresponding "
"generic parameter is captured in the trait definition, that is refining.  E."
"g.:"
msgstr ""

#: src/3617-precise-capturing.md:445
msgid "// Or: `impl use<'x, Self> Sized`\n"
msgstr ""

#: src/3617-precise-capturing.md:460
msgid ""
"This remains true even if the trait impl is _reparameterized_.  In that "
"case, it is refining unless _all_ generic parameters applied in the impl "
"header as generic arguments for the corresponding trait parameter are "
"captured in the impl when that parameter is captured in the trait "
"definition, e.g.:"
msgstr ""

#: src/3617-precise-capturing.md:464
msgid "// Or: `impl use<T, Self> Sized`\n"
msgstr ""

#: src/3617-precise-capturing.md:479
msgid ""
"Similarly, it's refining if `Self` is captured in the trait definition and, "
"in the impl, we don't capture all of the generic parameters that are applied "
"in the impl header as generic arguments to the `Self` type, e.g.:"
msgstr ""

#: src/3617-precise-capturing.md:483
msgid "// Or: `impl use<Self> Sized`\n"
msgstr ""

#: src/3617-precise-capturing.md:499
msgid "Lifetime equality"
msgstr ""

#: src/3617-precise-capturing.md:501
msgid ""
"While the capturing of generic parameters is generally syntactic, this is "
"currently allowed in Rust 2021:"
msgstr ""

#: src/3617-precise-capturing.md:510
msgid ""
"Rust 2021 does not adhere to the Lifetime Capture Rules 2024 for bare RPITs "
"such as this.  Correspondingly, lifetimes are only captured when they appear "
"in the bounds.  Here, `'b` but not `'a` appears in the bounds, yet we're "
"still able to capture `'a` due to the fact that it must be equal to `'b`."
msgstr ""

#: src/3617-precise-capturing.md:512
msgid "To preserve consistency with this, the following is also valid:"
msgstr ""

#: src/3617-precise-capturing.md:521
msgid ""
"A more difficult case is where, in the trait definition, only a subset of "
"the generic parameters on the trait are captured, and in the impl we capture "
"a lifetime _not_ applied syntactically as an argument for one of those "
"captured parameters but which is equal to a lifetime that is applied as an "
"argument for one of the captured parameters, e.g.:"
msgstr ""

#: src/3617-precise-capturing.md:535
msgid ""
"For the purposes of this RFC, in the interest of consistency with the above "
"cases, we're going to say that this is valid.  However, as mentioned "
"elsewhere, partial capturing of generics that are input parameters to the "
"trait (including `Self`) is unlikely to be part of initial rounds of "
"stabilization, and it's possible that implementation experience may lead us "
"to a different answer for this case."
msgstr ""

#: src/3617-precise-capturing.md:537
msgid "Reparameterization"
msgstr ""

#: src/3617-precise-capturing.md:539
msgid ""
"In Rust, trait impls may be parameterized over a different set of generics "
"than the trait itself.  E.g.:"
msgstr ""

#: src/3617-precise-capturing.md:553
msgid ""
"In these cases, what we look at is how these generics are applied as "
"arguments to the trait in the impl header.  In this example, all of `'a`, "
"`B`, and `C` are applied in place of the `Y` input parameter to the trait.  "
"Since `Y` is captured in the trait definition, we're correspondingly allowed "
"to capture `'a`, `B`, and `C` in the impl."
msgstr ""

#: src/3617-precise-capturing.md:555
msgid "The `Self` type"
msgstr ""

#: src/3617-precise-capturing.md:557
msgid ""
"In trait definitions (but not elsewhere), `use<..>` may capture `Self`.  "
"Doing so means that in the impl, the opaque type may capture any generic "
"parameters that are applied as generic arguments to the `Self` type.  E.g.:"
msgstr ""

#: src/3617-precise-capturing.md:572
msgid "Handling of projection types"
msgstr ""

#: src/3617-precise-capturing.md:574
msgid ""
"If we apply, in a trait impl header, a projection type to a trait in place "
"of a parameter that is captured in the trait definition, that does not allow "
"us to capture in the impl the generic parameter from which the type is "
"projected.  E.g.:"
msgstr ""

#: src/3617-precise-capturing.md:583
msgid "//~^ ERROR cannot capture `A`\n"
msgstr ""

#: src/3617-precise-capturing.md:587
msgid ""
"The reason this is an error is related to the fact that, in Rust, a generic "
"parameter used as an associated type does not constrain that generic "
"parameter in the impl.  E.g.:"
msgstr ""

#: src/3617-precise-capturing.md:594
msgid "//~^ ERROR the type parameter `A` is not constrained\n"
msgstr ""

#: src/3617-precise-capturing.md:600
msgid "Meaning of capturing a const generic parameter"
msgstr ""

#: src/3617-precise-capturing.md:602
msgid ""
"As with other generic parameters, a const generic parameter must be captured "
"in the opaque type for it to be used in the hidden _type_.  E.g., we must "
"capture `C` here:"
msgstr ""

#: src/3617-precise-capturing.md:610
msgid ""
"However, note that we do not need to capture `C` just to use it as a "
"_value_, e.g.:"
msgstr ""

#: src/3617-precise-capturing.md:618
msgid "Argument position impl Trait"
msgstr ""

#: src/3617-precise-capturing.md:620
msgid ""
"Note that for a generic type parameter to be captured with `use<..>` it must "
"have a name.  Anonymous generic type parameters introduced with argument "
"position `impl Trait` (APIT) syntax don't have names, and so cannot be "
"captured with `use<..>`.  E.g.:"
msgstr ""

#: src/3617-precise-capturing.md:628
msgid "Migration strategy for Lifetime Capture Rules 2024"
msgstr ""

#: src/3617-precise-capturing.md:630
msgid ""
"The migration lints for Rust 2024 will insert `use<..>` as needed so as to "
"preserve the set of generic parameters captured by each RPIT opaque type.  "
"That is, we will convert, e.g., this:"
msgstr ""

#: src/3617-precise-capturing.md:637 src/3617-precise-capturing.md:651
msgid "...into this:"
msgstr ""

#: src/3617-precise-capturing.md:644
msgid ""
"Note that since generic type parameters must have names to be captured with "
"`use<..>`, some uses of APIT will need to be converted to named generic "
"parameters.  E.g., we will convert this:"
msgstr ""

#: src/3617-precise-capturing.md:658
msgid ""
"As we're always cognizant of adding noise during migrations, it's worth "
"mentioning that this will also allow noise to be _removed_.  E.g., this code:"
msgstr ""

#: src/3617-precise-capturing.md:672
msgid "...can be replaced with this:"
msgstr ""

#: src/3617-precise-capturing.md:682
msgid ""
"As an example of what migrating to explicit `use<..>` captures looks like "
"within `rustc` itself (without yet migrating to the Lifetime Capture Rules "
"2024 which would simplify many cases further), see [this diff](https://"
"github.com/rust-lang/rust/compare/"
"efd136e5cd57789834c7555eed36c490b7be6fe7...0d15c5c62d2a6f46269e5812653900e0945738bf?"
"expand=1)."
msgstr ""

#: src/3617-precise-capturing.md:686
msgid "Stabilization strategy"
msgstr ""

#: src/3617-precise-capturing.md:688
msgid ""
"Due to implementation considerations, it's likely that the initial "
"stabilization of this feature will be partial.  We anticipate that partial "
"stabilization will have these restrictions:"
msgstr ""

#: src/3617-precise-capturing.md:690
msgid ""
"`use<..>`, if provided, must include all in-scope type and const generic "
"parameters."
msgstr ""

#: src/3617-precise-capturing.md:691
msgid ""
"In RPIT within trait definitions, `use<..>`, if provided, must include all "
"in-scope generic parameters."
msgstr ""

#: src/3617-precise-capturing.md:693
msgid "We anticipate lifting these restrictions over time."
msgstr ""

#: src/3617-precise-capturing.md:695
msgid ""
"Since all in-scope type and const generic parameters were already captured "
"in Rust 2021 and earlier editions, and since RPITIT already adheres to the "
"Lifetime Capture Rules 2024, these restrictions do not interfere with the "
"use of this feature to migrate code to Rust 2024."
msgstr ""

#: src/3617-precise-capturing.md:697
msgid "Alternatives"
msgstr ""

#: src/3617-precise-capturing.md:700
msgid "ATPIT / TAIT"
msgstr ""

#: src/3617-precise-capturing.md:702
msgid ""
"As we saw in the reference desugaring above, associated type position `impl "
"Trait` (ATPIT), once stabilized, can be used to effect precise capturing.  "
"Originally, we had hoped that this (particularly once expanded to full type "
"alias `impl Trait` (TAIT)) might be sufficient and that syntax such as that "
"in this RFC might not be necessary."
msgstr ""

#: src/3617-precise-capturing.md:704
msgid "As it turned out, there are four problems with this:"
msgstr ""

#: src/3617-precise-capturing.md:706
msgid "These features are too indirect a solution."
msgstr ""

#: src/3617-precise-capturing.md:707
msgid "They might not be stabilized in time."
msgstr ""

#: src/3617-precise-capturing.md:708
msgid "They would lead to a worse migration story."
msgstr ""

#: src/3617-precise-capturing.md:709
msgid "We would want this syntax anyway."
msgstr ""

#: src/3617-precise-capturing.md:711 src/3617-precise-capturing.md:923
msgid "Taking these in turn:"
msgstr ""

#: src/3617-precise-capturing.md:713
msgid ""
"One, as can be seen in the reference desugaring, using ATPIT/TAIT in this "
"way can be rather indirect, and this was confirmed in our practical "
"experience when migrating code.  ATPIT and TAIT are good tools, but they "
"weren't designed to solve this particular problem.  This problem calls for a "
"more direct solution."
msgstr ""

#: src/3617-precise-capturing.md:715
msgid ""
"Two, while ATPIT is nearing stabilization, there are yet some type systems "
"details being resolved.  For TAIT, there is much work yet to do.  Putting "
"these features in the critical path would add risk to the edition, to the "
"Lifetime Capture Rules 2024, and to these features."
msgstr ""

#: src/3617-precise-capturing.md:717
msgid ""
"Three, as a practical matter, an explicit `impl use<..> Trait` syntax lets "
"us write much better automatic migration lints and offers a much more "
"straightforward migration story for our users."
msgstr ""

#: src/3617-precise-capturing.md:719
msgid ""
"Four, the set of generic parameters that are captured by an opaque type is a "
"fundamental and practical property of that opaque type.  In a language like "
"Rust, it _feels_ like there ought to be an explicit syntax for it.  We "
"probably want this in any world."
msgstr ""

#: src/3617-precise-capturing.md:721
msgid "Inferred precise capturing"
msgstr ""

#: src/3617-precise-capturing.md:723
msgid ""
"We had hoped that we might be able to achieve something with a similar "
"effect to precise capturing at the cost of an extra generic lifetime "
"parameter in each signature with improvements to the type system.  The goal "
"would be to allow, e.g., this code to work rather than error:"
msgstr ""

#: src/3617-precise-capturing.md:735
msgid ""
"The idea is that, even though the opaque type returned by `foo` does capture "
"the generic type parameter `T`, since the opaque type is explicitly bounded "
"by `'o` and the signature does not assert `T: 'o`, we know that the hidden "
"type cannot actually use `T`."
msgstr ""

#: src/3617-precise-capturing.md:737
msgid ""
"As it turns out, making full use of this observation is challenging (see "
"[\\#116040](https://github.com/rust-lang/rust/pull/116040) and [\\#116733]"
"(https://github.com/rust-lang/rust/pull/116733)).  While we did make "
"improvements to the type system here, and while more might be possible, this "
"does not solve the problem today in all important cases (including, e.g., "
"avoiding the capture of higher ranked lifetimes in nested opaque types) and "
"will not for the foreseeable future."
msgstr ""

#: src/3617-precise-capturing.md:739
msgid ""
"Moreover, even with the fullest possible version of these improvements, "
"whether or not a generic parameter is captured by an opaque type would "
"remain observable.  Having an explicit syntax to control what is captured is "
"more direct, more expressive, and leads to a better migration story."
msgstr ""

#: src/3617-precise-capturing.md:741
msgid ""
"See [Appendix G](https://github.com/rust-lang/rfcs/blob/master/text/3498-"
"lifetime-capture-rules-2024.md#appendix-g-future-possibility-inferred-"
"precise-capturing) in [RFC 3498](https://github.com/rust-lang/rfcs/blob/"
"master/text/3498-lifetime-capture-rules-2024.md) for more details."
msgstr ""

#: src/3617-precise-capturing.md:749
msgid ""
"We considered a number of different possible syntaxes before landing on "
"`impl use<..> Trait`.  We'll discuss each considered."
msgstr ""

#: src/3617-precise-capturing.md:751 src/3617-precise-capturing.md:951
msgid "`impl use<..> Trait`"
msgstr ""

#: src/3617-precise-capturing.md:753
msgid ""
"This is the syntax used throughout this RFC (but see the [unresolved "
"questions](#unresolved-questions))."
msgstr ""

#: src/3617-precise-capturing.md:755
msgid ""
"Using a separate keyword makes this syntax more scalable in the sense that "
"we can apply `use<..>` in other places."
msgstr ""

#: src/3617-precise-capturing.md:757
msgid ""
"Conveniently, the word \"use\" is quite appropriate here, since we are "
"_using_ the generic parameters in the opaque type and allowing the generic "
"parameters to be _used_ in the hidden type.  That is, with `use`, we are "
"bringing the generic parameters _into scope_ for the hidden type, and `use` "
"is the keyword in Rust for bringing things into scope."
msgstr ""

#: src/3617-precise-capturing.md:759
msgid ""
"Picking an existing keyword allows for this syntax, including extensions to "
"other positions, to be allowed in older editions.  Because `use` is a full "
"keyword, we're not limited in where it can be placed."
msgstr ""

#: src/3617-precise-capturing.md:761
msgid ""
"By not putting the generic parameters on `impl<..>`, we reduce the risk of "
"confusion that we are somehow introducing generic parameters here rather "
"than using them."
msgstr ""

#: src/3617-precise-capturing.md:763
msgid ""
"We put `impl` before `use<..>` because `use<..>` is a property of the opaque "
"type and we're _applying_ the generic _parameters_ as generic _arguments_ to "
"this opaque type.  In `impl Trait` syntax, the `impl` keyword is the stand-"
"in for the opaque type itself.  Viewed this way, `impl use<..> Trait` "
"maintains the following order, which is seen throughout Rust: _type_, "
"_generic arguments_, _bounds_."
msgstr ""

#: src/3617-precise-capturing.md:765
msgid ""
"Using angle brackets, rather than parentheses or square brackets, is "
"consistent with other places in the language where type parameters are "
"applied to a type."
msgstr ""

#: src/3617-precise-capturing.md:767
msgid ""
"At three letters, the `use` keyword is short enough that it doesn't feel too "
"noisy or too much like a burden to use this, and it's parsimonious with "
"other short keywords in Rust."
msgstr ""

#: src/3617-precise-capturing.md:769
msgid ""
"Overall, naming is hard, but on average, people seemed to dislike this "
"choice the least."
msgstr ""

#: src/3617-precise-capturing.md:771
msgid "`impl<..> Trait`"
msgstr ""

#: src/3617-precise-capturing.md:773
msgid ""
"The original syntax proposal was `impl<..> Trait`.  This has the benefit of "
"being somewhat more concise than `impl use<..> Trait` but has the drawback "
"of perhaps suggesting that it's introducing generic parameters as other uses "
"of `impl<..>` do.  Many preferred to use a different keyword for this reason."
msgstr ""

#: src/3617-precise-capturing.md:775
msgid ""
"Decisive to some was that we may want this syntax to _scale_ to other uses, "
"most particularly to controlling the set of generic parameters and values "
"that are captured by closure-like blocks.  As we discuss in the future "
"possibilities, it's easy to see how `use<..>` can scale to address this in a "
"way that `impl<..> Trait` cannot."
msgstr ""

#: src/3617-precise-capturing.md:777 src/3617-precise-capturing.md:953
msgid "`use<..> impl Trait`"
msgstr ""

#: src/3617-precise-capturing.md:779
msgid ""
"Putting the `use<..>` specifier _before_ the `impl` keyword is potentially "
"appealing as `use<..>` applies to the entire `impl Trait` opaque type rather "
"than to just one of the bounds, and this ordering might better suggest that."
msgstr ""

#: src/3617-precise-capturing.md:781
msgid ""
"Let's discuss some arguments for this, some arguments against it, and then "
"discuss the fundamental tension here."
msgstr ""

#: src/3617-precise-capturing.md:783
msgid "The case for `use<..>` before `impl`"
msgstr ""

#: src/3617-precise-capturing.md:785
msgid ""
"We've been referring to the syntax for RPIT-like opaque types as `impl "
"Trait`, as is commonly done.  But this is a bit imprecise.  The syntax is "
"really `impl $bounds`.  We might say, e.g.:"
msgstr ""

#: src/3617-precise-capturing.md:793
msgid ""
"Each _bound_, separated by `+`, may be a _lifetime_ or a _trait bound_.  "
"Each trait bound may include a higher ranked `for<..>` _binder_.  The "
"lifetimes introduced in such a binder are in scope only for the bound in "
"which that binder appears."
msgstr ""

#: src/3617-precise-capturing.md:795
msgid ""
"This could create confusion with `use<..>` after `impl`.  If we say, e.g.:"
msgstr ""

#: src/3617-precise-capturing.md:801
msgid ""
"//    ^^^^^^^ ^^^^^^^                 ^^^^^^^\n"
"    //    |       |                       ^ Applies to one bound.\n"
"    //    |       ^ Applies to one bound.\n"
"    //    ^ Applies to the whole type.\n"
msgstr ""

#: src/3617-precise-capturing.md:809
msgid ""
"...then it may feel like `use<..>` should apply to only the first bound, "
"just as the `for<..>` binder right next to it does.  Putting `use<..>` "
"_before_ `impl` might avoid this issue.  E.g.:"
msgstr ""

#: src/3617-precise-capturing.md:819
msgid ""
"This would make it clear that `use<..>` applies to the entire type.  This "
"seems the strongest argument for putting `use<..>` before `impl`, and it's a "
"_good_ one."
msgstr ""

#: src/3617-precise-capturing.md:821
msgid "The case for and against `use<..>` before `impl`"
msgstr ""

#: src/3617-precise-capturing.md:823
msgid ""
"There are some other known arguments for this ordering that may or may not "
"resonate with the reader; we'll present these, along with the standard "
"arguments that might be made in response, as an imagined conversation "
"between Alice and Bob:"
msgstr ""

#: src/3617-precise-capturing.md:825
msgid ""
"**Bob**: We call the base feature here \"`impl Trait`\".  Anything that we "
"put between the `impl` and the `Trait` could make this less recognizable to "
"people."
msgstr ""

#: src/3617-precise-capturing.md:827
msgid ""
"**Alice**: Maybe, but users don't literally write the words `impl Trait`; "
"they write `impl` and then a set of bounds.  They could even write `impl "
"'static + Fn()`, e.g.  The fact that there can be multiple traits and that a "
"lifetime or a `for<..>` binder could come between the `impl` and the first "
"trait doesn't seem to be a problem here, so maybe adding `use<..>` won't be "
"either."
msgstr ""

#: src/3617-precise-capturing.md:829
msgid ""
"**Bob**: But what about the orthography?  In English, we might say \"using "
"'x, we implement the trait\".  We'd probably try to avoid saying \"we "
"implement, using 'x, the trait\".  Putting `use<..>` first better lines up "
"with this."
msgstr ""

#: src/3617-precise-capturing.md:831
msgid ""
"**Alice**: Is that true?  Would we always prefer the first version?  To my "
"ears, \"using 'x, we implement the trait\" sounds a bit like something Yoda "
"would say.  I'd probably say the second version, if I had to choose.  "
"Really, of course, I'd mostly try to say instead that \"we implement the "
"trait using 'x\", but there are probably good reasons to not use that "
"ordering here in Rust."
msgstr ""

#: src/3617-precise-capturing.md:833
msgid ""
"**Bob**: The RFC talks about maybe later extending the `use<..>` syntax to "
"closure-like blocks, e.g. `use<> |x| x`.  If it makes sense to put the "
"`use<..>` first here, shouldn't we put it first in `use<..> impl Trait`?"
msgstr ""

#: src/3617-precise-capturing.md:835
msgid ""
"**Alice**: That's interesting to think about.  In the case of closure-like "
"blocks, we'd probably want to put the `use<..>` in the same position as "
"`move` as it could be extended to serve a similar purpose.  For closures, "
"that would mean putting it before the arguments, e.g. `use<> |x| x`, just as "
"we do with `move`.  But this would also imply that `use<..>` should appear "
"_after_ certain keywords, e.g. for `async` blocks we currently write `async "
"move {}`, so maybe here we would write `async use<> {}`."
msgstr ""

#: src/3617-precise-capturing.md:837
msgid ""
"**Alice**: There is a key difference to keep in mind here.  Closure-like "
"blocks are _expressions_ but `impl Trait` is syntax for a _type_.  We often "
"have different conventions between type position and expression position in "
"Rust.  Maybe (or maybe not) this is a place where that distinction could "
"matter."
msgstr ""

#: src/3617-precise-capturing.md:839
msgid "The case against `use<..>` before `impl`"
msgstr ""

#: src/3617-precise-capturing.md:841
msgid ""
"The `use<..>` specifier syntax _applies_ the listed generic _parameters_ as "
"generic _arguments_ to the opaque type.  It's analogous, e.g., with the "
"generic arguments here:"
msgstr ""

#: src/3617-precise-capturing.md:846
msgid ""
"//                   ^^^^^^^^ ^^^^^\n"
"    //                   ^ Type   ^ Generic arguments\n"
msgstr ""

#: src/3617-precise-capturing.md:849
msgid ""
"//    ^^^^^^^^^^^^^\n"
"    //    ^ Bounds\n"
msgstr ""

#: src/3617-precise-capturing.md:854
msgid ""
"Just as the above _applies_ `<'t, T>` to `Concrete`, `use<..>` applies its "
"arguments to the opaque type."
msgstr ""

#: src/3617-precise-capturing.md:856
msgid ""
"In the above example and throughout Rust, we observe the following order: "
"_type_, _generic arguments_ (applied to the type), _bounds_.  In `impl "
"Trait` syntax, the `impl` keyword is the stand-in for the opaque type "
"itself.  The `use<..>` specifier lists the generic arguments to be applied "
"to that type.  Then the bounds follow.  Putting `use<..>` after `impl` is "
"consistent with this rule, but the other way would be inconsistent."
msgstr ""

#: src/3617-precise-capturing.md:858
msgid ""
"This observation, that we're applying generic _arguments_ to the opaque type "
"and that the `impl` keyword is the stand-in for that type, is also a strong "
"argument in favor of `impl<..> Trait` syntax.  It's conceivable that we'll "
"later, with more experience and consistently with [Stroustrup's Rule]"
"(https://www.thefeedbackloop.xyz/stroustrups-rule-and-layering-over-time/), "
"decide that we want to be more concise and adopt the `impl<..> Trait` syntax "
"after all.  One of the advantages of placing `use<..>` after `impl` is that "
"there would be less visual and conceptual churn in later making that change."
msgstr ""

#: src/3617-precise-capturing.md:860
msgid ""
"Finally, there's one other practical advantage to placing `impl` before "
"`use<..>`.  If we were to do it the other way and place `use<..>` before "
"`impl`, we would need to make a backward incompatible change to the `ty` "
"macro matcher fragment specifier.  This would require us to migrate this "
"specifier according to our policy in [RFC 3531](https://github.com/rust-lang/"
"rfcs/blob/master/text/3531-macro-fragment-policy.md).  This is something we "
"could do, but it is a cost on us and on our users, even if only a modest one."
msgstr ""

#: src/3617-precise-capturing.md:865
msgid "The fundamental tension on `impl use<..>` vs. `use<..> impl`"
msgstr ""

#: src/3617-precise-capturing.md:867
msgid ""
"Throughout this RFC, we've given two intuitions for the semantics of `use<.."
">`:"
msgstr ""

#: src/3617-precise-capturing.md:869
msgid ""
"**Intuition #1**: `use<..>` _applies_ generic arguments to the opaque type."
msgstr ""

#: src/3617-precise-capturing.md:870
msgid ""
"**Intuition #2**: `use<..>` brings generic parameters _into scope_ for the "
"hidden type."
msgstr ""

#: src/3617-precise-capturing.md:872
msgid ""
"These are _both_ true and are both valid _intuitions_, but there's some "
"tension between these for making this syntax choice."
msgstr ""

#: src/3617-precise-capturing.md:874
msgid ""
"It's often helpful to think of `impl Trait` in terms of generic associated "
"types (GATs), and let's make that analogy here.  Consider:"
msgstr ""

#: src/3617-precise-capturing.md:879
msgid ""
"//   ^^^^^^ ^^^^^    ^^^^^^^^ ^^^^^\n"
"    //   |      |        |        ^ Generic arguments applied\n"
"    //   |      |        ^ Concrete type\n"
"    //   |      ^ Generic parameters introduced into scope\n"
"    //   ^ Alias type (similar to an opaque type)\n"
msgstr ""

#: src/3617-precise-capturing.md:885
msgid ""
"//                  ^^^^^^^^^^^^ ^^^^^\n"
"    //                  ^ Alias type ^ Generic arguments applied\n"
msgstr ""

#: src/3617-precise-capturing.md:890
msgid ""
"The question is, are the generics in `use<..>` more like the generic "
"_parameters_ or more like the generic _arguments_ above?"
msgstr ""

#: src/3617-precise-capturing.md:892
msgid ""
"If these generics are more like the generic _arguments_ above (_Intuition "
"#1_), then `impl<..> Trait` and `impl use<..> Trait` make a lot of sense as "
"we're _applying_ these arguments to the type.  In Rust, when we're applying "
"generic arguments to a type, the generic arguments appear _after_ the type, "
"and `impl` is the stand-in for the type here."
msgstr ""

#: src/3617-precise-capturing.md:894
msgid ""
"However, if these generics are more like the generic _parameters_ above "
"(_Intuition #2_), then `use<..> impl Trait` makes more sense.  In Rust, when "
"we're putting generic parameters into scope, they appear before the type."
msgstr ""

#: src/3617-precise-capturing.md:896
msgid ""
"Since both intuitions are valid, but each argues for a different syntax "
"choice, picking one is tough.  The authors are sympathetic to both choices.  "
"The key historical and tiebreaker factors leading to our use of the `impl "
"use<..> Trait` syntax in this RFC are:"
msgstr ""

#: src/3617-precise-capturing.md:898
msgid ""
"The original longstanding and motivating semantic intuition for this feature "
"was _Intuition #1_, and it argues for this syntax.  The second intuition, "
"_Intuition #2_, was only developed in the process of writing this RFC and "
"after most of this RFC had been written."
msgstr ""

#: src/3617-precise-capturing.md:899
msgid ""
"The `use<..> impl Trait` syntax was never proposed before this RFC was "
"written (it may have been inspired by the presentation in this RFC of the "
"second intuition), and in discussion, no clear consensus has yet emerged in "
"its favor."
msgstr ""

#: src/3617-precise-capturing.md:900
msgid ""
"There are some practical costs that exist for `use<..> impl Trait` that "
"don't for `impl use<..> Trait`."
msgstr ""

#: src/3617-precise-capturing.md:901
msgid ""
"The \"obvious\" syntax for this feature is `impl<..> Trait`.  We may yet "
"someday want to switch to this, and migrating from `impl use<..> Trait` "
"seems like a smaller step."
msgstr ""

#: src/3617-precise-capturing.md:903
msgid ""
"Nonetheless, we leave this as an [unresolved question](#unresolved-"
"questions)."
msgstr ""

#: src/3617-precise-capturing.md:905
msgid "`impl Trait & ..`"
msgstr ""

#: src/3617-precise-capturing.md:907
msgid ""
"In some conceptions, the difference between `impl Trait + 'a + 'b` and `impl "
"use<'a, 'b> Trait` is the difference between capturing the union of those "
"lifetimes and capturing the intersection of them.  This inspires syntax "
"proposals such as `impl Trait & 't & T` or `impl Trait & ['t, T]` to express "
"this intersection."
msgstr ""

#: src/3617-precise-capturing.md:909
msgid ""
"One problem with the former of these is that it gives no obvious way to "
"express that the opaque type captures nothing.  Another is that it would "
"give `AsRef &T` a valid but distinct meaning to `AsRef<&T>` which might be "
"confusing."
msgstr ""

#: src/3617-precise-capturing.md:911
msgid ""
"For either of these, appearing later in the type would put these after "
"higher ranked `for<..>` lifetimes may have been introduced.  This could be "
"confusing, since `use<..>` (with any syntax) captures generic parameters for "
"the entire type where `for<..>` applies individually to each bound."
msgstr ""

#: src/3617-precise-capturing.md:913
msgid "Overall, nobody seemed to like this syntax."
msgstr ""

#: src/3617-precise-capturing.md:915
msgid "`impl k#captures<..> Trait`"
msgstr ""

#: src/3617-precise-capturing.md:917
msgid ""
"We could use a new and very literal keyword such as `captures` rather than "
"`use`.  There are three main drawbacks to this:"
msgstr ""

#: src/3617-precise-capturing.md:919
msgid "There are limits to how this could be used in older editions."
msgstr ""

#: src/3617-precise-capturing.md:920
msgid "There's a cost to each new keyword, and `use` is probably good enough."
msgstr ""

#: src/3617-precise-capturing.md:921
msgid "It's somewhat long."
msgstr ""

#: src/3617-precise-capturing.md:925
msgid ""
"One, while `captures` could be reserved in Rust 2024 and used in any "
"position in that edition, and in Rust 2021 could be used as `k#captures` in "
"any position, on older editions, it would only be able to be used where it "
"could be made contextual.  This could limit how we might be able to scale "
"this syntax to handle other use cases such as controlling the capturing of "
"generic parameters and values in closure-like blocks (as discussed in the "
"future possibilities)."
msgstr ""

#: src/3617-precise-capturing.md:927
msgid ""
"Two, each keyword takes from the space of names that users have available to "
"them, and it increases the number of keywords with which users must be "
"familiar (e.g. so as to not inadvertently trip over when choosing a name).  "
"That is, each keyword has a cost.  If an existing keyword can reasonably be "
"used in more places, then we get more benefit for that cost.  In this case, "
"`use` is probably a strong enough choice that paying the cost for a new "
"keyword doesn't seem worth it."
msgstr ""

#: src/3617-precise-capturing.md:929
msgid ""
"Three, `captures` would be a somewhat long keyword, especially when we "
"consider how we might scale the use of this syntax to other places such as "
"closure-like blocks.  We don't want people to feel punished for being "
"explicit about the generics that they capture, and we don't want them to do "
"other worse things (such as overcapturing where they should not) just to "
"avoid visual bloat in their code, so if we can be more concise here, that "
"seems like a win."
msgstr ""

#: src/3617-precise-capturing.md:931
msgid "`impl move<'t, T> Trait`"
msgstr ""

#: src/3617-precise-capturing.md:933
msgid ""
"We could use the existing `move` keyword, however the word \"move\" is "
"semantically worse.  In Rust, we already _use_ generic parameters in types, "
"but we don't _move_ any generic parameters.  We move only _values_, so this "
"could be confusing.  The word \"use\" is better."
msgstr ""

#: src/3617-precise-capturing.md:935
msgid "`impl k#via<'t, T> Trait`"
msgstr ""

#: src/3617-precise-capturing.md:937
msgid ""
"We could use a new short keyword such as `via`.  This has the number 1 and 2 "
"drawbacks of `k#captures` mentioned above.  As with `move`, it also seems a "
"semantically worse word.  With `use<..>`, we can explain that it means the "
"opaque type _uses_ the listed generic parameters.  In contrast, it's not "
"clear how we could explain the word \"via\" in this context."
msgstr ""

#: src/3617-precise-capturing.md:939
msgid "Using parentheses or square brackets"
msgstr ""

#: src/3617-precise-capturing.md:941
msgid ""
"We could say `use('t, T)` or `use['t, T]`.  However, in Rust today, generic "
"parameters always fall within angle brackets, even when being applied to a "
"type.  Doing something different here could feel inconsistent and doesn't "
"seem warranted."
msgstr ""

#: src/3617-precise-capturing.md:943
msgid "Unresolved questions"
msgstr ""

#: src/3617-precise-capturing.md:947
msgid "Syntax question"
msgstr ""

#: src/3617-precise-capturing.md:949
msgid ""
"We leave as an open question which of these two syntaxes we should choose:"
msgstr ""

#: src/3617-precise-capturing.md:952
msgid "This syntax is used throughout this RFC."
msgstr ""

#: src/3617-precise-capturing.md:954
msgid "This syntax is the worthy challenger."
msgstr ""

#: src/3617-precise-capturing.md:956
msgid ""
"See the [alternatives](#alternatives) section above for a detailed "
"comparative analysis of these options."
msgstr ""

#: src/3617-precise-capturing.md:958
msgid "Future possibilities"
msgstr ""

#: src/3617-precise-capturing.md:961
msgid "Opting out of captures"
msgstr ""

#: src/3617-precise-capturing.md:963
msgid ""
"There will plausibly be cases where we want to capture many generic "
"parameters and not capture only smaller number.  It could be convenient if "
"there were a way to express this without listing out all of the in-scope "
"type parameters except the ones not being captured."
msgstr ""

#: src/3617-precise-capturing.md:965
msgid ""
"The way we would approach this with the `use<..>` syntax is to add some "
"syntax that means \"fill in all in-scope generic parameters\", then add "
"syntax to remove certain generic parameters from the list.  E.g.:"
msgstr ""

#: src/3617-precise-capturing.md:970
msgid ""
"//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"//   ^ Captures `B`, `C`, and `D` but not `'a` or `A`.\n"
msgstr ""

#: src/3617-precise-capturing.md:975
msgid ""
"Here, the `..` means to include all in-scope generic parameters and `!` "
"means to exclude a particular generic parameter even if previously included."
msgstr ""

#: src/3617-precise-capturing.md:977
msgid "We leave this to future work."
msgstr ""

#: src/3617-precise-capturing.md:979
msgid "Explicit capturing for closure-like blocks"
msgstr ""

#: src/3617-precise-capturing.md:981
msgid ""
"Closures and closure-like blocks (e.g. `async`, `gen`, `async gen`, `async` "
"closures, `gen` closures, `async gen` closures, etc.) return opaque types "
"that capture both _values_ and _generic parameters_ from the outer scope."
msgstr ""

#: src/3617-precise-capturing.md:983
msgid "Specifying captured generics for closures-like blocks"
msgstr ""

#: src/3617-precise-capturing.md:985
msgid ""
"The capturing of outer generics in closure-like blocks can lead to "
"overcapturing, as in [\\#65442](https://github.com/rust-lang/rust/"
"issues/65442).  Consider:"
msgstr ""

#: src/3617-precise-capturing.md:997
msgid ""
"//~^ ERROR type parameter `T` is part of concrete type but not\n"
"    //~|       used in parameter list for the `impl Trait` type alias\n"
msgstr ""

#: src/3617-precise-capturing.md:1003
msgid ""
"Here, the opaque type of the closure is capturing `T`.  We may want a way to "
"specify which outer generic parameters are captured by closure-like blocks.  "
"We could apply the `use<..>` syntax to closure-like blocks to solve this, e."
"g.:"
msgstr ""

#: src/3617-precise-capturing.md:1015
msgid ""
"//  ^^^^^^^^^^^\n"
"    //  ^ Captures no generic parameters.\n"
msgstr ""

#: src/3617-precise-capturing.md:1021 src/3617-precise-capturing.md:1063
msgid ""
"We leave this to future work, but this demonstrates how the `use<..>` syntax "
"can scale to solve other problems."
msgstr ""

#: src/3617-precise-capturing.md:1025
msgid "Specifying captured values for closure-like blocks"
msgstr ""

#: src/3617-precise-capturing.md:1027
msgid ""
"Closure-like blocks capture values either by _moving_ them or by "
"_referencing_ them.  How Rust decides whether values should be captured by "
"move or by reference is implicit and can be a bit subtle.  E.g., this works:"
msgstr ""

#: src/3617-precise-capturing.md:1035
msgid "...but this does not:"
msgstr ""

#: src/3617-precise-capturing.md:1039
msgid "//~^ ERROR may outlive borrowed value `x`\n"
msgstr ""

#: src/3617-precise-capturing.md:1044
msgid ""
"While in simple cases like this we can apply `move` to the entire closure-"
"like block to get the result that we want, in other cases other techniques "
"are needed."
msgstr ""

#: src/3617-precise-capturing.md:1046
msgid ""
"We might want a syntax for specifying which values are captured by the "
"closure-like block and how each value is captured.  We could apply the `use` "
"syntax to solve this.  E.g.:"
msgstr ""

#: src/3617-precise-capturing.md:1051
msgid ""
"//      ^  ^^^^^  ^^^^^^^^^\n"
"        //      |  |      ^ Captures `c` by mutable reference.\n"
"        //      |  ^ Captures `b` by immutable reference.\n"
"        //      ^ Captures `a` by move.\n"
msgstr ""

#: src/3617-precise-capturing.md:1061
msgid ""
"This could be combined with specifying which outer generic parameters to "
"capture, e.g. with `use<A, B, C>(a, ref b, ref mut c)`."
msgstr ""
