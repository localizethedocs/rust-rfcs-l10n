msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:05Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2873-inline-asm.md:1
msgid "Feature Name: `asm`"
msgstr ""

#: src/2873-inline-asm.md:2
msgid "Start Date: 2020-01-13"
msgstr ""

#: src/2873-inline-asm.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2873](https://github.com/rust-lang/rfcs/pull/2873)"
msgstr ""

#: src/2873-inline-asm.md:4
msgid ""
"Rust Issue: [rust-lang/rust#72016](https://github.com/rust-lang/rust/"
"issues/72016)"
msgstr ""

#: src/2873-inline-asm.md:5
msgid ""
"Project group repository: [rust-lang/project-inline-asm](https://github.com/"
"rust-lang/project-inline-asm)"
msgstr ""

#: src/2873-inline-asm.md:7
msgid "Summary"
msgstr ""

#: src/2873-inline-asm.md:10
msgid ""
"This RFC specifies a new syntax for inline assembly which is suitable for "
"eventual stabilization."
msgstr ""

#: src/2873-inline-asm.md:12
msgid ""
"The initial implementation of this feature will focus on the ARM, x86 and "
"RISC-V architectures. Support for more architectures will be added based on "
"user demand."
msgstr ""

#: src/2873-inline-asm.md:14
msgid ""
"The transition from the existing `asm!` macro is described in RFC [2843]"
"(https://github.com/rust-lang/rfcs/pull/2843). The existing `asm!` macro "
"will be renamed to `llvm_asm!` to provide an easy way to maintain backwards-"
"compatibility with existing code using inline asm. However `llvm_asm!` is "
"not intended to ever be stabilized."
msgstr ""

#: src/2873-inline-asm.md:18
msgid "Motivation"
msgstr ""

#: src/2873-inline-asm.md:21
msgid ""
"In systems programming some tasks require dropping down to the assembly "
"level. The primary reasons are for performance, precise timing, and low "
"level hardware access. Using inline assembly for this is sometimes "
"convenient, and sometimes necessary to avoid function call overhead."
msgstr ""

#: src/2873-inline-asm.md:23
msgid ""
"The inline assembler syntax currently available in nightly Rust is very ad-"
"hoc. It provides a thin wrapper over the inline assembly syntax available in "
"LLVM IR. For stabilization a more user-friendly syntax that lends itself to "
"implementation across various backends is preferable."
msgstr ""

#: src/2873-inline-asm.md:25
msgid ""
"Inline assembly is widely used in the Rust community and is one of the top "
"reasons keeping people on the nightly toolchain. Examples of crates using "
"inline assembly include `cortex-m`, `x86`, `riscv`, `parking_lot`, "
"`libprobe`, `msp430`, etc. A collection of use cases for inline asm can also "
"be found in [this repository](https://github.com/bjorn3/"
"inline_asm_catalogue/)."
msgstr ""

#: src/2873-inline-asm.md:29
msgid "Guide-level explanation"
msgstr ""

#: src/2873-inline-asm.md:32
msgid ""
"Rust provides support for inline assembly via the `asm!` macro. It can be "
"used to embed handwritten assembly in the assembly output generated by the "
"compiler. Generally this should not be necessary, but might be where the "
"required performance or timing cannot be otherwise achieved. Accessing low "
"level hardware primitives, e.g. in kernel code, may also demand this "
"functionality."
msgstr ""

#: src/2873-inline-asm.md:37
msgid ""
"**Note**: the examples here are given in x86/x86-64 assembly, but ARM, "
"AArch64 and RISC-V are also supported."
msgstr ""

#: src/2873-inline-asm.md:39
msgid "Basic usage"
msgstr ""

#: src/2873-inline-asm.md:41
msgid "Let us start with the simplest possible example:"
msgstr ""

#: src/2873-inline-asm.md:45
msgid "\"nop\""
msgstr ""

#: src/2873-inline-asm.md:49
msgid ""
"This will insert a NOP (no operation) instruction into the assembly "
"generated by the compiler. Note that all `asm!` invocations have to be "
"inside an `unsafe` block, as they could insert arbitrary instructions and "
"break various invariants. The instructions to be inserted are listed in the "
"first argument of the `asm!` macro as a string literal."
msgstr ""

#: src/2873-inline-asm.md:54
msgid "Inputs and outputs"
msgstr ""

#: src/2873-inline-asm.md:56
msgid ""
"Now inserting an instruction that does nothing is rather boring. Let us do "
"something that actually acts on data:"
msgstr ""

#: src/2873-inline-asm.md:62
msgid "\"mov {}, 5\""
msgstr ""

#: src/2873-inline-asm.md:67
msgid ""
"This will write the value `5` into the `u64` variable `x`. You can see that "
"the string literal we use to specify instructions is actually a template "
"string. It is governed by the same rules as Rust [format strings](https://"
"doc.rust-lang.org/std/fmt/#syntax). The arguments that are inserted into the "
"template however look a bit different then you may be familiar with. First "
"we need to specify if the variable is an input or an output of the inline "
"assembly. In this case it is an output. We declared this by writing `out`. "
"We also need to specify in what kind of register the assembly expects the "
"variable. In this case we put it in an arbitrary general purpose register by "
"specifying `reg`. The compiler will choose an appropriate register to insert "
"into the template and will read the variable from there after the inline "
"assembly finishes executing."
msgstr ""

#: src/2873-inline-asm.md:78
msgid "Let us see another example that also uses an input:"
msgstr ""

#: src/2873-inline-asm.md:85
msgid "\"mov {0}, {1}\""
msgstr ""

#: src/2873-inline-asm.md:86 src/2873-inline-asm.md:122
#: src/2873-inline-asm.md:136
msgid "\"add {0}, {number}\""
msgstr ""

#: src/2873-inline-asm.md:95
msgid ""
"This will add `5` to the input in variable `i` and write the result to "
"variable `o`. The particular way this assembly does this is first copying "
"the value from `i` to the output, and then adding `5` to it."
msgstr ""

#: src/2873-inline-asm.md:99
msgid "The example shows a few things:"
msgstr ""

#: src/2873-inline-asm.md:101
msgid ""
"First, we can see that `asm!` allows multiple template string arguments; "
"each one is treated as a separate line of assembly code, as if they were all "
"joined together with newlines between them. This makes it easy to format "
"assembly code."
msgstr ""

#: src/2873-inline-asm.md:106
msgid ""
"Second, we can see that inputs are declared by writing `in` instead of `out`."
msgstr ""

#: src/2873-inline-asm.md:108
msgid ""
"Third, one of our operands has a type we haven't seen yet, `const`. This "
"tells the compiler to expand this argument to value directly inside the "
"assembly template. This is only possible for constants and literals."
msgstr ""

#: src/2873-inline-asm.md:112
msgid ""
"Fourth, we can see that we can specify an argument number, or name as in any "
"format string. For inline assembly templates this is particularly useful as "
"arguments are often used more than once. For more complex inline assembly "
"using this facility is generally recommended, as it improves readability, "
"and allows reordering instructions without changing the argument order."
msgstr ""

#: src/2873-inline-asm.md:117
msgid "We can further refine the above example to avoid the `mov` instruction:"
msgstr ""

#: src/2873-inline-asm.md:127
msgid ""
"We can see that `inout` is used to specify an argument that is both input "
"and output. This is different from specifying an input and output separately "
"in that it is guaranteed to assign both to the same register."
msgstr ""

#: src/2873-inline-asm.md:130
msgid ""
"It is also possible to specify different variables for the input and output "
"parts of an `inout` operand:"
msgstr ""

#: src/2873-inline-asm.md:141
msgid "Late output operands"
msgstr ""

#: src/2873-inline-asm.md:143
msgid ""
"The Rust compiler is conservative with its allocation of operands. It is "
"assumed that an `out` can be written at any time, and can therefore not "
"share its location with any other argument. However, to guarantee optimal "
"performance it is important to use as few registers as possible, so they "
"won't have to be saved and reloaded around the inline assembly block. To "
"achieve this Rust provides a `lateout` specifier. This can be used on any "
"output that is written only after all inputs have been consumed. There is "
"also a `inlateout` variant of this specifier."
msgstr ""

#: src/2873-inline-asm.md:151
msgid "Here is an example where `inlateout` _cannot_ be used:"
msgstr ""

#: src/2873-inline-asm.md:159 src/2873-inline-asm.md:177
#: src/2873-inline-asm.md:354
msgid "\"add {0}, {1}\""
msgstr ""

#: src/2873-inline-asm.md:160
msgid "\"add {0}, {2}\""
msgstr ""

#: src/2873-inline-asm.md:169
msgid ""
"Here the compiler is free to allocate the same register for inputs `b` and "
"`c` since it knows they have the same value. However it must allocate a "
"separate register for `a` since it uses `inout` and not `inlateout`. If "
"`inlateout` was used, then `a` and `c` could be allocated to the same "
"register, in which case the first instruction to overwrite the value of `c` "
"and cause the assembly code to produce the wrong result."
msgstr ""

#: src/2873-inline-asm.md:171
msgid ""
"However the following example can use `inlateout` since the output is only "
"modified after all input registers have been read:"
msgstr ""

#: src/2873-inline-asm.md:182
msgid ""
"As you can see, this assembly fragment will still work correctly if `a` and "
"`b` are assigned to the same register."
msgstr ""

#: src/2873-inline-asm.md:184
msgid "Explicit register operands"
msgstr ""

#: src/2873-inline-asm.md:186
msgid ""
"Some instructions require that the operands be in a specific register. "
"Therefore, Rust inline assembly provides some more specific constraint "
"specifiers. While `reg` is generally available on any architecture, these "
"are highly architecture specific. E.g. for x86 the general purpose registers "
"`eax`, `ebx`, `ecx`, `edx`, `ebp`, `esi`, and `edi` among others can be "
"addressed by their name."
msgstr ""

#: src/2873-inline-asm.md:194
msgid "\"out 0x64, eax\""
msgstr ""

#: src/2873-inline-asm.md:194 src/2873-inline-asm.md:249
msgid "\"eax\""
msgstr ""

#: src/2873-inline-asm.md:198
msgid ""
"In this example we call the `out` instruction to output the content of the "
"`cmd` variable to port `0x64`. Since the `out` instruction only accepts "
"`eax` (and its sub registers) as operand we had to use the `eax` constraint "
"specifier."
msgstr ""

#: src/2873-inline-asm.md:202
msgid ""
"Note that unlike other operand types, explicit register operands cannot be "
"used in the template string: you can't use `{}` and should write the "
"register name directly instead. Also, they must appear at the end of the "
"operand list after all other operand types."
msgstr ""

#: src/2873-inline-asm.md:204
msgid "Consider this example which uses the x86 `mul` instruction:"
msgstr ""

#: src/2873-inline-asm.md:213
msgid ""
"// The x86 mul instruction takes rax as an implicit input and writes\n"
"            // the 128-bit result of the multiplication to rax:rdx.\n"
"            \"mul {}\""
msgstr ""

#: src/2873-inline-asm.md:217 src/2873-inline-asm.md:304
#: src/2873-inline-asm.md:990
msgid "\"rax\""
msgstr ""

#: src/2873-inline-asm.md:218 src/2873-inline-asm.md:304
#: src/2873-inline-asm.md:990
msgid "\"rdx\""
msgstr ""

#: src/2873-inline-asm.md:226
msgid ""
"This uses the `mul` instruction to multiply two 64-bit inputs with a 128-bit "
"result. The only explicit operand is a register, that we fill from the "
"variable `a`. The second operand is implicit, and must be the `rax` "
"register, which we fill from the variable `b`. The lower 64 bits of the "
"result are stored in `rax` from which we fill the variable `lo`. The higher "
"64 bits are stored in `rdx` from which we fill the variable `hi`."
msgstr ""

#: src/2873-inline-asm.md:232
msgid "Clobbered registers"
msgstr ""

#: src/2873-inline-asm.md:234
msgid ""
"In many cases inline assembly will modify state that is not needed as an "
"output. Usually this is either because we have to use a scratch register in "
"the assembly, or instructions modify state that we don't need to further "
"examine. This state is generally referred to as being \"clobbered\". We need "
"to tell the compiler about this since it may need to save and restore this "
"state around the inline assembly block."
msgstr ""

#: src/2873-inline-asm.md:247 src/2873-inline-asm.md:870
msgid "\"cpuid\""
msgstr ""

#: src/2873-inline-asm.md:248
msgid "// EAX 4 selects the \"Deterministic Cache Parameters\" CPUID leaf\n"
msgstr ""

#: src/2873-inline-asm.md:250
msgid "// ECX 0 selects the L0 cache information.\n"
msgstr ""

#: src/2873-inline-asm.md:251
msgid "\"ecx\""
msgstr ""

#: src/2873-inline-asm.md:252
msgid "\"ebx\""
msgstr ""

#: src/2873-inline-asm.md:253
msgid "\"edx\""
msgstr ""

#: src/2873-inline-asm.md:258
msgid "\"L1 Cache: {}\""
msgstr ""

#: src/2873-inline-asm.md:263
msgid ""
"In the example above we use the `cpuid` instruction to get the L1 cache "
"size. This instruction writes to `eax`, `ebx`, `ecx`, and `edx`, but for the "
"cache size we only care about the contents of `ebx` and `ecx`."
msgstr ""

#: src/2873-inline-asm.md:266
msgid ""
"However we still need to tell the compiler that `eax` and `edx` have been "
"modified so that it can save any values that were in these registers before "
"the asm. This is done by declaring these as outputs but with `_` instead of "
"a variable name, which indicates that the output value is to be discarded."
msgstr ""

#: src/2873-inline-asm.md:268
msgid ""
"This can also be used with a general register class (e.g. `reg`) to obtain a "
"scratch register for use inside the asm code:"
msgstr ""

#: src/2873-inline-asm.md:271
msgid "// Multiply x by 6 using shifts and adds\n"
msgstr ""

#: src/2873-inline-asm.md:275
msgid "\"mov {tmp}, {x}\""
msgstr ""

#: src/2873-inline-asm.md:276
msgid "\"shl {tmp}, 1\""
msgstr ""

#: src/2873-inline-asm.md:277
msgid "\"shl {x}, 2\""
msgstr ""

#: src/2873-inline-asm.md:278
msgid "\"add {x}, {tmp}\""
msgstr ""

#: src/2873-inline-asm.md:286
msgid "Symbol operands"
msgstr ""

#: src/2873-inline-asm.md:288
msgid ""
"A special operand type, `sym`, allows you to use the symbol name of a `fn` "
"or `static` in inline assembly code. This allows you to call a function or "
"access a global variable without needing to keep its address in a register."
msgstr ""

#: src/2873-inline-asm.md:292 src/2873-inline-asm.md:777
msgid "\"C\""
msgstr ""

#: src/2873-inline-asm.md:293
msgid "\"arg = {}\""
msgstr ""

#: src/2873-inline-asm.md:299
msgid "\"call {}\""
msgstr ""

#: src/2873-inline-asm.md:301
msgid "// 1st argument in rdi, which is caller-saved\n"
msgstr ""

#: src/2873-inline-asm.md:302
msgid "\"rdi\""
msgstr ""

#: src/2873-inline-asm.md:303
msgid "// All caller-saved registers must be marked as clobberred\n"
msgstr ""

#: src/2873-inline-asm.md:304
msgid "\"rcx\""
msgstr ""

#: src/2873-inline-asm.md:304
msgid "\"rsi\""
msgstr ""

#: src/2873-inline-asm.md:305
msgid "\"r8\""
msgstr ""

#: src/2873-inline-asm.md:305
msgid "\"r9\""
msgstr ""

#: src/2873-inline-asm.md:305
msgid "\"r10\""
msgstr ""

#: src/2873-inline-asm.md:305
msgid "\"r11\""
msgstr ""

#: src/2873-inline-asm.md:306
msgid "\"xmm0\""
msgstr ""

#: src/2873-inline-asm.md:306
msgid "\"xmm1\""
msgstr ""

#: src/2873-inline-asm.md:306
msgid "\"xmm2\""
msgstr ""

#: src/2873-inline-asm.md:306
msgid "\"xmm3\""
msgstr ""

#: src/2873-inline-asm.md:307
msgid "\"xmm4\""
msgstr ""

#: src/2873-inline-asm.md:307
msgid "\"xmm5\""
msgstr ""

#: src/2873-inline-asm.md:307
msgid "\"xmm6\""
msgstr ""

#: src/2873-inline-asm.md:307
msgid "\"xmm7\""
msgstr ""

#: src/2873-inline-asm.md:308
msgid "\"xmm8\""
msgstr ""

#: src/2873-inline-asm.md:308
msgid "\"xmm9\""
msgstr ""

#: src/2873-inline-asm.md:308
msgid "\"xmm10\""
msgstr ""

#: src/2873-inline-asm.md:308
msgid "\"xmm11\""
msgstr ""

#: src/2873-inline-asm.md:309
msgid "\"xmm12\""
msgstr ""

#: src/2873-inline-asm.md:309
msgid "\"xmm13\""
msgstr ""

#: src/2873-inline-asm.md:309
msgid "\"xmm14\""
msgstr ""

#: src/2873-inline-asm.md:309
msgid "\"xmm15\""
msgstr ""

#: src/2873-inline-asm.md:315
msgid ""
"Note that the `fn` or `static` item does not need to be public or "
"`#[no_mangle]`: the compiler will automatically insert the appropriate "
"mangled symbol name into the assembly code."
msgstr ""

#: src/2873-inline-asm.md:318
msgid "Register template modifiers"
msgstr ""

#: src/2873-inline-asm.md:320
msgid ""
"In some cases, fine control is needed over the way a register name is "
"formatted when inserted into the template string. This is needed when an "
"architecture's assembly language has several names for the same register, "
"each typically being a \"view\" over a subset of the register (e.g. the low "
"32 bits of a 64-bit register)."
msgstr ""

#: src/2873-inline-asm.md:322
msgid ""
"By default the compiler will always choose the name that refers to the full "
"register size (e.g. `rax` on x86-64, `eax` on x86, etc)."
msgstr ""

#: src/2873-inline-asm.md:324
msgid ""
"This default can be overridden by using modifiers on the template string "
"operands, just like you would with format strings:"
msgstr ""

#: src/2873-inline-asm.md:330
msgid "\"mov {0:h}, {0:l}\""
msgstr ""

#: src/2873-inline-asm.md:336
msgid ""
"In this example, we use the `reg_abcd` register class to restrict the "
"register allocator to the 4 legacy x86 register (`ax`, `bx`, `cx`, `dx`) of "
"which the first two bytes can be addressed independently."
msgstr ""

#: src/2873-inline-asm.md:338
msgid ""
"Let us assume that the register allocator has chosen to allocate `x` in the "
"`ax` register. The `h` modifier will emit the register name for the high "
"byte of that register and the `l` modifier will emit the register name for "
"the low byte. The asm code will therefore be expanded as `mov ah, al` which "
"copies the low byte of the value into the high byte."
msgstr ""

#: src/2873-inline-asm.md:341
msgid ""
"If you use a smaller data type (e.g. `u16`) with an operand and forget the "
"use template modifiers, the compiler will emit a warning and suggest the "
"correct modifier to use."
msgstr ""

#: src/2873-inline-asm.md:343 src/2873-inline-asm.md:656
msgid "Options"
msgstr ""

#: src/2873-inline-asm.md:345
msgid ""
"By default, an inline assembly block is treated the same way as an external "
"FFI function call with a custom calling convention: it may read/write "
"memory, have observable side effects, etc. However in many cases, it is "
"desirable to give the compiler more information about what the assembly code "
"is actually doing so that it can optimize better."
msgstr ""

#: src/2873-inline-asm.md:347
msgid "Let's take our previous example of an `add` instruction:"
msgstr ""

#: src/2873-inline-asm.md:362
msgid ""
"Options can be provided as an optional final argument to the `asm!` macro. "
"We specified three options here:"
msgstr ""

#: src/2873-inline-asm.md:363
msgid ""
"`pure` means that the asm code has no observable side effects and that its "
"output depends only on its inputs. This allows the compiler optimizer to "
"call the inline asm fewer times or even eliminate it entirely."
msgstr ""

#: src/2873-inline-asm.md:364
msgid ""
"`nomem` means that the asm code does not read or write to memory. By default "
"the compiler will assume that inline assembly can read or write any memory "
"address that is accessible to it (e.g. through a pointer passed as an "
"operand, or a global)."
msgstr ""

#: src/2873-inline-asm.md:365
msgid ""
"`nostack` means that the asm code does not push any data onto the stack. "
"This allows the compiler to use optimizations such as the stack red zone on "
"x86-64 to avoid stack pointer adjustments."
msgstr ""

#: src/2873-inline-asm.md:367
msgid ""
"These allow the compiler to better optimize code using `asm!`, for example "
"by eliminating pure `asm!` blocks whose outputs are not needed."
msgstr ""

#: src/2873-inline-asm.md:369
msgid ""
"See the reference for the full list of available options and their effects."
msgstr ""

#: src/2873-inline-asm.md:371
msgid "Reference-level explanation"
msgstr ""

#: src/2873-inline-asm.md:374
msgid ""
"Inline assembler is implemented as an unsafe macro `asm!()`. The first "
"argument to this macro is a template string literal used to build the final "
"assembly. Additional template string literal arguments may be provided; all "
"of the template string arguments are interpreted as if concatenated into a "
"single template string with `\\n` between them. The following arguments "
"specify input and output operands. When required, options are specified as "
"the final argument."
msgstr ""

#: src/2873-inline-asm.md:380
msgid "The following ABNF specifies the general syntax:"
msgstr ""

#: src/2873-inline-asm.md:382
msgid ""
"```\n"
"dir_spec := \"in\" / \"out\" / \"lateout\" / \"inout\" / \"inlateout\"\n"
"reg_spec := <register class> / \"<explicit register>\"\n"
"operand_expr := expr / \"_\" / expr \"=>\" expr / expr \"=>\" \"_\"\n"
"reg_operand := dir_spec \"(\" reg_spec \")\" operand_expr\n"
"operand := reg_operand / \"const\" const_expr / \"sym\" path\n"
"option := \"pure\" / \"nomem\" / \"readonly\" / \"preserves_flags\" / "
"\"noreturn\" / \"nostack\" / \"att_syntax\"\n"
"options := \"options(\" option *[\",\" option] [\",\"] \")\"\n"
"asm := \"asm!(\" format_string *(\",\" format_string) *(\",\" [ident \"=\"] "
"operand) [\",\" options] [\",\"] \")\"\n"
"```"
msgstr ""

#: src/2873-inline-asm.md:393
msgid ""
"The macro will initially be supported only on ARM, AArch64, x86, x86-64 and "
"RISC-V targets. Support for more targets may be added in the future. The "
"compiler will emit an error if `asm!` is used on an unsupported target."
msgstr ""

#: src/2873-inline-asm.md:397
msgid "Template string arguments"
msgstr ""

#: src/2873-inline-asm.md:399
msgid ""
"The assembler template uses the same syntax as [format strings](https://doc."
"rust-lang.org/std/fmt/#syntax) (i.e. placeholders are specified by curly "
"braces). The corresponding arguments are accessed in order, by index, or by "
"name. However, implicit named arguments (introduced by [RFC #2795](https://"
"github.com/rust-lang/rfcs/pull/2795)) are not supported."
msgstr ""

#: src/2873-inline-asm.md:401
msgid ""
"An `asm!` invocation may have one or more template string arguments; an `asm!"
"` with multiple template string arguments is treated as if all the strings "
"were concatenated with a `\\n` between them. The expected usage is for each "
"template string argument to correspond to a line of assembly code. All "
"template string arguments must appear before any other arguments."
msgstr ""

#: src/2873-inline-asm.md:403
msgid ""
"As with format strings, named arguments must appear after positional "
"arguments. Explicit register operands must appear at the end of the operand "
"list, after named arguments if any."
msgstr ""

#: src/2873-inline-asm.md:405
msgid ""
"Explicit register operands cannot be used by placeholders in the template "
"string. All other named and positional operands must appear at least once in "
"the template string, otherwise a compiler error is generated."
msgstr ""

#: src/2873-inline-asm.md:407
msgid ""
"The exact assembly code syntax is target-specific and opaque to the compiler "
"except for the way operands are substituted into the template string to form "
"the code passed to the assembler."
msgstr ""

#: src/2873-inline-asm.md:409
msgid ""
"The 4 targets specified in this RFC (x86, ARM, AArch64, RISC-V) all use the "
"assembly code syntax of the GNU assembler (GAS). On x86, the `.intel_syntax "
"noprefix` mode of GAS is used by default. On ARM, the `.syntax unified` mode "
"is used. These targets impose an additional restriction on the assembly "
"code: any assembler state (e.g. the current section which can be changed "
"with `.section`) must be restored to its original value at the end of the "
"asm string. Assembly code that does not conform to the GAS syntax will "
"result in assembler-specific behavior."
msgstr ""

#: src/2873-inline-asm.md:413
msgid "Operand type"
msgstr ""

#: src/2873-inline-asm.md:415
msgid "Several types of operands are supported:"
msgstr ""

#: src/2873-inline-asm.md:417
msgid "`in(<reg>) <expr>`"
msgstr ""

#: src/2873-inline-asm.md:418 src/2873-inline-asm.md:422
#: src/2873-inline-asm.md:430
msgid ""
"`<reg>` can refer to a register class or an explicit register. The allocated "
"register name is substituted into the asm template string."
msgstr ""

#: src/2873-inline-asm.md:419 src/2873-inline-asm.md:431
msgid ""
"The allocated register will contain the value of `<expr>` at the start of "
"the asm code."
msgstr ""

#: src/2873-inline-asm.md:420
msgid ""
"The allocated register must contain the same value at the end of the asm "
"code (except if a `lateout` is allocated to the same register)."
msgstr ""

#: src/2873-inline-asm.md:421
msgid "`out(<reg>) <expr>`"
msgstr ""

#: src/2873-inline-asm.md:423
msgid ""
"The allocated register will contain an undefined value at the start of the "
"asm code."
msgstr ""

#: src/2873-inline-asm.md:424
msgid ""
"`<expr>` must be a (possibly uninitialized) place expression, to which the "
"contents of the allocated register is written to at the end of the asm code."
msgstr ""

#: src/2873-inline-asm.md:425
msgid ""
"An underscore (`_`) may be specified instead of an expression, which will "
"cause the contents of the register to be discarded at the end of the asm "
"code (effectively acting as a clobber)."
msgstr ""

#: src/2873-inline-asm.md:426
msgid "`lateout(<reg>) <expr>`"
msgstr ""

#: src/2873-inline-asm.md:427
msgid ""
"Identical to `out` except that the register allocator can reuse a register "
"allocated to an `in`."
msgstr ""

#: src/2873-inline-asm.md:428 src/2873-inline-asm.md:440
msgid ""
"You should only write to the register after all inputs are read, otherwise "
"you may clobber an input."
msgstr ""

#: src/2873-inline-asm.md:429
msgid "`inout(<reg>) <expr>`"
msgstr ""

#: src/2873-inline-asm.md:432
msgid ""
"`<expr>` must be a mutable initialized place expression, to which the "
"contents of the allocated register is written to at the end of the asm code."
msgstr ""

#: src/2873-inline-asm.md:433
msgid "`inout(<reg>) <in expr> => <out expr>`"
msgstr ""

#: src/2873-inline-asm.md:434
msgid ""
"Same as `inout` except that the initial value of the register is taken from "
"the value of `<in expr>`."
msgstr ""

#: src/2873-inline-asm.md:435
msgid ""
"`<out expr>` must be a (possibly uninitialized) place expression, to which "
"the contents of the allocated register is written to at the end of the asm "
"code."
msgstr ""

#: src/2873-inline-asm.md:436
msgid ""
"An underscore (`_`) may be specified instead of an expression for `<out "
"expr>`, which will cause the contents of the register to be discarded at the "
"end of the asm code (effectively acting as a clobber)."
msgstr ""

#: src/2873-inline-asm.md:437
msgid "`<in expr>` and `<out expr>` may have different types."
msgstr ""

#: src/2873-inline-asm.md:438
msgid "`inlateout(<reg>) <expr>` / `inlateout(<reg>) <in expr> => <out expr>`"
msgstr ""

#: src/2873-inline-asm.md:439
msgid ""
"Identical to `inout` except that the register allocator can reuse a register "
"allocated to an `in` (this can happen if the compiler knows the `in` has the "
"same initial value as the `inlateout`)."
msgstr ""

#: src/2873-inline-asm.md:441
msgid ""
"As with `inout`, `<out expr>` is allowed to be an underscore (`_`) which "
"discards the contents of the register at the end of the asm code."
msgstr ""

#: src/2873-inline-asm.md:442
msgid "`const <expr>`"
msgstr ""

#: src/2873-inline-asm.md:443
msgid "`<expr>` must be an integer or floating-point constant expression."
msgstr ""

#: src/2873-inline-asm.md:444
msgid ""
"The value of the expression is formatted as a string and substituted "
"directly into the asm template string."
msgstr ""

#: src/2873-inline-asm.md:445
msgid "`sym <path>`"
msgstr ""

#: src/2873-inline-asm.md:446
msgid "`<path>` must refer to a `fn` or `static`."
msgstr ""

#: src/2873-inline-asm.md:447
msgid ""
"A mangled symbol name referring to the item is substituted into the asm "
"template string."
msgstr ""

#: src/2873-inline-asm.md:448
msgid ""
"The substituted string does not include any modifiers (e.g. GOT, PLT, "
"relocations, etc)."
msgstr ""

#: src/2873-inline-asm.md:449
msgid ""
"`<path>` is allowed to point to a `#[thread_local]` static, in which case "
"the asm code can combine the symbol with relocations (e.g. `@plt`, `@TPOFF`) "
"to read from thread-local data."
msgstr ""

#: src/2873-inline-asm.md:451
msgid ""
"Operand expressions are evaluated from left to right, just like function "
"call arguments. After the `asm!` has executed, outputs are written to in "
"left to right order. This is significant if two outputs point to the same "
"place: that place will contain the value of the rightmost output."
msgstr ""

#: src/2873-inline-asm.md:453
msgid "Register operands"
msgstr ""

#: src/2873-inline-asm.md:455
msgid ""
"Input and output operands can be specified either as an explicit register or "
"as a register class from which the register allocator can select a register. "
"Explicit registers are specified as string literals (e.g. `\"eax\"`) while "
"register classes are specified as identifiers (e.g. `reg`). Using string "
"literals for register names enables support for architectures that use "
"special characters in register names, such as MIPS (`$0`, `$1`, etc)."
msgstr ""

#: src/2873-inline-asm.md:457
msgid ""
"Note that explicit registers treat register aliases (e.g. `r14` vs `lr` on "
"ARM) and smaller views of a register (e.g. `eax` vs `rax`) as equivalent to "
"the base register. It is a compile-time error to use the same explicit "
"register for two input operands or two output operands. Additionally, it is "
"also a compile-time error to use overlapping registers (e.g. ARM VFP) in "
"input operands or in output operands."
msgstr ""

#: src/2873-inline-asm.md:459
msgid "Only the following types are allowed as operands for inline assembly:"
msgstr ""

#: src/2873-inline-asm.md:460
msgid "Integers (signed and unsigned)"
msgstr ""

#: src/2873-inline-asm.md:461
msgid "Floating-point numbers"
msgstr ""

#: src/2873-inline-asm.md:462
msgid "Pointers (thin only)"
msgstr ""

#: src/2873-inline-asm.md:463
msgid "Function pointers"
msgstr ""

#: src/2873-inline-asm.md:464
msgid ""
"SIMD vectors (structs defined with `#[repr(simd)]` and which implement "
"`Copy`). This includes architecture-specific vector types defined in `std::"
"arch` such as `__m128` (x86) or `int8x16_t` (ARM)."
msgstr ""

#: src/2873-inline-asm.md:466
msgid "Here is the list of currently supported register classes:"
msgstr ""

#: src/2873-inline-asm.md:468 src/2873-inline-asm.md:503
#: src/2873-inline-asm.md:536 src/2873-inline-asm.md:586
#: src/2873-inline-asm.md:605
msgid "Architecture"
msgstr ""

#: src/2873-inline-asm.md:468 src/2873-inline-asm.md:503
#: src/2873-inline-asm.md:605
msgid "Register class"
msgstr ""

#: src/2873-inline-asm.md:468
msgid "Registers"
msgstr ""

#: src/2873-inline-asm.md:468
msgid "LLVM constraint code"
msgstr ""

#: src/2873-inline-asm.md:470 src/2873-inline-asm.md:471
#: src/2873-inline-asm.md:474 src/2873-inline-asm.md:475
#: src/2873-inline-asm.md:476 src/2873-inline-asm.md:477
#: src/2873-inline-asm.md:507 src/2873-inline-asm.md:508
#: src/2873-inline-asm.md:509 src/2873-inline-asm.md:510
#: src/2873-inline-asm.md:511 src/2873-inline-asm.md:512
#: src/2873-inline-asm.md:538 src/2873-inline-asm.md:539
#: src/2873-inline-asm.md:540 src/2873-inline-asm.md:541
#: src/2873-inline-asm.md:542 src/2873-inline-asm.md:543
#: src/2873-inline-asm.md:544 src/2873-inline-asm.md:545
#: src/2873-inline-asm.md:546 src/2873-inline-asm.md:547
#: src/2873-inline-asm.md:548 src/2873-inline-asm.md:549
#: src/2873-inline-asm.md:590 src/2873-inline-asm.md:591
#: src/2873-inline-asm.md:592 src/2873-inline-asm.md:593
#: src/2873-inline-asm.md:610 src/2873-inline-asm.md:611
#: src/2873-inline-asm.md:615 src/2873-inline-asm.md:616
#: src/2873-inline-asm.md:617 src/2873-inline-asm.md:618
#: src/2873-inline-asm.md:620 src/2873-inline-asm.md:621
#: src/2873-inline-asm.md:622 src/2873-inline-asm.md:623
#: src/2873-inline-asm.md:624 src/2873-inline-asm.md:625
#: src/2873-inline-asm.md:626 src/2873-inline-asm.md:627
#: src/2873-inline-asm.md:821
msgid "x86"
msgstr ""

#: src/2873-inline-asm.md:470 src/2873-inline-asm.md:478
#: src/2873-inline-asm.md:481 src/2873-inline-asm.md:492
#: src/2873-inline-asm.md:505 src/2873-inline-asm.md:506
#: src/2873-inline-asm.md:513 src/2873-inline-asm.md:515
#: src/2873-inline-asm.md:519 src/2873-inline-asm.md:520
#: src/2873-inline-asm.md:607 src/2873-inline-asm.md:608
#: src/2873-inline-asm.md:609 src/2873-inline-asm.md:610
#: src/2873-inline-asm.md:611 src/2873-inline-asm.md:612
#: src/2873-inline-asm.md:628 src/2873-inline-asm.md:629
#: src/2873-inline-asm.md:630 src/2873-inline-asm.md:638
#: src/2873-inline-asm.md:643
msgid "`reg`"
msgstr ""

#: src/2873-inline-asm.md:470
msgid "`ax`, `bx`, `cx`, `dx`, `si`, `di`, `r[8-15]` (x86-64 only)"
msgstr ""

#: src/2873-inline-asm.md:470 src/2873-inline-asm.md:478
#: src/2873-inline-asm.md:481 src/2873-inline-asm.md:492
#: src/2873-inline-asm.md:612 src/2873-inline-asm.md:619
msgid "`r`"
msgstr ""

#: src/2873-inline-asm.md:471 src/2873-inline-asm.md:613
#: src/2873-inline-asm.md:614 src/2873-inline-asm.md:615
#: src/2873-inline-asm.md:616 src/2873-inline-asm.md:617
#: src/2873-inline-asm.md:618 src/2873-inline-asm.md:619
msgid "`reg_abcd`"
msgstr ""

#: src/2873-inline-asm.md:471
msgid "`ax`, `bx`, `cx`, `dx`"
msgstr ""

#: src/2873-inline-asm.md:471
msgid "`Q`"
msgstr ""

#: src/2873-inline-asm.md:472 src/2873-inline-asm.md:505
#: src/2873-inline-asm.md:607 src/2873-inline-asm.md:613
msgid "x86-32"
msgstr ""

#: src/2873-inline-asm.md:472 src/2873-inline-asm.md:473
#: src/2873-inline-asm.md:507 src/2873-inline-asm.md:620
msgid "`reg_byte`"
msgstr ""

#: src/2873-inline-asm.md:472
msgid "`al`, `bl`, `cl`, `dl`, `ah`, `bh`, `ch`, `dh`"
msgstr ""

#: src/2873-inline-asm.md:472 src/2873-inline-asm.md:473
#: src/2873-inline-asm.md:608 src/2873-inline-asm.md:612
#: src/2873-inline-asm.md:614 src/2873-inline-asm.md:619
#: src/2873-inline-asm.md:637 src/2873-inline-asm.md:641
msgid "`q`"
msgstr ""

#: src/2873-inline-asm.md:473 src/2873-inline-asm.md:506
#: src/2873-inline-asm.md:608 src/2873-inline-asm.md:609
#: src/2873-inline-asm.md:612 src/2873-inline-asm.md:614
#: src/2873-inline-asm.md:619
msgid "x86-64"
msgstr ""

#: src/2873-inline-asm.md:473
msgid ""
"`al`, `bl`, `cl`, `dl`, `sil`, `dil`, `r[8-15]b`, `ah`\\*, `bh`\\*, `ch`\\*, "
"`dh`\\*"
msgstr ""

#: src/2873-inline-asm.md:474 src/2873-inline-asm.md:508
#: src/2873-inline-asm.md:621
msgid "`xmm_reg`"
msgstr ""

#: src/2873-inline-asm.md:474
msgid "`xmm[0-7]` (x86) `xmm[0-15]` (x86-64)"
msgstr ""

#: src/2873-inline-asm.md:474 src/2873-inline-asm.md:475
#: src/2873-inline-asm.md:480 src/2873-inline-asm.md:485
#: src/2873-inline-asm.md:488 src/2873-inline-asm.md:491
#: src/2873-inline-asm.md:610 src/2873-inline-asm.md:617
#: src/2873-inline-asm.md:621 src/2873-inline-asm.md:624
#: src/2873-inline-asm.md:628 src/2873-inline-asm.md:630
msgid "`x`"
msgstr ""

#: src/2873-inline-asm.md:475 src/2873-inline-asm.md:509
#: src/2873-inline-asm.md:622
msgid "`ymm_reg`"
msgstr ""

#: src/2873-inline-asm.md:475
msgid "`ymm[0-7]` (x86) `ymm[0-15]` (x86-64)"
msgstr ""

#: src/2873-inline-asm.md:476 src/2873-inline-asm.md:510
#: src/2873-inline-asm.md:623
msgid "`zmm_reg`"
msgstr ""

#: src/2873-inline-asm.md:476
msgid "`zmm[0-7]` (x86) `zmm[0-31]` (x86-64)"
msgstr ""

#: src/2873-inline-asm.md:476 src/2873-inline-asm.md:632
msgid "`v`"
msgstr ""

#: src/2873-inline-asm.md:477 src/2873-inline-asm.md:511
#: src/2873-inline-asm.md:512 src/2873-inline-asm.md:627
msgid "`kreg`"
msgstr ""

#: src/2873-inline-asm.md:477
msgid "`k[1-7]`"
msgstr ""

#: src/2873-inline-asm.md:477
msgid "`Yk`"
msgstr ""

#: src/2873-inline-asm.md:478 src/2873-inline-asm.md:479
#: src/2873-inline-asm.md:480 src/2873-inline-asm.md:513
#: src/2873-inline-asm.md:514 src/2873-inline-asm.md:550
#: src/2873-inline-asm.md:551 src/2873-inline-asm.md:552
#: src/2873-inline-asm.md:553 src/2873-inline-asm.md:554
#: src/2873-inline-asm.md:555 src/2873-inline-asm.md:594
#: src/2873-inline-asm.md:628 src/2873-inline-asm.md:629
#: src/2873-inline-asm.md:630 src/2873-inline-asm.md:631
#: src/2873-inline-asm.md:632 src/2873-inline-asm.md:633
#: src/2873-inline-asm.md:634 src/2873-inline-asm.md:635
#: src/2873-inline-asm.md:636 src/2873-inline-asm.md:637
#: src/2873-inline-asm.md:832
msgid "AArch64"
msgstr ""

#: src/2873-inline-asm.md:478
msgid "`x[0-28]`, `x30`"
msgstr ""

#: src/2873-inline-asm.md:479 src/2873-inline-asm.md:514
#: src/2873-inline-asm.md:631 src/2873-inline-asm.md:632
#: src/2873-inline-asm.md:633 src/2873-inline-asm.md:634
#: src/2873-inline-asm.md:635 src/2873-inline-asm.md:636
#: src/2873-inline-asm.md:637
msgid "`vreg`"
msgstr ""

#: src/2873-inline-asm.md:479 src/2873-inline-asm.md:555
msgid "`v[0-31]`"
msgstr ""

#: src/2873-inline-asm.md:479 src/2873-inline-asm.md:486
#: src/2873-inline-asm.md:489 src/2873-inline-asm.md:610
#: src/2873-inline-asm.md:617 src/2873-inline-asm.md:629
msgid "`w`"
msgstr ""

#: src/2873-inline-asm.md:480
msgid "`vreg_low16`"
msgstr ""

#: src/2873-inline-asm.md:480
msgid "`v[0-15]`"
msgstr ""

#: src/2873-inline-asm.md:481 src/2873-inline-asm.md:484
#: src/2873-inline-asm.md:485 src/2873-inline-asm.md:486
#: src/2873-inline-asm.md:487 src/2873-inline-asm.md:488
#: src/2873-inline-asm.md:489 src/2873-inline-asm.md:490
#: src/2873-inline-asm.md:491 src/2873-inline-asm.md:515
#: src/2873-inline-asm.md:516 src/2873-inline-asm.md:517
#: src/2873-inline-asm.md:518 src/2873-inline-asm.md:556
#: src/2873-inline-asm.md:557 src/2873-inline-asm.md:558
#: src/2873-inline-asm.md:559 src/2873-inline-asm.md:560
#: src/2873-inline-asm.md:561 src/2873-inline-asm.md:562
#: src/2873-inline-asm.md:563 src/2873-inline-asm.md:564
#: src/2873-inline-asm.md:595 src/2873-inline-asm.md:638
#: src/2873-inline-asm.md:639 src/2873-inline-asm.md:640
#: src/2873-inline-asm.md:641 src/2873-inline-asm.md:642
#: src/2873-inline-asm.md:825
msgid "ARM"
msgstr ""

#: src/2873-inline-asm.md:481 src/2873-inline-asm.md:483
msgid "`r[0-r10]`, `r12`, `r14`"
msgstr ""

#: src/2873-inline-asm.md:482
msgid "ARM (Thumb)"
msgstr ""

#: src/2873-inline-asm.md:482 src/2873-inline-asm.md:483
msgid "`reg_thumb`"
msgstr ""

#: src/2873-inline-asm.md:482
msgid "`r[0-r7]`"
msgstr ""

#: src/2873-inline-asm.md:482 src/2873-inline-asm.md:483
#: src/2873-inline-asm.md:609 src/2873-inline-asm.md:615
msgid "`l`"
msgstr ""

#: src/2873-inline-asm.md:483
msgid "ARM (ARM)"
msgstr ""

#: src/2873-inline-asm.md:484 src/2873-inline-asm.md:516
#: src/2873-inline-asm.md:639
msgid "`sreg`"
msgstr ""

#: src/2873-inline-asm.md:484
msgid "`s[0-31]`"
msgstr ""

#: src/2873-inline-asm.md:484 src/2873-inline-asm.md:487
#: src/2873-inline-asm.md:490 src/2873-inline-asm.md:622
#: src/2873-inline-asm.md:625
msgid "`t`"
msgstr ""

#: src/2873-inline-asm.md:485
msgid "`sreg_low16`"
msgstr ""

#: src/2873-inline-asm.md:485
msgid "`s[0-15]`"
msgstr ""

#: src/2873-inline-asm.md:486 src/2873-inline-asm.md:517
#: src/2873-inline-asm.md:640
msgid "`dreg`"
msgstr ""

#: src/2873-inline-asm.md:486
msgid "`d[0-31]`"
msgstr ""

#: src/2873-inline-asm.md:487
msgid "`dreg_low16`"
msgstr ""

#: src/2873-inline-asm.md:487
msgid "`d[0-15]`"
msgstr ""

#: src/2873-inline-asm.md:488
msgid "`dreg_low8`"
msgstr ""

#: src/2873-inline-asm.md:488
msgid "`d[0-8]`"
msgstr ""

#: src/2873-inline-asm.md:489 src/2873-inline-asm.md:518
#: src/2873-inline-asm.md:641 src/2873-inline-asm.md:642
msgid "`qreg`"
msgstr ""

#: src/2873-inline-asm.md:489
msgid "`q[0-15]`"
msgstr ""

#: src/2873-inline-asm.md:490
msgid "`qreg_low8`"
msgstr ""

#: src/2873-inline-asm.md:490
msgid "`q[0-7]`"
msgstr ""

#: src/2873-inline-asm.md:491
msgid "`qreg_low4`"
msgstr ""

#: src/2873-inline-asm.md:491
msgid "`q[0-3]`"
msgstr ""

#: src/2873-inline-asm.md:492 src/2873-inline-asm.md:493
#: src/2873-inline-asm.md:521 src/2873-inline-asm.md:522
#: src/2873-inline-asm.md:565 src/2873-inline-asm.md:566
#: src/2873-inline-asm.md:567 src/2873-inline-asm.md:568
#: src/2873-inline-asm.md:569 src/2873-inline-asm.md:570
#: src/2873-inline-asm.md:571 src/2873-inline-asm.md:572
#: src/2873-inline-asm.md:573 src/2873-inline-asm.md:574
#: src/2873-inline-asm.md:575 src/2873-inline-asm.md:576
#: src/2873-inline-asm.md:577 src/2873-inline-asm.md:578
#: src/2873-inline-asm.md:579 src/2873-inline-asm.md:580
#: src/2873-inline-asm.md:596 src/2873-inline-asm.md:597
#: src/2873-inline-asm.md:643 src/2873-inline-asm.md:644
#: src/2873-inline-asm.md:835
msgid "RISC-V"
msgstr ""

#: src/2873-inline-asm.md:492
msgid "`x1`, `x[5-7]`, `x[9-15]`, `x[16-31]` (non-RV32E)"
msgstr ""

#: src/2873-inline-asm.md:493 src/2873-inline-asm.md:521
#: src/2873-inline-asm.md:522 src/2873-inline-asm.md:644
msgid "`freg`"
msgstr ""

#: src/2873-inline-asm.md:493
msgid "`f[0-31]`"
msgstr ""

#: src/2873-inline-asm.md:493 src/2873-inline-asm.md:521
msgid "`f`"
msgstr ""

#: src/2873-inline-asm.md:495
msgid ""
"**Note**: On x86 we treat `reg_byte` differently from `reg` (and `reg_abcd`) "
"because the compiler can allocate `al` and `ah` separately whereas `reg` "
"reserves the whole register."
msgstr ""

#: src/2873-inline-asm.md:497
msgid ""
"**Note #2**: On x86-64 the high byte registers (e.g. `ah`) are only "
"available when used as an explicit register. Specifying the `reg_byte` "
"register class for an operand will always allocate a low byte register."
msgstr ""

#: src/2873-inline-asm.md:499
msgid ""
"Additional register classes may be added in the future based on demand (e.g. "
"MMX, x87, etc)."
msgstr ""

#: src/2873-inline-asm.md:501
msgid ""
"Each register class has constraints on which value types they can be used "
"with. This is necessary because the way a value is loaded into a register "
"depends on its type. For example, on big-endian systems, loading a `i32x4` "
"and a `i8x16` into a SIMD register may result in different register contents "
"even if the byte-wise memory representation of both values is identical. The "
"availability of supported types for a particular register class may depend "
"on what target features are currently enabled."
msgstr ""

#: src/2873-inline-asm.md:503
msgid "Target feature"
msgstr ""

#: src/2873-inline-asm.md:503
msgid "Allowed types"
msgstr ""

#: src/2873-inline-asm.md:505 src/2873-inline-asm.md:506
#: src/2873-inline-asm.md:507 src/2873-inline-asm.md:513
#: src/2873-inline-asm.md:515 src/2873-inline-asm.md:519
#: src/2873-inline-asm.md:520 src/2873-inline-asm.md:607
#: src/2873-inline-asm.md:608 src/2873-inline-asm.md:613
#: src/2873-inline-asm.md:614 src/2873-inline-asm.md:620
#: src/2873-inline-asm.md:621 src/2873-inline-asm.md:622
#: src/2873-inline-asm.md:623 src/2873-inline-asm.md:627
#: src/2873-inline-asm.md:628 src/2873-inline-asm.md:631
#: src/2873-inline-asm.md:632 src/2873-inline-asm.md:638
#: src/2873-inline-asm.md:639 src/2873-inline-asm.md:640
#: src/2873-inline-asm.md:641 src/2873-inline-asm.md:643
#: src/2873-inline-asm.md:644
msgid "None"
msgstr ""

#: src/2873-inline-asm.md:505
msgid "`i16`, `i32`, `f32`"
msgstr ""

#: src/2873-inline-asm.md:506
msgid "`i16`, `i32`, `f32`, `i64`, `f64`"
msgstr ""

#: src/2873-inline-asm.md:507
msgid "`i8`"
msgstr ""

#: src/2873-inline-asm.md:508
msgid "`sse`"
msgstr ""

#: src/2873-inline-asm.md:508
msgid ""
"`i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, "
"`f32x4`, `f64x2`"
msgstr ""

#: src/2873-inline-asm.md:509
msgid "`avx`"
msgstr ""

#: src/2873-inline-asm.md:509
msgid ""
"`i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, "
"`f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4`"
msgstr ""

#: src/2873-inline-asm.md:510
msgid "`avx512f`"
msgstr ""

#: src/2873-inline-asm.md:510
msgid ""
"`i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, "
"`f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4` "
"<br> `i8x64`, `i16x32`, `i32x16`, `i64x8`, `f32x16`, `f64x8`"
msgstr ""

#: src/2873-inline-asm.md:511
msgid "`axv512f`"
msgstr ""

#: src/2873-inline-asm.md:511
msgid "`i8`, `i16`"
msgstr ""

#: src/2873-inline-asm.md:512
msgid "`axv512bw`"
msgstr ""

#: src/2873-inline-asm.md:512
msgid "`i32`, `i64`"
msgstr ""

#: src/2873-inline-asm.md:513 src/2873-inline-asm.md:520
msgid "`i8`, `i16`, `i32`, `f32`, `i64`, `f64`"
msgstr ""

#: src/2873-inline-asm.md:514 src/2873-inline-asm.md:551
#: src/2873-inline-asm.md:560
msgid "`fp`"
msgstr ""

#: src/2873-inline-asm.md:514
msgid ""
"`i8`, `i16`, `i32`, `f32`, `i64`, `f64`, <br> `i8x8`, `i16x4`, `i32x2`, "
"`i64x1`, `f32x2`, `f64x1`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, "
"`f64x2`"
msgstr ""

#: src/2873-inline-asm.md:515 src/2873-inline-asm.md:519
msgid "`i8`, `i16`, `i32`, `f32`"
msgstr ""

#: src/2873-inline-asm.md:516 src/2873-inline-asm.md:517
msgid "`vfp2`"
msgstr ""

#: src/2873-inline-asm.md:516
msgid "`i32`, `f32`"
msgstr ""

#: src/2873-inline-asm.md:517
msgid "`i64`, `f64`, `i8x8`, `i16x4`, `i32x2`, `i64x1`, `f32x2`"
msgstr ""

#: src/2873-inline-asm.md:518
msgid "`neon`"
msgstr ""

#: src/2873-inline-asm.md:518
msgid "`i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`"
msgstr ""

#: src/2873-inline-asm.md:519
msgid "RISC-V32"
msgstr ""

#: src/2873-inline-asm.md:520
msgid "RISC-V64"
msgstr ""

#: src/2873-inline-asm.md:521
msgid "`f32`"
msgstr ""

#: src/2873-inline-asm.md:522 src/2873-inline-asm.md:636
msgid "`d`"
msgstr ""

#: src/2873-inline-asm.md:522
msgid "`f64`"
msgstr ""

#: src/2873-inline-asm.md:524
msgid ""
"**Note**: For the purposes of the above table, unsigned types `uN`, `isize`, "
"pointers and function pointers are treated as the equivalent integer type "
"(`i16`/`i32`/`i64` depending on the target)."
msgstr ""

#: src/2873-inline-asm.md:526
msgid ""
"**Note #2**: Registers not listed in the table above cannot be used as "
"operands for inline assembly."
msgstr ""

#: src/2873-inline-asm.md:528
msgid ""
"If a value is of a smaller size than the register it is allocated in then "
"the upper bits of that register will have an undefined value for inputs and "
"will be ignored for outputs. The only exception is the `freg` register class "
"on RISC-V where `f32` values are NaN-boxed in a `f64` as required by the "
"RISC-V architecture."
msgstr ""

#: src/2873-inline-asm.md:530
msgid ""
"When separate input and output expressions are specified for an `inout` "
"operand, both expressions must have the same type. The only exception is if "
"both operands are pointers or integers, in which case they are only required "
"to have the same size. This restriction exists because the register "
"allocators in LLVM and GCC sometimes cannot handle tied operands with "
"different types."
msgstr ""

#: src/2873-inline-asm.md:532
msgid "Register names"
msgstr ""

#: src/2873-inline-asm.md:534
msgid ""
"Some registers have multiple names. These are all treated by the compiler as "
"identical to the base register name. Here is the list of all supported "
"register aliases:"
msgstr ""

#: src/2873-inline-asm.md:536
msgid "Base register"
msgstr ""

#: src/2873-inline-asm.md:536
msgid "Aliases"
msgstr ""

#: src/2873-inline-asm.md:538 src/2873-inline-asm.md:610
#: src/2873-inline-asm.md:617
msgid "`ax`"
msgstr ""

#: src/2873-inline-asm.md:538
msgid "`eax`, `rax`"
msgstr ""

#: src/2873-inline-asm.md:539
msgid "`bx`"
msgstr ""

#: src/2873-inline-asm.md:539
msgid "`ebx`, `rbx`"
msgstr ""

#: src/2873-inline-asm.md:540
msgid "`cx`"
msgstr ""

#: src/2873-inline-asm.md:540
msgid "`ecx`, `rcx`"
msgstr ""

#: src/2873-inline-asm.md:541
msgid "`dx`"
msgstr ""

#: src/2873-inline-asm.md:541
msgid "`edx`, `rdx`"
msgstr ""

#: src/2873-inline-asm.md:542
msgid "`si`"
msgstr ""

#: src/2873-inline-asm.md:542
msgid "`esi`, `rsi`"
msgstr ""

#: src/2873-inline-asm.md:543
msgid "`di`"
msgstr ""

#: src/2873-inline-asm.md:543
msgid "`edi`, `rdi`"
msgstr ""

#: src/2873-inline-asm.md:544
msgid "`bp`"
msgstr ""

#: src/2873-inline-asm.md:544
msgid "`bpl`, `ebp`, `rbp`"
msgstr ""

#: src/2873-inline-asm.md:545 src/2873-inline-asm.md:553
#: src/2873-inline-asm.md:562 src/2873-inline-asm.md:567
#: src/2873-inline-asm.md:588
msgid "`sp`"
msgstr ""

#: src/2873-inline-asm.md:545
msgid "`spl`, `esp`, `rsp`"
msgstr ""

#: src/2873-inline-asm.md:546 src/2873-inline-asm.md:561
#: src/2873-inline-asm.md:591
msgid "`ip`"
msgstr ""

#: src/2873-inline-asm.md:546
msgid "`eip`, `rip`"
msgstr ""

#: src/2873-inline-asm.md:547
msgid "`st(0)`"
msgstr ""

#: src/2873-inline-asm.md:547
msgid "`st`"
msgstr ""

#: src/2873-inline-asm.md:548
msgid "`r[8-15]`"
msgstr ""

#: src/2873-inline-asm.md:548
msgid "`r[8-15]b`, `r[8-15]w`, `r[8-15]d`"
msgstr ""

#: src/2873-inline-asm.md:549
msgid "`xmm[0-31]`"
msgstr ""

#: src/2873-inline-asm.md:549
msgid "`ymm[0-31]`, `zmm[0-31]`"
msgstr ""

#: src/2873-inline-asm.md:550
msgid "`x[0-30]`"
msgstr ""

#: src/2873-inline-asm.md:550
msgid "`w[0-30]`"
msgstr ""

#: src/2873-inline-asm.md:551
msgid "`x29`"
msgstr ""

#: src/2873-inline-asm.md:552
msgid "`x30`"
msgstr ""

#: src/2873-inline-asm.md:552 src/2873-inline-asm.md:563
msgid "`lr`"
msgstr ""

#: src/2873-inline-asm.md:553
msgid "`wsp`"
msgstr ""

#: src/2873-inline-asm.md:554 src/2873-inline-asm.md:594
msgid "`xzr`"
msgstr ""

#: src/2873-inline-asm.md:554
msgid "`wzr`"
msgstr ""

#: src/2873-inline-asm.md:555
msgid "`b[0-31]`, `h[0-31]`, `s[0-31]`, `d[0-31]`, `q[0-31]`"
msgstr ""

#: src/2873-inline-asm.md:556
msgid "`r[0-3]`"
msgstr ""

#: src/2873-inline-asm.md:556
msgid "`a[1-4]`"
msgstr ""

#: src/2873-inline-asm.md:557
msgid "`r[4-9]`"
msgstr ""

#: src/2873-inline-asm.md:557
msgid "`v[1-6]`"
msgstr ""

#: src/2873-inline-asm.md:558
msgid "`r9`"
msgstr ""

#: src/2873-inline-asm.md:558
msgid "`rfp`"
msgstr ""

#: src/2873-inline-asm.md:559
msgid "`r10`"
msgstr ""

#: src/2873-inline-asm.md:559
msgid "`sl`"
msgstr ""

#: src/2873-inline-asm.md:560
msgid "`r11`"
msgstr ""

#: src/2873-inline-asm.md:561
msgid "`r12`"
msgstr ""

#: src/2873-inline-asm.md:562
msgid "`r13`"
msgstr ""

#: src/2873-inline-asm.md:563
msgid "`r14`"
msgstr ""

#: src/2873-inline-asm.md:564
msgid "`r15`"
msgstr ""

#: src/2873-inline-asm.md:564 src/2873-inline-asm.md:595
msgid "`pc`"
msgstr ""

#: src/2873-inline-asm.md:565 src/2873-inline-asm.md:596
#: src/2873-inline-asm.md:628 src/2873-inline-asm.md:630
msgid "`x0`"
msgstr ""

#: src/2873-inline-asm.md:565
msgid "`zero`"
msgstr ""

#: src/2873-inline-asm.md:566 src/2873-inline-asm.md:643
msgid "`x1`"
msgstr ""

#: src/2873-inline-asm.md:566
msgid "`ra`"
msgstr ""

#: src/2873-inline-asm.md:567
msgid "`x2`"
msgstr ""

#: src/2873-inline-asm.md:568
msgid "`x3`"
msgstr ""

#: src/2873-inline-asm.md:568
msgid "`gp`"
msgstr ""

#: src/2873-inline-asm.md:569
msgid "`x4`"
msgstr ""

#: src/2873-inline-asm.md:569
msgid "`tp`"
msgstr ""

#: src/2873-inline-asm.md:570
msgid "`x[5-7]`"
msgstr ""

#: src/2873-inline-asm.md:570
msgid "`t[0-2]`"
msgstr ""

#: src/2873-inline-asm.md:571
msgid "`x8`"
msgstr ""

#: src/2873-inline-asm.md:571
msgid "`fp`, `s0`"
msgstr ""

#: src/2873-inline-asm.md:572
msgid "`x9`"
msgstr ""

#: src/2873-inline-asm.md:572
msgid "`s1`"
msgstr ""

#: src/2873-inline-asm.md:573
msgid "`x[10-17]`"
msgstr ""

#: src/2873-inline-asm.md:573
msgid "`a[0-7]`"
msgstr ""

#: src/2873-inline-asm.md:574
msgid "`x[18-27]`"
msgstr ""

#: src/2873-inline-asm.md:574
msgid "`s[2-11]`"
msgstr ""

#: src/2873-inline-asm.md:575
msgid "`x[28-31]`"
msgstr ""

#: src/2873-inline-asm.md:575
msgid "`t[3-6]`"
msgstr ""

#: src/2873-inline-asm.md:576
msgid "`f[0-7]`"
msgstr ""

#: src/2873-inline-asm.md:576
msgid "`ft[0-7]`"
msgstr ""

#: src/2873-inline-asm.md:577
msgid "`f[8-9]`"
msgstr ""

#: src/2873-inline-asm.md:577
msgid "`fs[0-1]`"
msgstr ""

#: src/2873-inline-asm.md:578
msgid "`f[10-17]`"
msgstr ""

#: src/2873-inline-asm.md:578
msgid "`fa[0-7]`"
msgstr ""

#: src/2873-inline-asm.md:579
msgid "`f[18-27]`"
msgstr ""

#: src/2873-inline-asm.md:579
msgid "`fs[2-11]`"
msgstr ""

#: src/2873-inline-asm.md:580
msgid "`f[28-31]`"
msgstr ""

#: src/2873-inline-asm.md:580
msgid "`ft[8-11]`"
msgstr ""

#: src/2873-inline-asm.md:582
msgid ""
"**Note**: This table includes registers which are not usable as operands. "
"They are listed here purely for the purposes of compiler diagnostics."
msgstr ""

#: src/2873-inline-asm.md:584
msgid ""
"Registers not listed in the table of register classes cannot be used as "
"operands for inline assembly. This includes the following registers:"
msgstr ""

#: src/2873-inline-asm.md:586
msgid "Unsupported register"
msgstr ""

#: src/2873-inline-asm.md:586
msgid "Reason"
msgstr ""

#: src/2873-inline-asm.md:588 src/2873-inline-asm.md:589
msgid "All"
msgstr ""

#: src/2873-inline-asm.md:588
msgid ""
"The stack pointer must be restored to its original value at the end of an "
"asm code block."
msgstr ""

#: src/2873-inline-asm.md:589
msgid "`bp` (x86), `r11` (ARM), `x29` (AArch64), `x8` (RISC-V)"
msgstr ""

#: src/2873-inline-asm.md:589
msgid "The frame pointer cannot be used as an input or output."
msgstr ""

#: src/2873-inline-asm.md:590
msgid "`k0`"
msgstr ""

#: src/2873-inline-asm.md:590 src/2873-inline-asm.md:594
#: src/2873-inline-asm.md:596
msgid "This is a constant zero register which can't be modified."
msgstr ""

#: src/2873-inline-asm.md:591 src/2873-inline-asm.md:595
msgid "This is the program counter, not a real register."
msgstr ""

#: src/2873-inline-asm.md:592
msgid "`mm[0-7]`"
msgstr ""

#: src/2873-inline-asm.md:592
msgid "MMX registers are not currently supported (but may be in the future)."
msgstr ""

#: src/2873-inline-asm.md:593
msgid "`st([0-7])`"
msgstr ""

#: src/2873-inline-asm.md:593
msgid "x87 registers are not currently supported (but may be in the future)."
msgstr ""

#: src/2873-inline-asm.md:597
msgid "`gp`, `tp`"
msgstr ""

#: src/2873-inline-asm.md:597
msgid "These registers are reserved and cannot be used as inputs or outputs."
msgstr ""

#: src/2873-inline-asm.md:599
msgid "Template modifiers"
msgstr ""

#: src/2873-inline-asm.md:601
msgid ""
"The placeholders can be augmented by modifiers which are specified after the "
"`:` in the curly braces. These modifiers do not affect register allocation, "
"but change the way operands are formatted when inserted into the template "
"string. Only one modifier is allowed per template placeholder."
msgstr ""

#: src/2873-inline-asm.md:603
msgid ""
"The supported modifiers are a subset of LLVM's (and GCC's) [asm template "
"argument modifiers](http://llvm.org/docs/LangRef.html#asm-template-argument-"
"modifiers), but do not use the same letter codes."
msgstr ""

#: src/2873-inline-asm.md:605
msgid "Modifier"
msgstr ""

#: src/2873-inline-asm.md:605
msgid "Example output"
msgstr ""

#: src/2873-inline-asm.md:605
msgid "LLVM modifier"
msgstr ""

#: src/2873-inline-asm.md:607 src/2873-inline-asm.md:611
#: src/2873-inline-asm.md:613 src/2873-inline-asm.md:618
msgid "`eax`"
msgstr ""

#: src/2873-inline-asm.md:607 src/2873-inline-asm.md:611
#: src/2873-inline-asm.md:613 src/2873-inline-asm.md:618
msgid "`k`"
msgstr ""

#: src/2873-inline-asm.md:608 src/2873-inline-asm.md:612
#: src/2873-inline-asm.md:614 src/2873-inline-asm.md:619
msgid "`rax`"
msgstr ""

#: src/2873-inline-asm.md:609 src/2873-inline-asm.md:615
msgid "`al`"
msgstr ""

#: src/2873-inline-asm.md:609 src/2873-inline-asm.md:615
#: src/2873-inline-asm.md:633
msgid "`b`"
msgstr ""

#: src/2873-inline-asm.md:611 src/2873-inline-asm.md:618
msgid "`e`"
msgstr ""

#: src/2873-inline-asm.md:616 src/2873-inline-asm.md:634
msgid "`h`"
msgstr ""

#: src/2873-inline-asm.md:616
msgid "`ah`"
msgstr ""

#: src/2873-inline-asm.md:620
msgid "`al` / `ah`"
msgstr ""

#: src/2873-inline-asm.md:621 src/2873-inline-asm.md:624
msgid "`xmm0`"
msgstr ""

#: src/2873-inline-asm.md:622 src/2873-inline-asm.md:625
msgid "`ymm0`"
msgstr ""

#: src/2873-inline-asm.md:623 src/2873-inline-asm.md:626
msgid "`zmm0`"
msgstr ""

#: src/2873-inline-asm.md:623 src/2873-inline-asm.md:626
msgid "`g`"
msgstr ""

#: src/2873-inline-asm.md:624 src/2873-inline-asm.md:625
#: src/2873-inline-asm.md:626
msgid "`*mm_reg`"
msgstr ""

#: src/2873-inline-asm.md:625
msgid "`y`"
msgstr ""

#: src/2873-inline-asm.md:626
msgid "`z`"
msgstr ""

#: src/2873-inline-asm.md:627
msgid "`k1`"
msgstr ""

#: src/2873-inline-asm.md:629
msgid "`w0`"
msgstr ""

#: src/2873-inline-asm.md:631 src/2873-inline-asm.md:632
msgid "`v0`"
msgstr ""

#: src/2873-inline-asm.md:633
msgid "`b0`"
msgstr ""

#: src/2873-inline-asm.md:634
msgid "`h0`"
msgstr ""

#: src/2873-inline-asm.md:635
msgid "`s`"
msgstr ""

#: src/2873-inline-asm.md:635 src/2873-inline-asm.md:639
msgid "`s0`"
msgstr ""

#: src/2873-inline-asm.md:636 src/2873-inline-asm.md:640
msgid "`d0`"
msgstr ""

#: src/2873-inline-asm.md:637 src/2873-inline-asm.md:641
msgid "`q0`"
msgstr ""

#: src/2873-inline-asm.md:638
msgid "`r0`"
msgstr ""

#: src/2873-inline-asm.md:640
msgid "`P`"
msgstr ""

#: src/2873-inline-asm.md:642
msgid "`e` / `f`"
msgstr ""

#: src/2873-inline-asm.md:642
msgid "`d0` / `d1`"
msgstr ""

#: src/2873-inline-asm.md:644
msgid "`f0`"
msgstr ""

#: src/2873-inline-asm.md:646
msgid "**Notes**:"
msgstr ""

#: src/2873-inline-asm.md:647
msgid ""
"on ARM and AArch64, the `*_low` register classes have the same modifiers as "
"their base register class."
msgstr ""

#: src/2873-inline-asm.md:648
msgid ""
"on ARM `e` / `f`: this prints the low or high doubleword register name of a "
"NEON quad (128-bit) register."
msgstr ""

#: src/2873-inline-asm.md:649
msgid ""
"on x86: our behavior for `reg` with no modifiers differs from what GCC does. "
"GCC will infer the modifier based on the operand value type, while we "
"default to the full register size."
msgstr ""

#: src/2873-inline-asm.md:650
msgid ""
"on x86 `xmm_reg`: the `x`, `t` and `g` LLVM modifiers are not yet "
"implemented in LLVM (they are supported by GCC only), but this should be a "
"simple change."
msgstr ""

#: src/2873-inline-asm.md:652
msgid ""
"As stated in the previous section, passing an input value smaller than the "
"register width will result in the upper bits of the register containing "
"undefined values. This is not a problem if the inline asm only accesses the "
"lower bits of the register, which can be done by using a template modifier "
"to use a subregister name in the asm code (e.g. `ax` instead of `rax`). "
"Since this an easy pitfall, the compiler will suggest a template modifier to "
"use where appropriate given the input type. If all references to an operand "
"already have modifiers then the warning is suppressed for that operand."
msgstr ""

#: src/2873-inline-asm.md:658
msgid ""
"Flags are used to further influence the behavior of the inline assembly "
"block. Currently the following options are defined:"
msgstr ""

#: src/2873-inline-asm.md:660
msgid ""
"`pure`: The `asm` block has no side effects, and its outputs depend only on "
"its direct inputs (i.e. the values themselves, not what they point to) or "
"values read from memory (unless the `nomem` options is also set). This "
"allows the compiler to execute the `asm` block fewer times than specified in "
"the program (e.g. by hoisting it out of a loop) or even eliminate it "
"entirely if the outputs are not used."
msgstr ""

#: src/2873-inline-asm.md:661
msgid ""
"`nomem`: The `asm` blocks does not read or write to any memory. This allows "
"the compiler to cache the values of modified global variables in registers "
"across the `asm` block since it knows that they are not read or written to "
"by the `asm`."
msgstr ""

#: src/2873-inline-asm.md:662
msgid ""
"`readonly`: The `asm` block does not write to any memory. This allows the "
"compiler to cache the values of unmodified global variables in registers "
"across the `asm` block since it knows that they are not written to by the "
"`asm`."
msgstr ""

#: src/2873-inline-asm.md:663
msgid ""
"`preserves_flags`: The `asm` block does not modify the flags register "
"(defined in the [rules](#rules-for-inline-assembly) below). This allows the "
"compiler to avoid recomputing the condition flags after the `asm` block."
msgstr ""

#: src/2873-inline-asm.md:664
msgid ""
"`noreturn`: The `asm` block never returns, and its return type is defined as "
"`!` (never). Behavior is undefined if execution falls through past the end "
"of the asm code. A `noreturn` asm block behaves just like a function which "
"doesn't return; notably, local variables in scope are not dropped before it "
"is invoked."
msgstr ""

#: src/2873-inline-asm.md:665
msgid ""
"`nostack`: The `asm` block does not push data to the stack, or write to the "
"stack red-zone (if supported by the target). If this option is _not_ used "
"then the stack pointer is guaranteed to be suitably aligned (according to "
"the target ABI) for a function call."
msgstr ""

#: src/2873-inline-asm.md:666
msgid ""
"`att_syntax`: This option is only valid on x86, and causes the assembler to "
"use the `.att_syntax prefix` mode of the GNU assembler. Register operands "
"are substituted in with a leading `%`."
msgstr ""

#: src/2873-inline-asm.md:668
msgid "The compiler performs some additional checks on options:"
msgstr ""

#: src/2873-inline-asm.md:669
msgid ""
"The `nomem` and `readonly` options are mutually exclusive: it is a compile-"
"time error to specify both."
msgstr ""

#: src/2873-inline-asm.md:670
msgid ""
"The `pure` option must be combined with either the `nomem` or `readonly` "
"options, otherwise a compile-time error is emitted."
msgstr ""

#: src/2873-inline-asm.md:671
msgid ""
"It is a compile-time error to specify `pure` on an asm block with no outputs "
"or only discarded outputs (`_`)."
msgstr ""

#: src/2873-inline-asm.md:672
msgid ""
"It is a compile-time error to specify `noreturn` on an asm block with "
"outputs."
msgstr ""

#: src/2873-inline-asm.md:674
msgid "Mapping to LLVM IR"
msgstr ""

#: src/2873-inline-asm.md:676
msgid ""
"The direction specification maps to a LLVM constraint specification as "
"follows (using a `reg` operand as an example):"
msgstr ""

#: src/2873-inline-asm.md:678
msgid "`in(reg)` => `r`"
msgstr ""

#: src/2873-inline-asm.md:679
msgid ""
"`out(reg)` => `=&r` (Rust's outputs are early-clobber outputs in LLVM/GCC "
"terminology)"
msgstr ""

#: src/2873-inline-asm.md:680
msgid ""
"`inout(reg)` => `=&r,0` (an early-clobber output with an input tied to it, "
"`0` here is a placeholder for the position of the output)"
msgstr ""

#: src/2873-inline-asm.md:681
msgid ""
"`lateout(reg)` => `=r` (Rust's late outputs are regular outputs in LLVM/GCC "
"terminology)"
msgstr ""

#: src/2873-inline-asm.md:682
msgid "`inlateout(reg)` => `=r,0` (cf. `inout` and `lateout`)"
msgstr ""

#: src/2873-inline-asm.md:684
msgid ""
"If an `inout` is used where the output type is smaller than the input type "
"then some special handling is needed to avoid LLVM issues. See [this bug]"
"(https://github.com/rust-lang/rust/issues/65452)."
msgstr ""

#: src/2873-inline-asm.md:686
msgid ""
"As written this RFC requires architectures to map from Rust constraint "
"specifications to LLVM [constraint codes](http://llvm.org/docs/LangRef."
"html#supported-constraint-code-list). This is in part for better readability "
"on Rust's side and in part for independence of the backend:"
msgstr ""

#: src/2873-inline-asm.md:688
msgid ""
"Register classes are mapped to the appropriate constraint code as per the "
"table above."
msgstr ""

#: src/2873-inline-asm.md:689
msgid ""
"`const` operands are formatted and injected directly into the asm string."
msgstr ""

#: src/2873-inline-asm.md:690
msgid ""
"`sym` is mapped to the `s` constraint code. We automatically insert the `c` "
"modifier which removes target-specific modifiers from the value (e.g. `#` on "
"ARM)."
msgstr ""

#: src/2873-inline-asm.md:691
msgid "a register name `r1` is mapped to `{r1}`"
msgstr ""

#: src/2873-inline-asm.md:692
msgid ""
"If the `nomem` option is not set then `~{memory}` is added to the clobber "
"list. (Although this is currently ignored by LLVM)"
msgstr ""

#: src/2873-inline-asm.md:693
msgid ""
"If the `preserves_flags` option is not set then the following are added to "
"the clobber list:"
msgstr ""

#: src/2873-inline-asm.md:694
msgid "(x86) `~{dirflag},~{flags},~{fpsr}`"
msgstr ""

#: src/2873-inline-asm.md:695
msgid "(ARM/AArch64) `~{cc}`"
msgstr ""

#: src/2873-inline-asm.md:697
msgid ""
"Additionally, the following attributes are added to the LLVM `asm` statement:"
msgstr ""

#: src/2873-inline-asm.md:699
msgid ""
"The `nounwind` attribute is always added: unwinding from an inline asm block "
"is not allowed (and not supported by LLVM anyways)."
msgstr ""

#: src/2873-inline-asm.md:700
msgid ""
"If the `nomem` and `pure` options are both set then the `readnone` attribute "
"is added to the LLVM `asm` statement."
msgstr ""

#: src/2873-inline-asm.md:701
msgid ""
"If the `readonly` and `pure` options are both set then the `readonly` "
"attribute is added to the LLVM `asm` statement."
msgstr ""

#: src/2873-inline-asm.md:702
msgid ""
"If the `nomem` option is set without the `pure` option then the "
"`inaccessiblememonly` attribute is added to the LLVM `asm` statement."
msgstr ""

#: src/2873-inline-asm.md:703
msgid ""
"If the `pure` option is not set then the `sideeffect` flag is added the LLVM "
"`asm` statement."
msgstr ""

#: src/2873-inline-asm.md:704
msgid ""
"If the `nostack` option is not set then the `alignstack` flag is added the "
"LLVM `asm` statement."
msgstr ""

#: src/2873-inline-asm.md:705
msgid ""
"On x86, if the `att_syntax` option is not set then the `inteldialect` flag "
"is added to the LLVM `asm` statement."
msgstr ""

#: src/2873-inline-asm.md:707
msgid ""
"If the `noreturn` option is set then an `unreachable` LLVM instruction is "
"inserted after the asm invocation."
msgstr ""

#: src/2873-inline-asm.md:709
msgid ""
"Note that `alignstack` is not currently supported by GCC, so we will need to "
"implement support in GCC if Rust ever gets a GCC back-end."
msgstr ""

#: src/2873-inline-asm.md:714
msgid "Supporting back-ends without inline assembly"
msgstr ""

#: src/2873-inline-asm.md:716
msgid ""
"While LLVM supports inline assembly, rustc may gain alternative backends "
"such as Cranelift or GCC. If a back-end does not support inline assembly "
"natively then we can fall back to invoking an external assembler. The intent "
"is that support for `asm!` should be independent of the rustc back-end used: "
"it should always work, but with lower performance if the backend does not "
"support inline assembly."
msgstr ""

#: src/2873-inline-asm.md:718
msgid "Take the following (AArch64) asm block as an example:"
msgstr ""

#: src/2873-inline-asm.md:724
msgid "\"<some asm code>\""
msgstr ""

#: src/2873-inline-asm.md:724
msgid "\"x0\""
msgstr ""

#: src/2873-inline-asm.md:724
msgid "\"x20\""
msgstr ""

#: src/2873-inline-asm.md:729
msgid ""
"This could be expanded to an external asm file with the following contents:"
msgstr ""

#: src/2873-inline-asm.md:731
msgid ""
"```\n"
"# Function prefix directives\n"
".section \".text.foo_inline_asm\"\n"
".globl foo_inline_asm\n"
".p2align 2\n"
".type foo_inline_asm, @function\n"
"foo_inline_asm:\n"
"\n"
"// If necessary, save callee-saved registers to the stack here.\n"
"str x20, [sp, #-16]!\n"
"\n"
"// Move the pointer to the argument out of the way since x0 is used.\n"
"mov x1, x0\n"
"\n"
"// Load inputs values\n"
"ldr w2, [x1, #0]\n"
"ldr w0, [x1, #4]\n"
"\n"
"<some asm code>\n"
"\n"
"// Store output values\n"
"str w2, [x1, #0]\n"
"str w20, [x1, #8]\n"
"\n"
"// If necessary, restore callee-saved registers here.\n"
"ldr x20, [sp], #16\n"
"\n"
"ret\n"
"\n"
"# Function suffix directives\n"
".size foo_inline_asm, . - foo_inline_asm\n"
"```"
msgstr ""

#: src/2873-inline-asm.md:764
msgid "And the following Rust code:"
msgstr ""

#: src/2873-inline-asm.md:793
msgid "Rules for inline assembly"
msgstr ""

#: src/2873-inline-asm.md:796
msgid ""
"Any registers not specified as inputs will contain an undefined value on "
"entry to the asm block."
msgstr ""

#: src/2873-inline-asm.md:797
msgid ""
"An \"undefined value\" in the context of this RFC means that the register "
"can (non-deterministically) have any one of the possible values allowed by "
"the architecture. Notably it is not the same as an LLVM `undef` which can "
"have a different value every time you read it (since such a concept does not "
"exist in assembly code)."
msgstr ""

#: src/2873-inline-asm.md:798
msgid ""
"Any registers not specified as outputs must have the same value upon exiting "
"the asm block as they had on entry, otherwise behavior is undefined."
msgstr ""

#: src/2873-inline-asm.md:799
msgid ""
"This only applies to registers which can be specified as an input or output. "
"Other registers follow target-specific rules and are outside the scope of "
"this RFC."
msgstr ""

#: src/2873-inline-asm.md:800
msgid ""
"Note that a `lateout` may be allocated to the same register as an `in`, in "
"which case this rule does not apply. Code should not rely on this however "
"since it depends on the results of register allocation."
msgstr ""

#: src/2873-inline-asm.md:801
msgid "Behavior is undefined if execution unwinds out of an asm block."
msgstr ""

#: src/2873-inline-asm.md:802
msgid ""
"This also applies if the assembly code calls a function which then unwinds."
msgstr ""

#: src/2873-inline-asm.md:803
msgid ""
"The set of memory locations that assembly code is allowed the read and write "
"are the same as those allowed for an FFI function."
msgstr ""

#: src/2873-inline-asm.md:804
msgid "Refer to the unsafe code guidelines for the exact rules."
msgstr ""

#: src/2873-inline-asm.md:805
msgid "If the `readonly` option is set, then only memory reads are allowed."
msgstr ""

#: src/2873-inline-asm.md:806
msgid ""
"If the `nomem` option is set then no reads or writes to memory are allowed."
msgstr ""

#: src/2873-inline-asm.md:807
msgid ""
"These rules do not apply to memory which is private to the asm code, such as "
"stack space allocated within the asm block."
msgstr ""

#: src/2873-inline-asm.md:808
msgid ""
"The compiler cannot assume that the instructions in the asm are the ones "
"that will actually end up executed."
msgstr ""

#: src/2873-inline-asm.md:809
msgid ""
"This effectively means that the compiler must treat the `asm!` as a black "
"box and only take the interface specification into account, not the "
"instructions themselves."
msgstr ""

#: src/2873-inline-asm.md:810
msgid ""
"Runtime code patching is allowed, via target-specific mechanisms (outside "
"the scope of this RFC)."
msgstr ""

#: src/2873-inline-asm.md:811
msgid ""
"Unless the `nostack` option is set, asm code is allowed to use stack space "
"below the stack pointer."
msgstr ""

#: src/2873-inline-asm.md:812
msgid ""
"On entry to the asm block the stack pointer is guaranteed to be suitably "
"aligned (according to the target ABI) for a function call."
msgstr ""

#: src/2873-inline-asm.md:813
msgid ""
"You are responsible for making sure you don't overflow the stack (e.g. use "
"stack probing to ensure you hit a guard page)."
msgstr ""

#: src/2873-inline-asm.md:814
msgid ""
"You should adjust the stack pointer when allocating stack memory as required "
"by the target ABI."
msgstr ""

#: src/2873-inline-asm.md:815
msgid ""
"The stack pointer must be restored to its original value before leaving the "
"asm block."
msgstr ""

#: src/2873-inline-asm.md:816
msgid ""
"If the `noreturn` option is set then behavior is undefined if execution "
"falls through to the end of the asm block."
msgstr ""

#: src/2873-inline-asm.md:817
msgid ""
"If the `pure` option is set then behavior is undefined if the `asm` has side-"
"effects other than its direct outputs. Behavior is also undefined if two "
"executions of the `asm` code with the same inputs result in different "
"outputs."
msgstr ""

#: src/2873-inline-asm.md:818
msgid ""
"When used with the `nomem` option, \"inputs\" are just the direct inputs of "
"the `asm!`."
msgstr ""

#: src/2873-inline-asm.md:819
msgid ""
"When used with the `readonly` option, \"inputs\" comprise the direct inputs "
"of the `asm!` and any memory that the `asm!` block is allowed to read."
msgstr ""

#: src/2873-inline-asm.md:820
msgid ""
"These flags registers must be restored upon exiting the asm block if the "
"`preserves_flags` option is set:"
msgstr ""

#: src/2873-inline-asm.md:822
msgid "Status flags in `EFLAGS` (CF, PF, AF, ZF, SF, OF)."
msgstr ""

#: src/2873-inline-asm.md:823
msgid "Floating-point status word (all)."
msgstr ""

#: src/2873-inline-asm.md:824
msgid "Floating-point exception flags in `MXCSR` (PE, UE, OE, ZE, DE, IE)."
msgstr ""

#: src/2873-inline-asm.md:826
msgid "Condition flags in `CPSR` (N, Z, C, V)"
msgstr ""

#: src/2873-inline-asm.md:827
msgid "Saturation flag in `CPSR` (Q)"
msgstr ""

#: src/2873-inline-asm.md:828
msgid "Greater than or equal flags in `CPSR` (GE)."
msgstr ""

#: src/2873-inline-asm.md:829
msgid "Condition flags in `FPSCR` (N, Z, C, V)"
msgstr ""

#: src/2873-inline-asm.md:830
msgid "Saturation flag in `FPSCR` (QC)"
msgstr ""

#: src/2873-inline-asm.md:831
msgid ""
"Floating-point exception flags in `FPSCR` (IDC, IXC, UFC, OFC, DZC, IOC)."
msgstr ""

#: src/2873-inline-asm.md:833
msgid "Condition flags (`NZCV` register)."
msgstr ""

#: src/2873-inline-asm.md:834
msgid "Floating-point status (`FPSR` register)."
msgstr ""

#: src/2873-inline-asm.md:836
msgid "Floating-point exception flags in `fcsr` (`fflags`)."
msgstr ""

#: src/2873-inline-asm.md:837
msgid ""
"On x86, the direction flag (DF in `EFLAGS`) is clear on entry to an asm "
"block and must be clear on exit."
msgstr ""

#: src/2873-inline-asm.md:838
msgid ""
"Behavior is undefined if the direction flag is set on exiting an asm block."
msgstr ""

#: src/2873-inline-asm.md:839
msgid ""
"The requirement of restoring the stack pointer and non-output registers to "
"their original value only applies when exiting an `asm!` block."
msgstr ""

#: src/2873-inline-asm.md:840
msgid ""
"This means that `asm!` blocks that never return (even if not marked "
"`noreturn`) don't need to preserve these registers."
msgstr ""

#: src/2873-inline-asm.md:841
msgid ""
"When returning to a different `asm!` block than you entered (e.g. for "
"context switching), these registers must contain the value they had upon "
"entering the `asm!` block that you are _exiting_."
msgstr ""

#: src/2873-inline-asm.md:842
msgid ""
"You cannot exit an `asm!` block that has not been entered. Neither can you "
"exit an `asm!` block that has already been exited."
msgstr ""

#: src/2873-inline-asm.md:843
msgid ""
"You are responsible for switching any target-specific state (e.g. thread-"
"local storage, stack bounds)."
msgstr ""

#: src/2873-inline-asm.md:844
msgid ""
"The set of memory locations that you may access is the intersection of those "
"allowed by the `asm!` blocks you entered and exited."
msgstr ""

#: src/2873-inline-asm.md:845
msgid ""
"You cannot assume that an `asm!` block will appear exactly once in the "
"output binary. The compiler is allowed to instantiate multiple copies of the "
"`asm!` block, for example when the function containing it is inlined in "
"multiple places."
msgstr ""

#: src/2873-inline-asm.md:846
msgid ""
"As a consequence, you should only use [local labels](https://sourceware.org/"
"binutils/docs/as/Symbol-Names.html#Local-Labels) inside inline assembly "
"code. Defining symbols in assembly code may lead to assembler and/or linker "
"errors due to duplicate symbol definitions."
msgstr ""

#: src/2873-inline-asm.md:848
msgid ""
"**Note**: As a general rule, the flags covered by `preserves_flags` are "
"those which are _not_ preserved when performing a function call."
msgstr ""

#: src/2873-inline-asm.md:852
msgid "Drawbacks"
msgstr ""

#: src/2873-inline-asm.md:855
msgid "Unfamiliarity"
msgstr ""

#: src/2873-inline-asm.md:857
msgid ""
"This RFC proposes a completely new inline assembly format. It is not "
"possible to just copy examples of GCC-style inline assembly and re-use them. "
"There is however a fairly trivial mapping between the GCC-style and this "
"format that could be documented to alleviate this."
msgstr ""

#: src/2873-inline-asm.md:861
msgid ""
"Additionally, this RFC proposes using the Intel asm syntax by default on x86 "
"instead of the AT&T syntax. We believe this syntax will be more familiar to "
"most users, but may be surprising for users used to GCC-style asm."
msgstr ""

#: src/2873-inline-asm.md:863
msgid ""
"The `cpuid` example above would look like this in GCC-style inline assembly:"
msgstr ""

#: src/2873-inline-asm.md:866
msgid ""
"// GCC doesn't allow directly clobbering an input, we need\n"
"// to use a dummy output instead.\n"
msgstr ""

#: src/2873-inline-asm.md:871
msgid "\"=a\""
msgstr ""

#: src/2873-inline-asm.md:871
msgid "\"=b\""
msgstr ""

#: src/2873-inline-asm.md:871
msgid "\"=c\""
msgstr ""

#: src/2873-inline-asm.md:871
msgid "// outputs\n"
msgstr ""

#: src/2873-inline-asm.md:872 src/2873-inline-asm.md:1073
msgid "\"a\""
msgstr ""

#: src/2873-inline-asm.md:872
msgid "\"c\""
msgstr ""

#: src/2873-inline-asm.md:872
msgid "// inputs\n"
msgstr ""

#: src/2873-inline-asm.md:873
msgid "\"edx\" // clobbers\n"
msgstr ""

#: src/2873-inline-asm.md:875
msgid "\"L1 Cache: %i\\n\""
msgstr ""

#: src/2873-inline-asm.md:881
msgid "Limited set of operand types"
msgstr ""

#: src/2873-inline-asm.md:883
msgid ""
"The proposed set of operand types is much smaller than that which is "
"available through GCC-style inline assembly. In particular, the proposed "
"syntax does not include any form of memory operands and is missing many "
"register classes."
msgstr ""

#: src/2873-inline-asm.md:885
msgid ""
"We chose to keep operand constraints as simple as possible, and in "
"particular memory operands introduce a lot of complexity since different "
"instruction support different addressing modes. At the same time, the exact "
"rules for memory operands are not very well known (you are only allowed to "
"access the data directly pointed to by the constraint) and are often gotten "
"wrong."
msgstr ""

#: src/2873-inline-asm.md:887
msgid ""
"If we discover that there is a demand for a new register class or special "
"operand type, we can always add it later."
msgstr ""

#: src/2873-inline-asm.md:889
msgid "Difficulty of support"
msgstr ""

#: src/2873-inline-asm.md:891
msgid ""
"Inline assembly is a difficult feature to implement in a compiler backend. "
"While LLVM does support it, this may not be the case for alternative "
"backends such as [Cranelift](https://cranelift.readthedocs.io/) (see [this "
"issue](https://github.com/bytecodealliance/cranelift/issues/444)). We "
"provide a fallback implementation using an external assembler for such "
"backends."
msgstr ""

#: src/2873-inline-asm.md:896
msgid "Use of double braces in the template string"
msgstr ""

#: src/2873-inline-asm.md:898
msgid ""
"Because `{}` are used to denote operand placeholders in the template string, "
"actual uses of braces in the assembly code need to be escaped with `{{` and "
"`}}`. This is needed for AVX-512 mask registers and ARM register lists."
msgstr ""

#: src/2873-inline-asm.md:900
msgid "Post-monomorphization errors"
msgstr ""

#: src/2873-inline-asm.md:902
msgid ""
"Since the code generated by `asm!` is only evaluated late in the compiler "
"back-end, errors in the assembly code (e.g. invalid syntax, unrecognized "
"instruction, etc) are reported during code generation unlike every other "
"error generated by rustc. In particular this means that:"
msgstr ""

#: src/2873-inline-asm.md:903
msgid ""
"Since `cargo check` skips code generation, assembly code is not checked for "
"errors."
msgstr ""

#: src/2873-inline-asm.md:904
msgid ""
"`asm!` blocks that are determined to be unreachable are not checked for "
"errors. This can even vary depending on the optimization level since "
"inlining provides more opportunities for constant propagation."
msgstr ""

#: src/2873-inline-asm.md:906
msgid ""
"However there is a precedent in Rust for post-monomorphization errors: "
"linker errors. Code which references a non-existent `extern` symbol will "
"only cause an error at link-time, and this can also vary with optimization "
"levels as dead code elimination may removed the reference to the symbol "
"before it reaches the linker."
msgstr ""

#: src/2873-inline-asm.md:908
msgid "Rationale and alternatives"
msgstr ""

#: src/2873-inline-asm.md:911
msgid "Implement an embedded DSL"
msgstr ""

#: src/2873-inline-asm.md:914
msgid ""
"Both MSVC and D provide what is best described as an embedded DSL for inline "
"assembly. It is generally close to the system assembler's syntax, but "
"augmented with the ability to directly access variables that are in scope."
msgstr ""

#: src/2873-inline-asm.md:918
msgid "// This is D code\n"
msgstr ""

#: src/2873-inline-asm.md:927
msgid "\"L1 Cache: %s\""
msgstr ""

#: src/2873-inline-asm.md:933
msgid "// This is MSVC C++\n"
msgstr ""

#: src/2873-inline-asm.md:942
msgid "\"L1 Cache: \""
msgstr ""

#: src/2873-inline-asm.md:945
msgid "'\\n'"
msgstr ""

#: src/2873-inline-asm.md:948
msgid ""
"While this is very convenient on the user side in that it requires no "
"specification of inputs, outputs, or clobbers, it puts a major burden on the "
"implementation. The DSL needs to be implemented for each supported "
"architecture, and full knowledge of the side-effect of every instruction is "
"required."
msgstr ""

#: src/2873-inline-asm.md:953
msgid ""
"This huge implementation overhead is likely one of the reasons MSVC only "
"provides this capability for x86, while D at least provides it for x86 and "
"x86-64. It should also be noted that the D reference implementation falls "
"slightly short of supporting arbitrary assembly. E.g. the lack of access to "
"the `RIP` register makes certain techniques for writing position independent "
"code impossible."
msgstr ""

#: src/2873-inline-asm.md:959
msgid ""
"As a stop-gap the LDC implementation of D provides a `llvmasm` feature that "
"binds it closely to LLVM IR's inline assembly."
msgstr ""

#: src/2873-inline-asm.md:962
msgid ""
"We believe it would be unfortunate to put Rust into a similar situation, "
"making certain architectures a second-class citizen with respect to inline "
"assembly."
msgstr ""

#: src/2873-inline-asm.md:965
msgid "Provide intrinsics for each instruction"
msgstr ""

#: src/2873-inline-asm.md:967
msgid ""
"In discussions it is often postulated that providing intrinsics is a better "
"solution to the problems at hand. However, particularly where precise "
"timing, and full control over the number of generated instructions is "
"required intrinsics fall short."
msgstr ""

#: src/2873-inline-asm.md:972
msgid ""
"Intrinsics are of course still useful and have their place for inserting "
"specific instructions. E.g. making sure a loop uses vector instructions, "
"rather than relying on auto-vectorization."
msgstr ""

#: src/2873-inline-asm.md:975
msgid ""
"However, inline assembly is specifically designed for cases where more "
"control is required. Also providing an intrinsic for every (potentially "
"obscure) instruction that is needed e.g. during early system boot in kernel "
"code is unlikely to scale."
msgstr ""

#: src/2873-inline-asm.md:979
msgid "Make the `asm!` macro return outputs"
msgstr ""

#: src/2873-inline-asm.md:981
msgid ""
"It has been suggested that the `asm!` macro could return its outputs like "
"the LLVM statement does. The benefit is that it is clearer to see that "
"variables are being modified. Particular in the case of initialization it "
"becomes more obvious what is happening. On the other hand by necessity this "
"splits the direction and constraint specification from the variable name, "
"which makes this syntax overall harder to read."
msgstr ""

#: src/2873-inline-asm.md:990
msgid "\"mul {}\""
msgstr ""

#: src/2873-inline-asm.md:997
msgid "Use AT&T syntax by default on x86"
msgstr ""

#: src/2873-inline-asm.md:999
msgid ""
"x86 is particular in that there are [two widely used dialects](https://"
"sourceware.org/binutils/docs/as/i386_002dVariations.html) for its assembly "
"code: Intel syntax, which is the official syntax for x86 assembly, and AT&T "
"syntax which is used by GCC (via GAS). There is no functional difference "
"between those two dialects, they both support the same functionality but "
"with a different syntax. This RFC chooses to use Intel syntax by default "
"since it is more widely used and users generally find it easier to read and "
"write."
msgstr ""

#: src/2873-inline-asm.md:1003
msgid "Validate the assembly code in rustc"
msgstr ""

#: src/2873-inline-asm.md:1005
msgid ""
"There may be some slight differences in the set of assembly code that is "
"accepted by different compiler back-ends (e.g. LLVM's integrated assembler "
"vs using GAS as an external assembler). Examples of such differences are:"
msgstr ""

#: src/2873-inline-asm.md:1007
msgid ""
"LLVM's [assembly extensions](https://llvm.org/docs/Extensions.html#machine-"
"specific-assembly-syntax)"
msgstr ""

#: src/2873-inline-asm.md:1008
msgid ""
"Linking against the system LLVM instead of rustc's, which may/may not "
"support some newer instructions."
msgstr ""

#: src/2873-inline-asm.md:1009
msgid "GAS or LLVM introducing new assembler directives."
msgstr ""

#: src/2873-inline-asm.md:1011
msgid ""
"While it might be possible for rustc to verify that inline assembly code "
"conforms to a minimal stable subset of the assembly syntax supported by LLVM "
"and GAS, doing so would effectively require rustc to parse the assembly code "
"itself. Implementing a full assembler for all target architectures supported "
"by this RFC is a huge amount of work, most of which is redundant with the "
"work that LLVM has already done in implementing an assembler. As such, this "
"RFC does not propose that rustc perform any validation of the generated "
"assembly code."
msgstr ""

#: src/2873-inline-asm.md:1015
msgid "Include the target architecture name in `asm!`"
msgstr ""

#: src/2873-inline-asm.md:1017
msgid ""
"Including the name of the target architecture as part of the `asm!` "
"invocation could allow IDEs to perform syntax highlighting on the assembly "
"code. However this has several downsides:"
msgstr ""

#: src/2873-inline-asm.md:1018
msgid ""
"It would add a significant amount of complexity to the `asm!` macro which "
"already has many options."
msgstr ""

#: src/2873-inline-asm.md:1019
msgid ""
"Since assembly code is inherently target-specific, `asm!` is already going "
"to be behind a `#[cfg]`. Repeating the architecture name would be redundant."
msgstr ""

#: src/2873-inline-asm.md:1020
msgid ""
"Most inline asm is small and wouldn't really benefit from syntax "
"highlighting."
msgstr ""

#: src/2873-inline-asm.md:1021
msgid ""
"The `asm!` template isn't real assembly code (`{}` placeholders, `{` escaped "
"to `{{`), which may confuse syntax highlighters."
msgstr ""

#: src/2873-inline-asm.md:1023
msgid "Operands before template string"
msgstr ""

#: src/2873-inline-asm.md:1025
msgid ""
"The operands could be placed before the template string, which could make "
"the asm easier to read in some cases. However we decided against it because "
"the benefits are small and the syntax would no longer mirror that of Rust "
"format string."
msgstr ""

#: src/2873-inline-asm.md:1027
msgid "Operands interleaved with template string arguments"
msgstr ""

#: src/2873-inline-asm.md:1029
msgid ""
"An asm directive could contain a series of template string arguments, each "
"followed by the operands referenced in that template string argument. This "
"could potentially simplify long blocks of assembly. However, this could "
"introduce significant complexity and difficulty of reading, due to the "
"numbering of positional arguments, and the possibility of referencing named "
"or numbered arguments other than those that appear grouped with a given "
"template string argument."
msgstr ""

#: src/2873-inline-asm.md:1031
msgid ""
"Experimentation with such mechanisms could take place in wrapper macros "
"around `asm!`, rather than in `asm!` itself."
msgstr ""

#: src/2873-inline-asm.md:1033
msgid "Prior art"
msgstr ""

#: src/2873-inline-asm.md:1036
msgid "GCC inline assembly"
msgstr ""

#: src/2873-inline-asm.md:1038
msgid ""
"The proposed syntax is very similar to GCC's inline assembly in that it is "
"based on string substitution while leaving actual interpretation of the "
"final string to the assembler. However GCC uses poorly documented single-"
"letter constraint codes and template modifiers. Clang tries to emulate GCC's "
"behavior, but there are still several cases where its behavior differs from "
"GCC's."
msgstr ""

#: src/2873-inline-asm.md:1040
msgid ""
"The main reason why this is so complicated is that GCC's inline assembly "
"basically exports the raw internals of GCC's register allocator. This has "
"resulted in many internal constraint codes and modifiers being widely used, "
"despite them being completely undocumented."
msgstr ""

#: src/2873-inline-asm.md:1042
msgid "D & MSVC inline assembly"
msgstr ""

#: src/2873-inline-asm.md:1044
msgid "See the section [above](#dsl)."
msgstr ""

#: src/2873-inline-asm.md:1046
msgid "Unresolved questions"
msgstr ""

#: src/2873-inline-asm.md:1049
msgid "Namespacing the `asm!` macro"
msgstr ""

#: src/2873-inline-asm.md:1051
msgid ""
"Should the `asm!` macro be available directly from the prelude as it is now, "
"or should it have to be imported from `std::arch::$ARCH::asm`? The advantage "
"of the latter is that it would make it explicit that the `asm!` macro is "
"target-specific, but it would make cross-platform code slightly longer to "
"write."
msgstr ""

#: src/2873-inline-asm.md:1053
msgid "Future possibilities"
msgstr ""

#: src/2873-inline-asm.md:1056
msgid "Flag outputs"
msgstr ""

#: src/2873-inline-asm.md:1058
msgid ""
"GCC supports a special type of output which allows an asm block to return a "
"`bool` encoded in the condition flags register. This allows the compiler to "
"branch directly on the condition flag instead of materializing the condition "
"as a `bool`."
msgstr ""

#: src/2873-inline-asm.md:1060
msgid "We can support this in the future with a special output operand type."
msgstr ""

#: src/2873-inline-asm.md:1062
msgid "`asm goto`"
msgstr ""

#: src/2873-inline-asm.md:1064
msgid ""
"GCC supports passing C labels (the ones used with `goto`) to an inline asm "
"block, with an indication that the asm code may jump directly to one of "
"these labels instead of leaving the asm block normally."
msgstr ""

#: src/2873-inline-asm.md:1066
msgid ""
"This could be supported by allowing code blocks to be specified as operand "
"types. The following code will print `a` if the input value is `42`, or "
"print `b` otherwise."
msgstr ""

#: src/2873-inline-asm.md:1070
msgid "\"cmp {}, 42\""
msgstr ""

#: src/2873-inline-asm.md:1071
msgid "\"jeq {}\""
msgstr ""

#: src/2873-inline-asm.md:1074
msgid "\"b\""
msgstr ""

#: src/2873-inline-asm.md:1078
msgid "Unique ID per `asm`"
msgstr ""

#: src/2873-inline-asm.md:1080
msgid ""
"GCC supports `%=` which generates a unique identifier per instance of an asm "
"block. This is guaranteed to be unique even if the asm block is duplicated "
"(e.g. because of inlining)."
msgstr ""

#: src/2873-inline-asm.md:1082
msgid "We can support this in the future with a special operand type."
msgstr ""

#: src/2873-inline-asm.md:1084
msgid "`const` and `sym` for `global_asm!`"
msgstr ""

#: src/2873-inline-asm.md:1086
msgid ""
"The `global_asm!` macro could be extended to support `const` and `sym` "
"operands since those can be resolved by simple string substitution. Symbols "
"used in `global_asm!` will be marked as `#[used]` to ensure that they are "
"not optimized away by the compiler."
msgstr ""

#: src/2873-inline-asm.md:1088
msgid "Memory operands"
msgstr ""

#: src/2873-inline-asm.md:1090
msgid ""
"We could support `mem` as an alternative to specifying a register class "
"which would leave the operand in memory and instead produce a memory address "
"when inserted into the asm string. This would allow generating more "
"efficient code by taking advantage of addressing modes instead of using an "
"intermediate register to hold the computed address."
msgstr ""

#: src/2873-inline-asm.md:1092
msgid "Shorthand notation for operand names"
msgstr ""

#: src/2873-inline-asm.md:1094
msgid ""
"We should support some sort of shorthand notation for operand names to avoid "
"needing to write `blah = out(reg) blah`? For example, if the expression is "
"just a single identifier, we could implicitly allow that operand to be "
"referred to using that identifier."
msgstr ""

#: src/2873-inline-asm.md:1096
msgid "Clobbers for function calls"
msgstr ""

#: src/2873-inline-asm.md:1098
msgid ""
"Sometimes it can be difficult to specify the necessary clobbers for an asm "
"block which performs a function call. In particular, it is difficult for "
"such code to be forward-compatible if the architecture adds new registers in "
"a future revision, which the compiler may use but will be missing from the "
"`asm!` clobber list."
msgstr ""

#: src/2873-inline-asm.md:1100
msgid ""
"One possible solution to this would be to add a `clobber(<abi>)` operand "
"where `<abi>` is a calling convention such as `\"C\"` or `\"stdcall\"`. The "
"compiler would then automatically insert the necessary clobbers for a "
"function call to that ABI. Also `clobber(all)`, could be used to indicate "
"all registers are clobbered by the `asm!`."
msgstr ""
