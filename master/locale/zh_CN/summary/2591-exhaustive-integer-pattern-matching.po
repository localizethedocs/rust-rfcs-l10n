msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:45Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2591-exhaustive-integer-pattern-matching.md:1
msgid "Feature Name: `exhaustive_integer_patterns`"
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:2
msgid "Start Date: 2018-10-11"
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2591](https://github.com/rust-lang/rfcs/pull/2591)"
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:4
msgid ""
"Rust Issue: [rust-lang/rust#50907](https://github.com/rust-lang/rust/"
"issues/50907)"
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:6
msgid "Summary"
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:9
msgid ""
"Extend Rust's pattern matching exhaustiveness checks to cover the integer "
"types: `u8`, `u16`, `u32`, `u64`, `u128`, `usize`, `i8`, `i16`, `i32`, "
"`i64`, `i128`, `isize` and `char`."
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:13
#: src/2591-exhaustive-integer-pattern-matching.md:43
msgid "// ok\n"
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:14
#: src/2591-exhaustive-integer-pattern-matching.md:15
#: src/2591-exhaustive-integer-pattern-matching.md:16
#: src/2591-exhaustive-integer-pattern-matching.md:22
#: src/2591-exhaustive-integer-pattern-matching.md:44
#: src/2591-exhaustive-integer-pattern-matching.md:45
#: src/2591-exhaustive-integer-pattern-matching.md:46
#: src/2591-exhaustive-integer-pattern-matching.md:52
msgid "/* ... */"
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:21
#: src/2591-exhaustive-integer-pattern-matching.md:51
msgid "//~ ERROR: non-exhaustive patterns: `32u8..=255u8` not covered\n"
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:27
msgid "Motivation"
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:30
msgid ""
"This is viewed essentially as a bug fix: other than the implementational "
"challenges, there is no reason not to perform correct exhaustiveness "
"checking on integer patterns, especially as range patterns are permitted, "
"making it very straightforward to provide patterns covering every single "
"integer."
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:32
msgid ""
"This change will mean that Rust correctly performs exhaustiveness checking "
"on all the types that currently compose its type system."
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:34
msgid ""
"This feature has already [been implemented](https://github.com/rust-lang/"
"rust/pull/50912) behind the feature flag `exhaustive_integer_patterns`, so "
"this RFC is viewed as a motion to stabilise the feature."
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:36
msgid "Guide-level explanation"
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:39
msgid ""
"Exhaustive pattern matching works for integer types, just like any other "
"type. In addition, missing ranges of integers will be reported as errors."
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:57
msgid ""
"Specifically, for non-`char` integer types, the entire range of values from "
"`{integer}::MIN` to `{integer}::MAX` are considered valid constructors. For "
"`char`, the Unicode Scalar Value (USV) ranges (`\\u{0000}..=\\u{D7FF}` and "
"`\\u{E000}..=\\u{10FFFF}`) are considered valid constructors."
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:59
msgid ""
"More examples may be found in [the file of test cases](https://github.com/"
"rust-lang/rust/pull/50912/files#diff-8809036e5fb5a9a0fcc283431046ef51)."
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:61
msgid ""
"Note that guarded arms are ignored for the purpose of exhaustiveness checks, "
"just like with any other type (i.e. arms with `if` conditions are always "
"considered fallible and aren't considered to cover any possibilities)."
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:63
msgid "Reference-level explanation"
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:66
msgid ""
"The implementation of this features uses interval arithmetic and an "
"extension of the pattern matching exhaustiveness checks as described in "
"[this paper](http://moscova.inria.fr/~maranget/papers/warn/index.html)."
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:68
msgid ""
"This feature has already [been implemented](https://github.com/rust-lang/"
"rust/pull/50912), so the code there may be used for further reference. The "
"source contains detailed comments about the implementation."
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:70
msgid ""
"For `usize` and `isize`, no assumptions about the maximum value are "
"permitted. To exhaustively match on either pointer-size integer type a "
"wildcard pattern (`_`) must be used (or if [open-ended range patterns are "
"added](https://github.com/rust-lang/rfcs/issues/947), ranges must be open "
"ended \\[e.g. `0..`\\]). An unstable feature `precise_pointer_size_matching` "
"will be added to permit matching exactly on pointer-size integer types."
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:72
msgid "Drawbacks"
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:75
msgid ""
"There is no reason not to do this: it fixes a limitation of the existing "
"pattern exhaustiveness checks."
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:77
msgid "Rationale and alternatives"
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:80
msgid ""
"This is a straightforward extension of the existing exhaustiveness checks. "
"This is the only sensible design for the feature."
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:82
msgid "Prior art"
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:85
msgid ""
"As far as the author is unaware, Rust is the first language to support "
"exhaustive integer pattern matching. At the time of writing, Swift and "
"OCaml, two languages for which this feature could also make sense, do not "
"implement this extension. This is likely because the feature is not simple "
"to implement and the usefulness of this feature appears in specific domains."
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:87
msgid "Unresolved questions"
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:90
msgid ""
"This feature is already implemented and appears to meet expectations for "
"such a feature, as there have been no issues brought up about the "
"implementation or design."
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:92
msgid "Future possibilities"
msgstr ""

#: src/2591-exhaustive-integer-pattern-matching.md:95
msgid ""
"Having added exhaustive pattern matching for integers, all types in Rust for "
"which exhaustive matching is sensible are matched exhaustively. We should "
"aim to ensure this remains the case. However, at present, exhaustive pattern "
"matching in Rust is viewed complete."
msgstr ""
