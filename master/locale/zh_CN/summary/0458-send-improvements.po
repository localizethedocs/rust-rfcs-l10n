msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0458-send-improvements.md:1
msgid "Start Date: 2014-11-10"
msgstr ""

#: src/0458-send-improvements.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#458](https://github.com/rust-lang/rfcs/pull/458)"
msgstr ""

#: src/0458-send-improvements.md:3
msgid ""
"Rust Issue: [rust-lang/rust#22251](https://github.com/rust-lang/rust/"
"issues/22251)"
msgstr ""

#: src/0458-send-improvements.md:5
msgid "Summary"
msgstr ""

#: src/0458-send-improvements.md:7
msgid "I propose altering the `Send` trait as proposed by RFC #17 as follows:"
msgstr ""

#: src/0458-send-improvements.md:10
msgid "Remove the implicit `'static` bound from `Send`."
msgstr ""

#: src/0458-send-improvements.md:11
msgid "Make `&T` `Send` if and only if `T` is `Sync`."
msgstr ""

#: src/0458-send-improvements.md:17
msgid ""
"Evaluate each `Send` bound currently in `libstd` and either leave it as-is, "
"add an explicit `'static` bound, or bound it with another lifetime parameter."
msgstr ""

#: src/0458-send-improvements.md:20
msgid "Motivation"
msgstr ""

#: src/0458-send-improvements.md:22
msgid ""
"Currently, Rust has two types that deal with concurrency: `Sync` and `Send`"
msgstr ""

#: src/0458-send-improvements.md:24
msgid ""
"If `T` is `Sync`, then `&T` is threadsafe (that is, can cross task "
"boundaries without data races).  This is always true of any type with simple "
"inherited mutability, and it is also true of types with interior mutability "
"that perform explicit synchronization (e.g. `Mutex` and `Arc`).  By fiat, in "
"safe code all static items require a `Sync` bound.  `Sync` is most "
"interesting as the proposed bound for closures in a fork-join concurrency "
"model, where the thread running the closure can be guaranteed to terminate "
"before some lifetime `'a`, and as one of the required bounds for `Arc`."
msgstr ""

#: src/0458-send-improvements.md:32
msgid ""
"If `T` is `Send`, then `T` is threadsafe to send between tasks.  At an "
"initial glance, this type is harder to define.  `Send` currently requires a "
"`'static` bound, which excludes types with non-'static references, and there "
"are a few types (notably, `Rc` and `local_data::Ref`) that opt out of "
"`Send`.  All static items other than those that are `Sync` but not `Send` "
"(in the stdlib this is just `local_data::Ref` and its derivatives) are "
"`Send`.  `Send` is most interesting as a required bound for `Mutex`, "
"channels, `spawn()`, and other concurrent types and functions."
msgstr ""

#: src/0458-send-improvements.md:40
msgid ""
"This RFC is mostly motivated by the challenges of writing a safe interface "
"for fork-join concurrency in current Rust.  Specifically:"
msgstr ""

#: src/0458-send-improvements.md:43
msgid ""
"It is not clear what it means for a type to be `Sync` but not `Send`.  "
"Currently there is nothing in the type system preventing these types from "
"being instantiated.  In a fork-join model with a bounded, non-`'static` "
"lifetime `'a` for worker tasks, using a `Sync + 'a` bound on a closure is "
"the intended way to make sure the operation is safe to run in another thread "
"in parallel with the main thread.  But there is no way of preventing the "
"main and worker tasks from concurrently accessing an item that is `Sync + "
"NoSend`."
msgstr ""

#: src/0458-send-improvements.md:49
msgid ""
"Because `Send` has a `'static` bound, most concurrency constructs cannot be "
"used if they have any non-static references in them, even in a thread with a "
"bounded lifetime.  It seems like there should be a way to extend `Send` to "
"shorter lifetimes.  But naively removing the `'static` bound causes memory "
"unsafety in existing APIs like Mutex."
msgstr ""

#: src/0458-send-improvements.md:52
msgid "Detailed Design"
msgstr ""

#: src/0458-send-improvements.md:54
msgid "Proposal"
msgstr ""

#: src/0458-send-improvements.md:56
msgid ""
"Extend the current meaning of `Send` in a (mostly) backwards-compatible way "
"that retains memory-safety, but allows for existing concurrent types like "
"`Arc` and `Mutex` to be used across non-`'static` boundaries.  Use `Send` "
"with a bounded lifetime instead of `Sync` for fork-join concurrency."
msgstr ""

#: src/0458-send-improvements.md:60
msgid ""
"The first proposed change is to remove the `'static` bound from `Send`.  "
"Without doing this, we would have to write brand new types for fork-join "
"libraries that took `Sync` bounds but were otherwise identical to the "
"existing implementations.  For example, we cannot create a `Mutex<Vec<&'a "
"mut uint>>` as long as `Mutex` requires a `'static` bound.  By itself, "
"though, this causes unsafety.  For example, a `Mutex<&'a Cell<bool>>` does "
"not necessarily actually lock the data in the `Cell`:"
msgstr ""

#: src/0458-send-improvements.md:71
msgid "// Modifying the cell without locking the Mutex.\n"
msgstr ""

#: src/0458-send-improvements.md:74
msgid ""
"This leads us to our second refinement.  We add the rule that `&T` is `Send` "
"if and only if `T` is `Sync`\\--in other words, we disallow `Send`ing shared "
"references with a non-threadsafe interior.  We do, however, still allow "
"`&mut T` where `T` is `Send`, even if it is not `Sync`.  This is safe "
"because `&mut T` linearizes access--the only way to access the original data "
"is through the unique reference, so it is safe to send to other threads.  "
"Similarly, we allow `&T` where `T` is `Sync`, even if it is not `Send`, "
"since by the definition of `Sync` `&T` is already known to be threadsafe."
msgstr ""

#: src/0458-send-improvements.md:81
msgid ""
"Note that this definition of `Send` is identical to the old definition of "
"`Send` when restricted to `'static` lifetimes in safe code.  Since `static "
"mut` items are not accessible in safe code, and it is not possible to create "
"a safe `&'static mut` outside of such an item, we know that if `T: Send + "
"'static`, it either has only `&'static` references, or has no references at "
"all.  Since `'static` references can only be created in `static` items and "
"literals in safe code, and all `static` items (and literals) are `Sync`, we "
"know that any such references are `Sync`.  Thus, our new rule that `T` must "
"be `Sync` for `&'static T` to be `Send` does not actually remove `Send` from "
"any existing types.  And since `T` has no `&'static mut` references, unless "
"any were created in unsafe code, we also know that our rule allowing "
"`&'static mut T` did not add `Send` to any new types.  We conclude that the "
"second refinement is backwards compatible with the old behavior, provided "
"that old interfaces are updated to require `'static` bounds and they did not "
"create unsafe `'static` and `'static mut` references.  But unsafe types like "
"these were already not guaranteed to be threadsafe by Rust's type system."
msgstr ""

#: src/0458-send-improvements.md:95
msgid ""
"Another important note is that with this definition, `Send` will fulfill the "
"proposed role of `Sync` in a fork-join concurrency library.  At present, to "
"use `Sync` in a fork-join library one must make the implicit assumption that "
"if `T` is `Sync`, `T` is `Send`.  One might be tempted to codify this by "
"making `Sync` a subtype of `Send`.  Unfortunately, this is not always the "
"case, though it should be most of the time.  A type can be created with "
"`&mut` methods that are not thread safe, but no `&`\\-methods that are not "
"thread safe.  An example would be a version of `Rc` called `RcMut`.  `RcMut` "
"would have a `clone_mut()` method that took `&mut self` and no other "
"`clone()` method.  `RcMut` could be thread-safely shared provided that a "
"`&mut RcMut` was not sent to another thread.  As long as that invariant was "
"upheld, `RcMut` could only be cloned in its original thread and could not be "
"dropped while shared (hence, `RcMut` is `Sync`) but a mutable reference "
"could not be thread-safely shared, nor could it be moved into another thread "
"(hence, `&mut RcMut` is not `Send`, which means that `RcMut` is not "
"`Send`).  Because `&T` is Send if `T` is Sync (per the new definition), "
"adding a `Send` bound will guarantee that only shared pointers of this type "
"are moved between threads, so our new definition of `Send` preserves thread "
"safety in the presence of such types."
msgstr ""

#: src/0458-send-improvements.md:97
msgid ""
"Finally, we'd hunt through existing instances of `Send` in Rust libraries "
"and replace them with sensible defaults.  For example, the `spawn()` APIs "
"should all have `'static` bounds, preserving current behavior.  I don't "
"think this would be too difficult, but it may be that there are some edge "
"cases here where it's tricky to determine what the right solution is."
msgstr ""

#: src/0458-send-improvements.md:102
msgid "More unusual types"
msgstr ""

#: src/0458-send-improvements.md:104
msgid ""
"We discussed whether a type with a destructor that manipulated thread-local "
"data could be non-`Send` even though `&mut T` was.  In general it could not, "
"because you can call a destructor through `&mut` references (through `swap` "
"or simply assigning a new value to `*x` where `x: &mut T`).  It was noted "
"that since `&uniq T` cannot be dropped, this suggests a role for such types."
msgstr ""

#: src/0458-send-improvements.md:106
msgid ""
"Some unusual types proposed by `arielb1` and myself to explain why `T: Send` "
"does not mean `&mut T` is threadsafe, and `T: Sync` does not imply `T: "
"Send`.  The first type is a bottom type, the second takes `self` by value "
"(so `RcMainTask` is not `Send` but `&mut RcMainTask` is `Send`)."
msgstr ""

#: src/0458-send-improvements.md:108
msgid "Comments from arielb1:"
msgstr ""

#: src/0458-send-improvements.md:110
msgid ""
"Observe that `RcMainTask::main_clone` would be unsafe outside the main task."
msgstr ""

#: src/0458-send-improvements.md:112
msgid ""
"`&mut Xyz` and `&mut RcMainTask` are perfectly fine `Send` types. However, "
"`Xyz` is a bottom (can be used to violate memory safety), and `RcMainTask` "
"is not `Send`."
msgstr ""

#: src/0458-send-improvements.md:119
msgid ""
"// Invariant: &mut Xyz always points to a valid C xyz.\n"
"// Xyz rvalues don't exist.\n"
msgstr ""

#: src/0458-send-improvements.md:122
msgid ""
"// These leak. I *could* wrap a box or arena, but that would\n"
"// complicate things.\n"
msgstr ""

#: src/0458-send-improvements.md:126
msgid "\"C\""
msgstr ""

#: src/0458-send-improvements.md:127
msgid "// struct Xyz;\n"
msgstr ""

#: src/0458-send-improvements.md:146
msgid "// Invariant: only the main task has RcMainTask values\n"
msgstr ""

#: src/0458-send-improvements.md:166
msgid "//  - by Sharp\n"
msgstr ""

#: src/0458-send-improvements.md:183
msgid ""
"// fn on_main_task() -> bool { false /* XXX: implement */ }\n"
"// fn main() {}\n"
msgstr ""

#: src/0458-send-improvements.md:188
msgid "Drawbacks"
msgstr ""

#: src/0458-send-improvements.md:190
msgid ""
"Libraries get a bit more complicated to write, since you may have to write "
"`Send + 'static` where previously you just wrote `Send`."
msgstr ""

#: src/0458-send-improvements.md:192
msgid "Alternatives"
msgstr ""

#: src/0458-send-improvements.md:194
msgid ""
"We could accept the status quo.  This would mean that any existing `Sync` "
"`NoSend` type like those described above would be unsafe (that is, it would "
"not be possible to write a non-`'static` closure with the correct bounds to "
"make it safe to use), and it would not be possible to write a type like "
"`Arc<T>` for a `T` with a bounded lifetime, as well as other safe "
"concurrency constructs for fork-join concurrency.  I do not think this is a "
"good alternative."
msgstr ""

#: src/0458-send-improvements.md:197
msgid ""
"We could do as proposed above, but change `Sync` to be a subtype of `Send`.  "
"Things wouldn't be too different, but you wouldn't be able to write types "
"like those discussed above.  I am not sure that types like that are actually "
"useful, but even if we did this I think you would usually want to use a "
"`Send` bound anyway."
msgstr ""

#: src/0458-send-improvements.md:200
msgid ""
"We could do as proposed above, but instead of changing `Send`, create a new "
"type for this purpose.  I suppose the advantage of this would be that user "
"code currently using `Send` as a way to get a `'static` bound would not "
"break.  However, I don't think it makes a lot of sense to keep the current "
"`Send` type around if this is implemented, since the new type should be "
"backwards compatible with it where it was being used semantically correctly."
msgstr ""

#: src/0458-send-improvements.md:206
msgid "Unresolved questions"
msgstr ""

#: src/0458-send-improvements.md:208
msgid ""
"Is the new scheme actually safe?  I _think_ it is, but I certainly haven't "
"proved it."
msgstr ""

#: src/0458-send-improvements.md:210
msgid ""
"Can this wait until after Rust 1.0, if implemented?  I think it is backwards "
"incompatible, but I believe it will also be much easier to implement once "
"opt-in kinds are fully implemented."
msgstr ""

#: src/0458-send-improvements.md:213
msgid ""
"Is this actually necessary?  I've asserted that I think it's important to be "
"able to do the same things in bounded-lifetime threads that you can in "
"regular threads, but it may be that it isn't."
msgstr ""

#: src/0458-send-improvements.md:216
msgid "Are types that are `Sync` and `NoSend` actually useful?"
msgstr ""
