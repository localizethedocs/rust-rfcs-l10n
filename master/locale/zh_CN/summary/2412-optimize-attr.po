msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:44Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2412-optimize-attr.md:1
msgid "Feature Name: `optimize_attr`"
msgstr ""

#: src/2412-optimize-attr.md:2
msgid "Start Date: 2018-03-26"
msgstr ""

#: src/2412-optimize-attr.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2412](https://github.com/rust-lang/rfcs/pull/2412)"
msgstr ""

#: src/2412-optimize-attr.md:4
msgid ""
"Rust Issue: [rust-lang/rust#54882](https://github.com/rust-lang/rust/"
"issues/54882)"
msgstr ""

#: src/2412-optimize-attr.md:6
msgid "Summary"
msgstr ""

#: src/2412-optimize-attr.md:9
msgid ""
"This RFC introduces the `#[optimize]` attribute for controlling optimization "
"level on a per-item basis."
msgstr ""

#: src/2412-optimize-attr.md:12
msgid "Motivation"
msgstr ""

#: src/2412-optimize-attr.md:15
msgid ""
"Currently, rustc has only a small number of optimization options that apply "
"globally to the crate. With LTO and RLIB-only crates these options become "
"applicable to a whole-program, which reduces the ability to control "
"optimization even further."
msgstr ""

#: src/2412-optimize-attr.md:19
msgid ""
"For applications such as embedded, it is critical, that they satisfy the "
"size constraints. This means, that code must consciously pick one or the "
"other optimization level. Absence of a method to selectively optimize "
"different parts of a program in different ways precludes users from "
"utilising the hardware they have to the greatest degree."
msgstr ""

#: src/2412-optimize-attr.md:24
msgid ""
"With a C toolchain selective optimization is fairly easy to achieve by "
"compiling the relevant codegen units (objects) with different options. In "
"Rust ecosystem, where the concept of such units does not exist, an alternate "
"solution is necessary."
msgstr ""

#: src/2412-optimize-attr.md:28
msgid ""
"With the `#[optimize]` attribute it is possible to annotate the optimization "
"level of separate items, so that they are optimized differently from the "
"global optimization option."
msgstr ""

#: src/2412-optimize-attr.md:31
msgid "Guide-level explanation"
msgstr ""

#: src/2412-optimize-attr.md:34
msgid "`#[optimize(size)]`"
msgstr ""

#: src/2412-optimize-attr.md:36
msgid ""
"Sometimes, optimizations are a trade-off between execution time and the code "
"size. Some optimizations, such as loop unrolling increase code size many "
"times on average (compared to original function size) for marginal "
"performance benefits. In case such optimization is not desirable…"
msgstr ""

#: src/2412-optimize-attr.md:44 src/2412-optimize-attr.md:70
msgid "// code\n"
msgstr ""

#: src/2412-optimize-attr.md:48
msgid ""
"…will instruct rustc to consider this trade-off more carefully and avoid "
"optimising in a way that would result in larger code rather than a smaller "
"one. It may also have effect on what instructions are selected to appear in "
"the final binary."
msgstr ""

#: src/2412-optimize-attr.md:52
msgid ""
"Note that `#[optimize(size)]` is a hint, rather than a hard requirement and "
"compiler may still, while optimising, take decisions that increase function "
"size compared to an entirely unoptimized result."
msgstr ""

#: src/2412-optimize-attr.md:56
msgid ""
"Using this attribute is recommended when inspection of generated code "
"reveals unnecessarily large function or functions, but use of `-O` is still "
"preferable over `-C opt-level=s` or `-C opt-level=z`."
msgstr ""

#: src/2412-optimize-attr.md:60
msgid "`#[optimize(speed)]`"
msgstr ""

#: src/2412-optimize-attr.md:62
msgid ""
"Conversely, when one of the global optimization options for code size is "
"used (`-Copt-level=s` or `-Copt-level=z`), profiling might reveal some "
"functions that are unnecessarily “hot”. In that case, those functions may be "
"annotated with the `#[optimize(speed)]` to make the compiler make its best "
"effort to produce faster code."
msgstr ""

#: src/2412-optimize-attr.md:74
msgid ""
"Much like with `#[optimize(size)]`, the `speed` counterpart is also a hint "
"and will likely not yield the same results as using the global optimization "
"option for speed."
msgstr ""

#: src/2412-optimize-attr.md:77
msgid "Reference-level explanation"
msgstr ""

#: src/2412-optimize-attr.md:80
msgid ""
"The `#[optimize(size)]` attribute applied to an item or expression will "
"instruct the optimization pipeline to avoid applying optimizations that "
"could result in a size increase and machine code generator to generate code "
"that’s smaller rather than faster."
msgstr ""

#: src/2412-optimize-attr.md:84
msgid ""
"The `#[optimize(speed)]` attribute applied to an item or expression will "
"instruct the optimization pipeline to apply optimizations that are likely to "
"yield performance wins and machine code generator to generate code that’s "
"faster rather than smaller."
msgstr ""

#: src/2412-optimize-attr.md:88
msgid ""
"The `#[optimize]` attributes are just a hint to the compiler and are not "
"guaranteed to result in any different code."
msgstr ""

#: src/2412-optimize-attr.md:91
msgid ""
"If an `#[optimize]` attribute is applied to some grouping item (such as "
"`mod` or a crate), it propagates transitively to all items defined within "
"the grouping item. Note, that a function is also a “grouping” item for the "
"purposes of this RFC, and `#[optimize]` attribute applied to a function will "
"propagate to other functions or closures defined within the body of the "
"function."
msgstr ""

#: src/2412-optimize-attr.md:96
msgid ""
"`#[optimize]` attribute may also be applied to a closure expression using "
"the currently unstable `stmt_expr_attributes` feature."
msgstr ""

#: src/2412-optimize-attr.md:99
msgid ""
"It is an error to specify multiple incompatible `#[optimize]` options to a "
"single item or expression at once.  A more explicit `#[optimize]` attribute "
"overrides a propagated attribute."
msgstr ""

#: src/2412-optimize-attr.md:102
msgid ""
"`#[optimize(speed)]` is a no-op when a global optimization for speed option "
"is set (i.e. `-C opt-level=1-3`). Similarly `#[optimize(size)]` is a no-op "
"when a global optimization for size option is set (i.e. `-C opt-level=s/z`). "
"`#[optimize]` attributes are no-op when no optimizations are done globally "
"(i.e. `-C opt-level=0`). In all other cases the _exact_ interaction of the "
"`#[optimize]` attribute with the global optimization level is not specified "
"and is left up to implementation to decide."
msgstr ""

#: src/2412-optimize-attr.md:109
msgid ""
"`#[optimize]` attribute applied to non function-like items (such as "
"`struct`) or non function-like expressions (i.e. not closures) is considered "
"“unused” as of this RFC and should fire the `unused_attribute` lint (unless "
"the same attribute was used for a function-like item or expression, via e."
"g.  propagation). Some future RFC may assign some behaviour to this "
"attribute with respect to such definitions."
msgstr ""

#: src/2412-optimize-attr.md:115
msgid "Implementation approach"
msgstr ""

#: src/2412-optimize-attr.md:117
msgid ""
"For the LLVM backend, these attributes may be implemented in a following "
"manner:"
msgstr ""

#: src/2412-optimize-attr.md:119
msgid ""
"`#[optimize(size)]` – explicit function attributes exist at LLVM level. "
"Items with `optimize(size)` would simply apply the LLVM attributes to the "
"functions."
msgstr ""

#: src/2412-optimize-attr.md:122
msgid ""
"`#[optimize(speed)]` in conjunction with `-C opt-level=s/z` – use a global "
"optimization level of `-C opt-level=2/3` and apply the equivalent LLVM "
"function attribute (`optsize`, `minsize`) to all items which do not have an "
"`#[optimize(speed)]` attribute."
msgstr ""

#: src/2412-optimize-attr.md:126
msgid "Drawbacks"
msgstr ""

#: src/2412-optimize-attr.md:129
msgid ""
"Not all of the alternative codegen backends may be able to express such a "
"request, hence the “this is a hint” note on the `#[optimize]` attribute."
msgstr ""

#: src/2412-optimize-attr.md:131
msgid ""
"As a fallback, this attribute may be implemented in terms of more specific "
"optimization hints (such as `inline(never)`, the future `unroll(never)` etc)."
msgstr ""

#: src/2412-optimize-attr.md:134
msgid "Rationale and alternatives"
msgstr ""

#: src/2412-optimize-attr.md:137
msgid ""
"Proposed is a very semantic solution (describes the desired result, instead "
"of behaviour) to the problem of needing to sometimes inhibit some of the "
"trade-off optimizations such as loop unrolling."
msgstr ""

#: src/2412-optimize-attr.md:140
msgid ""
"Alternative, of course, would be to add attributes controlling such "
"optimizations, such as `#[unroll(no)]` on top of a loop statement. There’s "
"already precedent for this in the `#[inline]` annotations."
msgstr ""

#: src/2412-optimize-attr.md:144
msgid ""
"The author would like to argue that we should eventually have _both_, the "
"`#[optimize]` for people who look at generated code but are not willing to "
"dig for exact reasons, and the targeted attributes for people who know _why_ "
"the code is not satisfactory."
msgstr ""

#: src/2412-optimize-attr.md:148
msgid ""
"Furthermore, currently `optimize` is able to do more than any possible "
"combination of targeted attributes would be able to such as influencing the "
"instruction selection or switch codegen strategy (jump table, if chain, "
"etc.) This makes the attribute useful even in presence of all the targeted "
"optimization knobs we might have in the future."
msgstr ""

#: src/2412-optimize-attr.md:153
msgid "Prior art"
msgstr ""

#: src/2412-optimize-attr.md:156
msgid ""
"LLVM: `optsize`, `optnone`, `minsize` function attributes (exposed in Clang "
"in some way);"
msgstr ""

#: src/2412-optimize-attr.md:157
msgid ""
"GCC: `__attribute__((optimize))` function attribute which allows setting the "
"optimization level and using certain(?) `-f` flags for each function;"
msgstr ""

#: src/2412-optimize-attr.md:159
msgid ""
"IAR: Optimizations have a check box for “No size constraints”, which allows "
"compiler to go out of its way to optimize without considering the size trade-"
"off. Can only be applied on a per-compilation-unit basis. Enabled by "
"default, as is appropriate for a compiler targeting embedded use-cases."
msgstr ""

#: src/2412-optimize-attr.md:164
msgid "Unresolved questions"
msgstr ""

#: src/2412-optimize-attr.md:167
msgid "Should we also implement `optimize(always)`? `optimize(level=x)`?"
msgstr ""

#: src/2412-optimize-attr.md:168
msgid ""
"Left for future discussion, but should make sure such extension is possible."
msgstr ""

#: src/2412-optimize-attr.md:169
msgid ""
"Should there be any way to specify what global optimization for speed level "
"is used in conjunction with the optimization for speed option (e.g. `-Copt-"
"level=s3` could be equivalent to `-Copt-level=3` and `#[optimize(size)]` on "
"the crate item);"
msgstr ""

#: src/2412-optimize-attr.md:172
msgid "This may matter for users of `#[optimize(speed)]`."
msgstr ""

#: src/2412-optimize-attr.md:173
msgid "Are the propagation and `unused_attr` approaches right?"
msgstr ""
