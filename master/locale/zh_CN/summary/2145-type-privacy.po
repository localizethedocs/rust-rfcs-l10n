msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:04Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2145-type-privacy.md:1
msgid "Feature Name: N/A"
msgstr ""

#: src/2145-type-privacy.md:2
msgid "Start Date: 2017-09-09"
msgstr ""

#: src/2145-type-privacy.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2145](https://github.com/rust-lang/rfcs/pull/2145)"
msgstr ""

#: src/2145-type-privacy.md:4
msgid ""
"Rust Issue: [rust-lang/rust#48054](https://github.com/rust-lang/rust/"
"issues/48054)"
msgstr ""

#: src/2145-type-privacy.md:6
msgid "Summary"
msgstr ""

#: src/2145-type-privacy.md:9
msgid ""
"Type privacy rules are documented.  \n"
"Private-in-public errors are relaxed and turned into lints."
msgstr ""

#: src/2145-type-privacy.md:12
msgid "Motivation"
msgstr ""

#: src/2145-type-privacy.md:15
msgid ""
"Type privacy is implemented, but its rules still need to be documentated and "
"explained."
msgstr ""

#: src/2145-type-privacy.md:18
msgid ""
"Private-in-public checker is the previous incarnation of type privacy that "
"still exists in the compiler.  \n"
"Experience shows that private-in-public errors are often considered non-"
"intuitive, despite the rules being simple and sufficiently clear when "
"explained.  \n"
"People often expect private-in-public checker to check something it is not "
"supposed to check and otherwise, allow code that isn't supposed to be "
"allowed. This creates a source of confusion."
msgstr ""

#: src/2145-type-privacy.md:27
msgid ""
"With type privacy implemented, private-in-public errors are no longer "
"strictly necessary, so they can be removed from the language, thus removing "
"the source of confusion.  \n"
"However diagnosing \"private-in-public\" situations early can still help "
"programmers to prevent most of client-side type privacy errors, so \"private-"
"in-public\" diagnostics can be turned into lints instead of being completely "
"removed.  \n"
"Lints, unlike errors, can use heuristics, so \"private-in-public\" "
"diagnostics can match programmer's intuition closer now by using "
"reachability-based heuristics instead of just local `pub` annotations."
msgstr ""

#: src/2145-type-privacy.md:38
msgid "Guide-level explanation"
msgstr ""

#: src/2145-type-privacy.md:41 src/2145-type-privacy.md:292
msgid "Type privacy"
msgstr ""

#: src/2145-type-privacy.md:43
msgid ""
"Type privacy ensures that a type private to some module cannot be used "
"outside of this module (unless anonymized) without a privacy error.  \n"
"This is similar to more familiar name privacy ensuring that private items or "
"fields can't be _named_ outside of their module without a privacy error."
msgstr ""

#: src/2145-type-privacy.md:48
msgid ""
"\"Using\" a type means either explicitly naming it (maybe through `type` "
"aliases), or obtaining a value of that type."
msgstr ""

#: src/2145-type-privacy.md:53
msgid "// This is a type private to module `m`\n"
msgstr ""

#: src/2145-type-privacy.md:55
msgid "// OK, public alias to the private type\n"
msgstr ""

#: src/2145-type-privacy.md:59
msgid "// OK, public function returning a value of the private type\n"
msgstr ""

#: src/2145-type-privacy.md:62
msgid "// ERROR, can't name private type `m::Priv` outside of its module\n"
msgstr ""

#: src/2145-type-privacy.md:65
msgid ""
"// A type is considered private even if its primary component (type "
"constructor)\n"
"// is public, but it has private generic arguments.\n"
"// ERROR, can't name private type `Option<m::Priv>` outside of its module\n"
msgstr ""

#: src/2145-type-privacy.md:72
msgid ""
"// ERROR, can't have a value of private type `m::Priv` outside of its "
"module\n"
msgstr ""

#: src/2145-type-privacy.md:77
msgid ""
"Type privacy ensures that a private type is an implementation detail of its "
"module and you can always change it in any way (e.g. add or remove methods, "
"add or remove trait implementations) without requiring any changes in other "
"modules."
msgstr ""

#: src/2145-type-privacy.md:82
msgid ""
"Let's imagine for a minute that type privacy doesn't work and you can name a "
"private type `Priv` through an alias or obtain its values outside of its "
"module.  \n"
"Then let's assume that this type implements some trait `Trait` at the "
"moment. Now foreign code can freely define functions like"
msgstr ""

#: src/2145-type-privacy.md:91
msgid "and pass `Priv` to them"
msgstr ""

#: src/2145-type-privacy.md:96
msgid ""
", so it becomes a _requirement_ for `Priv` to implement `Trait` and we can't "
"remove it anymore.  \n"
"Type privacy helps to avoid such unintended requirements."
msgstr ""

#: src/2145-type-privacy.md:100
msgid ""
"The sentence introducing type privacy contains a clarification - \"unless "
"anonymized\".  \n"
"It means that private types can be leaked into other modules through trait "
"objects (dynamically anonymized), or `impl Trait` (statically anonymized), "
"or usual generics (statically anonymized as well)."
msgstr ""

#: src/2145-type-privacy.md:107
msgid ""
"// By defining functions like these you explicitly give a promise that they "
"will\n"
"// always return something implementing `Trait`, maybe `Priv`, maybe some "
"other\n"
"// type (this is an implementation detail).\n"
msgstr ""

#: src/2145-type-privacy.md:114
msgid ""
"// Here some code outside of our module (in `liballoc`) works with objects "
"of\n"
"// our private type, but knows only that they are `Clone`, the specific\n"
"// container element's type is anonymized for code in `liballoc`.\n"
msgstr ""

#: src/2145-type-privacy.md:123
msgid ""
"The rules for type privacy work for traits as well, e.g. you won't be able "
"to do this when trait aliases are implemented"
msgstr ""

#: src/2145-type-privacy.md:130
msgid "// ERROR, can't name private trait `m::PrivTr` outside of its module\n"
msgstr ""

#: src/2145-type-privacy.md:134
msgid ""
"(Trait objects are considered types, so they are covered by previous "
"paragraphs.)"
msgstr ""

#: src/2145-type-privacy.md:137
msgid "Private-in-public lints"
msgstr ""

#: src/2145-type-privacy.md:139
msgid ""
"Previously type privacy was ensured by so called private-in-public errors, "
"that worked preventively."
msgstr ""

#: src/2145-type-privacy.md:145
msgid "// ERROR, private type `Priv` in public interface.\n"
msgstr ""

#: src/2145-type-privacy.md:148
msgid ""
"// Can't obtain a value of `Priv` because for `leak` the function "
"definition\n"
"// itself is illegal.\n"
msgstr ""

#: src/2145-type-privacy.md:154
msgid ""
"The logic behind private-in-public rules is very simple, if some type has "
"visibility `vis_type` then it cannot be used in interfaces of items with "
"visibilities `vis_interface` where `vis_interface > vis_type`.  \n"
"In particular, this code is illegal"
msgstr ""

#: src/2145-type-privacy.md:167
msgid ""
"for a simple reason - `vis(f) = pub, vis(S) = pub(in outer), pub > pub(in "
"outer)`. Many people found this confusing because they expected private-in-"
"public rules to be based on crate-global reachability and not on local `pub` "
"annotations.  \n"
"(Both `S` and `f` are reachable only from `outer` despite `f` being `pub`.)"
msgstr ""

#: src/2145-type-privacy.md:173
msgid ""
"In addition, private-in-public rules were found to be [insufficient](https://"
"github.com/rust-lang/rust/issues/30476) for ensuring type privacy due to "
"type inference being quite smart.  \n"
"As a result, type privacy checking was implemented directly - when we see "
"value `m::leak()` we just check if its type private or not, so private-in-"
"public rules became not-strictly-necessary for the compiler."
msgstr ""

#: src/2145-type-privacy.md:180
msgid ""
"However, private-in-public diagnostics are still pretty useful for "
"humans!  \n"
"For example, if a function is defined like this"
msgstr ""

#: src/2145-type-privacy.md:188
msgid ""
"it's _guaranteed_ to be unusable outside of `m` because every its use will "
"cause a type privacy error.  \n"
"That's probably not what the author of `f` wanted. Either `Priv` is supposed "
"to be public, or `f` is supposed to be private. It would be nice to diagnose "
"cases like this, but to avoid \"false positives\" like the previous example "
"with `outer`/`inner`.  \n"
"Meet reachability-based private-in-public _lints_!"
msgstr ""

#: src/2145-type-privacy.md:196
msgid "Lint #1: Private types in primary interface of effectively public items"
msgstr ""

#: src/2145-type-privacy.md:198
msgid ""
"Effective visibility of an item is how far it's actually reexported or "
"leaked through other means, like return types.  \n"
"Effective visibility can never be larger than nominal visibility (i.e. what "
"`pub` annotation says), but it can be smaller."
msgstr ""

#: src/2145-type-privacy.md:203
msgid ""
"For example, in the `outer`/`inner` example nominal visibility of `f` is "
"`pub`, but its effective visibility is `pub(in outer)`, because it's neither "
"reexported from `outer`, nor can be named directly from outside of it.  \n"
"`effective_vis(f) <= vis(Priv)` means that the private-in-public lint #1 is "
"_not_ reported for `f`."
msgstr ""

#: src/2145-type-privacy.md:209
msgid ""
"\"Primary interface\" in the lint name means everything in the interface "
"except for trait bounds and `where` clauses, those are considered secondary "
"interface."
msgstr ""

#: src/2145-type-privacy.md:214
msgid "// WARN, private type in primary interface\n"
msgstr ""

#: src/2145-type-privacy.md:217
msgid "// OK, private trait in secondary interface\n"
msgstr ""

#: src/2145-type-privacy.md:220
msgid ""
"This lint replaces part of private-in-public errors. Having something "
"private in primary interface guarantees that the item will be unusable from "
"outer modules due to type privacy (primary interface is considered part of "
"the type when type privacy is checked), so it's very desirable to warn about "
"this situation in advance and this lint needs to be at least warn-by-default."
msgstr ""

#: src/2145-type-privacy.md:226
msgid "Provisional name for the lint - `private_interfaces`."
msgstr ""

#: src/2145-type-privacy.md:228
msgid ""
"Lint #2: Private traits/types in secondary interface of effectively public "
"items"
msgstr ""

#: src/2145-type-privacy.md:230
msgid ""
"This lint is reported if private types or traits are found in trait bounds "
"or `where` clauses of an effectively public item."
msgstr ""

#: src/2145-type-privacy.md:235
msgid "// WARN, private trait in secondary interface\n"
msgstr ""

#: src/2145-type-privacy.md:238
msgid ""
"Function `overloaded` has public type, can't leak values of any other "
"private types and can be freely used outside of its module without causing "
"type privacy errors. There are reasonable use cases for such functions, for "
"example emulation of sealed traits.  \n"
"The only suspicious part about it is documentation - what arguments can it "
"take exactly? The set of possible argument types is closed and determined by "
"implementations of the private trait `PrivTr`, so it's kinda mystery unless "
"it's well documented by the author of `overloaded`.  \n"
"There are stability implications as well - set of possible `T`s is still an "
"interface of `overload`, so impls of `PrivTr` cannot be removed backward-"
"compatibly.  \n"
"This lint replaces part of private-in-public errors and can be reported as "
"warn-by-default or allow-by-default."
msgstr ""

#: src/2145-type-privacy.md:252
msgid "Provisional name for the lint - `private_bounds`."
msgstr ""

#: src/2145-type-privacy.md:254
msgid "Lint #3: \"Voldemort types\" (it's reachable, but I can't name it)"
msgstr ""

#: src/2145-type-privacy.md:256
msgid "Consider this code"
msgstr ""

#: src/2145-type-privacy.md:259
msgid ""
"// `S` has public nominal and effective visibility,\n"
"    // but it can't be *named* outside of `m::super`.\n"
msgstr ""

#: src/2145-type-privacy.md:263
msgid ""
"// OK, can return public type `m::S` and\n"
"// can use the returned value in outer modules.\n"
"// BUT, we can't name the returned type, unless we have `typeof`,\n"
"// and we don't have it yet.\n"
msgstr ""

#: src/2145-type-privacy.md:270
msgid ""
"The \"Voldemort type\" (or, more often, \"Voldemort trait\") pattern has "
"legitimate uses, but often it's just an oversight and `S` is supposed to be "
"reexported and nameable from outer modules.  \n"
"The lint is supposed to report items for which effective visibility is "
"larger than the area in which they can be named.  \n"
"This lint is new and doesn't replace private-in-public errors, but it "
"provides checking that many people _expected_ from private-in-public.  \n"
"The lint should be allow-by-default or it can be placed into Clippy as an "
"alternative."
msgstr ""

#: src/2145-type-privacy.md:280
msgid "Provisional name for the lint - `unnameable_types`."
msgstr ""

#: src/2145-type-privacy.md:282
msgid "Lint #4: `private_in_public`"
msgstr ""

#: src/2145-type-privacy.md:284
msgid ""
"Some private-in-public errors are currently reported as a lint "
"`private_in_public` for compatibility reasons.  \n"
"This compatibility lint will be removed and its uses will be reported as "
"warnings by `renamed_and_removed_lints`."
msgstr ""

#: src/2145-type-privacy.md:289
msgid "Reference-level explanation"
msgstr ""

#: src/2145-type-privacy.md:294
msgid "How to determine visibility of a type?"
msgstr ""

#: src/2145-type-privacy.md:296
msgid ""
"Built-in types are considered `pub` (integer and floating point types, "
"`bool`, `char`, `str`, `!`)."
msgstr ""

#: src/2145-type-privacy.md:298
msgid ""
"Type parameters (including `Self` in traits) are considered `pub` as well."
msgstr ""

#: src/2145-type-privacy.md:299
msgid ""
"Arrays and slices inherit visibility from their element types.  \n"
"`vis([T; N]) = vis([T]) = vis(T)`."
msgstr ""

#: src/2145-type-privacy.md:301
msgid ""
"References and pointers inherit visibility from their pointee types.  \n"
"`vis(&MUTABILITY T) = vis(*MUTABILITY T) = vis(T)`."
msgstr ""

#: src/2145-type-privacy.md:303
msgid ""
"Tuple types are as visible as their least visible component.  \n"
"`vis((A, B)) = min(vis(A), vis(B))`."
msgstr ""

#: src/2145-type-privacy.md:305
msgid ""
"Struct, union and enum types are as visible as their least visible type "
"argument or type constructor.  \n"
"`vis(Struct<A, B>) = min(vis(Struct), vis(A), vis(B))`."
msgstr ""

#: src/2145-type-privacy.md:308
msgid ""
"Closures and generators have same visibilities as equivalent structs defined "
"in the same module.  \n"
"`vis(CLOSURE<A, B>) = min(vis(CURRENT_MOD), vis(A), vis(B))`."
msgstr ""

#: src/2145-type-privacy.md:311
msgid ""
"Traits or trait types are as visible as their least visible type argument or "
"trait constructor.  \n"
"`vis(Tr<A, B>) = min(vis(Tr), vis(A), vis(B))`."
msgstr ""

#: src/2145-type-privacy.md:314
msgid ""
"Trait objects and `impl Trait` types are as visible as their least visible "
"component.  \n"
"`vis(TrA + TrB) = vis(impl TrA + TrB) = min(vis(TrA), vis(TrB))`."
msgstr ""

#: src/2145-type-privacy.md:317
msgid ""
"Non-normalizable associated types are as visible as their least visible "
"component.  \n"
"`vis(<Type as Trait>::AssocType) = min(vis(Type), vis(Trait))`."
msgstr ""

#: src/2145-type-privacy.md:320
msgid ""
"Function pointer types are as visible as least visible types in their "
"signatures.  \n"
"`vis(fn(A, B) -> R) = min(vis(A), vis(B), vis(R))`."
msgstr ""

#: src/2145-type-privacy.md:323
msgid ""
"Function item types are as visible as their least visible component as well, "
"but the definition of a \"component\" is a bit more complex."
msgstr ""

#: src/2145-type-privacy.md:325
msgid ""
"For free functions and foreign functions components include signature, type "
"parameters and the function item's nominal visibility.  \n"
"`vis(fn(A, B) -> R { foo<C> }) = min(vis(fn(A, B) -> R), vis(C), vis(foo))`"
msgstr ""

#: src/2145-type-privacy.md:328
msgid ""
"For struct and enum variant constructors components include signature, type "
"parameters and the constructor item's nominal visibility.  \n"
"`vis(fn(A, B) -> S<C> { S_CTOR<C> }) = min(vis(fn(A, B) -> S<C>), "
"vis(S_CTOR))`.  \n"
"`vis(fn(A, B) -> E<C> { E::V_CTOR<C> }) = min(vis(fn(A, B) -> E<C>), vis(E::"
"V_CTOR))`.  \n"
"`vis(S_CTOR) = min(vis(S), vis(field_1), ..., vis(field_N))`.  \n"
"`vis(E::V_CTOR) = vis(E)`."
msgstr ""

#: src/2145-type-privacy.md:334
msgid ""
"For inherent methods components include signature, impl type, type "
"parameters and the method's nominal visibility.  \n"
"`vis(fn(A, B) -> R { <Type>::foo<C> })) = min(vis(fn(A, B) -> R), vis(C), "
"vis(Type), vis(foo))`."
msgstr ""

#: src/2145-type-privacy.md:337
msgid ""
"For trait methods components include signature, trait, type parameters "
"(including impl type `Self`) and the method item's nominal visibility "
"(inherited from the trait, included automatically).  \n"
"`vis(fn(A, B) -> R { <Type as Trait>::foo<C> })) = min(vis(fn(A, B) -> R), "
"vis(C), vis(Type), vis(Trait))`."
msgstr ""

#: src/2145-type-privacy.md:341
msgid ""
"\"Infer me\" types `_` are replaced with their inferred types before "
"checking."
msgstr ""

#: src/2145-type-privacy.md:343
msgid "The type privacy rule"
msgstr ""

#: src/2145-type-privacy.md:345
msgid ""
"A type or a trait private to module `m` (`vis(in m)`) cannot be used outside "
"of that module (`vis(outside) > vis(in m)`).  \n"
"Uses include naming this type or trait (possibly through aliases) or "
"obtaining values (expressions or patterns) of this type."
msgstr ""

#: src/2145-type-privacy.md:350
msgid ""
"The rule is enforced non-hygienically.  \n"
"So it's possible for a macro 2.0 to name some private type without causing "
"name privacy errors, but it will still be reported as a type privacy "
"violation.  \n"
"This can be partially relaxed in the future, but such relaxations are out of "
"scope for this RFC."
msgstr ""

#: src/2145-type-privacy.md:356
msgid "Additional restrictions for associated items"
msgstr ""

#: src/2145-type-privacy.md:358
msgid ""
"For technical reasons it's not always desirable or possible to fully "
"normalize associated types before checking them for privacy.  \n"
"So, if we see `<Type as Trait>::AssocType` we can guaranteedly check only "
"`Type` and `Trait`, but not the resulting type.  \n"
"So we must be sure it's no more private than what we can check."
msgstr ""

#: src/2145-type-privacy.md:364
msgid ""
"As a result, private-in-public violations for associated type definitions "
"are still eagerly reported as errors, using the old rules based on local "
"`pub` annotations and not reachability."
msgstr ""

#: src/2145-type-privacy.md:373
msgid "// ERROR, vis(Priv) < min(vis(Trait), vis(Type))\n"
msgstr ""

#: src/2145-type-privacy.md:377
msgid ""
"When associated function is defined in a private impl (i.e. the impl type or "
"trait is private) it's guaranteed that the function can't be used outside of "
"the impl's area of visibility.  \n"
"Type privacy ensures this because associated functions have their own unique "
"types attached to them."
msgstr ""

#: src/2145-type-privacy.md:383
msgid ""
"Associated constants and associated types from private impls don't have "
"attached unique types, so they sometimes can be used from outer modules due "
"to sufficiently smart type inference."
msgstr ""

#: src/2145-type-privacy.md:392 src/2145-type-privacy.md:397
msgid "// This is a private impl because `Pub<Priv>` is a private type\n"
msgstr ""

#: src/2145-type-privacy.md:401
msgid "// But we still can use `C` outside of `m`?\n"
msgstr ""

#: src/2145-type-privacy.md:403
msgid "// With type inference this means `<Pub<Priv>>::C`\n"
msgstr ""

#: src/2145-type-privacy.md:406
msgid ""
"It would be good to provide the same guarantees for associated constants and "
"types as for associated functions.  \n"
"As a result, type privacy additionally prohibits use of any associated items "
"from private impls."
msgstr ""

#: src/2145-type-privacy.md:411
msgid "// ERROR, `C` is from a private impl with type `Pub<Priv>`\n"
msgstr ""

#: src/2145-type-privacy.md:412
msgid ""
"// ERROR, `A` is from a private impl with type `Pub<Priv>`,\n"
"// even if the whole type of `x` is public `u8`.\n"
msgstr ""

#: src/2145-type-privacy.md:417
msgid ""
"In principle, this restriction can be considered a part of the primary type "
"privacy rule - \"can't name a private type\" - if all `_`s (types to infer, "
"explicit or implicit) are replaced by their inferred types before checking, "
"so `Pub` and `Pub<_>` in the examples above become `Pub<Priv>`."
msgstr ""

#: src/2145-type-privacy.md:422
msgid "Lints"
msgstr ""

#: src/2145-type-privacy.md:424
msgid ""
"Effective visibility of an item is determined by a module into which it can "
"be leaked through"
msgstr ""

#: src/2145-type-privacy.md:426
msgid "chain of public parent modules (they make it directly nameable)"
msgstr ""

#: src/2145-type-privacy.md:427
msgid ""
"chains of reexports or type aliases (they make it nameable through aliases)"
msgstr ""

#: src/2145-type-privacy.md:428
msgid ""
"functions, constants, fields \"returning\" the value of this item, if the "
"item is a type"
msgstr ""

#: src/2145-type-privacy.md:430
msgid "maybe something else if deemed necessary, but probably not macros 2.0."
msgstr ""

#: src/2145-type-privacy.md:432
msgid ""
"(Here we consider the \"whole universe\" a module too for uniformity.)  \n"
"If effective visibility of an item is larger than its nominal visibility "
"(`pub` annotation), then it's capped by the nominal visibility."
msgstr ""

#: src/2145-type-privacy.md:436
msgid ""
"Primary interface of an item is all its interface (types of returned values, "
"types of fields, types of fn parameters) except for bounds on generic "
"parameters and `where` clauses."
msgstr ""

#: src/2145-type-privacy.md:440
msgid ""
"Secondary interface of an item consists of bounds on generic parameters and "
"`where` clauses, including supertraits for trait items."
msgstr ""

#: src/2145-type-privacy.md:443
msgid ""
"Lint `private_interfaces` is reported when a type with visibility `x` is "
"used in primary interface of an item with effective visibility `y` and `x < "
"y`.  \n"
"This lint is warn-by-default."
msgstr ""

#: src/2145-type-privacy.md:447
msgid ""
"Lint `private_bounds` is reported when a type or trait with visibility `x` "
"is used in secondary interface of an item with effective visibility `y` and "
"`x < y`.  \n"
"This lint is warn-by-default."
msgstr ""

#: src/2145-type-privacy.md:452
msgid ""
"Lint `unnameable_types` is reported when effective visibility of a type is "
"larger than module in which it can be named, either directly, or through "
"reexports, or through trivial type aliases (`type X = Y;`, no generics on "
"both sides).  \n"
"This lint is allow-by-default."
msgstr ""

#: src/2145-type-privacy.md:458
msgid "Compatibility lint `private_in_public` is never reported and removed."
msgstr ""

#: src/2145-type-privacy.md:460
msgid "Drawbacks"
msgstr ""

#: src/2145-type-privacy.md:463
msgid "With"
msgstr ""

#: src/2145-type-privacy.md:469
msgid ""
"being legal (even if it's warned against by default) the set of "
"`PrivateTrait`'s implementations becomes a part of `f`'s interface. "
"`PrivateTrait` can still be freely renamed or even split into several traits "
"though.  \n"
"`rustdoc` may be not fully prepared to document items with private traits in "
"bounds, manually written documentation explaining how to use the interface "
"may be required."
msgstr ""

#: src/2145-type-privacy.md:477
msgid "Rationale and Alternatives"
msgstr ""

#: src/2145-type-privacy.md:480
msgid "Names for the lints are subject to bikeshedding."
msgstr ""

#: src/2145-type-privacy.md:482
msgid ""
"`private_interfaces` and `private_bounds` can be merged into one lint. The "
"rationale for keeping them separate is different probabilities of errors in "
"case of lint violations.  \n"
"The first lint indicates an almost guaranteed error on client side, the "
"second one is more in the \"missing documentation\" category."
msgstr ""

#: src/2145-type-privacy.md:488
msgid "Unresolved questions"
msgstr ""

#: src/2145-type-privacy.md:491
msgid ""
"It's not fully clear if the restriction for associated type definitions "
"required for type privacy soundness, or it's just a workaround for a "
"technical difficulty."
msgstr ""

#: src/2145-type-privacy.md:494
msgid ""
"Interactions between macros 2.0 and the notions of reachability / effective "
"visibility used for the lints are unclear."
msgstr ""
