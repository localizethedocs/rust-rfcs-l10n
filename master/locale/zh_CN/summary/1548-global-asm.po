msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:03Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1548-global-asm.md:1
msgid "Feature Name: global_asm"
msgstr ""

#: src/1548-global-asm.md:2
msgid "Start Date: 2016-03-18"
msgstr ""

#: src/1548-global-asm.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1548](https://github.com/rust-lang/rfcs/pull/1548)"
msgstr ""

#: src/1548-global-asm.md:4
msgid ""
"Rust Issue: [rust-lang/rust#35119](https://github.com/rust-lang/rust/"
"issues/35119)"
msgstr ""

#: src/1548-global-asm.md:6
msgid "Summary"
msgstr ""

#: src/1548-global-asm.md:9
msgid ""
"This RFC exposes LLVM's support for [module-level inline assembly](http://"
"llvm.org/docs/LangRef.html#module-level-inline-assembly) by adding a "
"`global_asm!` macro. The syntax is very simple: it just takes a string "
"literal containing the assembly code."
msgstr ""

#: src/1548-global-asm.md:11
msgid "Example:"
msgstr ""

#: src/1548-global-asm.md:13
msgid ""
"r#\"\n"
".globl my_asm_func\n"
"my_asm_func:\n"
"    ret\n"
"\"#"
msgstr ""

#: src/1548-global-asm.md:24
msgid "Motivation"
msgstr ""

#: src/1548-global-asm.md:27
msgid ""
"There are two main use cases for this feature. The first is that it allows "
"functions to be written completely in assembly, which mostly eliminates the "
"need for a `naked` attribute. This is mainly useful for function that use a "
"custom calling convention, such as interrupt handlers."
msgstr ""

#: src/1548-global-asm.md:29
msgid ""
"Another important use case is that it allows external assembly files to be "
"used in a Rust module without needing hacks in the build system:"
msgstr ""

#: src/1548-global-asm.md:32
msgid "\"my_asm_file.s\""
msgstr ""

#: src/1548-global-asm.md:35
msgid ""
"Assembly files can also be preprocessed or generated by `build.rs` (for "
"example using the C preprocessor), which will produce output files in the "
"Cargo output directory:"
msgstr ""

#: src/1548-global-asm.md:38
msgid "\"OUT_DIR\""
msgstr ""

#: src/1548-global-asm.md:38
msgid "\"/preprocessed_asm.s\""
msgstr ""

#: src/1548-global-asm.md:41
msgid "Detailed design"
msgstr ""

#: src/1548-global-asm.md:44
msgid ""
"See description above, not much to add. The macro will map directly to "
"LLVM's `module asm`."
msgstr ""

#: src/1548-global-asm.md:46
msgid "Drawbacks"
msgstr ""

#: src/1548-global-asm.md:49
msgid "Like `asm!`, this feature depends on LLVM's integrated assembler."
msgstr ""

#: src/1548-global-asm.md:51
msgid "Alternatives"
msgstr ""

#: src/1548-global-asm.md:54
msgid ""
"The current way of including external assembly is to compile the assembly "
"files using gcc in `build.rs` and link them into the Rust program as a "
"static library."
msgstr ""

#: src/1548-global-asm.md:56
msgid ""
"An alternative for functions written entirely in assembly is to add a "
"[`#[naked]` function attribute](https://github.com/rust-lang/rfcs/pull/1201)."
msgstr ""

#: src/1548-global-asm.md:58
msgid "Unresolved questions"
msgstr ""

#: src/1548-global-asm.md:61
msgid "None"
msgstr ""
