msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:03Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1789-as-cell.md:1
msgid "Feature Name: as_cell"
msgstr ""

#: src/1789-as-cell.md:2
msgid "Start Date: 2016-11-13"
msgstr ""

#: src/1789-as-cell.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1789](https://github.com/rust-lang/rfcs/pull/1789)"
msgstr ""

#: src/1789-as-cell.md:4
msgid ""
"Rust Issue: [rust-lang/rust#43038](https://github.com/rust-lang/rust/"
"issues/43038)"
msgstr ""

#: src/1789-as-cell.md:6
msgid "Summary"
msgstr ""

#: src/1789-as-cell.md:9
msgid "Change `Cell<T>` to allow `T: ?Sized`."
msgstr ""

#: src/1789-as-cell.md:10
msgid "Guarantee that `T` and `Cell<T>` have the same memory layout."
msgstr ""

#: src/1789-as-cell.md:11
msgid "Enable the following conversions through the std lib:"
msgstr ""

#: src/1789-as-cell.md:12
msgid "`&mut T -> &Cell<T> where T: ?Sized`"
msgstr ""

#: src/1789-as-cell.md:13
msgid "`&Cell<[T]> -> &[Cell<T>]`"
msgstr ""

#: src/1789-as-cell.md:15
msgid ""
"Note: https://github.com/rust-lang/rfcs/pull/1651 has been accepted "
"recently, so no `T: Copy` bound is needed anymore."
msgstr ""

#: src/1789-as-cell.md:18
msgid "Motivation"
msgstr ""

#: src/1789-as-cell.md:21
msgid ""
"Rust's iterators offer a safe, fast way to iterate over collections while "
"avoiding additional bound checks."
msgstr ""

#: src/1789-as-cell.md:24
msgid ""
"However, due to the borrow checker, they run into issues if we try to have "
"more than one iterator into the same data structure while mutating elements "
"in it."
msgstr ""

#: src/1789-as-cell.md:27
msgid ""
"Wanting to do this is not that unusual for many low level algorithms that "
"deal with integers, floats or similar primitive data types."
msgstr ""

#: src/1789-as-cell.md:30
msgid "For example, an algorithm might..."
msgstr ""

#: src/1789-as-cell.md:32
msgid "For each element, access each other element."
msgstr ""

#: src/1789-as-cell.md:33
msgid ""
"For each element, access an element a number of elements before or after it."
msgstr ""

#: src/1789-as-cell.md:35
msgid ""
"Todays answer for algorithms like that is to fall back to C-style for loops "
"and indexing, which might look like this..."
msgstr ""

#: src/1789-as-cell.md:41 src/1789-as-cell.md:63 src/1789-as-cell.md:101
#: src/1789-as-cell.md:248 src/1789-as-cell.md:362
msgid "// example 1\n"
msgstr ""

#: src/1789-as-cell.md:48 src/1789-as-cell.md:70 src/1789-as-cell.md:108
#: src/1789-as-cell.md:255 src/1789-as-cell.md:369
msgid "// example 2\n"
msgstr ""

#: src/1789-as-cell.md:56
msgid "...but this reintroduces potential bound-checking costs."
msgstr ""

#: src/1789-as-cell.md:58
msgid ""
"The alternative, short of changing the actual algorithms involved, is to use "
"internal mutability to enable safe mutations even with overlapping shared "
"views into the data:"
msgstr ""

#: src/1789-as-cell.md:78
msgid ""
"This has the advantages of allowing both bound-check free iteration and "
"aliasing references, but comes with restrictions that makes it not generally "
"applicable, namely:"
msgstr ""

#: src/1789-as-cell.md:82
msgid ""
"The need to change the definition of the data structure containing the data "
"(Which is not always possible because it might come from external code)."
msgstr ""

#: src/1789-as-cell.md:84
msgid ""
"Loss of the ability to directly hand out `&T` and `&mut T` references to the "
"data."
msgstr ""

#: src/1789-as-cell.md:86
msgid ""
"This RFC proposes a way to address these in cases where `Cell<T>` could be "
"used by introducing simple conversions functions to the standard library "
"that allow the creation of shared borrowed `Cell<T>`s from mutably borrowed "
"`T`s."
msgstr ""

#: src/1789-as-cell.md:91
msgid ""
"This in turn allows the original data structure to remain unchanged, while "
"allowing to temporary opt-in to the `Cell` API as needed. As an example, "
"given `Cell::from_mut_slice(&mut [T]) -> &[Cell<T>]`, the previous examples "
"can be written as this:"
msgstr ""

#: src/1789-as-cell.md:98 src/1789-as-cell.md:245 src/1789-as-cell.md:359
msgid "// convert the mutable borrow\n"
msgstr ""

#: src/1789-as-cell.md:116
msgid "Detailed design"
msgstr ""

#: src/1789-as-cell.md:119
msgid "Language"
msgstr ""

#: src/1789-as-cell.md:121
msgid ""
"The core of this proposal is the ability to convert a `&T` to a `&Cell<T>`, "
"so in order for it to be safe, **it needs to be guaranteed that `T` and "
"`Cell<T>` have the same memory layout**, and that there are no codegen "
"issues based on viewing a reference to a type that does not contain a "
"`UnsafeCell` as a reference to a type that does contain a `UnsafeCell`."
msgstr ""

#: src/1789-as-cell.md:127
msgid ""
"As far as the author is aware, both should already implicitly fall out of "
"the semantic of `Cell` and Rusts/llvms notion of aliasing:"
msgstr ""

#: src/1789-as-cell.md:130
msgid ""
"`Cell` is safe interior mutability based on memcopying the `T`, and thus "
"does not need additional fields or padding."
msgstr ""

#: src/1789-as-cell.md:132
msgid ""
"`&mut T -> &U` is a sub borrow, which prevents access to the original `&mut "
"T` for its duration, thus no aliasing."
msgstr ""

#: src/1789-as-cell.md:135
msgid "Std library"
msgstr ""

#: src/1789-as-cell.md:137
msgid "`from_mut`"
msgstr ""

#: src/1789-as-cell.md:139
msgid ""
"We add a constructor to the cell API that enables the `&mut T -> &Cell<T>` "
"conversion, implemented with the equivalent of a `transmute()` of the two "
"pointers:"
msgstr ""

#: src/1789-as-cell.md:153
msgid ""
"In the future this could also be provided through `AsRef`, `Into` or `From` "
"impls."
msgstr ""

#: src/1789-as-cell.md:156
msgid "Unsized `Cell<T>`"
msgstr ""

#: src/1789-as-cell.md:158
msgid ""
"We extend `Cell<T>` to allow `T: ?Sized`, and move all compatible methods to "
"a less restricted impl block:"
msgstr ""

#: src/1789-as-cell.md:173
msgid ""
"This is purely done to enable cell slicing below, and should otherwise have "
"no effect on any existing code."
msgstr ""

#: src/1789-as-cell.md:176
msgid "Cell Slicing"
msgstr ""

#: src/1789-as-cell.md:178
msgid ""
"We enable a conversion from `&Cell<[T]>` to `&[Cell<T>]`. This seems like it "
"violates the \"no interior references\" API of `Cell` at first glance, but "
"is actually safe:"
msgstr ""

#: src/1789-as-cell.md:182
msgid ""
"A slice represents a number of elements next to each other. Thus, if `&mut T "
"-> &Cell<T>` is ok, then `&mut [T] -> &[Cell<T>]` would be as well. `&mut "
"[T] -> &Cell<[T]>` follows from `&mut T -> &Cell<T>` through substitution, "
"so `&Cell<[T]> <-> &[Cell<T>]` has to be valid."
msgstr ""

#: src/1789-as-cell.md:186
msgid ""
"The API of a `Cell<T>` is to allow internal mutability through single-"
"threaded memcopies only. Since a memcopy is just a copy of all bits that "
"make up a type, it does not matter if we logically do a memcopy to all "
"elements of a slice through a `&Cell<[T]>`, or just a memcopy to a single "
"element through a `&Cell<T>`."
msgstr ""

#: src/1789-as-cell.md:191
msgid ""
"Yet another way to look at it is that if we created a `&mut T` to each "
"element of a `&mut [T]`, and converted each of them to a `&Cell<T>`, their "
"addresses would allow \"stitching\" them back together to a single "
"`&[Cell<T>]`"
msgstr ""

#: src/1789-as-cell.md:195
msgid ""
"For convenience, we expose this conversion by implementing `Index` for "
"`Cell<[T]>`:"
msgstr ""

#: src/1789-as-cell.md:241
msgid "Using this, the motivation example can be written as such:"
msgstr ""

#: src/1789-as-cell.md:263
msgid "Possible extensions"
msgstr ""

#: src/1789-as-cell.md:265
msgid ""
"The proposal only covers the base case `&mut T -> &Cell<T>` and the "
"trivially implementable extension to `[T]`, but in theory this conversion "
"could be enabled for many \"higher level mutable reference\" types, like for "
"example mutable iterators (with the goal of making them cloneable through "
"this)."
msgstr ""

#: src/1789-as-cell.md:271
msgid ""
"See https://play.rust-lang.org/?"
"gist=d012cebf462841887323185cff8ccbcc&version=stable&backtrace=0 for an "
"example implementation and a more complex use case, and https://crates.io/"
"crates/alias for an existing crate providing these features."
msgstr ""

#: src/1789-as-cell.md:275
msgid "How We Teach This"
msgstr ""

#: src/1789-as-cell.md:278
msgid ""
"What names and terminology work best for these concepts and why? How is this "
"idea best presentedâ€”as a continuation of existing Rust patterns, or as a "
"wholly new one?"
msgstr ""

#: src/1789-as-cell.md:281
msgid ""
"The API could be described as \"temporarily opting-in to internal "
"mutability\". It would be a more flexible continuation of the existing usage "
"of `Cell<T>` since the `Cell<T>` no longer needs to exist in the original "
"location if you have mutable access to it."
msgstr ""

#: src/1789-as-cell.md:286
msgid ""
"Would the acceptance of this proposal change how Rust is taught to new users "
"at any level? How should this feature be introduced and taught to existing "
"Rust users?"
msgstr ""

#: src/1789-as-cell.md:289
msgid ""
"As it is, the API just provides a few neat conversion functions. "
"Nevertheless, with the legalization of the `&mut T -> &Cell<T>` conversion "
"there is the potential for a major change in how accessors to data "
"structures are provided:"
msgstr ""

#: src/1789-as-cell.md:293
msgid "In todays Rust, there are generally three different ways:"
msgstr ""

#: src/1789-as-cell.md:294
msgid "Owned access that starts off with a `T` and yield `U`."
msgstr ""

#: src/1789-as-cell.md:295
msgid "Shared borrowed access that starts off with a `&T` and yields `&U`."
msgstr ""

#: src/1789-as-cell.md:296
msgid ""
"Mutable borrowed access that starts off with a `&mut T` and yields `&mut U`."
msgstr ""

#: src/1789-as-cell.md:298
msgid ""
"With this change, it would be possible in many cases to add a fourth "
"accessor:"
msgstr ""

#: src/1789-as-cell.md:300
msgid ""
"Shared borrowed cell access that starts off with a `&mut T` and yields "
"`&Cell<U>`."
msgstr ""

#: src/1789-as-cell.md:302
msgid "For example, today there exist:"
msgstr ""

#: src/1789-as-cell.md:304
msgid ""
"`Vec<T> -> std::vec::IntoIter<T>`, which yields `T` values and is cloneable."
msgstr ""

#: src/1789-as-cell.md:305
msgid ""
"`&[T] -> std::slice::Iter<T>`, which yields `&T` values and is cloneable "
"because it does a shared borrow."
msgstr ""

#: src/1789-as-cell.md:307
msgid ""
"`&mut [T] -> std::slice::IterMut<T>`, which yields `&mut T` values and is "
"not cloneable because it does a mutable borrow."
msgstr ""

#: src/1789-as-cell.md:310
msgid "We could then add a fourth iterator like this:"
msgstr ""

#: src/1789-as-cell.md:312
msgid ""
"`&mut [T] -> std::slice::CellIter<T>`, which yields `&Cell<T>` values and is "
"cloneable because it does a shared borrow."
msgstr ""

#: src/1789-as-cell.md:315
msgid ""
"So there is the potential that we go away from teaching the \"rule of "
"three\" of ownership and change it to a \"rule of four\"."
msgstr ""

#: src/1789-as-cell.md:318
msgid ""
"What additions or changes to the Rust Reference, _The Rust Programming "
"Language_, and/or _Rust by Example_ does it entail?"
msgstr ""

#: src/1789-as-cell.md:320
msgid ""
"The reference should explain that the `&mut T -> &Cell<T>` conversion, or "
"specifically the `&mut T -> &UnsafeCell<T>` conversion is fine."
msgstr ""

#: src/1789-as-cell.md:322
msgid ""
"The book could use the API introduced here if it talks about internal "
"mutability, and use it as a \"temporary opt-in\" example."
msgstr ""

#: src/1789-as-cell.md:324
msgid ""
"Rust by Example could have a few basic examples of situations where this API "
"is useful, eg the ones mention in the motivation section above."
msgstr ""

#: src/1789-as-cell.md:327
msgid "Drawbacks"
msgstr ""

#: src/1789-as-cell.md:330
msgid "Why should we _not_ do this?"
msgstr ""

#: src/1789-as-cell.md:332
msgid "More complexity around the `Cell` API."
msgstr ""

#: src/1789-as-cell.md:333
msgid ""
"`T` -> `Cell<T>` transmute compatibility might not be a desired guarantee."
msgstr ""

#: src/1789-as-cell.md:335
msgid "Alternatives"
msgstr ""

#: src/1789-as-cell.md:338
msgid "Removing cell slicing"
msgstr ""

#: src/1789-as-cell.md:340
msgid ""
"Instead of allowing unsized types in `Cell` and adding the `Index` impls, "
"there could just be a single `&mut [T] -> &[Cell<T>]` conversions function:"
msgstr ""

#: src/1789-as-cell.md:345
msgid "/// [...]\n"
msgstr ""

#: src/1789-as-cell.md:355
msgid "Usage:"
msgstr ""

#: src/1789-as-cell.md:376
msgid ""
"This would be less modular than the `&mut [T] -> &Cell<[T]> -> &[Cell<T>]` "
"conversions steps, while still offering essentially the same API."
msgstr ""

#: src/1789-as-cell.md:379
msgid "Just the language guarantee"
msgstr ""

#: src/1789-as-cell.md:381
msgid ""
"The conversion could be guaranteed as correct, but not be provided by std "
"itself. This would serve as legitimization of external implementations like "
"[alias](https://crates.io/crates/alias)."
msgstr ""

#: src/1789-as-cell.md:385
msgid "No guarantees"
msgstr ""

#: src/1789-as-cell.md:387
msgid ""
"If the safety guarantees of the conversion can not be granted, code would "
"have to use direct indexing as today, with either possible bound checking "
"costs or the use of unsafe code to avoid them."
msgstr ""

#: src/1789-as-cell.md:391
msgid "Replacing `Index` impls with `Deref`"
msgstr ""

#: src/1789-as-cell.md:393
msgid "Instead of the `Index` impls, have only this `Deref` impl:"
msgstr ""

#: src/1789-as-cell.md:407
msgid "Pro:"
msgstr ""

#: src/1789-as-cell.md:409
msgid "Automatic conversion due to deref coercions and auto deref."
msgstr ""

#: src/1789-as-cell.md:410
msgid "Less redundancy since we don't repeat the slicing impls of `[T]`."
msgstr ""

#: src/1789-as-cell.md:412
msgid "Cons:"
msgstr ""

#: src/1789-as-cell.md:414
msgid ""
"`Cell<[T]> -> [Cell<T>]` conversion does not seem like a good usecase for "
"`Deref`, since `Cell<[T]>` isn't a smartpointer."
msgstr ""

#: src/1789-as-cell.md:417
msgid "Cast to `&mut Cell<T>` instead of `&Cell<T>`"
msgstr ""

#: src/1789-as-cell.md:419
msgid ""
"Nothing that makes the `&mut T -> &Cell<T>` conversion safe would prevent "
"`&mut T -> &mut Cell<T>` from being safe either, and the latter can be "
"trivially turned into a `&Cell<T>` while also allowing mutable access - eg "
"to call `Cell::as_mut()` to conversion back again."
msgstr ""

#: src/1789-as-cell.md:424
msgid ""
"Similar to that, there could also be a way to turn a `&mut [Cell<T>]` back "
"into a `&mut [T]`."
msgstr ""

#: src/1789-as-cell.md:427
msgid ""
"However, this does not seem to be actually useful since the only reason to "
"use this API is to make use of shared internal mutability."
msgstr ""

#: src/1789-as-cell.md:430
msgid "Exposing the functions differently"
msgstr ""

#: src/1789-as-cell.md:432
msgid ""
"Instead of `Cell` constructors, we could just have freestanding functions "
"in, say, `std::cell`:"
msgstr ""

#: src/1789-as-cell.md:449
msgid ""
"On the opposite spectrum, and should this feature end up being used somewhat "
"commonly, we could provide the conversions by dedicated traits, possibly in "
"the prelude, or use the std coherence hack to implement them directly on "
"`&mut T` and `&mut [T]`:"
msgstr ""

#: src/1789-as-cell.md:471
msgid ""
"But given the issues of adding methods to pointer-like types, this approach "
"in general would probably be not a good idea (See the situation with `Rc` "
"and `Arc`)."
msgstr ""

#: src/1789-as-cell.md:475
msgid "Unresolved questions"
msgstr ""

#: src/1789-as-cell.md:478
msgid "None so far."
msgstr ""
