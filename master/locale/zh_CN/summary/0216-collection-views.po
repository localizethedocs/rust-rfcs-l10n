msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0216-collection-views.md:1
msgid "Start Date: 2014-08-28"
msgstr ""

#: src/0216-collection-views.md:2
msgid "RFC PR: (https://github.com/rust-lang/rfcs/pull/216)"
msgstr ""

#: src/0216-collection-views.md:3
msgid "Rust Issue: (https://github.com/rust-lang/rust/issues/17320)"
msgstr ""

#: src/0216-collection-views.md:5
msgid "Summary"
msgstr ""

#: src/0216-collection-views.md:7
msgid ""
"Add additional iterator-like Entry objects to collections. Entries provide a "
"composable mechanism for in-place observation and mutation of a single "
"element in the collection, without having to \"re-find\" the element "
"multiple times. This deprecates several \"internal mutation\" methods like "
"hashmap's `find_or_insert_with`."
msgstr ""

#: src/0216-collection-views.md:12
msgid "Motivation"
msgstr ""

#: src/0216-collection-views.md:14
msgid ""
"As we approach 1.0, we'd like to normalize the standard APIs to be "
"consistent, composable, and simple. However, this currently stands in "
"opposition to manipulating the collections in an _efficient_ manner. For "
"instance, if one wishes to build an accumulating map on top of one of the "
"concrete maps, they need to distinguish between the case when the element "
"they're inserting is _already_ in the map, and when it's _not_. One way to "
"do this is the following:"
msgstr ""

#: src/0216-collection-views.md:28
msgid ""
"However, searches for `key` _twice_ on every operation. The second search "
"can be squeezed out the `update` re-do by matching on the result of "
"`find_mut`, but the `insert` case will always require a re-search."
msgstr ""

#: src/0216-collection-views.md:32
msgid ""
"To solve this problem, Rust currently has an ad-hoc mix of \"internal "
"mutation\" methods which take multiple values or closures for the collection "
"to use contextually. Hashmap in particular has the following methods:"
msgstr ""

#: src/0216-collection-views.md:43
msgid ""
"Not only are these methods fairly complex to use, but they're over-"
"engineered and combinatorially explosive. They all seem to return a mutable "
"reference to the region accessed \"just in case\", and "
"`find_with_or_insert_with` takes a magic argument `a` to try to work around "
"the fact that the _two_ closures it requires can't both close over the same "
"value (even though only one will ever be called). `find_with_or_insert_with` "
"is also actually performing the role of `insert_with_or_update_with`, "
"suggesting that these aren't well understood."
msgstr ""

#: src/0216-collection-views.md:51
msgid ""
"Rust has been in this position before: internal iteration. Internal "
"iteration was (author's note: I'm told) confusing and complicated. However "
"the solution was simple: external iteration. You get all the benefits of "
"internal iteration, but with a much simpler interface, and greater "
"composability. Thus, this RFC proposes the same solution to the internal "
"mutation problem."
msgstr ""

#: src/0216-collection-views.md:56
msgid "Detailed design"
msgstr ""

#: src/0216-collection-views.md:58
msgid ""
"A fully tested \"proof of concept\" draft of this design has been "
"implemented on top of hashmap, as it seems to be the worst offender, while "
"still being easy to work with. It sits as a pull request [here](https://"
"github.com/rust-lang/rust/pull/17378)."
msgstr ""

#: src/0216-collection-views.md:62
msgid ""
"All the internal mutation methods are replaced with a single method on a "
"collection: `entry`. The signature of `entry` will depend on the specific "
"collection, but generally it will be similar to the signature for searching "
"in that structure. `entry` will in turn return an `Entry` object, which "
"captures the _state_ of a completed search, and allows mutation of the area."
msgstr ""

#: src/0216-collection-views.md:67
msgid "For convenience, we will use the hashmap draft as an example."
msgstr ""

#: src/0216-collection-views.md:69
msgid ""
"```\n"
"/// Get an Entry for where the given key would be inserted in the map\n"
"pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V>;\n"
"\n"
"/// A view into a single occupied location in a HashMap\n"
"pub struct OccupiedEntry<'a, K, V>{ ... }\n"
"\n"
"/// A view into a single empty location in a HashMap\n"
"pub struct VacantEntry<'a, K, V>{ ... }\n"
"\n"
"/// A view into a single location in a HashMap\n"
"pub enum Entry<'a, K, V> {\n"
"    /// An occupied Entry\n"
"    Occupied(OccupiedEntry<'a, K, V>),\n"
"    /// A vacant Entry\n"
"    Vacant(VacantEntry<'a, K, V>),\n"
"}\n"
"```"
msgstr ""

#: src/0216-collection-views.md:88
msgid ""
"Of course, the real meat of the API is in the Entry's interface (impl "
"details removed):"
msgstr ""

#: src/0216-collection-views.md:90
msgid ""
"```\n"
"impl<'a, K, V> OccupiedEntry<'a, K, V> {\n"
"    /// Gets a reference to the value of this Entry\n"
"    pub fn get(&self) -> &V;\n"
"\n"
"    /// Gets a mutable reference to the value of this Entry\n"
"    pub fn get_mut(&mut self) -> &mut V;\n"
"\n"
"    /// Converts the entry into a mutable reference to its value\n"
"    pub fn into_mut(self) -> &'a mut V;\n"
"\n"
"    /// Sets the value stored in this Entry\n"
"    pub fn set(&mut self, value: V) -> V;\n"
"\n"
"    /// Takes the value stored in this Entry\n"
"    pub fn take(self) -> V;\n"
"}\n"
"\n"
"impl<'a, K, V> VacantEntry<'a, K, V> {\n"
"    /// Set the value stored in this Entry, and returns a reference to it\n"
"    pub fn set(self, value: V) -> &'a mut V;\n"
"}\n"
"```"
msgstr ""

#: src/0216-collection-views.md:114
msgid ""
"There are definitely some strange things here, so let's discuss the "
"reasoning!"
msgstr ""

#: src/0216-collection-views.md:116
msgid ""
"First, `entry` takes a `key` by value, because this is the observed "
"behaviour of the internal mutation methods. Further, taking the `key` up-"
"front allows implementations to avoid _validating_ provided keys if they "
"require an owned `key` later for insertion. This key is effectively a "
"_guarantor_ of the entry."
msgstr ""

#: src/0216-collection-views.md:120
msgid ""
"Taking the key by-value might change once collections reform lands, and "
"Borrow and ToOwned are available. For now, it's an acceptable solution, "
"because in particular, the primary use case of this functionality is when "
"you're _not sure_ if you need to insert, in which case you should be "
"prepared to insert. Otherwise, `find_mut` is likely sufficient."
msgstr ""

#: src/0216-collection-views.md:125
msgid ""
"The result is actually an enum, that will either be Occupied or Vacant. "
"These two variants correspond to concrete types for when the key matched "
"something in the map, and when the key didn't, respectively."
msgstr ""

#: src/0216-collection-views.md:128
msgid ""
"If there isn't a match, the user has exactly one option: insert a value "
"using `set`, which will also insert the guarantor, and destroy the Entry. "
"This is to avoid the costs of maintaining the structure, which otherwise "
"isn't particularly interesting anymore."
msgstr ""

#: src/0216-collection-views.md:132
msgid ""
"If there is a match, a more robust set of options is provided. `get` and "
"`get_mut` provide access to the value found in the location. `set` behaves "
"as the vacant variant, but without destroying the entry. It also yields the "
"old value. `take` simply removes the found value, and destroys the entry for "
"similar reasons as `set`."
msgstr ""

#: src/0216-collection-views.md:136
msgid "Let's look at how we one now writes `insert_or_update`:"
msgstr ""

#: src/0216-collection-views.md:138
msgid "There are two options. We can either do the following:"
msgstr ""

#: src/0216-collection-views.md:140
msgid ""
"```\n"
"// cleaner, and more flexible if logic is more complex\n"
"let val = match map.entry(key) {\n"
"    Vacant(entry) => entry.set(0),\n"
"    Occupied(entry) => entry.into_mut(),\n"
"};\n"
"*val += 1;\n"
"```"
msgstr ""

#: src/0216-collection-views.md:149
msgid "or"
msgstr ""

#: src/0216-collection-views.md:151
msgid ""
"```\n"
"// closer to the original, and more compact\n"
"match map.entry(key) {\n"
"    Vacant(entry) => { entry.set(1); },\n"
"    Occupied(mut entry) => { *entry.get_mut() += 1; },\n"
"}\n"
"```"
msgstr ""

#: src/0216-collection-views.md:159
msgid ""
"Either way, one can now write something equivalent to the \"intuitive\" "
"inefficient code, but it is now as efficient as the complex "
"`insert_or_update` methods. In fact, this matches so closely to the "
"inefficient manipulation that users could reasonable ignore Entries _until "
"performance becomes an issue_, at which point it's an almost trivial "
"migration. Closures also aren't needed to dance around the fact that one may "
"want to avoid generating some values unless they have to, because that falls "
"naturally out of normal control flow."
msgstr ""

#: src/0216-collection-views.md:166
msgid ""
"If you look at the actual patch that does this, you'll see that Entry itself "
"is exceptionally simple to implement. Most of the logic is trivial. The "
"biggest amount of work was just capturing the search state correctly, and "
"even that was mostly a cut-and-paste job."
msgstr ""

#: src/0216-collection-views.md:170
msgid ""
"With Entries, the gate is also opened for... _adaptors_! Really want "
"`insert_or_update` back? That can be written on top of this generically with "
"ease. However, such discussion is out-of-scope for this RFC. Adaptors can be "
"tackled in a back-compat manner after this has landed, and usage is "
"observed. Also, this proposal does not provide any generic trait for "
"Entries, preferring concrete implementations for the time-being."
msgstr ""

#: src/0216-collection-views.md:177
msgid "Drawbacks"
msgstr ""

#: src/0216-collection-views.md:179
msgid "More structs, and more methods in the short-term"
msgstr ""

#: src/0216-collection-views.md:181
msgid "More collection manipulation \"modes\" for the user to think about"
msgstr ""

#: src/0216-collection-views.md:183
msgid ""
"`insert_or_update_with` is kind of convenient for avoiding the kind of "
"boiler-plate found in the examples"
msgstr ""

#: src/0216-collection-views.md:186
msgid "Alternatives"
msgstr ""

#: src/0216-collection-views.md:188
msgid ""
"Just put our foot down, say \"no efficient complex manipulations\", and drop "
"all the internal mutation stuff without a replacement."
msgstr ""

#: src/0216-collection-views.md:191
msgid "Try to build out saner/standard internal manipulation methods."
msgstr ""

#: src/0216-collection-views.md:193
msgid ""
"Try to make this functionality a subset of [Cursors](http://discuss.rust-"
"lang.org/t/pseudo-rfc-cursors-reversible-iterators/386/7), which would be "
"effectively a bi-directional mut_iter where the returned references borrow "
"the cursor preventing aliasing/safety issues, so that mutation can be "
"performed at the location of the cursor. However, preventing invalidation "
"would be more expensive, and it's not clear that cursor semantics would make "
"sense on e.g. a HashMap, as you can't insert _any_ key in _any_ location."
msgstr ""

#: src/0216-collection-views.md:201
msgid ""
"This RFC originally \\[proposed a design without enums that was "
"substantially more complex\\] (https://github.com/Gankro/rust/"
"commit/6d6804a6d16b13d07934f0a217a3562384e55612). However it had some "
"interesting ideas about Key manipulation, so we mention it here for "
"historical purposes."
msgstr ""

#: src/0216-collection-views.md:206
msgid "Unresolved questions"
msgstr ""

#: src/0216-collection-views.md:208
msgid "Naming bikesheds!"
msgstr ""
