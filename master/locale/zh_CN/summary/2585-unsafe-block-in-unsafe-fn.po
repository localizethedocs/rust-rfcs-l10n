msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:05Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2585-unsafe-block-in-unsafe-fn.md:1
msgid "Feature Name: `unsafe_block_in_unsafe_fn`"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:2
msgid "Start Date: 2018-11-04"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2585](https://github.com/rust-lang/rfcs/pull/2585)"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:4
msgid ""
"Rust Issue: [rust-lang/rust#71688](https://github.com/rust-lang/rust/"
"issues/71668)"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:6
msgid "Summary"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:9
msgid ""
"No longer treat the body of an `unsafe fn` as being an `unsafe` block.  To "
"avoid a breaking change, this is a warning now and may become an error in a "
"future edition."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:13
msgid "Motivation"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:16
msgid ""
"Marking a function as `unsafe` is one of Rust's key protections against "
"undefined behavior: Even if the programmer does not read the documentation, "
"calling an `unsafe` function (or performing another unsafe operation) "
"outside an `unsafe` block will lead to a compile error, hopefully followed "
"by reading the documentation."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:22
msgid ""
"However, we currently entirely lose this protection when writing an `unsafe "
"fn`: If I, say, accidentally call `offset` instead of `wrapping_offset`, or "
"if I dereference a raw pointer thinking it is a reference, this happens "
"without any further notice when I am writing an `unsafe fn` because the body "
"of an `unsafe fn` is treated as an `unsafe` block."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:28
msgid ""
"For example, notice how [this PR](https://github.com/rust-lang/rust/"
"pull/55043/files) significantly increased the amount of code in the thread "
"spawning function that is considered to be inside an `unsafe` block."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:33
msgid ""
"The original justification for this behavior (according to my understanding) "
"was that calling this function is anyway unsafe, so there is no harm done in "
"allowing _it_ to perform unsafe operations.  And indeed the current "
"situation _does_ provide the guarantee that a program without `unsafe` "
"cannot be UB. However, this neglects the other aspect of `unsafe` that I "
"described above: To make the programmer aware that they are treading "
"dangerous ground even when they may not realize they are doing so."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:41
msgid ""
"In fact, this double role of `unsafe` in `unsafe fn` (making it both unsafe "
"to call and enabling it to call other unsafe operations) conflates the two "
"_dual_ roles that `unsafe` plays in Rust.  On the one hand, there are places "
"that _define_ a proof obligation, these make things \"unsafe to call/do\" (e."
"g., the language definition says that dereferencing a raw pointer requires "
"it not to be dangling).  On the other hand, there are places that "
"_discharge_ the proof obligation, these are \"unsafe blocks of code\" (e.g., "
"unsafe code that dereferences a raw pointer has to locally argue why it "
"cannot be dangling)."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:50
msgid ""
"`unsafe {}` blocks are about _discharging_ obligations, but `unsafe fn` are "
"about _defining_ obligations.  The fact that the body of an `unsafe fn` is "
"also implicitly treated like a block has made it hard to realize this "
"duality [even for experienced Rust developers](https://github.com/rust-lang/"
"rfcs/pull/2585#issuecomment-577852430).  (Completing the picture, `unsafe "
"Trait` also defines an obligation, that is discharged by `unsafe impl`. "
"Curiously, `unsafe trait` does _not_ implicitly make all bodies of default "
"functions defined inside this trait unsafe blocks, which is somewhat "
"inconsistent with `unsafe fn` when viewed through this lens.)"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:61
msgid "Guide-level explanation"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:64
msgid "The `unsafe` keyword in Rust serves two related purposes."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:66
msgid ""
"When you perform an \"unsafe to call\" operation, like dereferencing a raw "
"pointer or calling an `unsafe fn`, you must enclose that code in an `unsafe "
"{}` block. The purpose of this is to acknowledge that the operation you are "
"performing here has _not_ been checked by the compiler, you are responsible "
"yourself for upholding Rust's safety guarantees.  Generally, unsafe "
"operations come with detailed documentation for the conditions that must be "
"met when this operation is executed; it is up to you to check that all these "
"conditions are indeed met."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:74
msgid ""
"When you are writing a function that itself has additional conditions to "
"ensure safety (say, it accesses some data without making some necessary "
"bounds checks, or it takes some raw pointers as arguments and performs "
"memory operations based on them), then you should mark this as an `unsafe "
"fn` and it is up to you to document the conditions that must be met for the "
"arguments.  This use of the `unsafe` keyword makes your function itself "
"\"unsafe to call\"."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:81
msgid ""
"The same duality can be observed in traits: `unsafe trait` is like `unsafe "
"fn`; it makes implementing this trait an \"unsafe to call\" operation and it "
"is up to whoever defines the trait to precisely document what is unsafe "
"about it. `unsafe impl` is like `unsafe {}`, it acknowledges that there are "
"extra requirements here that are not checked by the compiler and that the "
"programmer is responsible to uphold."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:88
msgid ""
"For this reason, \"unsafe to call\" operations inside an `unsafe fn` must be "
"contained inside an `unsafe {}` block like everywhere else.  The author of "
"these functions has to ensure that the requirements of the operation are "
"upheld.  To this end, the author may of course assume that the caller of the "
"`unsafe fn` in turn uphold their own requirements."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:94
msgid ""
"For backwards compatibility reasons, this unsafety check inside `unsafe fn` "
"is controlled by a lint, `unsafe_op_in_unsafe_fn`.  By setting "
"`#[deny(unsafe_op_in_unsafe_fn)]`, the compiler is as strict about unsafe "
"operations inside `unsafe fn` as it is everywhere else."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:99
msgid ""
"This lint is allow-by-default initially, and will be warn-by-default across "
"all editions eventually.  In future editions, it may become deny-by-default, "
"or even a hard error."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:103
msgid "Reference-level explanation"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:106
msgid ""
"The new `unsafe_op_in_unsafe_fn` lint triggers when an unsafe operation is "
"used inside an `unsafe fn` but outside `unsafe {}` blocks.  So, the "
"following will emit a warning:"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:117
msgid ""
"Moreover, if and only if the `unsafe_op_in_unsafe_fn` lint is not `allow`ed, "
"we no longer warn that an `unsafe` block is unnecessary when it is nested "
"immediately inside an `unsafe fn`.  So, the following compiles without any "
"warning:"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:129
msgid "However, nested `unsafe` blocks are still redundant, so this warns:"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:138
msgid "Drawbacks"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:141
msgid ""
"Many `unsafe fn` are actually rather short (no more than 3 lines) and will "
"end up just being one large `unsafe` block.  This change would make such "
"functions less ergonomic to write, they would likely become"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:147
msgid "// Code goes here\n"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:151
msgid "Rationale and alternatives"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:154
msgid ""
"To achieve the goals laid out in the motivation section, the proposed "
"approach is least invasive in the sense that it avoids introducing new "
"keywords, and instead relies on the existing lint mechanism to perform the "
"transition."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:158
msgid ""
"One alternative always is to not do anything, and live with the current "
"situation."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:161
msgid ""
"We could avoid using `unsafe` for dual purpose, and instead have "
"`unsafe_to_call fn` for functions that are \"unsafe to call\" but do not "
"implicitly have an `unsafe {}` block in their body.  For consistency, we "
"might want `unsafe_to_impl trait` for traits, though the behavior would be "
"the same as `unsafe trait`."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:166
msgid ""
"We could introduce named proof obligations (proposed by @Centril) such that "
"the compiler can be told (to some extend) if the assumptions made by the "
"`unsafe fn` are sufficient to discharge the requirements of the unsafe "
"operations."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:170
msgid ""
"We could restrict this requirement to use `unsafe` blocks in `unsafe fn` to "
"those `unsafe fn` that contain at least one `unsafe` block, meaning short "
"`unsafe fn` would keep compiling like they do now."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:174
msgid "And of course, the lint name is subject to bikeshedding."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:176
msgid "Prior art"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:179
msgid ""
"The only other language that I am aware of that has a notion of `unsafe` "
"blocks and `unsafe` functions is C#.  It [looks like](https://docs.microsoft."
"com/en-us/dotnet/csharp/language-reference/keywords/unsafe) there, unsafe "
"operations can be freely used inside an `unsafe` function even without a "
"further `unsafe` block.  However, based on @Ixrec's experience, `unsafe` "
"plays hardly any role in the C# ecosystem and they do not have a culture of "
"thinking about this in terms of proof obligations."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:187
msgid "Unresolved questions"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:190
msgid ""
"What is the timeline for adding the lint, and cranking up its default level? "
"Should the default level depend on the edition?"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:193
msgid ""
"Should we ever make this deny-by-default or even a hard error, in a future "
"edition?"
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:196
msgid ""
"Should we require `cargo fix` to be able to do _something_ about this "
"warning before making it even warn-by-default?  (We certainly need to do "
"something before making it deny-by-default or a hard error in a future "
"edition.)  `cargo fix` could add big `unsafe {}` blocks around the entire "
"body of every `unsafe fn`.  That would not improve the amount of care that "
"is taken for unsafety in the fixed code, but it would provide a way to the "
"incrementally improve the big functions, and new functions written later "
"would have the appropriate amount of care applied to them from the start.  "
"Potentially, `rustfmt` could be taught to format `unsafe` blocks that wrap "
"the entire function body in a way that avoids double-indent.  \"function "
"bodies as expressions\" would enable a format like `unsafe fn foo() = unsafe "
"{ body }`."
msgstr ""

#: src/2585-unsafe-block-in-unsafe-fn.md:208
msgid ""
"It is not entirely clear if having the behavior of one lint depend on "
"another will work (though most likely, it will).  If it does not, we should "
"try to find some other mechanism to opt-in to the new treatment of `unsafe "
"fn` bodies."
msgstr ""
