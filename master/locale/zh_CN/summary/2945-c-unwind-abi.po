msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:05Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2945-c-unwind-abi.md:1
msgid "Feature Name: `\"C-unwind\" ABI`"
msgstr ""

#: src/2945-c-unwind-abi.md:2
msgid "Start Date: 2019-04-03"
msgstr ""

#: src/2945-c-unwind-abi.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2945](https://github.com/rust-lang/rfcs/pull/2945)"
msgstr ""

#: src/2945-c-unwind-abi.md:4
msgid ""
"Rust Issue: [rust-lang/rust#74990](https://github.com/rust-lang/rust/"
"issues/74990)"
msgstr ""

#: src/2945-c-unwind-abi.md:5
msgid ""
"Project group: [FFI-unwind](https://github.com/rust-lang/project-ffi-unwind)"
msgstr ""

#: src/2945-c-unwind-abi.md:9
msgid "Summary"
msgstr ""

#: src/2945-c-unwind-abi.md:12
msgid ""
"We introduce a new ABI string, `\"C-unwind\"`, to enable unwinding from "
"other languages (such as C++) into Rust frames and from Rust into other "
"languages."
msgstr ""

#: src/2945-c-unwind-abi.md:15
msgid ""
"Additionally, we define the behavior for a limited number of previously-"
"undefined cases when an unwind operation reaches a Rust function boundary "
"with a non-`\"Rust\"`, non-`\"C-unwind\"` ABI."
msgstr ""

#: src/2945-c-unwind-abi.md:19
msgid ""
"As part of this specification, we introduce the term [\"Plain Old "
"Frame\" (POF)](#plain-old-frames). These are frames that have no pending "
"destructors and can be trivially deallocated."
msgstr ""

#: src/2945-c-unwind-abi.md:23
msgid ""
"This RFC does not define the behavior of `catch_unwind` in a Rust frame "
"being unwound by a foreign exception. This is something the [project group]"
"(https://github.com/rust-lang/project-ffi-unwind) would like to specify in a "
"future RFC; as such, it is \"TBD\" (see [\"Unresolved questions\"]"
"(#unresolved-questions))."
msgstr ""

#: src/2945-c-unwind-abi.md:28
msgid "Motivation"
msgstr ""

#: src/2945-c-unwind-abi.md:31
msgid ""
"There are some Rust projects that need cross-language unwinding to provide "
"their desired functionality. One major example is Wasm interpreters, "
"including the Lucet and Wasmer projects."
msgstr ""

#: src/2945-c-unwind-abi.md:35
msgid ""
"There are also existing Rust crates (notably, wrappers around the `libpng` "
"and `libjpeg` C libraries) that `panic` across C frames. The safety of such "
"unwinding relies on compatibility between Rust's unwinding mechanism and the "
"native exception mechanisms in GCC, LLVM, and MSVC. Despite using a "
"compatible unwinding mechanism, the current `rustc` implementation assumes "
"that `extern \"C\"` functions cannot unwind, which permits LLVM to optimize "
"with the assumption that such unwinding constitutes undefined behavior."
msgstr ""

#: src/2945-c-unwind-abi.md:43
msgid ""
"The desire for this feature has been previously discussed on other RFCs, "
"including [\\#2699](https://github.com/rust-lang/rfcs/pull/2699) and "
"[\\#2753](https://github.com/rust-lang/rfcs/pull/2753)."
msgstr ""

#: src/2945-c-unwind-abi.md:46
msgid "Key design goals"
msgstr ""

#: src/2945-c-unwind-abi.md:48
msgid ""
"As explained in [this Inside Rust blog post](https://blog.rust-lang.org/"
"inside-rust/2020/02/27/ffi-unwind-design-meeting.html#requirements-for-any-"
"cross-language-unwinding-specification), we have several requirements for "
"any cross-language unwinding design."
msgstr ""

#: src/2945-c-unwind-abi.md:51
msgid ""
"The [\"Analysis of key design goals\"](#analysis-of-design-goals) section "
"analyzes how well the current design satisfies these constraints."
msgstr ""

#: src/2945-c-unwind-abi.md:54
msgid ""
"**Changing from `panic=unwind` to `panic=abort` cannot cause undefined "
"behavior:** We wish to ensure that changing from `panic=unwind` to "
"`panic=abort` never creates undefined behavior (relate to `panic=unwind`), "
"even if one is relying on a library that triggers a panic or a foreign "
"exception."
msgstr ""

#: src/2945-c-unwind-abi.md:59
msgid ""
"**Optimization with `panic=abort`:** when using `panic=abort`, we wish to "
"enable as many code-size optimizations as possible. This means that we "
"shouldn't have to generate unwinding tables or other such constructs, at "
"least in most cases."
msgstr ""

#: src/2945-c-unwind-abi.md:63
msgid ""
"**Preserve the ability to change how Rust panics are propagated when using "
"the Rust ABI:** Currently, Rust panics are propagated using the native "
"unwinding mechanism, but we would like to keep the freedom to change that."
msgstr ""

#: src/2945-c-unwind-abi.md:67
msgid ""
"**Enable Rust panics to traverse through foreign frames:** Several projects "
"would like the ability to have Rust panics propagate through foreign "
"frames.  Those frames may or may not register destructors of their own with "
"the native unwinding mechanism."
msgstr ""

#: src/2945-c-unwind-abi.md:71
msgid ""
"**Enable foreign exceptions to propagate through Rust frames:** Similarly, "
"we would like to make it possible for C++ code (or other languages) to raise "
"exceptions that will propagate through Rust frames \"as if\" they were Rust "
"panics (i.e., running destructors or, in the case of `unwind=abort`, "
"aborting the program)."
msgstr ""

#: src/2945-c-unwind-abi.md:76
msgid ""
"**Enable error handling with `longjmp`:** As mentioned above, some existing "
"Rust libraries rely on the ability to `longjmp` across Rust frames to "
"interoperate with Ruby, Lua, and other C APIs. The behavior of `longjmp` "
"traversing Rust frames is not specified or guaranteed to be safe; in the "
"current implementation of `rustc`, however, it [is safe](https://github.com/"
"rust-lang/rust/pull/48572). On Windows, `longjmp` is implemented as a form "
"of unwinding called [\"forced unwinding\"](#forced-unwinding), so any "
"specification of the behavior of forced unwinding across FFI boundaries "
"should be forward-compatible with a [future RFC](#unresolved-questions) that "
"will provide a well-defined way to interoperate with longjmp-based APIs."
msgstr ""

#: src/2945-c-unwind-abi.md:86
msgid ""
"**Do not change the ABI of functions in the `libc` crate:** Some `libc` "
"functions may invoke `pthread_exit`, which uses [a form of unwinding]"
"(#forced-unwinding) in the GNU libc implementation. Such functions must be "
"safe to use with the existing `\"C\"` ABI, because changing the types of "
"these functions would be a breaking change."
msgstr ""

#: src/2945-c-unwind-abi.md:95
msgid "Guide-level explanation"
msgstr ""

#: src/2945-c-unwind-abi.md:98
msgid ""
"When declaring an external function that may unwind, such as an entrypoint "
"to a C++ library, use `extern \"C-unwind\"` instead of `extern \"C\"`:"
msgstr ""

#: src/2945-c-unwind-abi.md:101
msgid ""
"```\n"
"extern \"C-unwind\" {\n"
"  fn may_throw();\n"
"}\n"
"```"
msgstr ""

#: src/2945-c-unwind-abi.md:107
msgid ""
"Rust functions that call a possibly-unwinding external function should "
"either use the default Rust ABI (which can be made explicit with `extern "
"\"Rust\"`) or the `\"C-unwind\"` ABI:"
msgstr ""

#: src/2945-c-unwind-abi.md:111
msgid ""
"```\n"
"extern \"C-unwind\" fn can_unwind() {\n"
"  may_throw();\n"
"}\n"
"```"
msgstr ""

#: src/2945-c-unwind-abi.md:117
msgid ""
"Using the `\"C-unwind\"` ABI to \"sandwich\" Rust frames between frames from "
"another language (such as C++) allows an exception initiated in a callee "
"frame in the other language to traverse the intermediate Rust frames before "
"being caught in the caller frames. I.e., a C++ exception may be thrown, "
"cross into Rust via an `extern \"C-unwind\"` function declaration, safely "
"unwind the Rust frames, and cross back into C++ (where it may be caught) via "
"a Rust `\"C-unwind\"` function definition."
msgstr ""

#: src/2945-c-unwind-abi.md:125
msgid ""
"Conversely, languages that support the native unwinding mechanism, such as C+"
"+, may be \"sandwiched\" between Rust frames, so that Rust `panic`s may "
"safely unwind the C++ frames, if the Rust code declares both the C++ "
"entrypoint and the Rust entrypoint using `\"C-unwind\"`."
msgstr ""

#: src/2945-c-unwind-abi.md:130
msgid "Other `unwind` ABI strings"
msgstr ""

#: src/2945-c-unwind-abi.md:132
msgid ""
"Because the `C` ABI is not appropriate for all use cases, we also introduce "
"these `unwind` ABI strings, which will only differ from their non-`unwind` "
"variants by permitting unwinding, with the same semantics as `\"C-unwind\"`:"
msgstr ""

#: src/2945-c-unwind-abi.md:136
msgid "`\"system-unwind\"` - available on all platforms"
msgstr ""

#: src/2945-c-unwind-abi.md:137
msgid ""
"`\"stdcall-unwind\"` and `\"thiscall-unwind\"` - available only on platforms "
"where `\"stdcall\"` and `\"thiscall\"` are supported"
msgstr ""

#: src/2945-c-unwind-abi.md:140
msgid ""
"More `unwind` variants of existing ABI strings may be introduced, with the "
"same semantics, without an additional RFC."
msgstr ""

#: src/2945-c-unwind-abi.md:143
msgid "\"Plain Old Frames\""
msgstr ""

#: src/2945-c-unwind-abi.md:146
msgid ""
"A \"POF\", or \"Plain Old Frame\", is defined as a frame that can be "
"trivially deallocated: returning from or unwinding a POF cannot cause any "
"observable effects. This means that POFs do not contain any pending "
"destructors (live `Drop` objects) or `catch_unwind` calls."
msgstr ""

#: src/2945-c-unwind-abi.md:151
msgid ""
"The terminology is intentionally akin to [C++'s \"Plain Old Data\" types]"
"(https://en.cppreference.com/w/cpp/named_req/PODType), which are types that, "
"among other requirements, are trivially destructible (their destructors do "
"not cause any observable effects, and may be elided as an optimization)."
msgstr ""

#: src/2945-c-unwind-abi.md:156
msgid ""
"Rust frames that do contain pending destructors or `catch_unwind` calls are "
"called non-POFs."
msgstr ""

#: src/2945-c-unwind-abi.md:159
msgid ""
"Note that a non-POF may _become_ a POF during execution of the corresponding "
"function, for instance if all `Drop` objects are moved out of scope, or if "
"its only `catch_unwind` call is in a code path that will not be executed. "
"The next section provides an example."
msgstr ""

#: src/2945-c-unwind-abi.md:166
msgid "Forced unwinding"
msgstr ""

#: src/2945-c-unwind-abi.md:169
msgid ""
"This is a special kind of unwinding used to implement `longjmp` on Windows "
"and `pthread_exit` in `glibc`. A brief explanation is provided in [this "
"Inside Rust blog post](https://blog.rust-lang.org/inside-rust/2020/02/27/ffi-"
"unwind-design-meeting.html#forced-unwinding). This RFC distinguishes forced "
"unwinding from other types of foreign unwinding."
msgstr ""

#: src/2945-c-unwind-abi.md:174
msgid ""
"Since language features and library functions implemented using forced "
"unwinding on some platforms use other mechanisms on other platforms, Rust "
"code cannot rely on forced unwinding to invoke destructors (calling `drop` "
"on `Drop` types). In other words, a forced unwind operation on one platform "
"will simply deallocate Rust frames without true unwinding on other platforms."
msgstr ""

#: src/2945-c-unwind-abi.md:180
msgid ""
"This RFC specifies that, regardless of the platform or the ABI string "
"(`\"C\"` or `\"C-unwind\"`), any platform features that may rely on forced "
"unwinding will always be considered undefined behavior if they cross non-"
"[POFs](#plain-old-frames). Crossing only POFs is necessary but not "
"sufficient, however, to make forced unwinding safe, and for now we do not "
"specify any safe form of forced unwinding; we will specify this in [a future "
"RFC](#unresolved-questions)."
msgstr ""

#: src/2945-c-unwind-abi.md:190
msgid "Changes to the behavior of existing ABI strings"
msgstr ""

#: src/2945-c-unwind-abi.md:193
msgid ""
"Prior to this RFC, any unwinding operation that crossed an `extern \"C\"` "
"boundary, either from a `panic!` \"escaping\" from a Rust function defined "
"with `extern \"C\"` or by entering Rust from another language via an "
"entrypoint declared with `extern \"C\"`, caused undefined behavior."
msgstr ""

#: src/2945-c-unwind-abi.md:198
msgid ""
"This RFC retains most of that undefined behavior, with one exception: with "
"the `panic=unwind` runtime, `panic!` will cause an `abort` if it would "
"otherwise \"escape\" from a function defined with `extern \"C\"`."
msgstr ""

#: src/2945-c-unwind-abi.md:202
msgid ""
"This change will be applied to all ABI strings other than `\"Rust\"`, such "
"as `\"system\"`."
msgstr ""

#: src/2945-c-unwind-abi.md:205
msgid "Interaction with `panic=abort`"
msgstr ""

#: src/2945-c-unwind-abi.md:207
msgid ""
"If a non-forced foreign unwind would enter a Rust frame via an `extern \"C-"
"unwind\"` ABI boundary, but the Rust code is compiled with `panic=abort`, "
"the unwind will be caught and the process aborted."
msgstr ""

#: src/2945-c-unwind-abi.md:211
msgid ""
"Conversely, non-forced unwinding from another language into Rust through an "
"FFI entrypoint declared with `extern \"C\"` is always undefined behavior, "
"and is not guaranteed to cause the program to abort under `panic=abort`. As "
"noted [below](#abi-boundaries-and-forced-unwinding), however, when compiling "
"in debug mode, the compiler may be able to guarantee an abort in this case."
msgstr ""

#: src/2945-c-unwind-abi.md:217
msgid "`panic=abort` will have no impact on the behavior of forced unwinding."
msgstr ""

#: src/2945-c-unwind-abi.md:219
msgid "Reference-level explanation"
msgstr ""

#: src/2945-c-unwind-abi.md:222
msgid "ABI boundaries and unforced unwinding"
msgstr ""

#: src/2945-c-unwind-abi.md:225
msgid ""
"This table shows the behavior of an unwinding operation reaching each type "
"of ABI boundary (function declaration or definition). \"UB\" stands for "
"undefined behavior. `\"C\"`\\-like ABIs are `\"C\"` itself but also related "
"ABIs such as `\"system\"`."
msgstr ""

#: src/2945-c-unwind-abi.md:230
msgid "panic runtime"
msgstr ""

#: src/2945-c-unwind-abi.md:230
msgid "ABI"
msgstr ""

#: src/2945-c-unwind-abi.md:230
msgid "`panic`\\-unwind"
msgstr ""

#: src/2945-c-unwind-abi.md:230
msgid "Unforced foreign unwind"
msgstr ""

#: src/2945-c-unwind-abi.md:232 src/2945-c-unwind-abi.md:233
msgid "`panic=unwind`"
msgstr ""

#: src/2945-c-unwind-abi.md:232 src/2945-c-unwind-abi.md:234
msgid "`\"C-unwind\"`"
msgstr ""

#: src/2945-c-unwind-abi.md:232
msgid "unwind"
msgstr ""

#: src/2945-c-unwind-abi.md:233 src/2945-c-unwind-abi.md:235
msgid "`\"C\"`\\-like"
msgstr ""

#: src/2945-c-unwind-abi.md:233 src/2945-c-unwind-abi.md:234
msgid "abort"
msgstr ""

#: src/2945-c-unwind-abi.md:233 src/2945-c-unwind-abi.md:235
msgid "UB"
msgstr ""

#: src/2945-c-unwind-abi.md:234 src/2945-c-unwind-abi.md:235
msgid "`panic=abort`"
msgstr ""

#: src/2945-c-unwind-abi.md:234
msgid "`panic!` aborts"
msgstr ""

#: src/2945-c-unwind-abi.md:235
msgid "`panic!` aborts (no unwinding occurs)"
msgstr ""

#: src/2945-c-unwind-abi.md:237
msgid ""
"In debug mode, the compiler could insert code to catch unwind attempts at "
"`extern \"C\"` boundaries and `abort`; this would provide a safe way to "
"discover (and fix) instances of this form of UB."
msgstr ""

#: src/2945-c-unwind-abi.md:241
msgid "Frame deallocation and forced unwinding"
msgstr ""

#: src/2945-c-unwind-abi.md:243
msgid ""
"The interaction of Rust frames with C functions that deallocate frames (i.e. "
"functions that may use forced unwinding on specific platforms) is "
"independent of the panic runtime, ABI, or platform."
msgstr ""

#: src/2945-c-unwind-abi.md:247
msgid ""
"**When deallocating Rust non-POFs:** this is explicitly undefined behavior."
msgstr ""

#: src/2945-c-unwind-abi.md:248
msgid ""
"**When deallocating Rust [POFs](#plain-old-frames):** for now, this is not "
"specified, and must be considered undefined behavior. However, we do plan to "
"specify a safe way to deallocate POFs with `longjmp` or `pthread_exit` in [a "
"future RFC](#unresolved-questions)."
msgstr ""

#: src/2945-c-unwind-abi.md:253
msgid "Additional limitations"
msgstr ""

#: src/2945-c-unwind-abi.md:256
msgid ""
"In order to limit the scope of this RFC, the following limitations are "
"imposed:"
msgstr ""

#: src/2945-c-unwind-abi.md:258
msgid ""
"No subtype relationship is defined between functions or function pointers "
"using different ABIs."
msgstr ""

#: src/2945-c-unwind-abi.md:260
msgid "Coercions are not defined between `\"C\"` and `\"C-unwind\"`."
msgstr ""

#: src/2945-c-unwind-abi.md:261
msgid ""
"As noted in the [summary](#summary), if a Rust frame containing a pending "
"`catch_unwind` call is unwound by a foreign exception, the behavior is "
"undefined for now."
msgstr ""

#: src/2945-c-unwind-abi.md:264
msgid ""
"The behavior of asynchronous exceptions, such as SEH on Windows, "
"interrupting Rust code is not defined."
msgstr ""

#: src/2945-c-unwind-abi.md:267
msgid "These may be addressed in [future RFCs](#future-possibilities)."
msgstr ""

#: src/2945-c-unwind-abi.md:269
msgid "Drawbacks"
msgstr ""

#: src/2945-c-unwind-abi.md:272
msgid ""
"Forced unwinding is treated as universally unsafe across [non-POFs](#plain-"
"old-frames), but on some platforms it could theoretically be well-defined. "
"As noted [above](forced-unwind), however, this would make the UB "
"inconsistent across platforms, which is not desirable."
msgstr ""

#: src/2945-c-unwind-abi.md:277
msgid ""
"This design imposes some burden on existing codebases (mentioned [above]"
"(#motivation)) to change their `extern` annotations to use the new ABI."
msgstr ""

#: src/2945-c-unwind-abi.md:280
msgid ""
"Having separate ABIs for `\"C\"` and `\"C-unwind\"` may make interface "
"design more difficult, especially since this RFC [postpones](#unresolved-"
"questions) introducing coercions between function types using different "
"ABIs. Conversely, a single ABI that \"just works\" with C++ (or any other "
"language that may throw exceptions) would be simpler to learn and use than "
"two separate ABIs."
msgstr ""

#: src/2945-c-unwind-abi.md:286
msgid ""
"This RFC preserves an existing inconsistency between the `\"Rust\"` ABI "
"(which is the default for all functions without an explicit ABI string) and "
"the other existing ABIs: no ABI string without the word `unwind` will permit "
"unwinding, except the `\"Rust\"` ABI, which will permit unwinding, but only "
"when compiled with `panic=unwind`. Making other ABIs consistent with the "
"`\"Rust\"` ABI by permitting them to unwind by default (and possibly either "
"introducing a new `\"C-unwind\"` ABI or an annotation akin to C++'s "
"`noexcept` to explicitly prohibit unwinding) would also be a safer default, "
"since it would prevent undefined behavior when interfacing with external "
"libraries that may throw exceptions."
msgstr ""

#: src/2945-c-unwind-abi.md:297
msgid "Rationale and alternatives"
msgstr ""

#: src/2945-c-unwind-abi.md:300
msgid "Other proposals discussed with the lang team"
msgstr ""

#: src/2945-c-unwind-abi.md:303
msgid ""
"Two other potential designs have been discussed in depth; they are explained "
"in [this Inside Rust blog post](https://blog.rust-lang.org/inside-"
"rust/2020/02/27/ffi-unwind-design-meeting.html#three-specific-proposals). "
"The design in this RFC is referred to as \"option 2\" in that post."
msgstr ""

#: src/2945-c-unwind-abi.md:307
msgid ""
"\"Option 1\" in that blog post only differs from the current proposal in the "
"behavior of a forced unwind across a `\"C-unwind\"` boundary under "
"`panic=abort`. Under the current proposal, this type of unwind is permitted, "
"allowing `longjmp` and `pthread_exit` to behave \"normally\" with both the "
"`\"C\"` and the `\"C-unwind\"` ABI across all platforms regardless of panic "
"runtime. If [non-POFs](#plain-old-frames) are unwound, this results in "
"undefined behavior. Under \"option 1\", however, all foreign unwinding, "
"forced or unforced, is caught at `\"C-unwind\"` boundaries under "
"`panic=abort`, and the process is aborted. This gives `longjmp` and "
"`pthread_exit` surprising behavior on some platforms, but avoids that cause "
"of undefined behavior in the current proposal."
msgstr ""

#: src/2945-c-unwind-abi.md:318
msgid ""
"The other proposal in the blog post, \"option 3\", is dramatically "
"different. In that proposal, foreign exceptions are permitted to cross "
"`extern \"C\"` boundaries, and no new ABI is introduced."
msgstr ""

#: src/2945-c-unwind-abi.md:324
msgid "Reasons for the current proposal"
msgstr ""

#: src/2945-c-unwind-abi.md:327
msgid "Our reasons for preferring the current proposal are:"
msgstr ""

#: src/2945-c-unwind-abi.md:329
msgid ""
"Introducing a new ABI makes reliance on cross-language exception handling "
"more explicit."
msgstr ""

#: src/2945-c-unwind-abi.md:331
msgid ""
"`panic=abort` can be safely used with `extern \"C-unwind\"` (there is no "
"undefined behavior except with improperly used forced unwinding), but "
"`extern \"C\"` has more optimization potential (eliding landing pads). "
"Having two ABIs puts this choice in the hands of users."
msgstr ""

#: src/2945-c-unwind-abi.md:335
msgid ""
"The single-ABI proposal (\"option 3\") causes any foreign exception entering "
"Rust to have undefined behavior under `panic=abort`, whereas the current "
"proposal does not permit the `panic=abort` runtime to introduce undefined "
"behavior to a program that is well-defined under `panic=unwind`."
msgstr ""

#: src/2945-c-unwind-abi.md:339
msgid ""
"This optimization could be made available with a single ABI by means of a "
"function attribute indicating that a function cannot unwind (similar to C+"
"+'s `noexcept`). Such attributes [are already available in nightly Rust]"
"(#attributes-on-nightly-rust-and-prior-rfcs). However, Rust does not yet "
"support attributes for function pointers, so until that feature is added, "
"there would be no way to indicate whether function pointers unwind using an "
"attribute."
msgstr ""

#: src/2945-c-unwind-abi.md:345
msgid ""
"This design has simpler forward compatibility with alternate `panic!` "
"implementations. Any well-defined cross-language unwinding will require "
"shims to translate between the Rust unwinding mechanism and the natively "
"provided mechanism. In this proposal, only `\"C-unwind\"` boundaries would "
"require shims."
msgstr ""

#: src/2945-c-unwind-abi.md:350
msgid "Analysis of key design goals"
msgstr ""

#: src/2945-c-unwind-abi.md:353
msgid ""
"This section revisits the key design goals to assess how well they are met "
"by the proposed design."
msgstr ""

#: src/2945-c-unwind-abi.md:356
msgid "Changing from `panic=unwind` to `panic=abort` cannot cause UB"
msgstr ""

#: src/2945-c-unwind-abi.md:358
msgid "This constraint is met:"
msgstr ""

#: src/2945-c-unwind-abi.md:360
msgid ""
"Unwinding across a \"C\" boundary is UB regardless of whether one is using "
"`panic=unwind` or `panic=abort`."
msgstr ""

#: src/2945-c-unwind-abi.md:362
msgid ""
"Unwinding across a \"C-unwind\" boundary is always defined, though it is "
"defined to abort if `panic=abort` is used."
msgstr ""

#: src/2945-c-unwind-abi.md:364
msgid "Forced exceptions behave the same regardless of panic mode."
msgstr ""

#: src/2945-c-unwind-abi.md:366
msgid "Optimization with panic=abort"
msgstr ""

#: src/2945-c-unwind-abi.md:368
msgid ""
"Using this proposal, the compiler is **almost always** able to reduce "
"overhead related to unwinding when using panic=abort. The one exception is "
"that invoking a \"C-unwind\" ABI still requires some kind of minimal landing "
"pad to trigger an abort. The expectation is that very few functions will use "
"the \"C-unwind\" boundary unless they truly intend to unwind -- and, in that "
"case, those functions are likely using panic=unwind anyway, so this is not "
"expected to make much difference in practice."
msgstr ""

#: src/2945-c-unwind-abi.md:377
msgid ""
"Preserve the ability to change how Rust panics are propagated when using the "
"Rust ABI"
msgstr ""

#: src/2945-c-unwind-abi.md:379
msgid ""
"This constraint is met. If we were to change Rust panics to a different "
"mechanism from the mechanism used by the native ABI, however, there would "
"have to be a conversion step that interconverts between Rust panics and "
"foreign exceptions at \"C-unwind\" ABI boundaries."
msgstr ""

#: src/2945-c-unwind-abi.md:385
msgid "Enable Rust panics to traverse through foreign frames"
msgstr ""

#: src/2945-c-unwind-abi.md:387
msgid "This constraint is met."
msgstr ""

#: src/2945-c-unwind-abi.md:389
msgid "Enable foreign exceptions to propagate through Rust frame"
msgstr ""

#: src/2945-c-unwind-abi.md:391
msgid ""
"This constraint is partially met: the behavior of foreign exceptions with "
"respect to `catch_unwind` is currently undefined, and left for future work."
msgstr ""

#: src/2945-c-unwind-abi.md:395
msgid "Enable error handling with `longjmp`"
msgstr ""

#: src/2945-c-unwind-abi.md:397 src/2945-c-unwind-abi.md:401
msgid "This constraint has been [deferred](#unresolved-questions)."
msgstr ""

#: src/2945-c-unwind-abi.md:399
msgid "Do not change the ABI of functions in the `libc` crate"
msgstr ""

#: src/2945-c-unwind-abi.md:403
msgid "Prior art"
msgstr ""

#: src/2945-c-unwind-abi.md:406
msgid ""
"C++ as specified has no concept of \"foreign\" exceptions or of an "
"underlying exception mechanism. However, in practice, the C++ exception "
"mechanism is the \"native\" unwinding mechanism used by compilers."
msgstr ""

#: src/2945-c-unwind-abi.md:410
msgid ""
"On Microsoft platforms, when using MSVC, unwinding is always supported for "
"both C++ and C code; this is very similar to \"option 3\" described in [the "
"inside-rust post](https://blog.rust-lang.org/inside-rust/2020/02/27/ffi-"
"unwind-design-meeting.html#three-specific-proposals) mentioned [above]"
"(#other-proposals-discussed-with-the-lang-team)."
msgstr ""

#: src/2945-c-unwind-abi.md:414
msgid ""
"On other platforms, GCC, LLVM, and any related compilers provide a flag, `-"
"fexceptions`, for explicitly ensuring that stack frames have unwinding "
"support regardless of the language being compiled. Conversely, `-fno-"
"exceptions` removes unwinding support even from C++. This is somewhat "
"similar to how Rust's `panic=unwind` and `panic=abort` work for `panic!` "
"unwinds, and under the \"option 3\" proposal, the behavior would be similar "
"for foreign exceptions as well. In the current proposal, though, such "
"foreign exception support is not enabled by default with `panic=unwind` but "
"requires the new `\"C-unwind\"` ABI."
msgstr ""

#: src/2945-c-unwind-abi.md:424
msgid "Attributes on nightly Rust and prior RFCs"
msgstr ""

#: src/2945-c-unwind-abi.md:427
msgid ""
"Currently, nightly Rust provides attributes, `#[unwind(allowed)]` and "
"`#[unwind(abort)]`, that permit users to select a well-defined behavior when "
"a `panic` reaches an `extern \"C\"` function boundary. Stabilization of "
"these attributes has [a tracking issue](https://github.com/rust-lang/rust/"
"issues/58760), but most of the discussion about whether this was the best "
"approach took place in two RFC PR threads, [\\#2699](https://github.com/rust-"
"lang/rfcs/pull/2699) and [\\#2753](https://github.com/rust-lang/rfcs/"
"pull/2753)."
msgstr ""

#: src/2945-c-unwind-abi.md:434
msgid ""
"The attribute approach was deemed insufficient for the following reasons:"
msgstr ""

#: src/2945-c-unwind-abi.md:436
msgid ""
"Currently, Rust does not support attributes on function pointers. This may "
"change in the future, but until then, attributes cannot provide any way to "
"differentiate function pointers that may unwind from those that are "
"guaranteed not to. Assuming that no function pointers may unwind is not "
"viable, because that severely limits the utility of cross-FFI unwinding. "
"Conversely, assuming that all `extern \"C\"` function pointers may unwind is "
"inconsistent with the no-unwind default for `extern \"C\"` functions."
msgstr ""

#: src/2945-c-unwind-abi.md:443
msgid ""
"The existence of a compatible unwind mechanism on both sides of a function "
"invocation boundary is part of the binary interface for that invocation, so "
"the ABI string is a more appropriate part of the language syntax than "
"function attributes to indicate that unwinding may occur."
msgstr ""

#: src/2945-c-unwind-abi.md:447
msgid ""
"The ability of a function to unwind must be part of the type system to "
"ensure that callers that cannot unwind don't invoke functions that can "
"unwind. Although attributes are sometimes part of a function's type, a "
"function's ABI string is always part of its type, so we are not introducing "
"any new elements to the type system."
msgstr ""

#: src/2945-c-unwind-abi.md:457
msgid "Older discussions about unwinding through `extern \"C\"` boundaries"
msgstr ""

#: src/2945-c-unwind-abi.md:459
msgid ""
"As mentioned [above](#motivation), it is currently undefined behavior for "
"`extern \"C\"` functions to unwind. As documented in [this issue](https://"
"github.com/rust-lang/rust/issues/52652), the lang team has long intended to "
"make `panic!` cause the runtime to abort rather than unwind through an "
"`extern \"C\"` boundary (which the current proposal [also specifies]"
"(#changes-to-extern-c-behavior))."
msgstr ""

#: src/2945-c-unwind-abi.md:465
msgid ""
"The abort-on-unwind behavior was [stabilized in 1.24](https://blog.rust-lang."
"org/2018/02/15/Rust-1.24.html#other-good-stuff) and [reverted in 1.24.1]"
"(https://blog.rust-lang.org/2018/03/01/Rust-1.24.1.html#do-not-abort-when-"
"unwinding-through-ffi); the team originally planned to [stabilize it again]"
"(https://github.com/rust-lang/rust/pull/55982) in 1.33, but ultimately "
"[decided not to](https://github.com/rust-lang/rust/issues/58794). Community "
"discussion [on discourse](https://internals.rust-lang.org/t/unwinding-"
"through-ffi-after-rust-1-33/9521?u=batmanaod) was largely concerned with the "
"lack of any stable language feature to permit unwinding across FFI "
"boundaries, and this contributed to the decision to block the re-"
"stabilization of the abort-on-unwind behavior until such a feature could be "
"introduced."
msgstr ""

#: src/2945-c-unwind-abi.md:481
msgid "Unresolved questions"
msgstr ""

#: src/2945-c-unwind-abi.md:484
msgid ""
"The behavior of `catch_unwind` when a foreign exception encounters it is "
"currently [left undefined](#reference-level-explanation). We would like to "
"provide a well-defined behavior for this case, which will probably be either "
"to let the exception pass through uncaught or to catch some or all foreign "
"exceptions."
msgstr ""

#: src/2945-c-unwind-abi.md:490
msgid ""
"We would also like to specify conditions under which `longjmp` and "
"`pthread_exit` may safely deallocate Rust frames. This RFC specifies that "
"frames deallocated in this way [must be POFs](#reference-level-explanation). "
"However, this condition is merely necessary rather than sufficient to ensure "
"well-defined behavior."
msgstr ""

#: src/2945-c-unwind-abi.md:496
msgid ""
"Within the context of this RFC and in discussions among members of the [FFI-"
"unwind project group](https://github.com/rust-lang/project-ffi-unwind), this "
"class of formally-undefined behavior which we plan to define in future RFCs "
"is referred to as \"TBD behavior\"."
msgstr ""

#: src/2945-c-unwind-abi.md:501
msgid "Future possibilities"
msgstr ""

#: src/2945-c-unwind-abi.md:504
msgid ""
"The [FFI-unwind project group](https://github.com/rust-lang/project-ffi-"
"unwind) intends to remain active at least until all [\"TBD behavior\"]"
"(#unresolved-questions) is defined. We may also address some or all of the "
"current proposal's [limitations](#additional-limitations) in future RFCs."
msgstr ""

#: src/2945-c-unwind-abi.md:509
msgid ""
"We may want to provide more means of interaction with foreign exceptions. "
"For instance, it may be possible to provide a way for Rust to catch C++ "
"exceptions and rethrow them from another thread. Such a mechanism may either "
"be incorporated into the functionality of `catch_unwind` or provided as a "
"separate language or standard library feature."
msgstr ""

#: src/2945-c-unwind-abi.md:515
msgid ""
"Coercions between `\"C-unwind\"` function types (such as function pointers) "
"and the other ABIs are not part of this RFC. However, they will probably be "
"indispensable for API design, so we plan to provide them in a future RFC."
msgstr ""

#: src/2945-c-unwind-abi.md:519
msgid ""
"As mentioned [above](#reasons-for-the-current-proposal), shims will be "
"required if Rust changes its unwind mechanism."
msgstr ""
