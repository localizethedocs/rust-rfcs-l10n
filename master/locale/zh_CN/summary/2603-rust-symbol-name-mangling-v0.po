msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:45Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2603-rust-symbol-name-mangling-v0.md:1
msgid "Feature Name: N/A"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:2
msgid "Start Date: 2018-11-27"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2603](https://github.com/rust-lang/rfcs/pull/2603)"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:4
msgid ""
"Rust Issue: [rust-lang/rust#60705](https://github.com/rust-lang/rust/"
"issues/60705)"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:6
msgid "Summary"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:9
msgid ""
"This RFC proposes a new mangling scheme that describes what the symbol names "
"generated by the Rust compiler look like. This new scheme has a number of "
"advantages over the existing one which has grown over time without a clear "
"direction. The new scheme is consistent, depends less on compiler internals, "
"and the information it stores in symbol names can be decoded again which "
"provides an improved experience for users of external tools that work with "
"Rust symbol names."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:17
msgid ""
"Note that, at this point, the new mangling scheme would not be part of the "
"language specification or the specification of a stable Rust ABI. In the "
"future it _could_ be part of both and it is designed to be stable and "
"extensible; but for the time being it would still be an implementation "
"detail of the Rust compiler."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:23
msgid "Motivation"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:26
msgid ""
"Due to its ad-hoc nature, the compiler's current name mangling scheme has a "
"number of drawbacks:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:29
msgid ""
"Information about generic parameters and other things is lost in the "
"mangling process. One cannot extract the type arguments of a monomorphized "
"function from its symbol name."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:33
msgid ""
"The current scheme is inconsistent: most paths use [Itanium ABI](http://"
"refspecs.linuxbase.org/cxxabi-1.86.html#mangling) style encoding, but some "
"don't."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:36
msgid ""
"The symbol names it generates can contain `.` characters which is not "
"generally supported on all platforms. \\[[1](https://sourceware.org/binutils/"
"docs/as/Symbol-Names.html#Symbol-Names)\\] \\[[2](https://github.com/rust-"
"lang/rust/issues/54190)\\] \\[[3](https://github.com/rust-lang/rust/"
"issues/53912)\\]"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:40
msgid ""
"It depends on compiler internals and its results cannot be replicated by "
"another compiler implementation or external tool."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:47
msgid "The proposed scheme solves these problems:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:49
msgid "It encodes information about generic parameters in a reversible way."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:50
msgid ""
"It has a consistent definition that does not rely on pretty-printing certain "
"language constructs."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:52
msgid ""
"It generates symbols that only consist of the characters `A-Z`, `a-z`, "
"`0-9`, and `_`."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:54
msgid ""
"While the proposed scheme still contains things that are implementation "
"defined it has a clearer path towards full name predictability in future."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:57
msgid ""
"These properties should make it easier for third party tools to work with "
"Rust binaries."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:60
msgid "Guide-level explanation"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:63
msgid ""
"The following section will lay out the requirements for a name mangling "
"scheme and then introduce the actual scheme through a series of ever more "
"complex examples."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:67
msgid "Requirements for a Symbol Mangling Scheme"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:69
msgid ""
"A symbol mangling scheme has a few goals, one of them essential, the rest of "
"them desirable. The essential one is:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:72
msgid ""
"The scheme must provide an unambiguous string encoding for everything that "
"can end up in a binary's symbol table."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:75
msgid ""
"\"Unambiguous\" means that no two distinct compiler-generated entities (that "
"is, mostly object code for functions) must be mapped to the same symbol "
"name. This disambiguation is the main purpose of the hash-suffix in the "
"current, legacy mangling scheme. The scheme proposed here, on the other "
"hand, achieves it in a way that allows to also satisfy a number of "
"additional desirable properties of a mangling scheme:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:82
msgid ""
"A mangled symbol should be _decodable_ to some degree. That is, it is "
"desirable to be able to tell which exact concrete instance of e.g. a "
"polymorphic function a given symbol identifies. This is true for external "
"tools, backtraces, or just people only having the binary representation of "
"some piece of code available to them. With the current scheme, this kind of "
"information gets lost in the magical hash-suffix."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:90
msgid ""
"A mangling scheme should be platform-independent. This is mainly achieved by "
"restricting the character set to `A-Z`, `a-z`, `0-9`, `_`. All other "
"characters might have special meaning in some context (e.g. `.` for MSVC "
"`DEF` files) or are simply not supported (e.g. Unicode)."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:96
msgid ""
"The scheme should be efficient, meaning that the symbols it produces are not "
"unnecessarily long (because that takes up space in object files and means "
"more work for the compiler and the linker). In addition, generating or "
"demangling a symbol name should not be too computationally expensive."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:102
msgid ""
"When used as part of a stable ABI, it should be possible to predict the "
"symbol name for a given source-level construct. For example, given the "
"definition `fn foo<T>() { ... }`, the scheme should allow to construct, by "
"hand, the symbol names for e.g. `foo<u32>` or `foo<extern fn(i32, &mut "
"SomeStruct<(char, &str)>, ...) -> !>()`. Since the current scheme generates "
"its hash from the values of various compiler internal data structures, an "
"alternative compiler implementation could not predict the symbol name, even "
"for simple cases. Note that the scheme proposed here does not fulfill this "
"requirement either (yet) as some things are still left to the compiler "
"implementation."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:114
msgid "The RFC also has a couple of non-goals:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:116
msgid ""
"The mangling scheme does not try to be compatible with an existing (e.g. C+"
"+) mangling scheme. While it might sound tempting to encode Rust symbols "
"with an existing scheme, it is the author's opinion that the actual benefits "
"are small (C++ tools would not demangle to Rust syntax, demanglings would be "
"hard to read) and at the same time supporting a Rust-specific scheme in "
"existing tools seems quite feasible (many tools like GDB, LLDB, binutils, "
"and valgrind already have specialized code paths for Rust symbols)."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:125
msgid ""
"The RFC does not try to define a standardized _demangled_ form for symbol "
"names. It defines the mangled form and makes sure it can be demangled in an "
"efficient manner but different demanglers still have some degree of freedom "
"regarding how symbol names are presented to the user."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:132
msgid "The Mangling Scheme by Example"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:134
msgid ""
"This section will develop an overview of the mangling scheme by walking "
"through a number of examples. We'll start with the simplest case -- and will "
"see how that already involves things that might be surprising."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:138
msgid "Free-standing Functions and Statics"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:140
msgid ""
"A free-standing function is fully identified via its absolute path. For "
"example, the following function"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:149
msgid ""
"has the path `foo::bar` and `NN3foo3bar` is a possible mangling of that path "
"that complies to the character set we are restricted to. Why this format "
"with numbers embedded in it? It is a run-length encoding, similar to what "
"the [Itanium C++ ABI](http://refspecs.linuxbase.org/cxxabi-1.86."
"html#mangling) name mangling scheme uses for identifiers. The scheme "
"proposed here will also use this format because it does not need termination "
"tokens for identifiers (which are hard to come by with our limited character "
"set)."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:157
msgid ""
"Note that each component in the path (i.e. `foo` and `bar`) also has an "
"accompanying _start-tag_ (here `N`) at the beginning. This start-tag is "
"needed in order for the syntax to be able to represent complex, nested "
"structures as we will see later."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:162
msgid ""
"The symbol name above, unfortunately, does not unambiguously identify the "
"function in every context. It is perfectly valid for another crate to also "
"define `mod foo { fn bar() {} }` somewhere. So in order to avoid conflicts "
"in such cases, the absolute path must always include the crate-id, as in "
"`NNC7mycrate3foo3bar`. The crate-id has a `C` start-tag."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:169
msgid ""
"There is another possible ambiguity that we have to take care of. Rust has "
"two distinct namespaces: the type and the value namespace. This leads to a "
"path of the form `crate_id::foo::bar` not uniquely identifying the item "
"`bar` because the following snippet is legal Rust code:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:185
msgid ""
"The function `foo` lives in the value namespace while the module `foo` lives "
"in the type namespace. They don't interfere. In order to make the symbol "
"names for the two distinct `bar` functions unique, we thus add a namespace "
"identifier to the start-tag of components where necessary, as in "
"`NvNvC7mycrate3foo3bar` for the first case and `NvNtC7mycrate3foo3bar` "
"second case (notice the difference: `NvNv...` vs `NvNt...`)."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:192
msgid ""
"There is one final case of name ambiguity that we have to take care of. "
"Because of macro hygiene, multiple items with the same name can appear in "
"the same context. The compiler internally disambiguates such names by "
"augmenting them with a numeric index. For example, the first occurrence of "
"the name `foo` within its parent is actually treated as `foo'0`, the second "
"occurrence would be `foo'1`, the next `foo'2`, and so one. The mangling "
"scheme will adopt this setup by prepending a disambiguation prefix to each "
"identifier with a non-zero index. So if macro expansion would result in the "
"following code:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:205
msgid "// The second `bar` function was introduced by macro expansion.\n"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:210
msgid ""
"then we would encode the two functions symbols as `NvNtC7mycrate3foo3bar` "
"and `NvNtC7mycrate3foos_3bar` respectively (note the `s_` prefix in the "
"second case). A very similar disambiguation is needed for avoiding conflicts "
"between crates of the same name but different versions. The same syntactic "
"prefix is thus used for crate-id where we encode the crate disambiguator as "
"in `NtNvCs1234_7mycrate3foo3bar`. Details on the shape of this prefix are "
"provided in the reference-level description."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:218
msgid ""
"As opposed to C++ and other languages that support function overloading, we "
"don't need to include function parameter types in the symbol name. Rust does "
"not allow two functions of the same name but different arguments."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:222
msgid ""
"The final symbol name for the function would also include the prefix `_R` "
"that is common to all symbol names generated by this scheme:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:225
msgid ""
"```\n"
"  _RNvNtCs1234_7mycrate3foo3bar\n"
"  <>^^^^^<----><------><--><-->\n"
"   ||||||   |      |     |   |\n"
"   ||||||   |      |     |   +--- \"bar\" identifier\n"
"   ||||||   |      |     +------- \"foo\" identifier\n"
"   ||||||   |      +------------- \"mycrate\" identifier\n"
"   ||||||   +-------------------- disambiguator for \"mycrate\"\n"
"   |||||+------------------------ start-tag for \"mycrate\"\n"
"   ||||+------------------------- namespace tag for \"foo\"\n"
"   |||+-------------------------- start-tag for \"foo\"\n"
"   ||+--------------------------- namespace tag for \"bar\"\n"
"   |+---------------------------- start-tag for \"bar\"\n"
"   +----------------------------- common Rust symbol prefix\n"
"```"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:242
msgid "Generic Functions"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:244
msgid ""
"Each monomorphization of a generic function has its own symbol name. The "
"monomorphizations are disambiguated by the list of concrete generic "
"arguments. These arguments are added to the symbol name by a pair of `I` "
"start-tag at the beginning and a list of the actual arguments at the end. So "
"the instance"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:254
msgid "would be mangled to"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:265
msgid ""
"where `I` precedes the thing the arguments belong to, `d` designates `f64` "
"and `E` ends the argument list. As we can see, we need to be able to "
"represent all kinds of types that can be part of such an argument list. (In "
"the future, when const generics get added to the language, we will also need "
"to represent _values_) These kinds of types are:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:271
msgid "basic types (`char`, `()`, `str`, `!`, `i8`, `i16`, ...)"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:272
msgid "reference and pointers types, shared, `mut` and `const`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:273
msgid "tuples"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:274
msgid "arrays, with and without fixed size (e.g. `[u8]`, `[u8; 17]`)"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:275
msgid ""
"structs, enums, closures, and other named types, possibly with their own set "
"of type arguments"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:277
msgid "function types such as `fn(&i32) -> u16`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:278
msgid "`dyn` traits"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:280
msgid ""
"Basic types are all encoded via a single lower-case letter, like in the "
"Itanium scheme. Named types are encoded as their absolute path (including "
"arguments) like is done for function symbols. Composites like references, "
"tuples, and function types all follow a simple grammar given in the "
"reference-level explanation below. Here are some example manglings to get a "
"general feel of what they look like:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:287
msgid "`std::mem::align_of::<usize>`: `_RINvNtC3std3mem8align_ofjE`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:288
msgid "`std::mem::align_of::<&char>`: `_RINvNtC3std3mem8align_ofRcE`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:289
msgid ""
"`std::mem::align_of::<std::mem::Discriminant>`: "
"`_RINvNtC3std3mem8align_ofNtNtC3std3mem12DiscriminantE`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:291
msgid ""
"`std::mem::align_of::<&mut (&str,())>`: `_RINvNtC3std3mem8align_ofQTReuEE`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:293
msgid ""
"There's one more thing we have to take into account for generic functions: "
"The compiler may produce \"crate-local\" copies of a monomorphization. That "
"is, if there is a function `foo<T>` which gets used as `foo<u32>` in two "
"different crates, the compiler (depending on the optimization level) might "
"generate two distinct functions at the LLVM IR level, each with it's own "
"symbol. In order to support this without running into conflicts, symbol "
"names for monomorphizations must include the id of the crate they are "
"instantiated for. This scheme does this by appending an `<crate-id>` suffix "
"to the symbol. So for example the mangling for `std::mem::align_of::<usize>` "
"would actually look like this:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:304
msgid ""
"```\n"
"_RINvNtC3std3mem8align_ofjEC3foo (for crate \"foo\")\n"
"_RINvNtC3std3mem8align_ofjEC3bar (for crate \"bar\")\n"
"```"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:310
msgid "Closures and Closure Environments"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:312
msgid ""
"The scheme needs to be able to generate symbol names for the function "
"containing the code of a closure and it needs to be able to refer to the "
"type of a closure if it occurs as a type argument. As closures don't have a "
"name, we need to generate one. The scheme proposes to use the namespace and "
"disambiguation mechanisms already introduced above for this purpose. "
"Closures get their own \"namespace\" (i.e. they are neither in the type nor "
"the value namespace), and each closure has an empty name with a "
"disambiguation index (like for macro hygiene) identifying them within their "
"parent. The full name of a closure is then constructed like for any other "
"named item:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:326
msgid "// local name: NC<...>0\n"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:327
msgid "// local name: NC<...>s_0\n"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:335
msgid ""
"In the above example we have two closures, the one assigned to `a` and the "
"one assigned to `b`. The first one would get the local name `NC<...>0` and "
"the second one the name `NC<...>s_0`. The `0` signifies the length of their "
"(empty) name. The `<...>` part is the path of the parent. The `C` is the "
"namespace tag, analogous to the `v` tag for the value namespace. The `s_` "
"for the second closure is the disambiguation index (index `0` is, again, "
"encoded by not prepending a prefix). Their full names would then be "
"`NCNvNtC7mycrate3foo3bar0` and `NCNvNtC7mycrate3foo3bars_0` respectively."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:346
msgid "Methods"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:348
msgid ""
"Methods are nested within `impl` or `trait` items. As such it would be "
"possible to construct their symbol names as paths like `my_crate::foo::"
"{{impl}}::some_method` where `{{impl}}` somehow identifies the `impl` in "
"question. Since `impl`s don't have names, we'd have to use an indexing "
"scheme like the one used for closures (and indeed, this is what the compiler "
"does internally). Adding in generic arguments to, this would lead to symbol "
"names looking like `my_crate::foo::impl'17::<u32, char>::some_method`."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:357
msgid ""
"However, in the opinion of the author these symbols are very hard to map "
"back to the method they represent. Consider a module containing dozens of "
"types, each with multiple `impl` blocks generated via `#[derive(...)]`. In "
"order to find out which method a symbol maps to, one would have to count the "
"number of handwritten _and_ macro generated `impl` blocks in the module, and "
"hope that one correctly guessed the number of `impl` blocks introduced by "
"the given derive-macro (each macro invocation can introduce `0..n` such "
"blocks). The name of the method might give a hint, but there are still "
"likely to be dozens of methods named `clone`, `hash`, `eq`, et cetera."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:367
msgid ""
"The RFC therefore proposes to keep symbol names close to how methods are "
"represented in error messages, that is:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:370
msgid "`<Foo<u32, char>>::some_method` for inherent methods, and"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:371
msgid "`<Foo<u32, char> as SomeTrait<Quux>>::some_method` for trait methods."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:373
msgid ""
"This can be achieved by extending the definition of paths that we have used "
"so far. Instead of the path root always being a crate-id, we now also allow "
"a path to start with an `impl` production that contains the self-type and "
"(for trait methods) the name of the trait being implemented."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:378
msgid "Thus, this extended form of paths would have the following syntax:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:380
msgid ""
"```\n"
"<path> = C <identifier>                      // crate-id root\n"
"       | M <type>                            // inherent impl root\n"
"       | X <type> <path>                     // trait impl root\n"
"       | N <namespace> <path> <identifier>   // nested path\n"
"       | I <path> {<generic-arg>} E          // generic arguments\n"
"```"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:388
msgid "Here are some examples for complete symbol names:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:397
msgid "Items Within Generic Impls"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:399
msgid ""
"In Rust one can define items within generic items, e.g. functions or impls, "
"like in the following example:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:407
#: src/2603-rust-symbol-name-mangling-v0.md:431
msgid "\"...\""
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:408
#: src/2603-rust-symbol-name-mangling-v0.md:432
#: src/2603-rust-symbol-name-mangling-v0.md:439
msgid "\"{}\""
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:413
msgid ""
"The `MSG` here (or any other such nested definition) does not inherit the "
"generic context from the `impl`. `MSG` is non-generic, and a function "
"defined in its place would be too. The fully qualified name of `MSG`, "
"according to our examples so far, is thus `<mycrate::Foo<_> as std::convert::"
"From<_>>::from::MSG` and its symbol name:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:423
msgid ""
"However, with trait specialization, this symbol can be ambiguous. Consider "
"the following piece of code:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:438
msgid "\"123\""
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:444
msgid ""
"Notice that both `MSG` statics have the path `<Foo<_> as From<_>>::foo::"
"MSG`. We somehow have to disambiguate the `impls`. We do so by adding the "
"path of the `impl` to the symbol name."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:448
msgid ""
"```\n"
"<path> = C <identifier>                      // crate-id root\n"
"       | M <impl-path> <type>                // inherent impl root\n"
"       | X <impl-path> <type> <path>         // trait impl root\n"
"       | N <namespace> <path> <identifier>   // nested path\n"
"       | I <path> {<generic-arg>} E          // generic arguments\n"
"\n"
"<impl-path> = [<disambiguator>] <path>\n"
"```"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:458
msgid "The two symbol names would then look something like:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:467
msgid ""
"Like other disambiguation information, this path would usually not actually "
"be shown by demanglers."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:470
msgid "Unicode Identifiers"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:472
msgid ""
"Rust allows Unicode identifiers but our character set is restricted to ASCII "
"alphanumerics, and `_`. In order to transcode the former to the latter, we "
"use the same approach as Swift, which is: encode all non-ASCII identifiers "
"via [Punycode](https://tools.ietf.org/html/rfc3492), a standardized and "
"efficient encoding that keeps encoded strings in a rather human-readable "
"format. So for example, the string"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:479
msgid ""
"```\n"
"\"G√∂del, Escher, Bach\"\n"
"```"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:483
msgid "is encoded as"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:485
msgid ""
"```\n"
"\"Gdel, Escher, Bach-d3b\"\n"
"```"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:489
msgid ""
"which, as opposed to something like _Base64_, still gives a pretty good idea "
"of what the original string looked like."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:492
msgid ""
"Each component of a name, i.e. anything that starts with the number of bytes "
"to read in the examples above, is encoded individually. Components encoded "
"this way are augmented with a `u` prefix so that demanglers know that the "
"identifier needs further decoding. As an example, the function:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:506
msgid "would be mangled as:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:514
msgid "Compression/Substitution"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:516
msgid ""
"The length of symbol names has an influence on how much work the compiler, "
"linker, and loader have to perform. The shorter the names, the better. At "
"the same time, Rust's generics can lead to rather long names (which are "
"often not visible in the code because of type inference and `impl Trait`). "
"For example, the return type of the following function:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:532
msgid "is"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:546
msgid ""
"It would make for a long symbol name if this type is used (maybe repeatedly) "
"as a generic argument somewhere. C++ has the same problem with its "
"templates; which is why the Itanium mangling introduces the concept of "
"compression. If a component of a definition occurs more than once, it will "
"not be repeated and instead be emitted as a substitution marker that allows "
"to reconstruct which component it refers to. The scheme proposed here will "
"use the same approach (but with a simpler definition)."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:555
msgid ""
"The exact scheme will be described in detail in the reference level "
"explanation below but it roughly works as follows: As a mangled symbol name "
"is being built, we remember the position of every substitutable item in the "
"output string, that is, we keep track of things a subsequent occurrence of "
"which could be replaced by a back reference."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:561
msgid ""
"The things that are eligible for substitution are (1) all prefixes of paths "
"(including the entire path itself), (2) all types except for basic types, "
"and (3) type-level constants (array lengths and values passed to const "
"generic params)."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:566
msgid "Here's an example in order to illustrate the concept. The name"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:572
msgid ""
"is mangled to the following uncompressed string. The lines below show parts "
"of the mangled string that already occurred before and can thus be replaced "
"by a back reference. The number of at the beginning of each span given the 0-"
"based byte position of where it occurred the first time."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:586
msgid ""
"The compiler is always supposed to use the longest replacement possible in "
"order to achieve the best compression. The compressed symbol looks as "
"follows:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:595
msgid "Back references have the form `B<base-62-number>_`."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:597
msgid "Reference-level explanation"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:600
msgid "The reference-level explanation consists of three parts:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:602
msgid "A specification of the syntax mangled names conform to."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:603
msgid "A specification of the compression scheme."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:604
msgid "A mapping of Rust entities to the mangling syntax."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:606
msgid ""
"For implementing a demangler, only the first two sections are of interest, "
"that is, a demangler only needs to understand syntax and compression of "
"names, but it does not have to care about how the compiler generates mangled "
"names."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:612
msgid "Syntax Of Mangled Names"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:614
msgid "The syntax of mangled names is given in extended Backus-Naur form:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:616
msgid "Non-terminals are within angle brackets (as in `<path>`)"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:617
msgid "Terminals are within quotes (as in `\"_R\"`),"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:618
msgid "Optional parts are in brackets (as in `[<disambiguator>]`),"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:619
msgid ""
"Repetition (zero or more times) is signified by curly braces (as in `{<type>}"
"`)"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:620
msgid "Comments are marked with `//`."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:622
msgid "Mangled names conform to the following grammar:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:624
msgid ""
"```\n"
"// The <decimal-number> specifies the encoding version.\n"
"<symbol-name> =\n"
"    \"_R\" [<decimal-number>] <path> [<instantiating-crate>] [<vendor-"
"specific-suffix>]\n"
"\n"
"<path> = \"C\" <identifier>                    // crate root\n"
"       | \"M\" <impl-path> <type>              // <T> (inherent impl)\n"
"       | \"X\" <impl-path> <type> <path>       // <T as Trait> (trait impl)\n"
"       | \"Y\" <type> <path>                   // <T as Trait> (trait "
"definition)\n"
"       | \"N\" <namespace> <path> <identifier> // ...::ident (nested path)\n"
"       | \"I\" <path> {<generic-arg>} \"E\"      // ...<T, U> (generic "
"args)\n"
"       | <backref>\n"
"\n"
"// Path to an impl (without the Self type or the trait).\n"
"// The <path> is the parent, while the <disambiguator> distinguishes\n"
"// between impls in that same parent (e.g. multiple impls in a mod).\n"
"// This exists as a simple way of ensure uniqueness, and demanglers\n"
"// don't need to show it (unless the location of the impl is desired).\n"
"<impl-path> = [<disambiguator>] <path>\n"
"\n"
"// The <decimal-number> is the length of the identifier in bytes.\n"
"// <bytes> is the identifier itself, and it's optionally preceded by \"_\",\n"
"// to separate it from its length - this \"_\" is mandatory if the <bytes>\n"
"// starts with a decimal digit, or \"_\", in order to keep it unambiguous.\n"
"// If the \"u\" is present then <bytes> is Punycode-encoded.\n"
"<identifier> = [<disambiguator>] <undisambiguated-identifier>\n"
"<disambiguator> = \"s\" <base-62-number>\n"
"<undisambiguated-identifier> = [\"u\"] <decimal-number> [\"_\"] <bytes>\n"
"\n"
"// Namespace of the identifier in a (nested) path.\n"
"// It's an a-zA-Z character, with a-z reserved for implementation-internal\n"
"// disambiguation categories (and demanglers should never show them), while\n"
"// A-Z are used for special namespaces (e.g. closures), which the demangler\n"
"// can show in a special way (e.g. `NC...` as `...::{closure}`), or just\n"
"// default to showing the uppercase character.\n"
"<namespace> = \"C\"      // closure\n"
"            | \"S\"      // shim\n"
"            | <A-Z>    // other special namespaces\n"
"            | <a-z>    // internal namespaces\n"
"\n"
"<generic-arg> = <lifetime>\n"
"              | <type>\n"
"              | \"K\" <const> // forward-compat for const generics\n"
"\n"
"// An anonymous (numbered) lifetime, either erased or higher-ranked.\n"
"// Index 0 is always erased (can show as '_, if at all), while indices\n"
"// starting from 1 refer (as de Bruijn indices) to a higher-ranked\n"
"// lifetime bound by one of the enclosing <binder>s.\n"
"<lifetime> = \"L\" <base-62-number>\n"
"\n"
"// Specify the number of higher-ranked (for<...>) lifetimes to bound.\n"
"// <lifetime> can then later refer to them, with lowest indices for\n"
"// innermost lifetimes, e.g. in `for<'a, 'b> fn(for<'c> fn(...))`,\n"
"// any <lifetime>s in ... (but not inside more binders) will observe\n"
"// the indices 1, 2, and 3 refer to 'c, 'b, and 'a, respectively.\n"
"// The number of bound lifetimes is value of <base-62-number> + 1.\n"
"<binder> = \"G\" <base-62-number>\n"
"\n"
"<type> = <basic-type>\n"
"       | <path>                      // named type\n"
"       | \"A\" <type> <const>          // [T; N]\n"
"       | \"S\" <type>                  // [T]\n"
"       | \"T\" {<type>} \"E\"            // (T1, T2, T3, ...)\n"
"       | \"R\" [<lifetime>] <type>     // &T\n"
"       | \"Q\" [<lifetime>] <type>     // &mut T\n"
"       | \"P\" <type>                  // *const T\n"
"       | \"O\" <type>                  // *mut T\n"
"       | \"F\" <fn-sig>                // fn(...) -> ...\n"
"       | \"D\" <dyn-bounds> <lifetime> // dyn Trait<Assoc = X> + Send + 'a\n"
"       | <backref>\n"
"\n"
"<basic-type> = \"a\"      // i8\n"
"             | \"b\"      // bool\n"
"             | \"c\"      // char\n"
"             | \"d\"      // f64\n"
"             | \"e\"      // str\n"
"             | \"f\"      // f32\n"
"             | \"h\"      // u8\n"
"             | \"i\"      // isize\n"
"             | \"j\"      // usize\n"
"             | \"l\"      // i32\n"
"             | \"m\"      // u32\n"
"             | \"n\"      // i128\n"
"             | \"o\"      // u128\n"
"             | \"s\"      // i16\n"
"             | \"t\"      // u16\n"
"             | \"u\"      // ()\n"
"             | \"v\"      // ...\n"
"             | \"x\"      // i64\n"
"             | \"y\"      // u64\n"
"             | \"z\"      // !\n"
"             | \"p\"      // placeholder (e.g. for generic params), shown as "
"_\n"
"\n"
"// If the \"U\" is present then the function is `unsafe`.\n"
"// The return type is always present, but demanglers can\n"
"// choose to omit the ` -> ()` by special-casing \"u\".\n"
"<fn-sig> = [<binder>] [\"U\"] [\"K\" <abi>] {<type>} \"E\" <type>\n"
"\n"
"<abi> = \"C\"\n"
"      | <undisambiguated-identifier>\n"
"\n"
"<dyn-bounds> = [<binder>] {<dyn-trait>} \"E\"\n"
"<dyn-trait> = <path> {<dyn-trait-assoc-binding>}\n"
"<dyn-trait-assoc-binding> = \"p\" <undisambiguated-identifier> <type>\n"
"<const> = <type> <const-data>\n"
"        | \"p\" // placeholder, shown as _\n"
"        | <backref>\n"
"\n"
"// The encoding of a constant depends on its type. Integers use their "
"value,\n"
"// in base 16 (0-9a-f), not their memory representation. Negative integer\n"
"// values are preceded with \"n\". The bool value false is encoded as `0_`, "
"true\n"
"// value as `1_`. The char constants are encoded using their Unicode scalar\n"
"// value.\n"
"<const-data> = [\"n\"] {<hex-digit>} \"_\"\n"
"\n"
"// <base-62-number> uses 0-9-a-z-A-Z as digits, i.e. 'a' is decimal 10 and\n"
"// 'Z' is decimal 61.\n"
"// \"_\" with no digits indicates the value 0, while any other value is "
"offset\n"
"// by 1, e.g. \"0_\" is 1, \"Z_\" is 62, \"10_\" is 63, etc.\n"
"<base-62-number> = {<0-9a-zA-Z>} \"_\"\n"
"\n"
"<backref> = \"B\" <base-62-number>\n"
"\n"
"// We use <path> here, so that we don't have to add a special rule for\n"
"// compression. In practice, only a crate root is expected.\n"
"<instantiating-crate> = <path>\n"
"\n"
"// There are no restrictions on the characters that may be used\n"
"// in the suffix following the `.` or `$`.\n"
"<vendor-specific-suffix> = (\".\" | \"$\") <suffix>\n"
"```"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:756
msgid "Namespace Tags"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:758
msgid ""
"Namespaces are identified by an implementation defined single character tag "
"(the `<namespace>` production). Only closures (`C`) and shims (`S`) have a "
"specific character assigned to them so that demanglers can reliable adjust "
"their output accordingly. Other namespace tags have to be omitted or shown "
"verbatim during demangling."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:764
msgid ""
"This is a concession to the compiler's current implementation. While the "
"language only knows two namespaces (the type and the value namespace), the "
"compiler uses many more in some important data structures and disambiguation "
"indices are assigned according to these internal data structures. So, in "
"order not to force the compiler to waste processing time on re-constructing "
"different disambiguation indices, the internal unspecified \"namespaces\" "
"are used. This may change in the future."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:772
msgid "Type-Level Constants"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:774
msgid ""
"As described above, the grammar encodes constant values via the `<const-"
"data> = {<hex-digit>} \"_\"` production, where `{<hex-digit>}` is the "
"numeric value of the constant, not its representation as bytes. Using the "
"numeric value is platform independent but does not easily scale to non-"
"integer data types."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:780
msgid ""
"In the future it is likely that Rust will support complex type-level "
"constants (i.e. not just integers). This RFC suggests to develop a proper "
"mangling for these as part of the future const-generics work, and, for now, "
"only define a mangling for integer values."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:785
msgid "Punycode Identifiers"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:787
msgid ""
"Punycode generates strings of the form `([[:ascii:]]+-)?[[:alnum:]]+`. This "
"is problematic because of the `-` character, which is not in the supported "
"character set; Punycode uses it to separate the ASCII part (if it exists), "
"from the base-36 encoding of the non-ASCII characters."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:792
msgid ""
"For this reasons, we deviate from vanilla Punycode, by replacing the `-` "
"character with a `_` character."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:795
msgid "Here are some examples:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:797
msgid "Original"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:797
msgid "Punycode"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:797
msgid "Punycode + Encoding"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:799
msgid "f√∏√∏"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:799
msgid "f-5gaa"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:799
msgid "f_5gaa"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:800
msgid "Œ±_œâ"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:800
msgid "\\_\\-ylb7e"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:800
msgid "\\_\\_ylb7e"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:801
msgid "ÈìÅÈîà"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:801
msgid "n84amf"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:802
msgid "ü§¶"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:802
msgid "fq9h"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:803
msgid "œÅœÖœÉœÑ"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:803
msgid "2xaedc"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:805
msgid ""
"With this post-processing in place the Punycode strings can be treated like "
"regular identifiers and need no further special handling."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:809
msgid "Vendor-specific suffix"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:811
msgid ""
"Similarly to the [Itanium C++ ABI mangling scheme](https://itanium-cxx-abi."
"github.io/cxx-abi/abi.html#mangling-structure), a symbol name containing a "
"period (`.`) or a dollar sign (`$`) represents a vendor-specific version of "
"the symbol. There are no restrictions on the characters following the period "
"or dollar sign."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:816
msgid ""
"This can happen in practice when locally unique names needed to become "
"globally unique. For example, LLVM can append a `.llvm.<numbers>` suffix "
"during LTO to ensure a unique name, and `$` can be used for thread-local "
"data on Mach-O. In these situations it's generally fine to ignore the "
"suffix: the suffixed name has the same semantics as the original."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:824
msgid "Compression"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:826
msgid ""
"Symbol name compression works by substituting parts of the mangled name that "
"have already been seen for a back reference. Compression is directly built "
"into the mangling algorithm, as shown by the following piece of pseudocode:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:834
msgid "// Emit the backref instead of the node's contents\n"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:837
msgid "// Remember where the current node starts in the output\n"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:840
msgid ""
"// Do the actual mangling, including recursive mangling of child nodes\n"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:842
msgid "// Add the current node to the substitution dictionary\n"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:850
msgid ""
"This algorithm automatically chooses the best compression because parent "
"nodes (which are always larger) are visited before child nodes."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:854
msgid ""
"Note that this kind of compression relies on the fact that all substitutable "
"AST nodes have a self-terminating mangled form, that is, given the start "
"position of the encoded node, the grammar guarantees that it is always "
"unambiguous where the node ends. This is ensured by not allowing optional or "
"repeating elements at the end of substitutable productions."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:862
msgid "Decompression"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:864
msgid ""
"Decompression too is built directly into demangling/parsing. When a back "
"reference is encountered, we decode the referenced position and use a "
"temporary demangler/parser to do the decoding of the node's actual content:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:871
msgid ""
"// Read the byte offset of the referenced node and\n"
"    // advance `pos` past the backref.\n"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:876
msgid "// do regular demangling\n"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:881
msgid ""
"Using byte offsets as backref keys (as this RFC does) instead of post-order "
"traversal indices (as Itanium mangling does) has the advantage that the "
"demangler does not need to duplicate the mangler's substitution indexing "
"logic, something that can become quite complex (as demonstrated by the "
"compression scheme proposed in the initial version of this RFC)."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:887
msgid "A Note On Implementing Efficient Demanglers"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:889
msgid ""
"The mangling syntax is constructed in a way that allows for implementing "
"efficient demanglers:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:892
msgid ""
"Mangled names contain information in the same order as unmangled names are "
"expected to contain it. Therefore, a demangler can directly generate its "
"output while parsing the mangled form. There is no need to explicitly "
"instantiate the AST in memory."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:897
msgid ""
"The same is true for decompression. Decompression can be done without "
"allocating memory outside of the stack. Alternatively the demangler can keep "
"a simple array that maps back-ref indices to ranges in the already generated "
"output. When it encounters a `<backref>` in need of expansion, it can just "
"look up corresponding range and do a simple `memcpy`."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:904
msgid ""
"Parsing, decompression, and demangling can thus be done in a single pass "
"over the mangled name without the need for complex data structures, which is "
"useful when having to implement `#[no_std]` or C demanglers. (Note that "
"Punycode can complicate decoding slightly because it needs dynamic memory "
"allocation in the general case but it can be implemented with an on-stack "
"buffer for a reasonable maximum supported length)."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:911
msgid "Mapping Rust Language Entities to Symbol Names"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:913
msgid ""
"This RFC suggests the following mapping of Rust entities to mangled names:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:915
msgid ""
"Named functions, methods, and statics shall be represented by a `<path>` "
"production."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:918
msgid ""
"Paths should be rooted at the inner-most entity that can act as a path root. "
"Roots can be crate-ids, inherent impls, trait impls, and (for items within "
"default methods) trait definitions."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:922
msgid ""
"The compiler is free to choose disambiguation indices and namespace tags "
"from the reserved ranges as long as it ascertains identifier unambiguity."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:925
msgid ""
"Generic arguments that are equal to the default should not be encoded in "
"order to save space."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:929
msgid "Drawbacks"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:932
msgid "Why should we _not_ do this?"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:934
msgid ""
"The current/legacy scheme based on symbol-hashes is flexible in that hashes "
"can be changed at will. That is, the unstable part of the current mangling "
"scheme is nicely contained and does not keep breaking external tools. The "
"danger of breakage is greater with the scheme proposed here because it "
"exposes more information."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:941
msgid "Rationale and alternatives"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:944
msgid "The alternatives considered are:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:946
msgid ""
"Keeping the current scheme. It does meet the minimum requirements after all. "
"However, the general consensus seems to be that this leads to situations "
"where people are unpleasantly surprised when they come across (demangled) "
"symbol names in backtraces or profilers."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:951
msgid ""
"Keeping the current scheme but cleaning it up by making the non-hash part "
"more consistent and more expressive. Keep the hash part as a safeguard "
"against symbol conflicts and the rest as something just for demangling. The "
"downside of this is that the hash would still not be predictable, and "
"symbols would get rather long if they should contain more human-readable "
"information about generic arguments."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:958
msgid ""
"Define a standardized pretty-printing format for things that end up as "
"symbols, and then encode that via Punycode in order to meet the character "
"set restrictions. This would be rather simple. Symbol names would remain "
"somewhat human-readable (but not very, because all separators would be "
"stripped out). But without some kind of additional compression, symbol names "
"would become rather long."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:965
msgid ""
"Use the scheme from the previous bullet point but apply the compression "
"scheme described above. We could do this but it wouldn't really be less "
"complex than the scheme proposed by the RFC."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:969
msgid ""
"Define a standardized pretty-printing format for things that end up as "
"symbols, compress with `zstd` (specially trained for Rust symbols) and "
"encode the result as `base63`. This is rather simple but loses all human-"
"readability. It's unclear how well this would compress. It would pull the "
"`zstd` specification into the mangling scheme specification, as well as the "
"pre-trained dictionary."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:976
msgid "Prior art"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:979
msgid ""
"One of the major modern mangling schemes with a public specification is the "
"[Itanium C++ ABI](http://refspecs.linuxbase.org/cxxabi-1.86.html#mangling) "
"scheme for C++ which is used by the GCC toolchain. An initial version of "
"this RFC sticked closely to Itanium mangling, however, the latest version "
"only retains the run-length encoding for identifiers and some literals for "
"tagging things like basic types. The Itanium scheme has been criticized for "
"being overly complex, due to its extensive grammar and two separate "
"compression schemes."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:987
msgid ""
"The idea of using [Punycode](https://tools.ietf.org/html/rfc3492) for "
"handling of unicode identifiers is taken from the [Swift](https://github.com/"
"apple/swift) programming language's [mangling scheme](https://github.com/"
"apple/swift/blob/master/docs/ABI/Mangling.rst#identifiers)."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:997
msgid "Unresolved questions"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1000
msgid "Punycode vs UTF-8"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1001
msgid ""
"During the pre-RFC phase, it has been suggested that Unicode identifiers "
"should be encoded as UTF-8 instead of Punycode on platforms that allow it. "
"GCC, Clang, and MSVC seem to do this. The author of the RFC has a hard time "
"making up their mind about this issue. Here are some interesting points that "
"might influence the final decision:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1007
msgid ""
"Using UTF-8 instead of Punycode would make mangled strings containing non-"
"ASCII identifiers a bit more human-readable. For demangled strings, there "
"would be no difference."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1011
msgid ""
"Punycode support is non-optional since some platforms only allow a very "
"limited character set for symbol names. Thus, we would be using UTF-8 on "
"some platforms and Punycode on others, making it harder to predict what a "
"symbol name for a given item looks like."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1016
msgid ""
"Punycode encoding and decoding is more runtime effort for the mangler and "
"demangler."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1019
msgid ""
"Once a demangler supports Punycode, it is not much effort to support both "
"encodings. The `u` identifier prefix tells the demangler whether it is "
"Punycode. Otherwise it can just assume UTF-8 which already subsumes ASCII."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1024
msgid ""
"**UPDATE**: This RFC recommends that Punycode encoded identifiers must be "
"supported by demanglers but that it is up to the compiler implementation "
"(for now) to decide whether to use it for a given platform. This question "
"will have to be revisited if Rust ever wants to define a stable ABI."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1029
msgid "Encoding parameter types for function symbols"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1031
msgid ""
"It has been suggested that parameter types for functions and methods should "
"be encoded in mangled form too. This is not necessary for symbol name "
"uniqueness but it would provide an additional safeguard against silent ABI-"
"related errors where definition and callers of some function make different "
"assumptions about what parameters a function takes. The RFC does not propose "
"to do this because:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1038
msgid "Rust makes sure this cannot happen via crate metadata,"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1039
msgid "it would make symbol names longer, and"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1040
msgid "only some but not all ABI related errors are caught by the safeguard."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1042
msgid "However, a final decision on the topic has not been made yet."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1044
msgid ""
"**UPDATE**: This RFC suggests that parameter types are _not_ encoded into "
"function and method symbols. Symbol names will already get significantly "
"longer due to encoding additional information and the additional safeguard "
"provided against ABI mismatches is less relevant for Rust than it is for "
"other languages that don't have a concept of library/crate metadata."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1052
msgid "Appendix A - Suggested Demangling"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1054
msgid ""
"This RFC suggests that names are demangled to a form that matches Rust "
"syntax as it is used in source code, compiler error messages and `rustdoc`:"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1057
msgid "Path components should be separated by `::`."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1059
msgid ""
"If the path root is a `<crate-id>` it should be printed as the crate name. "
"If the context requires it for correctness, the crate disambiguator can be "
"printed too, as in, for example, `std[a0b1c2d3]::collections::HashMap`. In "
"this case `a0b1c2d3` would be the disambiguator. Usually, the disambiguator "
"can be omitted for better readability."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1065
msgid ""
"If the path root is an impl, it should be printed as `<SelfType>` (for "
"inherent impls) or `<SelfType as Trait>` (for trait impls), like the "
"compiler does in error messages. The `<impl-path>` also contained in the AST "
"node should usually be omitted."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1070
msgid "The list of generic arguments should be demangled as `<T1, T2, T3>`."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1072
msgid ""
"Identifiers can have a numeric disambiguator (the `<disambiguator>` "
"production). The syntactic version of the numeric disambiguator maps to a "
"numeric index. If the disambiguator is not present, this index is 0. If it "
"is of the form `s_` then the index is 1. If it is of the form `s<base-62-"
"digit>_` then the index is `<base-62-digit> + 2`. The suggested demangling "
"of a disambiguator is `[<index>]`. However, for better readability, these "
"disambiguators should usually be omitted in the demangling altogether. "
"Disambiguators with index zero can _always_ be omitted."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1082
msgid ""
"The exception here are closures. Since these do not have a name, the "
"disambiguator is the only thing identifying them. The suggested demangling "
"for closures is thus `{closure}[<index>]`."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1086
msgid "Appendix B - Examples"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1088
msgid ""
"We assume that all examples are defined in a crate named `mycrate[1234]`."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1091
msgid "Free-standing Item"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1100
msgid "unmangled: `mycrate::foo::bar::baz`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1101
msgid "mangled: `_RNvNtNtCs1234_7mycrate3foo3bar3baz`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1104
msgid "Item Defined In Inherent Method"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1112
#: src/2603-rust-symbol-name-mangling-v0.md:1129
msgid "// ...\n"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1117
msgid "unmangled: `<mycrate::Foo<_>>::bar::QUUX`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1118
msgid "mangled: `_RNvNvMCs1234_7mycrateINtCs1234_7mycrate3FoopE3bar4QUUX`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1121
msgid "Item Defined In Trait Method"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1133
msgid "unmangled: `<mycrate::Foo<_> as std::clone::Clone>::clone::QUUX`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1134
msgid ""
"mangled: "
"`_RNvNvXCs1234_7mycrateINtCs1234_7mycrate3FoopENtNtC3std5clone5Clone5clone4QUUX`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1137
msgid "Item Defined In Initializer Of A Static"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1145
msgid "unmangled: `mycrate::QUUX::FOO`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1146
msgid "mangled: `_RNvNvCs1234_7mycrate4QUUX3FOO`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1149
msgid ""
"Compressed Prefix Constructed From Prefix That Contains A Substitution "
"Itself - TODO"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1150
msgid "unmangled: `mycrate::foo<mycrate::bar,mycrate::bar::baz>`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1151
msgid "mangled: `_RINvCs1234_7mycrate3fooNvB4_3barNvBn_3bazE`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1154
msgid "Progressive type compression"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1155
msgid "unmangled: `std::foo<(std::Bar,std::Bar),(std::Bar,std::Bar)>`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1156
msgid "mangled: `_RINxC3std3fooTNyB4_3BarBe_EBd_E`"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1159
msgid "Appendix C - Change LOG"
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1160
msgid "Removed mention of Itanium mangling in introduction."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1161
msgid "Weakened \"predictability\" goal."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1162
msgid "Removed non-goal of not providing a mangling for lifetimes."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1163
msgid "Added non-goal for not trying to standardize the demangled form."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1164
msgid "Updated specification and examples to new grammar as proposed by eddyb."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1165
msgid ""
"`impl` disambiguation strategy changed to using the impl path instead of "
"param bounds."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1166
msgid ""
"Updated prior art section to not say this RFC is an adaptation of Itanium "
"mangling."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1167
msgid ""
"Updated compiler's expected assignment of disambiguation indices and "
"namespace tags."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1168
msgid ""
"Removed \"complexity\" drawback since the scheme is not very complex anymore."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1169
msgid ""
"Removed unresolved question \"Re-use `<disambiguator>` for crate "
"disambiguator\"."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1170
msgid ""
"Added note about default generic arguments to reference-level-explanation."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1171
msgid "Added note about Punycode making decoding more complicated."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1172
msgid "Resolve question of complex constant data."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1173
msgid ""
"Add a recommended resolution for open question around Punycode identifiers."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1174
msgid ""
"Add a recommended resolution for open question around encoding function "
"parameter types."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1175
msgid "Allow identifiers to start with a digit."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1176
msgid "Make `<binder>` optional in `<fn-sig>` and `<dyn-bounds>` productions."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1177
msgid ""
"Extend `<const-data>` to include `bool` values, `char` values, and negative "
"integer values."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1178
msgid "Remove type from constant placeholders."
msgstr ""

#: src/2603-rust-symbol-name-mangling-v0.md:1179
msgid "Allow vendor-specific suffixes."
msgstr ""
