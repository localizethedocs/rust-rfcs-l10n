msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:04Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2195-really-tagged-unions.md:1
msgid "Feature Name: really_tagged_unions"
msgstr ""

#: src/2195-really-tagged-unions.md:2
msgid "Start Date: 2017-10-30"
msgstr ""

#: src/2195-really-tagged-unions.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2195](https://github.com/rust-lang/rfcs/pull/2195)"
msgstr ""

#: src/2195-really-tagged-unions.md:4
msgid "Rust Issue: N/A"
msgstr ""

#: src/2195-really-tagged-unions.md:6
msgid "Summary"
msgstr ""

#: src/2195-really-tagged-unions.md:9
msgid ""
"Formally define the enum `#[repr(u32, i8, etc..)]` and `#[repr(C)]` "
"attributes to force a non-C-like enum to have a defined layouts. This serves "
"two purposes: allowing low-level Rust code to independently initialize the "
"tag and payload, and allowing C(++) to safely manipulate these types."
msgstr ""

#: src/2195-really-tagged-unions.md:12
msgid "Motivation"
msgstr ""

#: src/2195-really-tagged-unions.md:15
msgid ""
"Enums that contain data are very good and useful. Unfortunately, their "
"layout is currently purposefully unspecified, which makes these kinds of "
"enums unusable for FFI and for low-level code. To demonstrate this, this RFC "
"will look at two examples from firefox development where this has been a "
"problem."
msgstr ""

#: src/2195-really-tagged-unions.md:19
msgid "C(++) FFI"
msgstr ""

#: src/2195-really-tagged-unions.md:22
msgid ""
"Consider a native Rust API for drawing a line, that uses a C-like LineStyle "
"enum:"
msgstr ""

#: src/2195-really-tagged-unions.md:25
msgid "// In native Rust crate\n"
msgstr ""

#: src/2195-really-tagged-unions.md:46
msgid ""
"This API is fairly easy for us to write a machine-checked shim for C++ code "
"to invoke:"
msgstr ""

#: src/2195-really-tagged-unions.md:49
msgid "// In Rust shim crate\n"
msgstr ""

#: src/2195-really-tagged-unions.md:52 src/2195-really-tagged-unions.md:67
msgid "\"C\""
msgstr ""

#: src/2195-really-tagged-unions.md:63
msgid "// In C++ shim header\n"
msgstr ""

#: src/2195-really-tagged-unions.md:65
msgid "// Autogenerated by cbindgen\n"
msgstr ""

#: src/2195-really-tagged-unions.md:69
msgid "// opaque\n"
msgstr ""

#: src/2195-really-tagged-unions.md:84
msgid "// namespace wr\n"
msgstr ""

#: src/2195-really-tagged-unions.md:85
msgid "// extern\n"
msgstr ""

#: src/2195-really-tagged-unions.md:88
msgid "// Hand-written\n"
msgstr ""

#: src/2195-really-tagged-unions.md:101
msgid "This works well, and we're happy."
msgstr ""

#: src/2195-really-tagged-unions.md:103
msgid ""
"Now consider adding a WavyLine style, which requires an extra thickness "
"value:"
msgstr ""

#: src/2195-really-tagged-unions.md:106 src/2195-really-tagged-unions.md:122
msgid "// Native Rust crate\n"
msgstr ""

#: src/2195-really-tagged-unions.md:108
msgid "// Doesn't actually do anything we can rely on now\n"
msgstr ""

#: src/2195-really-tagged-unions.md:117
msgid ""
"We cannot safely pass this to/from C(++), nor can we manipulate it there. As "
"such, we're forced to take the thickness as an extra argument that is just "
"ignored most of the time:"
msgstr ""

#: src/2195-really-tagged-unions.md:141
msgid ""
"This produces a worse API for everyone, while also throwing away the type-"
"safety benefits of enums. This trick also doesn't scale: if you have many "
"nested enums, the combinatorics eventually become completely intractable."
msgstr ""

#: src/2195-really-tagged-unions.md:145
msgid "In-Place Construction"
msgstr ""

#: src/2195-really-tagged-unions.md:147
msgid ""
"Popular deserialization APIs in Rust generally have a signature like "
"`deserialize<T>() -> Result<T, Error>`. This works well for small values, "
"but optimizes very poorly for large values, as Rust ends up copying the `T` "
"many times. Further, in many cases we just want to overwrite an old value "
"that we no longer care about."
msgstr ""

#: src/2195-really-tagged-unions.md:149
msgid ""
"In those cases, we could potentially use an API like "
"`deserialize_from<T>(&mut T) -> Result<(), Error>`. However Rust currently "
"requires enums to be constructed \"atomically\", so we can't actually take "
"advantage of this API if our large value is an enum."
msgstr ""

#: src/2195-really-tagged-unions.md:151
msgid "That is, we must do something like:"
msgstr ""

#: src/2195-really-tagged-unions.md:167
msgid ""
"We must construct the entire payload out-of-place, and then move it into "
"place at the end, even though our API is specifically designed to let us "
"construct in-place."
msgstr ""

#: src/2195-really-tagged-unions.md:169
msgid ""
"Now, this is pretty important for memory-safety in the _general_ case, but "
"there are many cases where this can be done safely. For instance, this is "
"safe to do if the entire payload is plain-old-data, like `[u8; 200]`, or if "
"the code catches panics and fixes up the value."
msgstr ""

#: src/2195-really-tagged-unions.md:171
msgid "Note that one cannot do something like:"
msgstr ""

#: src/2195-really-tagged-unions.md:180
msgid ""
"because enum optimizations make it unsound to put `mem::uninitialized` in an "
"enum. That is, checking if `dest = A` can require inspecting the payload."
msgstr ""

#: src/2195-really-tagged-unions.md:182
msgid "To accomplish this task, we need dedicated support from the language."
msgstr ""

#: src/2195-really-tagged-unions.md:188
msgid "Guide-level explanation"
msgstr ""

#: src/2195-really-tagged-unions.md:191
msgid ""
"An enum can currently be adorned with `#[repr(Int)]` where `Int` is one of "
"Rust's integer types (u8, isize, etc). For C-like enums -- enums which have "
"no variants with associated data -- this specifies that the enum should have "
"the ABI of that integer type (size, alignment, and calling convention). "
"`#[repr(C)]` currently just tells Rust to try to pick whatever integer type "
"that a C compiler for the target platform would use for an enum."
msgstr ""

#: src/2195-really-tagged-unions.md:193
msgid ""
"With this RFC, two new guaranteed, C(++)-compatible enum layouts will be "
"added."
msgstr ""

#: src/2195-really-tagged-unions.md:195
msgid ""
"`#[repr(Int)]` on a non-C-like enum will now mean: the enum must be "
"represented as a C-union of C-structs that each start with a C-like enum "
"with `#[repr(Int)]`. The other fields of the structs are the payloads of the "
"variants. This is a mouthful, so let's look at an example. This definition:"
msgstr ""

#: src/2195-really-tagged-unions.md:207 src/2195-really-tagged-unions.md:317
msgid "Has the same layout as the following:"
msgstr ""

#: src/2195-really-tagged-unions.md:234
msgid ""
"Note that the structs must be `repr(C)`, because otherwise the MyEnumTag "
"value wouldn't be guaranteed to have the same position in each variant."
msgstr ""

#: src/2195-really-tagged-unions.md:236 src/2195-really-tagged-unions.md:344
msgid ""
"C++ can also correctly manipulate this enum with the following definition:"
msgstr ""

#: src/2195-really-tagged-unions.md:239 src/2195-really-tagged-unions.md:347
msgid "<stdint.h>"
msgstr ""

#: src/2195-really-tagged-unions.md:255
msgid ""
"The correct C definition is essentially the same, but with the `enum class` "
"replaced with a plain integer of the appropriate type."
msgstr ""

#: src/2195-really-tagged-unions.md:257
msgid ""
"This layout might be a bit surprising to those used to using tagged unions "
"in C(++), which are commonly represented as a `(tag, union)` pair. There are "
"two reasons to prefer this more complex layout. First, it's what Rust has "
"incidentally used this layout for a long time, so code that wants to begin "
"relying on this layout will be compatible with old versions of Rust. Second, "
"it can make slightly better use of space. For instance:"
msgstr ""

#: src/2195-really-tagged-unions.md:268
msgid "Becomes"
msgstr ""

#: src/2195-really-tagged-unions.md:286
msgid ""
"Which ends up being 4 bytes large, because the TwoCasesVariantA struct can "
"be laid out like:"
msgstr ""

#: src/2195-really-tagged-unions.md:293
msgid "While a (tag, union) pair would have to make it 6 bytes large:"
msgstr ""

#: src/2195-really-tagged-unions.md:303
msgid ""
"However, for better compatibility with common C(++) idioms, and better "
"ergonomics for low-level Rust programs, this RFC defines `#[repr(C, Int)]` "
"on a tagged enum to specify the `(tag, union)` representation. Specifically "
"the layout will be equivalent to a C-struct containing a C-like "
"`#[repr(Int)]` enum followed by a C-union containing each payload."
msgstr ""

#: src/2195-really-tagged-unions.md:305
msgid "So for example this enum:"
msgstr ""

#: src/2195-really-tagged-unions.md:365
msgid ""
"If a non-C-like enum is _only_ `#[repr(C)]`, then the layout will be the "
"same as `#[repr(C, Int)]`, but the C-like tag enum will instead just be "
"`#[repr(C)]` (so it will have whatever size C enums default to)."
msgstr ""

#: src/2195-really-tagged-unions.md:367
msgid ""
"For both layouts, it is defined for Rust programs to cast/reinterpret/"
"transmute such an enum into the equivalent Repr definition. Separately "
"manipulating the tag and payload is also defined. The tag and payload need "
"only be in a consistent/initialized state when the value is matched on "
"(which includes Dropping it)."
msgstr ""

#: src/2195-really-tagged-unions.md:369
msgid "For instance, this code is valid (using the same definitions above):"
msgstr ""

#: src/2195-really-tagged-unions.md:372
msgid ""
"/// Tries to parse a `#[repr(C, u8)] MyEnum` from a custom binary format, "
"overwriting `dest`.\n"
"/// On Err, `dest` may be partially overwritten (but will be in a memory-"
"safe state)\n"
msgstr ""

#: src/2195-really-tagged-unions.md:376
msgid "// Convert to raw repr\n"
msgstr ""

#: src/2195-really-tagged-unions.md:379
msgid ""
"// If MyEnum was non-trivial, we might match on the tag and \n"
"        // drop_in_place the payload here to start.\n"
msgstr ""

#: src/2195-really-tagged-unions.md:382
msgid "// Read the tag\n"
msgstr ""

#: src/2195-really-tagged-unions.md:383
msgid "\"Couldn't Read Tag\""
msgstr ""

#: src/2195-really-tagged-unions.md:389
msgid "\"Invalid Tag Value\""
msgstr ""

#: src/2195-really-tagged-unions.md:393
msgid ""
"// Note: it would be very bad if we panicked past this point, or if\n"
"        // the following methods didn't initialize the payload on Err!\n"
msgstr ""

#: src/2195-really-tagged-unions.md:396
msgid "// Read the payload\n"
msgstr ""

#: src/2195-really-tagged-unions.md:401
msgid "/* do nothing */"
msgstr ""

#: src/2195-really-tagged-unions.md:408
msgid ""
"It should be noted that Rust enums should still idiomatically not have any "
"repr annotation, as this allows for maximum optimization opportunities and "
"the precise layout is unlikely to matter. If a deterministic layout is "
"required, `repr(Int)` should be preferred by default over `repr(C, Int)` as "
"it has a strictly superior space-usage, and incidentally works in older "
"versions of Rust. However `repr(C, Int)` is a reasonable choice for a more "
"idiomatic-feeling tagged union, or to interoperate with an existing C(++) "
"codebase."
msgstr ""

#: src/2195-really-tagged-unions.md:410
msgid ""
"There are a few enum repr combinations that are left unspecified under this "
"proposal, and thus produce compiler warnings:"
msgstr ""

#: src/2195-really-tagged-unions.md:412
msgid "repr(Int1, Int2)"
msgstr ""

#: src/2195-really-tagged-unions.md:413
msgid "repr(C, Int) on C-like enums"
msgstr ""

#: src/2195-really-tagged-unions.md:414
msgid "repr(C) on a zero-variant enum"
msgstr ""

#: src/2195-really-tagged-unions.md:415
msgid "repr(Int) on a zero-variant enum"
msgstr ""

#: src/2195-really-tagged-unions.md:416
msgid "repr(packed) on an enum"
msgstr ""

#: src/2195-really-tagged-unions.md:417
msgid "repr(simd) on an enum"
msgstr ""

#: src/2195-really-tagged-unions.md:420
msgid "Reference-level explanation"
msgstr ""

#: src/2195-really-tagged-unions.md:423
msgid ""
"Since the whole point of this proposal is to enable low-level control, the "
"guide-level explanation should cover all the relevant corner-cases and "
"details in sufficient detail. All that remains is to discuss implementation "
"details."
msgstr ""

#: src/2195-really-tagged-unions.md:425
msgid ""
"It was [informally decided earlier this year](https://github.com/rust-lang/"
"rust/issues/40029) that `repr(Int)`should have the behaviour this RFC "
"proposes, as it was being partially relied on (in that it suppressed "
"dangerous optimizations) and it made sense to the developers. There is even "
"a test in the rust-lang repo that was added to ensure that this behaviour "
"doesn't regress. So this part of the proposal is already implemented and "
"somewhat tested on stable Rust. This RFC just seeks to codify that this "
"won't break in the future."
msgstr ""

#: src/2195-really-tagged-unions.md:427
msgid ""
"However `repr(C, Int)` currently doesn't do anything different from "
"`repr(Int)`. Changing this is a relatively minor tweak to the code that "
"lowers Rust code to a particular ABI. Anyone relying on `repr(C, Int)` being "
"the same as `repr(Int)` is relying on unspecified behaviour, but a cargo "
"bomb run should still be done just to check."
msgstr ""

#: src/2195-really-tagged-unions.md:429
msgid ""
"A PR [has been submitted](https://github.com/rust-lang/rust/pull/46123) to "
"implement this, along with several tests."
msgstr ""

#: src/2195-really-tagged-unions.md:432
msgid "Drawbacks"
msgstr ""

#: src/2195-really-tagged-unions.md:435
msgid ""
"Half of this proposal is already implemented, and the other half has an "
"implementation submitted (~20 line patch). The existence of this proposal "
"can also be completely ignored by anyone who doesn't care about it, as they "
"can keep using the default Rust repr. This is simply making things that "
"exist sort-of-by-accident do something useful, which is basically a pure win "
"considering the implementation/maintenance burden is minimal."
msgstr ""

#: src/2195-really-tagged-unions.md:437
msgid ""
"One minor issue with this proposal is that there's no way to request the "
"`repr(Int)` layout with the `repr(C)` tag size. To be blunt, this doesn't "
"seem very important. It's unclear if developers should even use bare "
"`repr(C)` on tagged unions, as the default C enum size is actually quite "
"large for a tag. This is also consistent with the Rust philosophy of trying "
"to minimize unnecessary platform-specific details. Also, a desperate Rust "
"programmer could acquire the desired behaviour with platform-specific cfgs "
"(Rust has to basically guess at the type of a `repr(C)` enum anyway)."
msgstr ""

#: src/2195-really-tagged-unions.md:439
msgid ""
"The remaining drawbacks amount to \"what if this is the _wrong_ "
"interpretation\", which shall be addressed in the alternatives."
msgstr ""

#: src/2195-really-tagged-unions.md:442
msgid "Rationale and alternatives"
msgstr ""

#: src/2195-really-tagged-unions.md:445
msgid ""
"There are a few alternative interpretations of `repr(Int)` on a non-C-like "
"enum."
msgstr ""

#: src/2195-really-tagged-unions.md:449
msgid "It should do nothing"
msgstr ""

#: src/2195-really-tagged-unions.md:451
msgid ""
"In which case it should probably become an error/warning. This isn't "
"particularly desirable, as was discussed [when we decided to maintain this "
"behaviour](https://github.com/rust-lang/rust/issues/40029)."
msgstr ""

#: src/2195-really-tagged-unions.md:455
msgid ""
"The tag should come after the union, and/or order should be manually "
"specified"
msgstr ""

#: src/2195-really-tagged-unions.md:457
msgid ""
"With the `repr(C)` layout, there isn't a particularly compelling reason to "
"move the tag around because of how padding and alignment are handled: you "
"can't actually save space by putting the tag after, as long as your tag is a "
"reasonable size."
msgstr ""

#: src/2195-really-tagged-unions.md:459
msgid ""
"It's possible positioning the tag afterwards could be desirable to "
"interoperate with a definition that is provided by a third party (hardware "
"spec or some existing C library). However there are tons of other tag "
"packing strategies that we also can't handle, so we'd probably want a more "
"robust solution for those kinds of cases anyway."
msgstr ""

#: src/2195-really-tagged-unions.md:461
msgid ""
"With the `repr(Int)` layout, this could potentially save space (for "
"instance, with a variant like `A(u16, u8)`). However the benefits are "
"relatively minimal compared to the increased complexity. If that complexity "
"is desirable, it can be addressed with a future extension."
msgstr ""

#: src/2195-really-tagged-unions.md:465
msgid "Compound variants shouldn't automatically be marked as `repr(C)`"
msgstr ""

#: src/2195-really-tagged-unions.md:467
msgid ""
"With the `repr(Int)` layout this isn't really possible, because the tag "
"needs a deterministic position, and we can't \"partially\" `repr(C)` a "
"struct."
msgstr ""

#: src/2195-really-tagged-unions.md:469
msgid ""
"With either layout, one can make the payload be a single repr(Rust) struct, "
"and that will have its layout aggressively optimized, because `repr(C)` "
"isn't infectious. So this is just a matter of \"what is a good default\". "
"The FFI case clearly wants fully defined layouts, while the pure-Rust case "
"seems like a toss up. It seems like `repr(C)` is therefore the better "
"default."
msgstr ""

#: src/2195-really-tagged-unions.md:472
msgid "Opaque Tags"
msgstr ""

#: src/2195-really-tagged-unions.md:474
msgid "This code isn't valid under the main proposal:"
msgstr ""

#: src/2195-really-tagged-unions.md:483
msgid ""
"It relies on the fact that the Some-ness of an Option (or the tag of any "
"`repr(Rust)` enum) can't rely on the tag of a `repr(C/Int)` enum. Or in "
"other words, `repr(C/Int)` enums have opaque tags. The cost of making this "
"work is that `Option<MyEnum>` would have to be larger than `MyEnum`."
msgstr ""

#: src/2195-really-tagged-unions.md:485
msgid ""
"It would be _nice_ for this to work, but if you really need it, you can just "
"define `#[repr(u8)] COption<T> { ... }` and use that."
msgstr ""

#: src/2195-really-tagged-unions.md:491
msgid "Unresolved questions"
msgstr ""

#: src/2195-really-tagged-unions.md:494
msgid "Currently None. ðŸŽ‰"
msgstr ""

#: src/2195-really-tagged-unions.md:498
msgid "Future Extensions"
msgstr ""

#: src/2195-really-tagged-unions.md:500
msgid ""
"Here's some quick sketches of future extensions which could be done to this "
"design."
msgstr ""

#: src/2195-really-tagged-unions.md:502
msgid "A field/method for the tag/payload (my_enum.tag, my_enum.payload)"
msgstr ""

#: src/2195-really-tagged-unions.md:503
msgid "Probably should be a field to avoid conflicts with user-defined methods"
msgstr ""

#: src/2195-really-tagged-unions.md:504
msgid "Might need `#[repr(pub(Int))]` for API design reasons"
msgstr ""

#: src/2195-really-tagged-unions.md:505
msgid "Compiler-generated definitions for the Repr types"
msgstr ""

#: src/2195-really-tagged-unions.md:506
msgid ""
"With inherent type aliases on the enum? (`MyEnum::Tag`, `MyEnum::Payload`, "
"`MyEnum::PayloadA`, etc.)"
msgstr ""

#: src/2195-really-tagged-unions.md:507
msgid ""
"As discussed in previous sections, more advanced tag placement strategies?"
msgstr ""

#: src/2195-really-tagged-unions.md:508
msgid ""
"Allow specifying tag's value: `#[repr(u32)] MyEnum { A(u32) = 2, B = 5 }`"
msgstr ""
