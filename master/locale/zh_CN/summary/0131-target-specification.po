msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0131-target-specification.md:1
msgid "Start Date: 2014-06-18"
msgstr ""

#: src/0131-target-specification.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#131](https://github.com/rust-lang/rfcs/pull/131)"
msgstr ""

#: src/0131-target-specification.md:3
msgid ""
"Rust Issue: [rust-lang/rust#16093](https://github.com/rust-lang/rust/"
"issues/16093)"
msgstr ""

#: src/0131-target-specification.md:5
msgid "Summary"
msgstr ""

#: src/0131-target-specification.md:7
msgid ""
"_Note:_ This RFC discusses the behavior of `rustc`, and not any changes to "
"the language."
msgstr ""

#: src/0131-target-specification.md:10
msgid ""
"Change how target specification is done to be more flexible for unexpected "
"usecases. Additionally, add support for the \"unknown\" OS in target "
"triples, providing a minimum set of target specifications that is valid for "
"bare-metal situations."
msgstr ""

#: src/0131-target-specification.md:15
msgid "Motivation"
msgstr ""

#: src/0131-target-specification.md:17
msgid ""
"One of Rust's important use cases is embedded, OS, or otherwise \"bare "
"metal\" software. At the moment, we still depend on LLVM's split-stack "
"prologue for stack safety. In certain situations, it is impossible or "
"undesirable to support what LLVM requires to enable this (on x86, a certain "
"thread-local storage setup). Additionally, porting `rustc` to a new platform "
"requires modifying the compiler, adding a new OS manually."
msgstr ""

#: src/0131-target-specification.md:24
msgid "Detailed design"
msgstr ""

#: src/0131-target-specification.md:26
msgid ""
"A target triple consists of three strings separated by a hyphen, with a "
"possible fourth string at the end preceded by a hyphen. The first is the "
"architecture, the second is the \"vendor\", the third is the OS type, and "
"the optional fourth is environment type. In theory, this specifies precisely "
"what platform the generated binary will be able to run on. All of this is "
"determined not by us but by LLVM and other tools. When on bare metal or a "
"similar environment, there essentially is no OS, and to handle this there is "
"the concept of \"unknown\" in the target triple.  When the OS is "
"\"unknown\", no runtime environment is assumed to be present (including "
"things such as dynamic linking, threads/thread-local storage, IO, etc)."
msgstr ""

#: src/0131-target-specification.md:37
msgid ""
"Rather than listing specific targets for special treatment, introduce a "
"general mechanism for specifying certain characteristics of a target triple. "
"Redesign how targets are handled around this specification, including for "
"the built-in targets. Extend the `--target` flag to accept a file name of a "
"target specification. A table of the target specification flags and their "
"meaning:"
msgstr ""

#: src/0131-target-specification.md:43
msgid ""
"`data-layout`: The [LLVM data layout](http://llvm.org/docs/LangRef.html#data-"
"layout) to use. Mostly included for completeness; changing this is unlikely "
"to be used."
msgstr ""

#: src/0131-target-specification.md:46
msgid "`link-args`: Arguments to pass to the linker, unconditionally."
msgstr ""

#: src/0131-target-specification.md:47
msgid ""
"`cpu`: Default CPU to use for the target, overridable with `-C target-cpu`"
msgstr ""

#: src/0131-target-specification.md:48
msgid ""
"`features`: Default target features to enable, augmentable with `-C target-"
"features`."
msgstr ""

#: src/0131-target-specification.md:50
msgid "`dynamic-linking-available`: Whether the `dylib` crate type is allowed."
msgstr ""

#: src/0131-target-specification.md:51
msgid ""
"`split-stacks-supported`: Whether there is runtime support that will allow "
"LLVM's split stack prologue to function as intended."
msgstr ""

#: src/0131-target-specification.md:53
msgid "`llvm-target`: What target to pass to LLVM."
msgstr ""

#: src/0131-target-specification.md:54
msgid "`relocation-model`: What relocation model to use by default."
msgstr ""

#: src/0131-target-specification.md:55
msgid ""
"`target_endian`, `target_word_size`: Specify the strings used for the "
"corresponding `cfg` variables."
msgstr ""

#: src/0131-target-specification.md:57
msgid ""
"`code-model`: Code model to pass to LLVM, overridable with `-C code-model`."
msgstr ""

#: src/0131-target-specification.md:58
msgid ""
"`no-redzone`: Disable use of any stack redzone, overridable with `-C no-"
"redzone`"
msgstr ""

#: src/0131-target-specification.md:61
msgid ""
"Rather than hardcoding a specific set of behaviors per-target, with no "
"recourse for escaping them, the compiler would also use this mechanism when "
"deciding how to build for a given target. The process would look like:"
msgstr ""

#: src/0131-target-specification.md:65
msgid ""
"Look up the target triple in an internal map, and load that configuration if "
"it exists. If that fails, check if the target name exists as a file, and try "
"loading that. If the file does not exist, look up `<target>.json` in the "
"`RUST_TARGET_PATH`, which is a colon-separated list of directories."
msgstr ""

#: src/0131-target-specification.md:69
msgid ""
"If `-C linker` is specified, use that instead of the target-specified linker."
msgstr ""

#: src/0131-target-specification.md:71
msgid ""
"If `-C link-args` is given, add those to the ones specified by the target."
msgstr ""

#: src/0131-target-specification.md:72
msgid "If `-C target-cpu` is specified, replace the target `cpu` with it."
msgstr ""

#: src/0131-target-specification.md:73
msgid ""
"If `-C target-feature` is specified, add those to the ones specified by the "
"target."
msgstr ""

#: src/0131-target-specification.md:75
msgid ""
"If `-C relocation-model` is specified, replace the target `relocation-model` "
"with it."
msgstr ""

#: src/0131-target-specification.md:77
msgid ""
"If `-C code-model` is specified, replace the target `code-model` with it."
msgstr ""

#: src/0131-target-specification.md:78
msgid ""
"If `-C no-redzone` is specified, replace the target `no-redzone` with true."
msgstr ""

#: src/0131-target-specification.md:81
msgid ""
"Then during compilation, this information is used at the proper places "
"rather than matching against an enum listing the OSes we recognize. The "
"`target_os`, `target_family`, and `target_arch` `cfg` variables would be "
"extracted from the `--target` passed to rustc."
msgstr ""

#: src/0131-target-specification.md:86
msgid "Drawbacks"
msgstr ""

#: src/0131-target-specification.md:88
msgid ""
"More complexity. However, this is very flexible and allows one to use Rust "
"on a new or non-standard target _incredibly easy_, without having to modify "
"the compiler. rustc is the only compiler I know of that would allow that."
msgstr ""

#: src/0131-target-specification.md:92
msgid "Alternatives"
msgstr ""

#: src/0131-target-specification.md:94
msgid ""
"A less holistic approach would be to just allow disabling split stacks on a "
"per-crate basis. Another solution could be adding a family of targets, "
"`<arch>-unknown-unknown`, which omits all of the above complexity but does "
"not allow extending to new targets easily."
msgstr ""
