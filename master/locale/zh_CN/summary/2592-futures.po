msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:05Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2592-futures.md:1
msgid "Feature Name: `futures_api`"
msgstr ""

#: src/2592-futures.md:2
msgid "Start Date: 2018-11-09"
msgstr ""

#: src/2592-futures.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2592](https://github.com/rust-lang/rfcs/pull/2592)"
msgstr ""

#: src/2592-futures.md:4
msgid ""
"Rust Issue: [rust-lang/rust#59113](https://github.com/rust-lang/rust/"
"issues/59113)"
msgstr ""

#: src/2592-futures.md:6
msgid "Summary"
msgstr ""

#: src/2592-futures.md:9
msgid ""
"This RFC proposes to stabilize the library component for the [first-class "
"`async`/`await` syntax](https://github.com/rust-lang/rfcs/pull/2394). In "
"particular, it would stabilize:"
msgstr ""

#: src/2592-futures.md:12
msgid "All APIs of the `std`\\-level task system, i.e. `std::task::*`."
msgstr ""

#: src/2592-futures.md:13
msgid ""
"The core `Future` API, i.e. `core::future::Future` and `std::future::Future`."
msgstr ""

#: src/2592-futures.md:15
msgid ""
"It does _not_ propose to stabilize any of the `async`/`await` syntax itself, "
"which will be proposed in a separate step. It also does not cover "
"stabilization of the `Pin` APIs, which has [already been proposed elsewhere]"
"(https://github.com/rust-lang/rust/issues/55766)."
msgstr ""

#: src/2592-futures.md:17
msgid ""
"This is a revised and slimmed down version of the [earlier futures RFC]"
"(https://github.com/rust-lang/rfcs/pull/2418), which was postponed until "
"more experience was gained on nightly."
msgstr ""

#: src/2592-futures.md:22
msgid "Motivation"
msgstr ""

#: src/2592-futures.md:25
msgid "Why `Future`s in `std`?"
msgstr ""

#: src/2592-futures.md:27
msgid ""
"The core motivation for this RFC is to stabilize the supporting mechanisms "
"for `async`/`await` syntax.  The syntax itself is motivated in the (already "
"merged) [companion RFC](https://github.com/rust-lang/rfcs/pull/2394), and "
"there is a [blog post](https://aturon.github.io/tech/2018/04/24/async-"
"borrowing/) that goes through its importance in greater detail."
msgstr ""

#: src/2592-futures.md:32
msgid ""
"As with closures, `async` syntax involves producing an anonymous type that "
"implements a key trait: `Future`. Because `async`/`await` requires language-"
"level support, the underlying trait must also be part of the standard "
"library. Thus, the goal of this RFC is to stabilize this `Future` trait and "
"the types it depends on. This is the last step needed before we are in a "
"position to stabilize `async`/`await` itself."
msgstr ""

#: src/2592-futures.md:39
msgid "How does this step fit into the bigger picture?"
msgstr ""

#: src/2592-futures.md:41
msgid ""
"The `async`/`await` syntax is one of the most eagerly desired features in "
"Rust, and will have a major impact on the ecosystem. It, and the APIs "
"described here, have been available on nightly and put into major use since "
"late May 2018."
msgstr ""

#: src/2592-futures.md:45
msgid ""
"Stabilizing the futures API portion of this design makes it easier for "
"libraries to both work on stable Rust _and_ to seamlessly support use of "
"`async`/`await` on nightly. It also allows us to finalize design debate on "
"the API portion, and focus on the few remaining questions about `async` "
"syntax before it, too, is stabilized."
msgstr ""

#: src/2592-futures.md:50
msgid "Historical context"
msgstr ""

#: src/2592-futures.md:52
msgid "The APIs proposed for stabilization have a lengthy history:"
msgstr ""

#: src/2592-futures.md:54
msgid ""
"The `Future` trait began with the futures crate; [0.1 was released](https://"
"aturon.github.io/tech/2016/08/11/futures/) in August of 2016. That release "
"established the core ideas of the task/polling model, as well as many other "
"aspects of the API that are retained here. The 0.1 series continues to be "
"heavily used throughout the Rust ecosystem and in production systems."
msgstr ""

#: src/2592-futures.md:59
msgid ""
"In early 2018, as work began toward `async`/`await`, the futures team set up "
"an RFC process and wrote [several RFCs](https://github.com/rust-lang-nursery/"
"futures-rfcs/pulls?q=is%3Apr+is%3Aclosed) to make revisions to the core APIs "
"based on longstanding community feedback. These RFCs ultimately resulted in "
"a [0.2le release](https://aturon.github.io/tech/2018/02/27/futures-0-2-RC/), "
"which [shipped](https://aturon.github.io/tech/2018/04/06/futures2/) in April."
msgstr ""

#: src/2592-futures.md:63
msgid ""
"During the same period, @withoutboats's work on the pinning APIs supporting "
"borrowing within `async` blocks [came to completion](https://boats.gitlab.io/"
"blog/post/2018-04-06-async-await-final/). The [pinning APIs](https://github."
"com/rust-lang/rfcs/pull/2349) were a game-changer, making it possible to "
"support borrowing-across-yield _without_ making the core future APIs unsafe."
msgstr ""

#: src/2592-futures.md:67
msgid ""
"In April 2018, a pair of RFCs formally proposed the `async`/`await` syntax "
"as well as further revision of the futures API (to take advantage of the "
"pinning APIs); the latter went through many revisions, including a [fresh "
"RFC](https://github.com/rust-lang/rfcs/pull/2418). Ultimately, the [syntax "
"RFC was merged](https://github.com/rust-lang/rfcs/"
"pull/2394#issuecomment-387550523) in May, while the API RFC was closed, with "
"[the understanding](https://github.com/rust-lang/rfcs/"
"pull/2418#issuecomment-415841459) that further design iteration would occur "
"on nightly, to be followed up by a stabilization RFC: this one!"
msgstr ""

#: src/2592-futures.md:69
msgid ""
"The APIs [landed in `std`](https://github.com/rust-lang/rust/pull/51263) at "
"the end of May."
msgstr ""

#: src/2592-futures.md:71
msgid ""
"Since then, the syntax, the `std` APIs, and the futures 0.3 crate have all "
"evolved in tandem as we've gained experience with the APIs. A major driver "
"in this experience has been Google's Fuchsia project, which is using _all_ "
"of these features at large scale in an operating system setting."
msgstr ""

#: src/2592-futures.md:73
msgid ""
"The most recent revisions were in August, and involved [some insights]"
"(https://boats.gitlab.io/blog/post/rethinking-pin/) into how to make the "
"`Pin` APIs even cleaner. These APIs have been [proposed for stabilization]"
"(https://github.com/rust-lang/rust/issues/55766), as has [their use as "
"`self` types](https://github.com/rust-lang/rust/issues/55786)."
msgstr ""

#: src/2592-futures.md:75
msgid ""
"There are multiple compatibility layers available for using futures 0.1 and "
"0.3 simultaneously. That's important, because it allows for _incremental_ "
"migration of existing production code."
msgstr ""

#: src/2592-futures.md:77
msgid ""
"Since the initial futures 0.3 release, relatively little has changed about "
"the core `Future` trait and task system, other than the refinements "
"mentioned above. The actual `Future` trait has stayed essentially as it was "
"back in April."
msgstr ""

#: src/2592-futures.md:79
msgid "Guide-level explanation"
msgstr ""

#: src/2592-futures.md:82
msgid ""
"The `Future` trait represents an _asynchronous_ and lazy computation that "
"may eventually produce a final value, but doesn't have to block the current "
"thread to do so."
msgstr ""

#: src/2592-futures.md:86
msgid ""
"Futures can be constructed through `async` blocks or `async` functions, e.g.,"
msgstr ""

#: src/2592-futures.md:92
msgid ""
"This `async` function, when invoked, produces a future that represents the "
"completion of reading a frame from the given socket. The function signature "
"is equivalent to:"
msgstr ""

#: src/2592-futures.md:101
msgid ""
"Other async functions can _await_ this future; see the [companion RFC]"
"(https://github.com/rust-lang/rfcs/pull/2394) for full details."
msgstr ""

#: src/2592-futures.md:104
msgid ""
"In addition to `async fn` definitions, futures can be built using adapters, "
"much like with `Iterator`s. Initially these adapters will be provided "
"entirely \"out of tree\", but eventually they will make their way into the "
"standard library."
msgstr ""

#: src/2592-futures.md:108
msgid ""
"Ultimately asynchronous computations are executed in the form of _tasks_, "
"which are comparable to lightweight threads. _executor_s provide the ability "
"to create tasks from `()`\\-producing `Future`s. The executor will pin the "
"`Future` and `poll` it until completion inside the task that it creates for "
"it."
msgstr ""

#: src/2592-futures.md:113
msgid ""
"The implementation of an executor schedules the tasks it owns in a "
"cooperative fashion. It is up to the implementation of an executor whether "
"one or more operation system threads are used for this, as well as how many "
"tasks can be spawned on it in parallel. Some executor implementations may "
"only be able to drive a single `Future` to completion, while others can "
"provide the ability to dynamically accept new `Future`s that are driven to "
"completion inside tasks."
msgstr ""

#: src/2592-futures.md:120
msgid ""
"This RFC does not include any definition of an executor. It merely defines "
"the interaction between executors, tasks and `Future`s, in the form of APIs "
"that allow tasks to request getting scheduled again. The `task` module "
"provides these APIs, which are required when manually implementing `Future`s "
"or executors."
msgstr ""

#: src/2592-futures.md:126
msgid "Reference-level explanation"
msgstr ""

#: src/2592-futures.md:129
msgid "`core::task` module"
msgstr ""

#: src/2592-futures.md:131
msgid ""
"The fundamental mechanism for asynchronous computation in Rust is _tasks_, "
"which are lightweight threads of execution; many tasks can be cooperatively "
"scheduled onto a single operating system thread."
msgstr ""

#: src/2592-futures.md:135
msgid ""
"To perform this cooperative scheduling we use a technique sometimes referred "
"to as a \"trampoline\". When a task would otherwise need to block waiting "
"for some event, instead it saves an object that allows it to get scheduled "
"again later and _returns_ to the executor running it, which can then run "
"another task. Subsequent wakeups place the task back on the executors queue "
"of ready tasks, much like a thread scheduler in an operating system."
msgstr ""

#: src/2592-futures.md:142
msgid ""
"Attempting to complete a task (or async value within it) is called "
"_polling_, and always yields a `Poll` value back:"
msgstr ""

#: src/2592-futures.md:146
msgid ""
"/// Indicates whether a value is available, or if the current task has been\n"
"/// scheduled for later wake-up instead.\n"
msgstr ""

#: src/2592-futures.md:150
msgid "/// Represents that a value is immediately ready.\n"
msgstr ""

#: src/2592-futures.md:153
msgid ""
"/// Represents that a value is not ready yet.\n"
"    ///\n"
"    /// When a function returns `Pending`, the function *must* also\n"
"    /// ensure that the current task is scheduled to be awoken when\n"
"    /// progress can be made.\n"
msgstr ""

#: src/2592-futures.md:162
msgid ""
"When a task returns `Poll::Ready`, the executor knows the task has completed "
"and can be dropped."
msgstr ""

#: src/2592-futures.md:165
msgid "Waking up"
msgstr ""

#: src/2592-futures.md:167
msgid ""
"If a future cannot be directly fulfilled during execution and returns "
"`Pending`, it needs a way to later on inform the executor that it needs to "
"get polled again to make progress."
msgstr ""

#: src/2592-futures.md:171
msgid "This functionality is provided through a set of `Waker` types."
msgstr ""

#: src/2592-futures.md:173
msgid ""
"`Waker`s are objects which are passed as a parameter to the `Future::poll` "
"call, and which can be stored by the implementation of those `Futures`s. "
"Whenever a `Future` has the need to get polled again, it can use the `wake` "
"method of the waker in order to inform the executor that the task which owns "
"the `Future` should get scheduled and executed again."
msgstr ""

#: src/2592-futures.md:179
msgid ""
"The RFC defines a concrete `Waker` type with which implementors of `Futures` "
"and asynchronous functions will interact. This type defines a `wake(&self)` "
"method which is used to schedule the task that is associated to the `Waker` "
"to be polled again."
msgstr ""

#: src/2592-futures.md:184
msgid ""
"The mechanism through which tasks get scheduled again depends on the "
"executor which is driving the task. Possible ways of waking up an executor "
"include:"
msgstr ""

#: src/2592-futures.md:187
msgid ""
"If the executor is blocked on a condition variable, the condition variable "
"needs to get notified."
msgstr ""

#: src/2592-futures.md:189
msgid ""
"If the executor is blocked on a system call like `select`, it might need to "
"get woken up by a syscall like `write` to a pipe."
msgstr ""

#: src/2592-futures.md:191
msgid "If the executor's thread is parked, the wakeup call needs to unpark it."
msgstr ""

#: src/2592-futures.md:193
msgid ""
"To allow executors to implement custom wakeup behavior, the `Waker` type "
"contains a type called `RawWaker`, which consists of a  pointer to a custom "
"wakeable object and a reference to a virtual function pointer table (vtable) "
"which provides functions to `clone`, `wake`, and `drop` the underlying "
"wakeable object."
msgstr ""

#: src/2592-futures.md:199
msgid ""
"This mechanism is chosen in favor of trait objects since it allows for more "
"flexible memory management schemes. `RawWaker` can be implemented purely in "
"terms of global functions and state, on top of reference counted objects, or "
"in other ways. This strategy also makes it easier to provide different "
"vtable functions that will perform different behaviors despite referencing "
"the same underlying wakeable object type."
msgstr ""

#: src/2592-futures.md:206
msgid ""
"The relation between those `Waker` types is outlined in the following "
"definitions:"
msgstr ""

#: src/2592-futures.md:209
msgid ""
"/// A `RawWaker` allows the implementor of a task executor to create a "
"`Waker`\n"
"/// which provides customized wakeup behavior.\n"
"///\n"
"/// It consists of a data pointer and a virtual function pointer table "
"(vtable) that\n"
"/// customizes the behavior of the `RawWaker`.\n"
msgstr ""

#: src/2592-futures.md:216
msgid ""
"/// A data pointer, which can be used to store arbitrary data as required\n"
"    /// by the executor. This could be e.g. a type-erased pointer to an "
"`Arc`\n"
"    /// that is associated with the task.\n"
"    /// The value of this field gets passed to all functions that are part "
"of\n"
"    /// the vtable as first parameter.\n"
msgstr ""

#: src/2592-futures.md:222
msgid ""
"/// Virtual function pointer table that customizes the behavior of this "
"waker.\n"
msgstr ""

#: src/2592-futures.md:225
msgid ""
"/// A virtual function pointer table (vtable) that specifies the behavior\n"
"/// of a `RawWaker`.\n"
"///\n"
"/// The pointer passed to all functions inside the vtable is the `data` "
"pointer\n"
"/// from the enclosing `RawWaker` object.\n"
msgstr ""

#: src/2592-futures.md:233
msgid ""
"/// This function will be called when the `RawWaker` gets cloned, e.g. when\n"
"    /// the `Waker` in which the `RawWaker` is stored gets cloned.\n"
"    ///\n"
"    /// The implementation of this function must retain all resources that "
"are\n"
"    /// required for this additional instance of a `RawWaker` and "
"associated\n"
"    /// task. Calling `wake` on the resulting `RawWaker` should result in a "
"wakeup\n"
"    /// of the same task that would have been awoken by the original "
"`RawWaker`.\n"
msgstr ""

#: src/2592-futures.md:242
msgid ""
"/// This function will be called when `wake` is called on the `Waker`.\n"
"    /// It must wake up the task associated with this `RawWaker`.\n"
msgstr ""

#: src/2592-futures.md:246
msgid ""
"/// This function gets called when a `RawWaker` gets dropped.\n"
"    ///\n"
"    /// The implementation of this function must make sure to release any\n"
"    /// resources that are associated with this instance of a `RawWaker` "
"and\n"
"    /// associated task.\n"
msgstr ""

#: src/2592-futures.md:253
msgid ""
"/// A `Waker` is a handle for waking up a task by notifying its executor "
"that it\n"
"/// is ready to be run.\n"
"///\n"
"/// This handle encapsulates a `RawWaker` instance, which defines the\n"
"/// executor-specific wakeup behavior.\n"
"///\n"
"/// Implements `Clone`, `Send`, and `Sync`.\n"
msgstr ""

#: src/2592-futures.md:266
msgid "/// Wake up the task associated with this `Waker`.\n"
msgstr ""

#: src/2592-futures.md:268
msgid ""
"// The actual wakeup call is delegated through a virtual function call\n"
"        // to the implementation which is defined by the executor.\n"
msgstr ""

#: src/2592-futures.md:273
msgid ""
"/// Returns whether or not this `Waker` and other `Waker` have awaken the "
"same task.\n"
"    ///\n"
"    /// This function works on a best-effort basis, and may return false "
"even\n"
"    /// when the `Waker`s would awaken the same task. However, if this "
"function\n"
"    /// returns `true`, it is guaranteed that the `Waker`s will awaken the "
"same task.\n"
"    ///\n"
"    /// This function is primarily used for optimization purposes.\n"
msgstr ""

#: src/2592-futures.md:284
msgid ""
"/// Creates a new `Waker` from `RawWaker`.\n"
"    ///\n"
"    /// The method cannot check whether `RawWaker` fulfills the required "
"API\n"
"    /// contract to make it usable for `Waker` and is therefore unsafe.\n"
msgstr ""

#: src/2592-futures.md:310
msgid "`Waker`s must fulfill the following requirements:"
msgstr ""

#: src/2592-futures.md:311
msgid "They must be cloneable."
msgstr ""

#: src/2592-futures.md:312
msgid ""
"If all instances of a `Waker` have been dropped and their associated task "
"had been driven to completion, all resources which had been allocated for "
"the task must have been released."
msgstr ""

#: src/2592-futures.md:315
msgid ""
"It must be safe to call `wake()` on a `Waker` even if the associated task "
"has already been driven to completion."
msgstr ""

#: src/2592-futures.md:317
msgid ""
"`Waker::wake()` must wake up an executor even if it is called from an "
"arbitrary thread."
msgstr ""

#: src/2592-futures.md:320
msgid ""
"An executor that instantiates a `RawWaker` must therefore make sure that all "
"these requirements are fulfilled."
msgstr ""

#: src/2592-futures.md:323
msgid "`core::future` module"
msgstr ""

#: src/2592-futures.md:325
msgid ""
"With all of the above task infrastructure in place, defining `Future` is "
"straightforward:"
msgstr ""

#: src/2592-futures.md:330
msgid "/// The type of value produced on completion.\n"
msgstr ""

#: src/2592-futures.md:333
msgid ""
"/// Attempt to resolve the future to a final value, registering\n"
"    /// the current task for wakeup if the value is not yet available.\n"
"    ///\n"
"    /// # Return value\n"
"    ///\n"
"    /// This function returns:\n"
"    ///\n"
"    /// - [`Poll::Pending`] if the future is not ready yet\n"
"    /// - [`Poll::Ready(val)`] with the result `val` of this future if it\n"
"    ///   finished successfully.\n"
"    ///\n"
"    /// Once a future has finished, clients should not `poll` it again.\n"
"    ///\n"
"    /// When a future is not ready yet, `poll` returns `Poll::Pending` and\n"
"    /// stores a clone of the [`Waker`] to be woken once the future can\n"
"    /// make progress. For example, a future waiting for a socket to become\n"
"    /// readable would call `.clone()` on the [`Waker`] and store it.\n"
"    /// When a signal arrives elsewhere indicating that the socket is "
"readable,\n"
"    /// `[Waker::wake]` is called and the socket future's task is awoken.\n"
"    /// Once a task has been woken up, it should attempt to `poll` the "
"future\n"
"    /// again, which may or may not produce a final value.\n"
"    ///\n"
"    /// Note that on multiple calls to `poll`, only the most recent\n"
"    /// [`Waker`] passed to `poll` should be scheduled to receive a\n"
"    /// wakeup.\n"
"    ///\n"
"    /// # Runtime characteristics\n"
"    ///\n"
"    /// Futures alone are *inert*; they must be *actively* `poll`ed to make\n"
"    /// progress, meaning that each time the current task is woken up, it "
"should\n"
"    /// actively re-`poll` pending futures that it still has an interest "
"in.\n"
"    ///\n"
"    /// The `poll` function is not called repeatedly in a tight loop-- "
"instead,\n"
"    /// it should only be called when the future indicates that it is ready "
"to\n"
"    /// make progress (by calling `wake()`). If you're familiar with the\n"
"    /// `poll(2)` or `select(2)` syscalls on Unix it's worth noting that "
"futures\n"
"    /// typically do *not* suffer the same problems of \"all wakeups must "
"poll\n"
"    /// all events\"; they are more like `epoll(4)`.\n"
"    ///\n"
"    /// An implementation of `poll` should strive to return quickly, and "
"must\n"
"    /// *never* block. Returning quickly prevents unnecessarily clogging up\n"
"    /// threads or event loops. If it is known ahead of time that a call to\n"
"    /// `poll` may end up taking awhile, the work should be offloaded to a\n"
"    /// thread pool (or something similar) to ensure that `poll` can return\n"
"    /// quickly.\n"
"    ///\n"
"    /// # Panics\n"
"    ///\n"
"    /// Once a future has completed (returned `Ready` from `poll`),\n"
"    /// then any future calls to `poll` may panic, block forever, or "
"otherwise\n"
"    /// cause bad behavior. The `Future` trait itself provides no "
"guarantees\n"
"    /// about the behavior of `poll` after a future has completed.\n"
"    ///\n"
"    /// [`Poll::Pending`]: ../task/enum.Poll.html#variant.Pending\n"
"    /// [`Poll::Ready(val)`]: ../task/enum.Poll.html#variant.Ready\n"
"    /// [`Waker`]: ../task/struct.Waker.html\n"
"    /// [`Waker::wake`]: ../task/struct.Waker.html#method.wake\n"
msgstr ""

#: src/2592-futures.md:394
msgid ""
"Most of the explanation here follows what we've already said about the task "
"system. The one twist is the use of `Pin`, which makes it possible to keep "
"data borrowed across separate calls to `poll` (i.e., \"borrowing over yield "
"points\"). The mechanics of pinning are explained in [the RFC that "
"introduced it](https://github.com/rust-lang/rfcs/pull/2349) and the [blog "
"post about the latest revisions](https://boats.gitlab.io/blog/post/"
"rethinking-pin/)."
msgstr ""

#: src/2592-futures.md:401
msgid "Relation to futures 0.1"
msgstr ""

#: src/2592-futures.md:403
msgid ""
"The various discussions outlined in the historical context section above "
"cover the path to these APIs from futures 0.1. But, in a nutshell, there are "
"three major shifts:"
msgstr ""

#: src/2592-futures.md:406
msgid ""
"The use of `Pin<&mut self>` rather than just `&mut self`, which is necessary "
"to support borrowing within `async` blocks. The `Unpin` marker trait can be "
"used to restore ergonomics and safety similar to futures 0.1 when writing "
"futures by hand."
msgstr ""

#: src/2592-futures.md:410
msgid ""
"Dropping _built in_ errors from `Future`, in favor of futures returning a "
"`Result` when they can fail. The futures 0.3 crate provides a `TryFuture` "
"trait that bakes in the `Result` to provide better ergonomics when working "
"with `Result`\\-producing futures. Dropping the error type has been "
"discussed in previous threads, but the most important rationale is to "
"provide an orthogonal, compositional semantics for `async fn` that mirrors "
"normal `fn`, rather than _also_ baking in a particular style of error "
"handling."
msgstr ""

#: src/2592-futures.md:418
msgid ""
"Passing a `Waker` explicitly, rather than stashing it in thread-local "
"storage. This has been a hotly debated issue since futures 0.1 was released, "
"and this RFC does not seek to relitigate it, but to summarize, the major "
"advantages are (1) when working with manual futures (as opposed to `async` "
"blocks) it's much easier to tell where an ambient task is required, and (2) "
"`no_std` compatibility is significantly smoother."
msgstr ""

#: src/2592-futures.md:425
msgid ""
"To bridge the gap between futures 0.1 and 0.3, there are several "
"compatibility shims, including one built into the futures crate itself, "
"where you can shift between the two simply by using a `.compat()` "
"combinator. These compatibility layers make it possible to use the existing "
"ecosystem smoothly with the new futures APIs, and make it possible to "
"transition large code bases incrementally."
msgstr ""

#: src/2592-futures.md:431
msgid "Rationale, drawbacks, and alternatives"
msgstr ""

#: src/2592-futures.md:433
msgid ""
"This RFC is one of the most substantial additions to `std` proposed since "
"1.0. It commits us to including a particular task and polling model in the "
"standard library, and ties us to `Pin`."
msgstr ""

#: src/2592-futures.md:437
msgid ""
"So far we've been able to push the task/polling model into virtually every "
"niche Rust wishes to occupy, and the main downside has been, in essence, the "
"lack of async/await syntax (and the [borrowing it supports](https://aturon."
"github.io/tech/2018/04/24/async-borrowing/))."
msgstr ""

#: src/2592-futures.md:443
msgid ""
"This RFC does not attempt to provide a complete introduction to the task "
"model that originated with the futures crate. A fuller account of the design "
"rationale and alternatives can be found in the following two blog posts:"
msgstr ""

#: src/2592-futures.md:447
msgid ""
"[Zero-cost futures in Rust](https://aturon.github.io/tech/2016/08/11/"
"futures/)"
msgstr ""

#: src/2592-futures.md:448
msgid ""
"[Designing futures for Rust](https://aturon.github.io/tech/2016/09/07/"
"futures-design/)"
msgstr ""

#: src/2592-futures.md:450
msgid ""
"To summarize, the main alternative model for futures is a callback-based "
"approach, which was attempted for several months before the current approach "
"was discovered. In our experience, the callback approach suffered from "
"several drawbacks in Rust:"
msgstr ""

#: src/2592-futures.md:454
msgid ""
"It forced allocation almost everywhere, and hence was not compatible with "
"no_std."
msgstr ""

#: src/2592-futures.md:455
msgid ""
"It made cancellation _extremely_ difficult to get right, whereas with the "
"proposed model it's just \"drop\"."
msgstr ""

#: src/2592-futures.md:457
msgid ""
"Subjectively, the combinator code was quite hairy, while with the task-based "
"model things fell into place quickly and easily."
msgstr ""

#: src/2592-futures.md:460
msgid ""
"Some additional context and rationale for the overall async/await project is "
"available in the [companion RFC](https://github.com/rust-lang/rfcs/"
"pull/2394)."
msgstr ""

#: src/2592-futures.md:463
msgid ""
"For the remainder of this section, we'll dive into specific API design "
"questions where this RFC differs from futures 0.2."
msgstr ""

#: src/2592-futures.md:466
msgid "Rationale, drawbacks and alternatives for removing built-in errors"
msgstr ""

#: src/2592-futures.md:468
msgid ""
"There are an assortment of reasons to drop the built-in error type in the "
"main trait:"
msgstr ""

#: src/2592-futures.md:471
msgid ""
"**Improved type checking and inference**. The error type is one of the "
"biggest pain points when working with futures combinators today, both in "
"trying to get different types to match up, and in inference failures that "
"result when a piece of code cannot produce an error. To be clear, many of "
"these problems will become less pronounced when `async` syntax is available."
msgstr ""

#: src/2592-futures.md:477
msgid ""
"**Async functions**. If we retain a built-in error type, it's much less "
"clear how `async fn` should work: should it always require the return type "
"to be a `Result`? If not, what happens when a non-`Result` type is returned?"
msgstr ""

#: src/2592-futures.md:481
msgid ""
"**Combinator clarity**. Splitting up the combinators by whether they rely on "
"errors or not clarifies the semantics. This is _especially_ true for "
"streams, where error handling is a common source of confusion."
msgstr ""

#: src/2592-futures.md:485
msgid ""
"**Orthogonality**. In general, producing and handling errors is separable "
"from the core polling mechanism, so all things being equal, it seems good to "
"follow Rust's general design principles and treat errors by _composing_ with "
"`Result`."
msgstr ""

#: src/2592-futures.md:489
msgid ""
"All of that said, there are real downsides for error-heavy code, even with "
"`TryFuture`:"
msgstr ""

#: src/2592-futures.md:492
msgid ""
"An extra import is needed (obviated if code imports the futures prelude, "
"which we could perhaps more vocally encourage)."
msgstr ""

#: src/2592-futures.md:495
msgid ""
"It can be confusing for code to _bound_ by one trait but _implement_ another."
msgstr ""

#: src/2592-futures.md:497
msgid ""
"The error handling piece of this RFC is separable from the other pieces, so "
"the main alternative would be to retain the built-in error type."
msgstr ""

#: src/2592-futures.md:500
msgid ""
"Rationale, drawbacks and alternatives to the core trait design (wrt `Pin`)"
msgstr ""

#: src/2592-futures.md:502
msgid ""
"Putting aside error handling, which is orthogonal and discussed above, the "
"primary other big item in this RFC is the move to `Pin` for the core polling "
"method, and how it relates to `Unpin`/manually-written futures. Over the "
"course of RFC discussions, we've identified essentially three main "
"approaches to this question:"
msgstr ""

#: src/2592-futures.md:508
msgid ""
"**One core trait**. That's the approach taken in the main RFC text: there's "
"just a single core `Future` trait, which works on `Pin<&mut Self>`. "
"Separately there's a `poll_unpin` helper for working with `Unpin` futures in "
"manual implementations."
msgstr ""

#: src/2592-futures.md:513
msgid ""
"**Two core traits**. We can provide two traits, for example `MoveFuture` and "
"`Future`, where one operates on `&mut self` and the other on `Pin<&mut "
"Self>`. This makes it possible to continue writing code in the futures 0.2 "
"style, i.e. without importing `Pin`/`Unpin` or otherwise talking about pins. "
"A critical requirement is the need for interoperation, so that a "
"`MoveFuture` can be used anywhere a `Future` is required. There are at least "
"two ways to achieve such interop:"
msgstr ""

#: src/2592-futures.md:521
msgid ""
"Via a blanket impl of `Future` for `T: MoveFuture`. This approach currently "
"blocks some _other_ desired impls (around `Box` and `&mut` specifically), "
"but the problem doesn't appear to be fundamental."
msgstr ""

#: src/2592-futures.md:525
msgid ""
"Via a subtrait relationship, so that `T: Future` is defined essentially as "
"an alias for `for<'a> Pin<&mut 'a T>: MoveFuture`. Unfortunately, such "
"\"higher ranked\" trait relationships don't currently work well in the trait "
"system, and this approach also makes things more convoluted when "
"implementing `Future` by hand, for relatively little gain."
msgstr ""

#: src/2592-futures.md:531
msgid ""
"The drawback of the \"one core trait\" approach taken by this RFC is its "
"ergonomic hit when writing moveable futures by hand: you now need to import "
"`Pin` and `Unpin`, invoke `poll_unpin`, and impl `Unpin` for your types. "
"This is all pretty mechanical, but it's a pain. It's possible that "
"improvements in `Pin` ergonomics will obviate some of these issues, but "
"there are a lot of open questions there still."
msgstr ""

#: src/2592-futures.md:538
msgid ""
"On the other hand, a two-trait approach has downsides as well. If we _also_ "
"remove the error type, there's a combinatorial explosion, since we end up "
"needing `Try` variants of each trait (and this extends to related traits, "
"like `Stream`, as well). More broadly, with the one-trait approach, `Unpin` "
"acts as a kind of \"independent knob\" that can be applied orthogonally from "
"other concerns; with the two-trait approach, it's \"mixed in\". And both of "
"the two-trait approaches run up against compiler limitations at the moment, "
"though of course that shouldn't be taken as a deciding factor."
msgstr ""

#: src/2592-futures.md:547
msgid ""
"**The primary reason this RFC opts for the one-trait approach is that it's "
"the conservative, forward-compatible option, and has proven itself in "
"practice**. It's possible to add `MoveFuture`, together with a blanket impl, "
"at any point in the future. Thus, starting with just the single `Future` "
"trait as proposed in this RFC keeps our options maximally open while we gain "
"experience."
msgstr ""

#: src/2592-futures.md:553
msgid "Rationale, drawbacks and alternatives to the wakeup design (`Waker`)"
msgstr ""

#: src/2592-futures.md:555
msgid ""
"Previous iterations of this proposal included a separate wakeup type, "
"`LocalWaker`, which was `!Send + !Sync` and could be used to implement "
"optimized executor behavior without requiring atomic reference counting or "
"atomic wakeups. However, in practice, these same optimizations are available "
"through the use of thread-local wakeup queues, carrying IDs rather than "
"pointers to wakeup objects, and tracking an executor ID or thread ID to "
"perform a runtime assertion that a `Waker` wasn't sent across threads. For a "
"simple example, a single thread-locked executor with zero atomics can be "
"implemented as follows:"
msgstr ""

#: src/2592-futures.md:567
msgid "// map from task id (usize) to task\n"
msgstr ""

#: src/2592-futures.md:569
msgid "// list of woken tasks to poll\n"
msgstr ""

#: src/2592-futures.md:584
msgid ""
"While this solution gives inferior error messages to the `LocalWaker` "
"approach (since it can't panic until `wake` occurs on the wrong thread, "
"rather than panicking when `LocalWaker` is transformed into a `Waker`), it "
"dramatically simplifies the user-facing API by de-duplicating the "
"`LocalWaker` and `Waker` types."
msgstr ""

#: src/2592-futures.md:590
msgid ""
"In practice, it's also likely that the most common executors in the Rust "
"ecosystem will continue to be multithreaded-compatible (as they are today), "
"so optimizing for the ergonomics of this case is prioritized over better "
"error messages in the more heavily specialized case."
msgstr ""

#: src/2592-futures.md:595
msgid "Prior art"
msgstr ""

#: src/2592-futures.md:598
msgid ""
"There is substantial prior art both with async/await notation and with "
"futures (aka promises) as a basis. The proposed futures API was influenced "
"by Scala's futures in particular, and is broadly similar to APIs in a "
"variety of other languages (in terms of the adapters provided)."
msgstr ""

#: src/2592-futures.md:603
msgid ""
"What's more unique about the model in this RFC is the use of tasks, rather "
"than callbacks. The RFC author is not aware of other _futures_ libraries "
"using this technique, but it is a fairly well-known technique more generally "
"in functional programming. For a recent example, see [this paper](https://"
"www.microsoft.com/en-us/research/wp-content/uploads/2011/01/monad-par.pdf) "
"on parallelism in Haskell. What seems to be perhaps new with this RFC is the "
"idea of melding the \"trampoline\" technique with an explicit, open-ended "
"task/wakeup model."
msgstr ""

#: src/2592-futures.md:613
msgid "Unresolved questions"
msgstr ""

#: src/2592-futures.md:616
msgid "None at the moment."
msgstr ""
