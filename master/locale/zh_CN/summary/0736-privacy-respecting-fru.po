msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:43Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0736-privacy-respecting-fru.md:1
msgid "Start Date: 2015-01-26"
msgstr ""

#: src/0736-privacy-respecting-fru.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#736](https://github.com/rust-lang/rfcs/pull/736)"
msgstr ""

#: src/0736-privacy-respecting-fru.md:3
msgid ""
"Rust Issue: [rust-lang/rust#21407](https://github.com/rust-lang/rust/"
"issues/21407)"
msgstr ""

#: src/0736-privacy-respecting-fru.md:5
msgid "Summary"
msgstr ""

#: src/0736-privacy-respecting-fru.md:7
msgid ""
"Change Functional Record Update (FRU) for struct literal expressions to "
"respect struct privacy."
msgstr ""

#: src/0736-privacy-respecting-fru.md:10
msgid "Motivation"
msgstr ""

#: src/0736-privacy-respecting-fru.md:12
msgid ""
"Functional Record Update is the name for the idiom by which one can write `.."
"<expr>` at the end of a struct literal expression to fill in all remaining "
"fields of the struct literal by using `<expr>` as the source for them."
msgstr ""

#: src/0736-privacy-respecting-fru.md:27 src/0736-privacy-respecting-fru.md:231
msgid "\"bar one\""
msgstr ""

#: src/0736-privacy-respecting-fru.md:29 src/0736-privacy-respecting-fru.md:233
msgid "\"bar two\""
msgstr ""

#: src/0736-privacy-respecting-fru.md:29 src/0736-privacy-respecting-fru.md:233
msgid "// FRU!\n"
msgstr ""

#: src/0736-privacy-respecting-fru.md:31 src/0736-privacy-respecting-fru.md:235
msgid "\"bar_1: {} bar_2a: {}\""
msgstr ""

#: src/0736-privacy-respecting-fru.md:33 src/0736-privacy-respecting-fru.md:237
msgid "// FRU again!\n"
msgstr ""

#: src/0736-privacy-respecting-fru.md:35 src/0736-privacy-respecting-fru.md:239
msgid "\"bar_1: {} bar_2b: {}\""
msgstr ""

#: src/0736-privacy-respecting-fru.md:39
msgid ""
"Currently, Functional Record Update will freely move or copy all fields not "
"explicitly mentioned in the struct literal expression, so the code above "
"runs successfully."
msgstr ""

#: src/0736-privacy-respecting-fru.md:43
msgid "In particular, consider a case like this:"
msgstr ""

#: src/0736-privacy-respecting-fru.md:62 src/0736-privacy-respecting-fru.md:146
msgid "\"because of {}, deallocating {:p}\""
msgstr ""

#: src/0736-privacy-respecting-fru.md:69 src/0736-privacy-respecting-fru.md:153
msgid "\"ess one\""
msgstr ""

#: src/0736-privacy-respecting-fru.md:70 src/0736-privacy-respecting-fru.md:156
msgid "\"ess two\""
msgstr ""

#: src/0736-privacy-respecting-fru.md:70
msgid "// FRU ...\n"
msgstr ""

#: src/0736-privacy-respecting-fru.md:72 src/0736-privacy-respecting-fru.md:160
msgid "\"s_1.b: {} s_2.b: {}\""
msgstr ""

#: src/0736-privacy-respecting-fru.md:73
msgid "// at end of scope, ... both s_1 *and* s_2 get dropped.  Boom!\n"
msgstr ""

#: src/0736-privacy-respecting-fru.md:77
msgid ""
"This example prints the following (if one's memory allocator is not checking "
"for double-frees):"
msgstr ""

#: src/0736-privacy-respecting-fru.md:85
msgid ""
"In particular, from reading the module `foo`, it appears that one is "
"attempting to preserve an invariant that each instance of `Secrets` has its "
"own unique `ptr` value; but this invariant is broken by the use of FRU."
msgstr ""

#: src/0736-privacy-respecting-fru.md:90
msgid ""
"Note that there is essentially no way around this abstraction violation "
"today; as shown for example in [Issue 21407](https://github.com/rust-lang/"
"rust/issues/21407#issuecomment-71374092), where the backing storage for a "
"`Vec` is duplicated in a second `Vec` by use of the trivial FRU expression "
"`{ ..t }` where `t: Vec<T>`."
msgstr ""

#: src/0736-privacy-respecting-fru.md:97
msgid ""
"Again, this is due to the current rule that Functional Record Update will "
"freely move or copy all fields not explicitly mentioned in the struct "
"literal expression, _regardless_ of whether they are visible (in terms of "
"privacy) in the spot in code."
msgstr ""

#: src/0736-privacy-respecting-fru.md:102
msgid ""
"This RFC proposes to change that rule, and say that a struct literal "
"expression using FRU is effectively expanded into a complete struct literal "
"with initializers for all fields (i.e., a struct literal that does not use "
"FRU), and that this expanded struct literal is subject to privacy "
"restrictions."
msgstr ""

#: src/0736-privacy-respecting-fru.md:108
msgid ""
"The main motivation for this is to plug this abstraction-violating hole with "
"as little other change to the rules, implementation, and character of the "
"Rust language as possible."
msgstr ""

#: src/0736-privacy-respecting-fru.md:113
msgid "Detailed design"
msgstr ""

#: src/0736-privacy-respecting-fru.md:115
msgid ""
"As already stated above, the change proposed here is that a struct literal "
"expression using FRU is effectively expanded into a complete struct literal "
"with initializers for all fields (i.e., a struct literal that does not use "
"FRU), and that this expanded struct literal is subject to privacy "
"restrictions."
msgstr ""

#: src/0736-privacy-respecting-fru.md:121
msgid ""
"(Another way to think of this change is: one can only use FRU with a struct "
"if one has visibility of all of its declared fields. If any fields are "
"hidden by privacy, then all forms of struct literal syntax are unavailable, "
"including FRU.)"
msgstr ""

#: src/0736-privacy-respecting-fru.md:128
msgid "This way, the `Secrets` example above will be essentially equivalent to"
msgstr ""

#: src/0736-privacy-respecting-fru.md:154
msgid ""
"// let s_2 = foo::Secrets { b: format!(\"ess two\"), ..s_1 };\n"
"    // is rewritten to:\n"
msgstr ""

#: src/0736-privacy-respecting-fru.md:157
msgid "/* remainder from FRU */"
msgstr ""

#: src/0736-privacy-respecting-fru.md:164
msgid ""
"which is rejected as field `ptr` of `foo::Secrets` is private and cannot be "
"accessed from `fn main` (both in terms of reading it from `s_1`, but also in "
"terms of using it to build a new instance of `foo::Secrets`."
msgstr ""

#: src/0736-privacy-respecting-fru.md:171
msgid ""
"(While the change to the language is described above in terms of rewriting "
"the code, the implementation need not go that route. In particular, [this "
"commit](https://github.com/pnkfelix/rust/commit/"
"c651bac4189dc03d6a5637323b6ae02fc30e711a) shows a different strategy that is "
"isolated to the `librustc_privacy` crate.)"
msgstr ""

#: src/0736-privacy-respecting-fru.md:180
msgid ""
"The proposed change is applied only to struct literal expressions.  In "
"particular, enum struct variants are left unchanged, since all of their "
"fields are already implicitly public."
msgstr ""

#: src/0736-privacy-respecting-fru.md:184
msgid "Drawbacks"
msgstr ""

#: src/0736-privacy-respecting-fru.md:186
msgid ""
"There is a use case for allowing private fields to be moved/copied via FRU, "
"which I call the \"future extensibility\" library design pattern: it is a "
"convenient way for a library author to tell clients to make updated copies "
"of a record in a manner that is oblivious to the addition of new private "
"fields to the struct (at least, new private fields that implement `Copy`...)."
msgstr ""

#: src/0736-privacy-respecting-fru.md:193
msgid ""
"For example, in Rust today without the change proposed here, in the first "
"example above using `Bar`, the author of the `mod foo` can change `Bar` like "
"so:"
msgstr ""

#: src/0736-privacy-respecting-fru.md:205
msgid ""
"And all of the code from the `fn main` in the first example will continue to "
"run."
msgstr ""

#: src/0736-privacy-respecting-fru.md:208
msgid ""
"Also, when the struct is moved (rather than copied) by the FRU expression, "
"the same pattern applies and works even when the new private fields do not "
"implement `Copy`."
msgstr ""

#: src/0736-privacy-respecting-fru.md:212
msgid ""
"However, there is a small coding pattern that enables such continued future-"
"extensibility for library authors: divide the struct into the entirely `pub` "
"frontend, with one member that is the `pub` backend with entirely private "
"contents, like so:"
msgstr ""

#: src/0736-privacy-respecting-fru.md:243
msgid ""
"All hidden changes that one would have formerly made to `Bar` itself are now "
"made to `BarHidden`.  The struct `Bar` is entirely public (including the "
"supposedly-hidden field named `_hidden`), and thus can be legally be used "
"with FRU in all client contexts that can see the type `Bar`, even under the "
"new rules proposed by this RFC."
msgstr ""

#: src/0736-privacy-respecting-fru.md:251
msgid "Alternatives"
msgstr ""

#: src/0736-privacy-respecting-fru.md:253
msgid ""
"Most Important: If we do not do _something_ about this, then both stdlib "
"types like `Vec` and user-defined types will fundmentally be unable to "
"enforce abstraction. In other words, the Rust language will be broken."
msgstr ""

#: src/0736-privacy-respecting-fru.md:259
msgid ""
"glaebhoerl and pnkfelix outlined a series of potential alternatives, "
"including this one. Here is an attempt to transcribe/summarize them:"
msgstr ""

#: src/0736-privacy-respecting-fru.md:262
msgid ""
"Change the FRU form `Bar { x: new_x, y: new_y, ..old_b }` so it somehow is "
"treated as consuming `old_b`, rather than moving/copying each of the "
"remaining fields in `old_b`."
msgstr ""

#: src/0736-privacy-respecting-fru.md:266
msgid ""
"It is not totally clear what the semantics actually are for this form. Also, "
"there may not be time to do this properly for 1.0."
msgstr ""

#: src/0736-privacy-respecting-fru.md:269
msgid ""
"Try to adopt a data/abstract-type distinction along the lines of the one in "
"[glaebhoerl's draft RFC](https://raw.githubusercontent.com/glaebhoerl/rust-"
"notes/master/my_rfcs/Distinguish%20data%20types%20from%20abstract%20types."
"txt)."
msgstr ""

#: src/0736-privacy-respecting-fru.md:280
msgid ""
"    (Another potential criterion could be \"has *all* private fields.\"; "
"see\n"
"     related discussion below in the item \"Outlaw the trivial FRU form "
"Foo\".)\n"
"    "
msgstr ""

#: src/0736-privacy-respecting-fru.md:283
msgid ""
"let FRU keep its current privacy violating semantics, but also make FRU "
"something one must opt-in to support on a type. E.g. make a builtin "
"`FunUpdate` trait that a struct must implement in order to be usable with "
"FRU. (Or maybe its an attribute you attach to the struct item.)"
msgstr ""

#: src/0736-privacy-respecting-fru.md:289
msgid ""
"This approach would impose a burden on all code today that makes use of FRU, "
"since they would have to start implementing `FunUpdate`. Thus, not simple to "
"implement for the libraries and the overall ecosystem.  What other designs "
"have been considered? What is the impact of not doing this?"
msgstr ""

#: src/0736-privacy-respecting-fru.md:295
msgid ""
"Adopt this RFC, but add a builtin `HygienicFunUpdate` trait that one can opt-"
"into to get the old (privacy violating) semantics."
msgstr ""

#: src/0736-privacy-respecting-fru.md:298
msgid ""
"While this is obviously complicated, it has the advantage that it has a "
"staged landing strategy: We could just adopt and implement this RFC for 1.0 "
"beta. We could add `HygienicFunUpdate` at an arbitrary point in the future; "
"it would not have to be in the 1.0 release."
msgstr ""

#: src/0736-privacy-respecting-fru.md:304
msgid ""
"(For why the trait is named `HygienicFunUpdate`, see comment thread on "
"[Issue 21407](https://github.com/rust-lang/rust/"
"issues/21407#issuecomment-71374092).)"
msgstr ""

#: src/0736-privacy-respecting-fru.md:307
msgid ""
"Add way for struct item to opt out of FRU support entirely, e.g. via an "
"attribute."
msgstr ""

#: src/0736-privacy-respecting-fru.md:310
msgid "This seems pretty fragile; i.e., easy to forget."
msgstr ""

#: src/0736-privacy-respecting-fru.md:312
msgid ""
"Outlaw the trivial FRU form `Foo { ..<expr> }`. That is, to use FRU, you "
"have to use at least one field in the constructing expression. Again, this "
"implies that types like Vec and HashMap will not be subject to the "
"vulnerability outlined here."
msgstr ""

#: src/0736-privacy-respecting-fru.md:317
msgid ""
"This solves the vulnerability for types like `Vec` and `HashMap`, but the "
"`Secrets` example from the Motivation section still breaks; the author for "
"the `mod foo` library will need to write their code more carefully to ensure "
"that secret things are contained in a separate struct with all private "
"fields, much like the `BarHidden` code pattern discussed above."
msgstr ""

#: src/0736-privacy-respecting-fru.md:324
msgid "Unresolved questions"
msgstr ""

#: src/0736-privacy-respecting-fru.md:326
msgid ""
"How important is the \"future extensibility\" library design pattern "
"described in the Drawbacks section?  How many Cargo packages, if any, use it?"
msgstr ""
