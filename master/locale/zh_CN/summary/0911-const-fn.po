msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0911-const-fn.md:1
msgid "Feature Name: const_fn"
msgstr ""

#: src/0911-const-fn.md:2
msgid "Start Date: 2015-02-25"
msgstr ""

#: src/0911-const-fn.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#911](https://github.com/rust-lang/rfcs/pull/911)"
msgstr ""

#: src/0911-const-fn.md:4
msgid ""
"Rust Issue: [rust-lang/rust#24111](https://github.com/rust-lang/rust/"
"issues/24111)"
msgstr ""

#: src/0911-const-fn.md:6
msgid "Summary"
msgstr ""

#: src/0911-const-fn.md:8
msgid ""
"Allow marking free functions and inherent methods as `const`, enabling them "
"to be called in constants contexts, with constant arguments."
msgstr ""

#: src/0911-const-fn.md:11
msgid "Motivation"
msgstr ""

#: src/0911-const-fn.md:13
msgid ""
"As it is right now, `UnsafeCell` is a stabilization and safety hazard: the "
"field it is supposed to be wrapping is public. This is only done out of the "
"necessity to initialize static items containing atomics, mutexes, etc. - for "
"example:"
msgstr ""

#: src/0911-const-fn.md:18
msgid "\"unsafe_cell\""
msgstr ""

#: src/0911-const-fn.md:26
msgid ""
"This approach is fragile and doesn't compose well - consider having to "
"initialize an `AtomicUsize` static with `usize::MAX` - you would need a "
"`const` for each possible value."
msgstr ""

#: src/0911-const-fn.md:30
msgid ""
"Also, types like `AtomicPtr<T>` or `Cell<T>` have no way _at all_ to "
"initialize them in constant contexts, leading to overuse of `UnsafeCell` or "
"`static mut`, disregarding type safety and proper abstractions."
msgstr ""

#: src/0911-const-fn.md:34
msgid ""
"During implementation, the worst offender I've found was `std::"
"thread_local`: all the fields of `std::thread_local::imp::Key` are public, "
"so they can be filled in by a macro - and they're also marked "
"\"stable\" (due to the lack of stability hygiene in macros)."
msgstr ""

#: src/0911-const-fn.md:39
msgid ""
"A pre-RFC for the removal of the dangerous (and often misused) `static mut` "
"received positive feedback, but only under the condition that abstractions "
"could be created and used in `const` and `static` items."
msgstr ""

#: src/0911-const-fn.md:43
msgid ""
"Another concern is the ability to use certain intrinsics, like `size_of`, "
"inside constant expressions, including fixed-length array types. Unlike "
"keyword-based alternatives, `const fn` provides an extensible and composable "
"building block for such features."
msgstr ""

#: src/0911-const-fn.md:48
msgid ""
"The design should be as simple as it can be, while keeping enough "
"functionality to solve the issues mentioned above."
msgstr ""

#: src/0911-const-fn.md:51
msgid ""
"The intention of this RFC is to introduce a minimal change that enables safe "
"abstraction resembling the kind of code that one writes outside of a "
"constant. Compile-time pure constants (the existing `const` items) with "
"added parametrization over types and values (arguments) should suffice."
msgstr ""

#: src/0911-const-fn.md:57
msgid ""
"This RFC explicitly does not introduce a general CTFE mechanism. In "
"particular, conditional branching and virtual dispatch are still not "
"supported in constant expressions, which imposes a severe limitation on what "
"one can express."
msgstr ""

#: src/0911-const-fn.md:62
msgid "Detailed design"
msgstr ""

#: src/0911-const-fn.md:64
msgid "Functions and inherent methods can be marked as `const`:"
msgstr ""

#: src/0911-const-fn.md:83
msgid ""
"Traits, trait implementations and their methods cannot be `const` - this "
"allows us to properly design a constness/CTFE system that interacts well "
"with traits - for more details, see _Alternatives_."
msgstr ""

#: src/0911-const-fn.md:87
msgid ""
"Only simple by-value bindings are allowed in arguments, e.g. `x: T`. While "
"by-ref bindings and destructuring can be supported, they're not necessary "
"and they would only complicate the implementation."
msgstr ""

#: src/0911-const-fn.md:91
msgid ""
"The body of the function is checked as if it were a block inside a `const`:"
msgstr ""

#: src/0911-const-fn.md:94
msgid "// Currently, only item \"statements\" are allowed here.\n"
msgstr ""

#: src/0911-const-fn.md:96
msgid ""
"// The function's arguments and constant expressions can be freely "
"combined.\n"
msgstr ""

#: src/0911-const-fn.md:101
msgid ""
"As the current `const` items are not formally specified (yet), there is a "
"need to expand on the rules for `const` values (pure compile-time "
"constants), instead of leaving them implicit:"
msgstr ""

#: src/0911-const-fn.md:104
msgid ""
"the set of currently implemented expressions is: primitive literals, ADTs "
"(tuples, arrays, structs, enum variants), unary/binary operations on "
"primitives, casts, field accesses/indexing, capture-less closures, "
"references and blocks (only item statements and a tail expression)"
msgstr ""

#: src/0911-const-fn.md:108
msgid ""
"no side-effects (assignments, non-`const` function calls, inline assembly)"
msgstr ""

#: src/0911-const-fn.md:109
msgid ""
"struct/enum values are not allowed if their type implements `Drop`, but this "
"is not transitive, allowing the (perfectly harmless) creation of, e.g. "
"`None::<Vec<T>>` (as an aside, this rule could be used to allow `[x; N]` "
"even for non-`Copy` types of `x`, but that is out of the scope of this RFC)"
msgstr ""

#: src/0911-const-fn.md:113
msgid ""
"references are truly immutable, no value with interior mutability can be "
"placed behind a reference, and mutable references can only be created from "
"zero-sized values (e.g. `&mut || {}`) - this allows a reference to be "
"represented just by its value, with no guarantees for the actual address in "
"memory"
msgstr ""

#: src/0911-const-fn.md:117
msgid ""
"raw pointers can only be created from an integer, a reference or another raw "
"pointer, and cannot be dereferenced or cast back to an integer, which means "
"any constant raw pointer can be represented by either a constant integer or "
"reference"
msgstr ""

#: src/0911-const-fn.md:120
msgid ""
"as a result of not having any side-effects, loops would only affect "
"termination, which has no practical value, thus remaining unimplemented"
msgstr ""

#: src/0911-const-fn.md:122
msgid ""
"although more useful than loops, conditional control flow (`if`/`else` and "
"`match`) also remains unimplemented and only `match` would pose a challenge"
msgstr ""

#: src/0911-const-fn.md:124
msgid ""
"immutable `let` bindings in blocks have the same status and implementation "
"difficulty as `if`/`else` and they both suffer from a lack of demand (blocks "
"were originally introduced to `const`/`static` for scoping items used only "
"in the initializer of a global)."
msgstr ""

#: src/0911-const-fn.md:129
msgid ""
"For the purpose of rvalue promotion (to static memory), arguments are "
"considered potentially varying, because the function can still be called "
"with non-constant values at runtime."
msgstr ""

#: src/0911-const-fn.md:133
msgid ""
"`const` functions and methods can be called from any constant expression:"
msgstr ""

#: src/0911-const-fn.md:135
msgid "// Standalone example.\n"
msgstr ""

#: src/0911-const-fn.md:158
msgid "// Assuming the Foo::new methods used here are const.\n"
msgstr ""

#: src/0911-const-fn.md:166
msgid ""
"Type parameters and their bounds are not restricted, though trait methods "
"cannot be called, as they are never `const` in this design. Accessing trait "
"methods can still be useful - for example, they can be turned into function "
"pointers:"
msgstr ""

#: src/0911-const-fn.md:175
msgid ""
"`const` functions can also be unsafe, allowing construction of types that "
"require invariants to be maintained (e.g. `std::ptr::Unique` requires a non-"
"null pointer)"
msgstr ""

#: src/0911-const-fn.md:180
msgid "/// Value must be non-zero\n"
msgstr ""

#: src/0911-const-fn.md:187
msgid "Drawbacks"
msgstr ""

#: src/0911-const-fn.md:189
msgid ""
"A design that is not conservative enough risks creating backwards "
"compatibility hazards that might only be uncovered when a more extensive "
"CTFE proposal is made, after 1.0."
msgstr ""

#: src/0911-const-fn.md:193
msgid "Alternatives"
msgstr ""

#: src/0911-const-fn.md:195
msgid ""
"While not an alternative, but rather a potential extension, I want to point "
"out there is only way I could make `const fn`s work with traits (in an "
"untested design, that is): qualify trait implementations and bounds with "
"`const`. This is necessary for meaningful interactions with operator "
"overloading traits:"
msgstr ""

#: src/0911-const-fn.md:217
msgid ""
"Having `const` trait methods (where all implementations are `const`) seems "
"useful, but it would not allow the usecase above on its own. Trait "
"implementations with `const` methods (instead of the entire `impl` being "
"`const`) would allow direct calls, but it's not obvious how one could write "
"a function generic over a type which implements a trait and requiring that a "
"certain method of that trait is implemented as `const`."
msgstr ""

#: src/0911-const-fn.md:224
msgid "Unresolved questions"
msgstr ""

#: src/0911-const-fn.md:226
msgid ""
"Keep recursion or disallow it for now? The conservative choice of having no "
"recursive `const fn`s would not affect the usecases intended for this RFC. "
"If we do allow it, we probably need a recursion limit, and/or an evaluation "
"algorithm that can handle _at least_ tail recursion. Also, there is no way "
"to actually write a recursive `const fn` at this moment, because no control "
"flow primitives are implemented for constants, but that cannot be taken for "
"granted, at least `if`/`else` should eventually work."
msgstr ""

#: src/0911-const-fn.md:234
msgid "History"
msgstr ""

#: src/0911-const-fn.md:236
msgid ""
"This RFC was accepted on 2015-04-06. The primary concerns raised in the "
"discussion concerned CTFE, and whether the `const fn` strategy locks us into "
"an undesirable plan there."
msgstr ""

#: src/0911-const-fn.md:240
msgid "Updates since being accepted"
msgstr ""

#: src/0911-const-fn.md:242
msgid "Since it was accepted, the RFC has been updated as follows:"
msgstr ""

#: src/0911-const-fn.md:244
msgid "Allowed `const unsafe fn`"
msgstr ""
