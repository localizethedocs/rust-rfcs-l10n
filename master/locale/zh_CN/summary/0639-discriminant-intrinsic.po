msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0639-discriminant-intrinsic.md:1
msgid "Start Date: 2015-01-21"
msgstr ""

#: src/0639-discriminant-intrinsic.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#639](https://github.com/rust-lang/rfcs/pull/639)"
msgstr ""

#: src/0639-discriminant-intrinsic.md:3
msgid ""
"Rust Issue: [rust-lang/rust#24263](https://github.com/rust-lang/rust/"
"issues/24263)"
msgstr ""

#: src/0639-discriminant-intrinsic.md:5
msgid "Summary"
msgstr ""

#: src/0639-discriminant-intrinsic.md:7
msgid ""
"Add a new intrinsic, `discriminant_value` that extracts the value of the "
"discriminant for enum types."
msgstr ""

#: src/0639-discriminant-intrinsic.md:10
msgid "Motivation"
msgstr ""

#: src/0639-discriminant-intrinsic.md:12
msgid ""
"Many operations that work with discriminant values can be significantly "
"improved with the ability to extract the value of the discriminant that is "
"used to distinguish between variants in an enum. While trivial cases often "
"optimise well, more complex ones would benefit from direct access to this "
"value."
msgstr ""

#: src/0639-discriminant-intrinsic.md:16
msgid ""
"A good example is the `SqlState` enum from the `postgres` crate (Listed at "
"the end of this RFC). It contains 233 variants, of which all but one contain "
"no fields. The most obvious implementation of (for example) the `PartialEq` "
"trait looks like this:"
msgstr ""

#: src/0639-discriminant-intrinsic.md:34
msgid ""
"Even with optimisations enabled, this code is very suboptimal, producing "
"[this code](https://gist.github.com/Aatch/c23a45634b10aaecad05). A way to "
"extract the discriminant would allow this code:"
msgstr ""

#: src/0639-discriminant-intrinsic.md:47
msgid ""
"Which is compiled into [this IR](https://gist.github.com/Aatch/"
"beb736b93a908aa67e84)."
msgstr ""

#: src/0639-discriminant-intrinsic.md:49
msgid "Detailed design"
msgstr ""

#: src/0639-discriminant-intrinsic.md:51
msgid "What is a discriminant?"
msgstr ""

#: src/0639-discriminant-intrinsic.md:53
msgid ""
"A discriminant is a value stored in an enum type that indicates which "
"variant the value is. The most common case is that the discriminant is "
"stored directly as an extra field in the variant. However, the discriminant "
"may be stored in any place, and in any format. However, we can always "
"extract the discriminant from the value somehow."
msgstr ""

#: src/0639-discriminant-intrinsic.md:58
msgid "Implementation"
msgstr ""

#: src/0639-discriminant-intrinsic.md:60
msgid ""
"For any given type, `discriminant_value` will return a `u64` value. The "
"values returned are as specified:"
msgstr ""

#: src/0639-discriminant-intrinsic.md:63
msgid "**Non-Enum Type**: Always 0"
msgstr ""

#: src/0639-discriminant-intrinsic.md:64
msgid ""
"**C-Like Enum Type**: If no variants have fields, then the enum is "
"considered \"C-Like\". The user is able to specify discriminant values in "
"this case, and the return value would be equivalent to the result of casting "
"the variant to a `u64`."
msgstr ""

#: src/0639-discriminant-intrinsic.md:67
msgid ""
"**ADT Enum Type**: If any variant has a field, then the enum is conidered to "
"be an \"ADT\" enum. The user is not able to specify the discriminant value "
"in this case. The precise values are unspecified, but have the following "
"characteristics:"
msgstr ""

#: src/0639-discriminant-intrinsic.md:71
msgid ""
"The value returned for the same variant of the same enum type will compare "
"as equal. I.E. `discriminant_value(v) == discriminant_value(v)`."
msgstr ""

#: src/0639-discriminant-intrinsic.md:73
msgid ""
"Two values returned for different variants will compare as unequal relative "
"to their respective listed positions. That means that if variant `A` is "
"listed before variant `B`, then `discriminant_value(A) < "
"discriminant_value(B)`."
msgstr ""

#: src/0639-discriminant-intrinsic.md:77
msgid ""
"Note the returned values for two differently-typed variants may compare in "
"any way."
msgstr ""

#: src/0639-discriminant-intrinsic.md:79
msgid "Drawbacks"
msgstr ""

#: src/0639-discriminant-intrinsic.md:81
msgid ""
"Potentially exposes implementation details. However, relying the specific "
"values returned from `discriminant_value` should be considered bad practice, "
"as the intrinsic provides no such guarantee."
msgstr ""

#: src/0639-discriminant-intrinsic.md:84
msgid ""
"Allows non-enum types to be provided. This may be unexpected by some users."
msgstr ""

#: src/0639-discriminant-intrinsic.md:86
msgid "Alternatives"
msgstr ""

#: src/0639-discriminant-intrinsic.md:88
msgid ""
"More strongly specify the values returned. This would allow for a broader "
"range of uses, but requires specifying behaviour that we may not want to."
msgstr ""

#: src/0639-discriminant-intrinsic.md:91
msgid ""
"Disallow non-enum types. Non-enum types do not have a discriminant, so "
"trying to extract might be considered an error. However, there is no "
"compelling reason to disallow these types as we can simply treat them as "
"single-variant enums and synthesise a zero constant. Note that this is what "
"would be done for single-variant enums anyway."
msgstr ""

#: src/0639-discriminant-intrinsic.md:96
msgid ""
"Do nothing. Improvements to codegen and/or optimisation could make this "
"unnecessary. The \"Sufficiently Smart Compiler\" trap is a strong case "
"against this reasoning though. There will likely always be cases where the "
"user can write more efficient code than the compiler can produce."
msgstr ""

#: src/0639-discriminant-intrinsic.md:100
msgid "Unresolved questions"
msgstr ""

#: src/0639-discriminant-intrinsic.md:102
msgid ""
"Should `#[derive]` use this intrinsic to improve derived implementations of "
"traits? While intrinsics are inherently unstable, `#[derive]`d code is "
"compiler generated and therefore can be updated if the intrinsic is changed "
"or removed."
msgstr ""

#: src/0639-discriminant-intrinsic.md:106
msgid "Appendix"
msgstr ""

#: src/0639-discriminant-intrinsic.md:346
msgid "History"
msgstr ""

#: src/0639-discriminant-intrinsic.md:348
msgid ""
"This RFC was accepted on a provisional basis on 2015-10-04.  The intention "
"is to implement and experiment with the proposed intrinsic. Some concerns "
"expressed in the RFC discussion that will require resolution before the RFC "
"can be fully accepted:"
msgstr ""

#: src/0639-discriminant-intrinsic.md:353
msgid "Using bounds such as `T:Reflect` to help ensure parametricity."
msgstr ""

#: src/0639-discriminant-intrinsic.md:354
msgid "Do we want to change the return type in some way?"
msgstr ""

#: src/0639-discriminant-intrinsic.md:355
msgid ""
"It may not be helpful if we expose discriminant directly in the case of "
"(potentially) negative discriminants."
msgstr ""

#: src/0639-discriminant-intrinsic.md:357
msgid ""
"We might want to return something more opaque to guard against unintended "
"representation exposure."
msgstr ""

#: src/0639-discriminant-intrinsic.md:359
msgid "Does this intrinsic need to be unsafe?"
msgstr ""
