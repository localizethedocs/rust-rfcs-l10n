msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:04Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2515-type_alias_impl_trait.md:1
msgid "Feature Name: `type_alias_impl_trait`"
msgstr ""

#: src/2515-type_alias_impl_trait.md:2
msgid "Start Date: 2018-08-03"
msgstr ""

#: src/2515-type_alias_impl_trait.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2515](https://github.com/rust-lang/rfcs/pull/2515)"
msgstr ""

#: src/2515-type_alias_impl_trait.md:4
msgid ""
"Rust Issue: [rust-lang/rust#63063](https://github.com/rust-lang/rust/"
"issues/63063)"
msgstr ""

#: src/2515-type_alias_impl_trait.md:6
msgid "Summary"
msgstr ""

#: src/2515-type_alias_impl_trait.md:9
msgid ""
"Allow type aliases and associated types to use `impl Trait`, replacing the "
"prototype `existential type` as a way to declare type aliases and associated "
"types for opaque, uniquely inferred types."
msgstr ""

#: src/2515-type_alias_impl_trait.md:11
msgid "Motivation"
msgstr ""

#: src/2515-type_alias_impl_trait.md:14
msgid ""
"[RFC 2071](https://github.com/rust-lang/rfcs/blob/master/text/2071-impl-"
"trait-existential-types.md) described a method to define opaque types "
"satisfying certain bounds (described in RFC 2071 and elsewhere as "
"_existential types_). It left open the question of what the precise concrete "
"syntax for the feature should be, opting to use a placeholder syntax, "
"`existential type`. Since then, a clearer picture has emerged as to how to "
"rephrase `impl Trait` in terms of type inference, rather than existentially-"
"quantified types, which also provides new motivation for a proposed concrete "
"syntax making use of the existing and familiar syntax `impl Trait`."
msgstr ""

#: src/2515-type_alias_impl_trait.md:16
msgid "In essence, this RFC proposes that the syntax:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:22
msgid "be implemented with the same semantics as:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:28
msgid ""
"both as the syntax for type aliases and also for associated types, and that "
"existing placeholder be removed."
msgstr ""

#: src/2515-type_alias_impl_trait.md:30
msgid ""
"Furthermore, this RFC proposes a strategy by which the terminology "
"surrounding `impl Trait` might be transitioned from existentially-type "
"theoretic terminology to type inference terminology, reducing the cognitive "
"complexity of the feature."
msgstr ""

#: src/2515-type_alias_impl_trait.md:32
msgid "Semantic Justification"
msgstr ""

#: src/2515-type_alias_impl_trait.md:33
msgid ""
"Currently, each occurrence `impl Trait` serves two complementary functional "
"purposes."
msgstr ""

#: src/2515-type_alias_impl_trait.md:34
msgid ""
"It defines an opaque type `T` (that is, a new type whose precise "
"identification is hidden) satisfying (trait) bounds."
msgstr ""

#: src/2515-type_alias_impl_trait.md:35
msgid ""
"It infers the precise type for `T` (that must satisfy the bounds for `T`), "
"based on its occurrences."
msgstr ""

#: src/2515-type_alias_impl_trait.md:37
msgid "Thus, the following code:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:41 src/2515-type_alias_impl_trait.md:85
#: src/2515-type_alias_impl_trait.md:95
msgid "// return some type implementing `Bar`\n"
msgstr ""

#: src/2515-type_alias_impl_trait.md:45
msgid "is functionally equivalent to:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:48
msgid "/* some inferred type (2"
msgstr ""

#: src/2515-type_alias_impl_trait.md:48
msgid "// (1)\n"
msgstr ""

#: src/2515-type_alias_impl_trait.md:51
msgid "// return some type implementing `Bar` wrapped in `__foo_return` (3)\n"
msgstr ""

#: src/2515-type_alias_impl_trait.md:55
msgid ""
"The generated type `__foo_return` is not exposed: it is automatically "
"constructed from any valid type (as in `(3)`)."
msgstr ""

#: src/2515-type_alias_impl_trait.md:57
msgid ""
"Note that, in order for the type inference to support argument-position "
"`impl Trait`, which may be polymorphic (just like a generic parameter), the "
"inference used here is actually a more expressive form of type inference "
"similar to ML-style let polymorphism. Here, the inference of function types "
"may result in additional generic parameters, specifically relating to the "
"occurrences of argument-position `impl Trait`."
msgstr ""

#: src/2515-type_alias_impl_trait.md:59
msgid ""
"RFC 2071 proposed a new construct for declaring types acting like `impl "
"Trait`, but whose actual type was not hidden (i.e. a method to expose the "
"`__foo_return` above), to use such types in positions other than function "
"arguments and return-types (for example, at the module level)."
msgstr ""

#: src/2515-type_alias_impl_trait.md:61
msgid ""
"If the semantics of `impl Trait` are justified from the perspective of "
"existentially-quantified types, this new construct is a sensible solution as "
"re-using `impl Trait` for this purpose introduces additional inconsistency "
"with the existential quantifier scopes. (See [here](https://varkor.github.io/"
"blog/2018/07/03/existential-types-in-rust.html) for more details on this "
"point.)"
msgstr ""

#: src/2515-type_alias_impl_trait.md:63
msgid ""
"However, if we justify the semantics of `impl Trait` solely using type "
"inference (as in point 2 above, expounded below) then we can re-use `impl "
"Trait` for the purpose of `existential type` consistently, leading to a more "
"unified syntax and lower cognitive barrier to learning."
msgstr ""

#: src/2515-type_alias_impl_trait.md:65
msgid "Here, we define the syntax:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:71
msgid "to represent a type alias to a generated type:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:74
msgid "/* some inferred type */"
msgstr ""

#: src/2515-type_alias_impl_trait.md:78
msgid ""
"This is functionally identical to `existential type`, but remains consistent "
"with `impl Trait` where the original generated type is technically still "
"hidden (exposed through the type alias)."
msgstr ""

#: src/2515-type_alias_impl_trait.md:80
msgid "Aliasing `impl Trait` in function signatures"
msgstr ""

#: src/2515-type_alias_impl_trait.md:81
msgid ""
"Note that though the type alias above is not contextual, it can be used to "
"alias any existing occurrence of `impl Trait` in return position, because "
"the type it aliases is inferred."
msgstr ""

#: src/2515-type_alias_impl_trait.md:89
msgid "can be replaced by:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:99
msgid ""
"However, if the function is parameterised, it may be necessary to add "
"explicit parameters to the type alias (due to the return-type being within "
"the scope of the function's generic parameters, unlike the type alias)."
msgstr ""

#: src/2515-type_alias_impl_trait.md:101
msgid ""
"Using `Baz` in multiple locations constrains all occurrences of the inferred "
"type to be the same, just as with `existential type`."
msgstr ""

#: src/2515-type_alias_impl_trait.md:103
msgid ""
"Notice that we can describe the type alias syntax using features that are "
"already present in Rust, rather than introducing any new constructs."
msgstr ""

#: src/2515-type_alias_impl_trait.md:105
msgid "Learnability Justification"
msgstr ""

#: src/2515-type_alias_impl_trait.md:107
msgid "Reduced technical and theoretic complexity"
msgstr ""

#: src/2515-type_alias_impl_trait.md:108
msgid ""
"As a relatively recently stabilised feature, there is not significant "
"(official) documentation on `impl Trait` so far. Apart from the various RFC "
"threads and internal discussions, `impl Trait` [is described in a blog post]"
"(https://blog.rust-lang.org/2018/05/10/Rust-1.26.html) and in the [Rust 2018 "
"edition guide](https://rust-lang-nursery.github.io/edition-guide/2018/"
"transitioning/traits/impl-trait.html). The edition guide primary describes "
"`impl Trait` intuitively, in terms of use cases. It does however contain the "
"following:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:110
msgid ""
"`impl Trait` in argument position are universal (universally quantified "
"types). Meanwhile, `impl Trait` in return position are existentials "
"(existentially quantified types)."
msgstr ""

#: src/2515-type_alias_impl_trait.md:112
msgid ""
"[This is incorrect](https://varkor.github.io/blog/2018/07/03/existential-"
"types-in-rust.html#confusion-2-return-position-impl-trait-vs-argument-"
"position-impl-trait) (albeit subtly): in fact, the distinction between "
"argument-position and return-position `impl Trait` is the scope of their "
"existential quantifier. This (understandable) mistake is pervasive and it's "
"not alone (the fact that those documenting the feature missed this is "
"indicative of the issues surrounding this mental model). The problem stems "
"from a poor understanding of what \"existential types\" are â€” which is "
"entirely unsurprising: existential types are a technical type theoretic "
"concept that are not widely encountered outside type theory (unlike "
"universally-quantified types, for instance). In discussions about "
"existential types in Rust, these sorts of confusions are endemic."
msgstr ""

#: src/2515-type_alias_impl_trait.md:114
msgid ""
"In any model that does not unify the meaning of `impl Trait` in various "
"positions, these technical explanations are likely to arise, as they provide "
"the original motivation for treating `impl Trait` nonhomogeneously. From "
"this perspective, it is valuable from documentation and explanatory angles "
"to unify the uses of `impl Trait` so that these types of questions never "
"even arise. Then we would have the ability to transition entirely away from "
"the topic of existentially-quantified types."
msgstr ""

#: src/2515-type_alias_impl_trait.md:116
msgid "Natural syntax"
msgstr ""

#: src/2515-type_alias_impl_trait.md:117
msgid ""
"Having explained `impl Trait` solely in terms of type inference (or less "
"formal equivalent explanations), the syntax proposed here is the only "
"natural syntax. Indeed, while discussing the syntax here, many express "
"surprise that this syntax has ever been under question (often from people "
"who think of `impl Trait` from an intuition about the feature's behaviour, "
"rather than thinking about the existential type perspective)."
msgstr ""

#: src/2515-type_alias_impl_trait.md:119
msgid ""
"The argument that is occasionally put forward: that this syntax makes type "
"aliases (or their uses) somehow contextual, is also addressed by the above "
"interpretation. Indeed, every use of an individual `impl Trait` type alias "
"refers to the same type. This argument is [detailed and addressed further in "
"**Drawbacks**](#drawbacks)."
msgstr ""

#: src/2515-type_alias_impl_trait.md:121
msgid ""
"The following section provides a documentation-style introductory "
"explanation for `impl Trait` that justifies the type alias syntax proposed "
"here."
msgstr ""

#: src/2515-type_alias_impl_trait.md:123
msgid "Guide-level explanation"
msgstr ""

#: src/2515-type_alias_impl_trait.md:126
msgid ""
"\\[Adapted from the [Rust 2018 edition guide](https://rust-lang-nursery."
"github.io/edition-guide/2018/transitioning/traits/impl-trait.html#more-"
"details).\\]"
msgstr ""

#: src/2515-type_alias_impl_trait.md:128
msgid ""
"`impl Trait` provides a way to specify unnamed concrete types with specific "
"bounds. You can currently use it in three places (to be extended in future "
"versions of Rust: see [the tracking issue](https://github.com/rust-lang/rust/"
"issues/34511) for more details):"
msgstr ""

#: src/2515-type_alias_impl_trait.md:129
msgid "Argument position"
msgstr ""

#: src/2515-type_alias_impl_trait.md:130
msgid "Return position"
msgstr ""

#: src/2515-type_alias_impl_trait.md:131
msgid "Type aliases"
msgstr ""

#: src/2515-type_alias_impl_trait.md:135
msgid "// Argument-position\n"
msgstr ""

#: src/2515-type_alias_impl_trait.md:138 src/2515-type_alias_impl_trait.md:143
#: src/2515-type_alias_impl_trait.md:160 src/2515-type_alias_impl_trait.md:170
#: src/2515-type_alias_impl_trait.md:176 src/2515-type_alias_impl_trait.md:217
#: src/2515-type_alias_impl_trait.md:232 src/2515-type_alias_impl_trait.md:237
#: src/2515-type_alias_impl_trait.md:256 src/2515-type_alias_impl_trait.md:262
msgid "// ...\n"
msgstr ""

#: src/2515-type_alias_impl_trait.md:140
msgid "// Return-position\n"
msgstr ""

#: src/2515-type_alias_impl_trait.md:145
msgid "// Type alias\n"
msgstr ""

#: src/2515-type_alias_impl_trait.md:150
msgid "How does `impl Trait` work?"
msgstr ""

#: src/2515-type_alias_impl_trait.md:151
msgid ""
"Whenever you write `impl Trait`, in any of the three places, you're saying "
"that you have _some type_ that implements `Trait`, but you don't want to "
"expose any more information than that. The concrete type that implements "
"`Trait` will be hidden, but you'll still be able to treat the type as if it "
"implements `Trait`: calling trait methods and so on."
msgstr ""

#: src/2515-type_alias_impl_trait.md:153
msgid ""
"The compiler will infer the concrete type, but other code won't be able to "
"make use of that fact. This is straightforward to describe, but it manifests "
"a little differently depending on the place it's used, so let's take a look "
"at some examples."
msgstr ""

#: src/2515-type_alias_impl_trait.md:155
msgid "Argument-position"
msgstr ""

#: src/2515-type_alias_impl_trait.md:164
msgid ""
"Here, we're saying that `foo` takes an argument whose type implements "
"`Trait`, but we're not saying exactly what it is. Thus, the caller can pass "
"a value of any type, as long as it implements `Trait`."
msgstr ""

#: src/2515-type_alias_impl_trait.md:166
msgid ""
"You may notice this sounds very like a generic type parameter. In fact, "
"functionally, using `impl Trait` in argument position is almost identical to "
"a generic type parameter."
msgstr ""

#: src/2515-type_alias_impl_trait.md:172
msgid "// is almost the same as:\n"
msgstr ""

#: src/2515-type_alias_impl_trait.md:180
msgid ""
"The only difference is that you can't use turbo-fish syntax for the first "
"definition (as turbo-fish syntax only works with explicit generic type "
"parameters). Thus, it's worth being mindful that switching between `impl "
"Trait` and generic type parameters can consistute a breaking change for "
"users of your code."
msgstr ""

#: src/2515-type_alias_impl_trait.md:182
msgid "Return-position"
msgstr ""

#: src/2515-type_alias_impl_trait.md:193
msgid ""
"Using `impl Trait` as a return type is more useful, as it enables us to do "
"things we weren't able to before. In this example, `bar` returns some type "
"that's not specified: it just asserts that the type implements `Trait`. "
"Inside the function, we can return any type that fits, but from the caller's "
"perspective, all they know is that the type implements the trait."
msgstr ""

#: src/2515-type_alias_impl_trait.md:195
msgid "This is useful especially for two things:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:196
msgid "Hiding (potentially complex) implementation details"
msgstr ""

#: src/2515-type_alias_impl_trait.md:197
msgid "Referring to types that were previously unnameable, such as closures"
msgstr ""

#: src/2515-type_alias_impl_trait.md:199
msgid ""
"\\[Here, we would also provide a more useful example, as in the [Rust 2018 "
"edition guide](https://rust-lang-nursery.github.io/edition-guide/2018/"
"transitioning/traits/impl-trait.html#impl-trait-and-closures).\\]"
msgstr ""

#: src/2515-type_alias_impl_trait.md:201
msgid "Type alias"
msgstr ""

#: src/2515-type_alias_impl_trait.md:208
msgid ""
"`impl Trait` type aliases are useful for declaring types that are "
"constrained by traits, but whose concrete type should be a hidden "
"implementation detail. We can use it in place of return-position `impl "
"Trait` as in the previous examples."
msgstr ""

#: src/2515-type_alias_impl_trait.md:214
msgid "// The same as `fn bar() -> impl Baz`\n"
msgstr ""

#: src/2515-type_alias_impl_trait.md:221
msgid ""
"However, if we use `Baz` in multiple locations, we constrain the concrete "
"type referred to by `Baz` to be the same, so we get a type that we know will "
"be the same everywhere and will satisfy specific bounds, whose concrete type "
"is hidden. This can be useful in libraries where you want to hide "
"implementation details."
msgstr ""

#: src/2515-type_alias_impl_trait.md:246
msgid ""
"In this example, the concrete type referred to by `Baz` is guaranteed to be "
"the same wherever `Baz` occurs."
msgstr ""

#: src/2515-type_alias_impl_trait.md:248
msgid ""
"Note that using `Baz` as an argument type is _not_ the same as argument-"
"position `impl Trait`, as `Baz` refers to a unique type, whereas the "
"concrete type for argument-position `impl Trait` is determined by the caller."
msgstr ""

#: src/2515-type_alias_impl_trait.md:258
msgid "// is *not* the same as:\n"
msgstr ""

#: src/2515-type_alias_impl_trait.md:266
msgid ""
"Just like with any other type alias, we can use `impl Trait` to specify "
"associated types for traits, as in the following example."
msgstr ""

#: src/2515-type_alias_impl_trait.md:280
msgid ""
"Here, anything that makes use of `Foo` knows that `Foo::Assoc` implements "
"`Debug`, but has no knowledge of its concrete type."
msgstr ""

#: src/2515-type_alias_impl_trait.md:282
msgid ""
"\\[Eventually, we would also describe the use of `impl Trait` in `let`, "
"`const` and `static` bindings, but as they are as-yet unimplemented and "
"function the same as return-type `impl Trait`, they haven't been included "
"here.\\]"
msgstr ""

#: src/2515-type_alias_impl_trait.md:284
msgid "Reference-level explanation"
msgstr ""

#: src/2515-type_alias_impl_trait.md:287
msgid ""
"Since RFC 2071 was accepted, the initial implementation of `existential "
"type` [has already been completed](https://github.com/rust-lang/rust/"
"pull/52024). This RFC would replace the syntax of `existential type`, from:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:293
msgid "to:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:299
msgid ""
"In addition, having multiple occurrences of `impl Trait` in a type alias or "
"associated type is now permitted, where each occurrence is desugared into a "
"separate inferred type. For example, the following alias:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:305
msgid "would be desugared to the equivalent of:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:313
msgid ""
"Furthermore, when documenting `impl Trait`, explanations of the feature "
"would avoid type theoretic terminology (specifically \"existential types\") "
"and prefer type inference language (if any technical description is needed "
"at all)."
msgstr ""

#: src/2515-type_alias_impl_trait.md:315
msgid ""
"`impl Trait` type aliases may contain generic parameters just like any other "
"type alias. The type alias must contain the same type parameters as its "
"concrete type, except those implicitly captured in the scope (see [RFC 2071]"
"(https://github.com/rust-lang/rfcs/blob/master/text/2071-impl-trait-"
"existential-types.md) for details)."
msgstr ""

#: src/2515-type_alias_impl_trait.md:318
msgid "// `impl Trait` type aliases may contain type parameters...\n"
msgstr ""

#: src/2515-type_alias_impl_trait.md:325
msgid "// ...and lifetime parameters (and so on).\n"
msgstr ""

#: src/2515-type_alias_impl_trait.md:335
msgid "Drawbacks"
msgstr ""

#: src/2515-type_alias_impl_trait.md:338
msgid ""
"This feature has already been accepted under a placeholder syntax, so the "
"only reason not to do this is if another syntax is chosen as a better "
"choice, from an ergonomic and consistency perspective."
msgstr ""

#: src/2515-type_alias_impl_trait.md:340
msgid ""
"There is one critique of the type alias syntax proposed here, which is "
"frequently brought up in discussions, regarding referential transparency."
msgstr ""

#: src/2515-type_alias_impl_trait.md:342
msgid "Consider the following code:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:345 src/2515-type_alias_impl_trait.md:346
#: src/2515-type_alias_impl_trait.md:358 src/2515-type_alias_impl_trait.md:359
#: src/2515-type_alias_impl_trait.md:367
msgid "/* ... */"
msgstr ""

#: src/2515-type_alias_impl_trait.md:349
msgid ""
"A user who has not come across `impl Trait` before might imagine that the "
"return type of both functions is the same (as synactically, they are). "
"However, because each occurrence of `impl Trait` defines a new type, the "
"return types are potentially distinct."
msgstr ""

#: src/2515-type_alias_impl_trait.md:351
msgid ""
"This is a problem inherent with `impl Trait` (and any other syntax that "
"determines a type contextually) and thus `impl Trait` type aliases have the "
"same caveat."
msgstr ""

#: src/2515-type_alias_impl_trait.md:353
msgid ""
"A user unaware of the behaviour of `impl Trait` might try refactoring this "
"example into the following:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:362
msgid ""
"This evidently means something different to what the user intended, because "
"here `SharedImplTrait` is inferred as a single type, shared with `foo` and "
"`bar`."
msgstr ""

#: src/2515-type_alias_impl_trait.md:364
msgid ""
"However, this problem is specifically with the behaviour of `impl Trait` and "
"not with the type aliases, whose behaviour is not altered. Specifically note "
"that, after this RFC, it is still true that for any type alias:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:370
msgid ""
"all uses of `Alias` refer to the same unique type. The potential confusion "
"is rather with whether all uses of `impl Trait` refer to the same unique "
"type (which is, of course, false)."
msgstr ""

#: src/2515-type_alias_impl_trait.md:372
msgid ""
"It is likely that a misunderstanding of the nature of `impl Trait` in "
"argument or return position will lead to similar confusion as to the role of "
"`impl Trait` in type aliases, and vice versa. By clearly teaching the "
"behaviour of `impl Trait`, we should be able to eliminate most of these "
"conceptual difficulties."
msgstr ""

#: src/2515-type_alias_impl_trait.md:374
msgid ""
"Since we will teach `impl Trait` cohesively (that is, argument-position, "
"return-position and type alias `impl Trait` at the same time), it is "
"unlikely that users who understand `impl Trait` will be confused about `impl "
"Trait` type aliases. (What's more, examples in the reference will illustrate "
"this clearly.)"
msgstr ""

#: src/2515-type_alias_impl_trait.md:376
msgid "Rationale and alternatives"
msgstr ""

#: src/2515-type_alias_impl_trait.md:378
msgid ""
"The justification for the type alias syntax proposed here comes down to two "
"key motvations:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:379
msgid "Consistency"
msgstr ""

#: src/2515-type_alias_impl_trait.md:380
msgid "Minimality"
msgstr ""

#: src/2515-type_alias_impl_trait.md:382
msgid ""
"Ideally a language should provide as small a surface area as possible. New "
"keywords or constructs add to the cognitive complexity of a language, "
"requiring users to look more concepts up or read larger guides to understand "
"code they read and want to write. If it is possible to add new capabilities "
"to the language that fit into the existing syntax and concepts, this "
"generally increases cohesion."
msgstr ""

#: src/2515-type_alias_impl_trait.md:384
msgid ""
"The syntax proposed here is a natural extension of the existing `impl Trait` "
"syntax and it is felt that, should users encounter it after seeing argument-"
"position and return-position `impl Trait`, its meaning will be immediately "
"clear. On the other hand, new keywords or syntax will require the user to "
"investigate further and provide more questions:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:385
msgid "\"Why can't I use `impl Trait` here?\""
msgstr ""

#: src/2515-type_alias_impl_trait.md:386
msgid "\"What's the difference between `impl Trait` and X?\""
msgstr ""

#: src/2515-type_alias_impl_trait.md:388
msgid ""
"Using different syntax, and then trying to justify the differences between "
"`impl Trait` and some new feature, seems likely to lead into conversations "
"about existential types, which are almost always unhelpful for understanding."
msgstr ""

#: src/2515-type_alias_impl_trait.md:390
msgid ""
"`type Foo = impl Bar;` has the additional benefit that it's easy to search "
"for and can appear alongside documentation for other uses of `impl Trait`."
msgstr ""

#: src/2515-type_alias_impl_trait.md:392
msgid ""
"The syntax `existential type` was intended to be a placeholder, so we need "
"to pick a syntax eventually for this feature. Justification for why this is "
"the best syntax, given the existing syntax in Rust, has been included "
"throughout the RFC."
msgstr ""

#: src/2515-type_alias_impl_trait.md:394
msgid "The other alternatives commonly given are:"
msgstr ""

#: src/2515-type_alias_impl_trait.md:395
msgid ""
"`type Foo: Bar;`, which suffers from complete and confusing inconsistency "
"with associated types. Although on the surface, they can appear similar to "
"existential types, by virtue of being a declaration that \"some type exists "
"\\[that will be provided\\]\", they are more closely related to type "
"parameters (which also declare that \"some type exists that will be "
"provided\"), though type parameters with [Haskell-style functional "
"dependencies](https://wiki.haskell.org/Functional_dependencies). This is "
"sure to lead to confusions as users wonder why two features with identical "
"syntax turn out to behave so differently."
msgstr ""

#: src/2515-type_alias_impl_trait.md:396
msgid ""
"Some other, new syntax for declaring a new type that acts in the same way as "
"`existential type`. Though a new syntax would not be inconsistent, it would "
"not be minimal, given that we can achieve the functionality using existing "
"syntax (`impl Trait`). What's more, if the syntax proposed here were _not_ "
"added alongside this new syntax, this would lead to inconsistencies with "
"`impl Trait`."
msgstr ""

#: src/2515-type_alias_impl_trait.md:398
msgid "Unresolved questions"
msgstr ""

#: src/2515-type_alias_impl_trait.md:401
msgid "None"
msgstr ""
