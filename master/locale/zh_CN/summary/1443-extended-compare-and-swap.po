msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:03Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1443-extended-compare-and-swap.md:1
msgid "Feature Name: `extended_compare_and_swap`"
msgstr ""

#: src/1443-extended-compare-and-swap.md:2
msgid "Start Date: 2016-01-05"
msgstr ""

#: src/1443-extended-compare-and-swap.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1443](https://github.com/rust-lang/rfcs/pull/1443)"
msgstr ""

#: src/1443-extended-compare-and-swap.md:4
msgid ""
"Rust Issue: [rust-lang/rust#31767](https://github.com/rust-lang/rust/"
"issues/31767)"
msgstr ""

#: src/1443-extended-compare-and-swap.md:6
msgid "Summary"
msgstr ""

#: src/1443-extended-compare-and-swap.md:9
msgid ""
"Rust currently provides a `compare_and_swap` method on atomic types, but "
"this method only exposes a subset of the functionality of the C++11 "
"equivalents [`compare_exchange_strong` and `compare_exchange_weak`](http://"
"en.cppreference.com/w/cpp/atomic/atomic/compare_exchange):"
msgstr ""

#: src/1443-extended-compare-and-swap.md:11
msgid ""
"`compare_and_swap` maps to the C++11 `compare_exchange_strong`, but there is "
"no Rust equivalent for `compare_exchange_weak`. The latter is allowed to "
"fail spuriously even when the comparison succeeds, which allows the compiler "
"to generate better assembly code when the compare and swap is used in a loop."
msgstr ""

#: src/1443-extended-compare-and-swap.md:13
msgid ""
"`compare_and_swap` only has a single memory ordering parameter, whereas the "
"C++11 versions have two: the first describes the memory ordering when the "
"operation succeeds while the second one describes the memory ordering on "
"failure."
msgstr ""

#: src/1443-extended-compare-and-swap.md:15
msgid "Motivation"
msgstr ""

#: src/1443-extended-compare-and-swap.md:18
msgid ""
"While all of these variants are identical on x86, they can allow more "
"efficient code to be generated on architectures such as ARM:"
msgstr ""

#: src/1443-extended-compare-and-swap.md:20
msgid ""
"On ARM, the strong variant of compare and swap is compiled into an `LDREX` / "
"`STREX` loop which restarts the compare and swap when a spurious failure is "
"detected. This is unnecessary for many lock-free algorithms since the "
"compare and swap is usually already inside a loop and a spurious failure is "
"often caused by another thread modifying the atomic concurrently, which will "
"probably cause the compare and swap to fail anyways."
msgstr ""

#: src/1443-extended-compare-and-swap.md:22
msgid ""
"When Rust lowers `compare_and_swap` to LLVM, it uses the same memory "
"ordering type for success and failure, which on ARM adds extra memory "
"barrier instructions to the failure path. Most lock-free algorithms which "
"make use of compare and swap in a loop only need relaxed ordering on failure "
"since the operation is going to be restarted anyways."
msgstr ""

#: src/1443-extended-compare-and-swap.md:24
msgid "Detailed design"
msgstr ""

#: src/1443-extended-compare-and-swap.md:27
msgid ""
"Since `compare_and_swap` is stable, we can't simply add a second memory "
"ordering parameter to it. This RFC proposes deprecating the "
"`compare_and_swap` function and replacing it with `compare_exchange` and "
"`compare_exchange_weak`, which match the names of the equivalent C++11 "
"functions (with the `_strong` suffix removed)."
msgstr ""

#: src/1443-extended-compare-and-swap.md:29
msgid "`compare_exchange`"
msgstr ""

#: src/1443-extended-compare-and-swap.md:31
#: src/1443-extended-compare-and-swap.md:51
msgid "A new method is instead added to atomic types:"
msgstr ""

#: src/1443-extended-compare-and-swap.md:37
msgid ""
"The restrictions on the failure ordering are the same as C++11: only "
"`SeqCst`, `Acquire` and `Relaxed` are allowed and it must be equal or weaker "
"than the success ordering. Passing an invalid memory ordering will result in "
"a panic, although this can often be optimized away since the ordering is "
"usually statically known."
msgstr ""

#: src/1443-extended-compare-and-swap.md:39
msgid ""
"The documentation for the original `compare_and_swap` is updated to say that "
"it is equivalent to `compare_exchange` with the following mapping for memory "
"orders:"
msgstr ""

#: src/1443-extended-compare-and-swap.md:41
msgid "Original"
msgstr ""

#: src/1443-extended-compare-and-swap.md:41
msgid "Success"
msgstr ""

#: src/1443-extended-compare-and-swap.md:41
msgid "Failure"
msgstr ""

#: src/1443-extended-compare-and-swap.md:43
#: src/1443-extended-compare-and-swap.md:45
msgid "Relaxed"
msgstr ""

#: src/1443-extended-compare-and-swap.md:44
#: src/1443-extended-compare-and-swap.md:46
msgid "Acquire"
msgstr ""

#: src/1443-extended-compare-and-swap.md:45
msgid "Release"
msgstr ""

#: src/1443-extended-compare-and-swap.md:46
msgid "AcqRel"
msgstr ""

#: src/1443-extended-compare-and-swap.md:47
msgid "SeqCst"
msgstr ""

#: src/1443-extended-compare-and-swap.md:49
msgid "`compare_exchange_weak`"
msgstr ""

#: src/1443-extended-compare-and-swap.md:57
msgid ""
"`compare_exchange` does not need to return a success flag because it can be "
"inferred by checking if the returned value is equal to the expected one. "
"This is not possible for `compare_exchange_weak` because it is allowed to "
"fail spuriously, which means that it could fail to perform the swap even "
"though the returned value is equal to the expected one."
msgstr ""

#: src/1443-extended-compare-and-swap.md:59
msgid ""
"A lock free algorithm using a loop would use the returned bool to determine "
"whether to break out of the loop, and if not, use the returned value for the "
"next iteration of the loop."
msgstr ""

#: src/1443-extended-compare-and-swap.md:61
msgid "Intrinsics"
msgstr ""

#: src/1443-extended-compare-and-swap.md:63
msgid "These are the existing intrinsics used to implement `compare_and_swap`:"
msgstr ""

#: src/1443-extended-compare-and-swap.md:73
msgid ""
"The following intrinsics need to be added to support relaxed memory "
"orderings on failure:"
msgstr ""

#: src/1443-extended-compare-and-swap.md:82
msgid ""
"The following intrinsics need to be added to support `compare_exchange_weak`:"
msgstr ""

#: src/1443-extended-compare-and-swap.md:96
msgid "Drawbacks"
msgstr ""

#: src/1443-extended-compare-and-swap.md:99
msgid ""
"Ideally support for failure memory ordering would be added by simply adding "
"an extra parameter to the existing `compare_and_swap` function. However this "
"is not possible because `compare_and_swap` is stable."
msgstr ""

#: src/1443-extended-compare-and-swap.md:101
msgid ""
"This RFC proposes deprecating a stable function, which may not be desirable."
msgstr ""

#: src/1443-extended-compare-and-swap.md:103
msgid "Alternatives"
msgstr ""

#: src/1443-extended-compare-and-swap.md:106
msgid ""
"One alternative for supporting failure orderings is to add new enum variants "
"to `Ordering` instead of adding new methods with two ordering parameters. "
"The following variants would need to be added: `AcquireFailRelaxed`, "
"`AcqRelFailRelaxed`, `SeqCstFailRelaxed`, `SeqCstFailAcquire`. The downside "
"is that the names are quite ugly and are only valid for `compare_and_swap`, "
"not other atomic operations. It is also a breaking change to a stable enum."
msgstr ""

#: src/1443-extended-compare-and-swap.md:108
msgid ""
"Another alternative is to not deprecate `compare_and_swap` and instead add "
"`compare_and_swap_explicit`, `compare_and_swap_weak` and "
"`compare_and_swap_weak_explicit`. However the distiniction between the "
"explicit and non-explicit isn't very clear and can lead to some confusion."
msgstr ""

#: src/1443-extended-compare-and-swap.md:110
msgid ""
"Not doing anything is also a possible option, but this will cause Rust to "
"generate worse code for some lock-free algorithms."
msgstr ""

#: src/1443-extended-compare-and-swap.md:112
msgid "Unresolved questions"
msgstr ""

#: src/1443-extended-compare-and-swap.md:115
msgid "None"
msgstr ""
