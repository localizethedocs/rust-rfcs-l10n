msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:44Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2089-implied-bounds.md:1
msgid "Feature Name: `implied_bounds`"
msgstr ""

#: src/2089-implied-bounds.md:2
msgid "Start Date: 2017-07-28"
msgstr ""

#: src/2089-implied-bounds.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2089](https://github.com/rust-lang/rfcs/pull/2089)"
msgstr ""

#: src/2089-implied-bounds.md:4
msgid ""
"Rust Issue: [rust-lang/rust#44491](https://github.com/rust-lang/rust/"
"issues/44491)"
msgstr ""

#: src/2089-implied-bounds.md:6
msgid "Summary"
msgstr ""

#: src/2089-implied-bounds.md:9
msgid ""
"Eliminate the need for “redundant” bounds on functions and impls where those "
"bounds can be inferred from the input types and other trait bounds. For "
"example, in this simple program, the impl would no longer require a bound, "
"because it can be inferred from the `Foo<T>` type:"
msgstr ""

#: src/2089-implied-bounds.md:14
msgid "//    ^^^^^ this bound is redundant\n"
msgstr ""

#: src/2089-implied-bounds.md:18
msgid ""
"Hence, simply writing `impl<T> Foo<T> { ... }` would suffice. We currently "
"support implied bounds for lifetime bounds, super traits and projections. We "
"propose to extend this to all where clauses on traits and types, as was "
"already discussed [here](https://internals.rust-lang.org/t/lang-team-minutes-"
"implied-bounds/4905)."
msgstr ""

#: src/2089-implied-bounds.md:20
msgid "Motivation"
msgstr ""

#: src/2089-implied-bounds.md:23
msgid "Types"
msgstr ""

#: src/2089-implied-bounds.md:25
msgid ""
"Let's take an example from the standard library where trait bounds are "
"actually expressed on a type¹."
msgstr ""

#: src/2089-implied-bounds.md:34
msgid "The `ToOwned` bound has then to be carried everywhere:"
msgstr ""

#: src/2089-implied-bounds.md:54
msgid ""
"even if one does not actually care about the semantics implied by `ToOwned`:"
msgstr ""

#: src/2089-implied-bounds.md:56
msgid "//      where B: ToOwned\n"
msgstr ""

#: src/2089-implied-bounds.md:63
msgid "//  ^ the trait `std::borrow::ToOwned` is not implemented for `B`\n"
msgstr ""

#: src/2089-implied-bounds.md:66
msgid ""
"However what we know is that if `Cow<'a, B>` is well-formed, then `B` _has_ "
"to implement `ToOwned`. We would say that such a bound is _implied_ by the "
"well-formedness of `Cow<'a, B>`."
msgstr ""

#: src/2089-implied-bounds.md:68
msgid ""
"Currently, impls and functions have to prove that their arguments are well-"
"formed. Under this proposal, they would _assume_ that their arguments are "
"well-formed, leaving the responsibility for proving well-formedness to the "
"caller. Hence we would be able to drop the `B: ToOwned` bounds in the "
"previous examples."
msgstr ""

#: src/2089-implied-bounds.md:70
msgid ""
"Beside reducing repeated constraints, it would also provide a clearer "
"separation between what bounds a type needs so that it is well-formed, and "
"what additional bounds an `fn` or an `impl` actually needs:"
msgstr ""

#: src/2089-implied-bounds.md:76
msgid "// VS\n"
msgstr ""

#: src/2089-implied-bounds.md:82
msgid "Moreover, we already support implied lifetime bounds on types:"
msgstr ""

#: src/2089-implied-bounds.md:89
msgid ""
"//  where 'b: 'a\n"
"//  ^^^^^^^^^^^^  this is not needed\n"
msgstr ""

#: src/2089-implied-bounds.md:93
msgid "/* inside here: assume that `'b: 'a` */"
msgstr ""

#: src/2089-implied-bounds.md:96
msgid ""
"This RFC proposes to extend this sort of logic beyond these special cases "
"and use it uniformly for both trait bounds and lifetime bounds."
msgstr ""

#: src/2089-implied-bounds.md:98
msgid ""
"¹Actually only a few types in the standard library have bounds, for example "
"`HashSet<T>` does not have a `T: Hash + Eq` on the type declaration, but on "
"the impl declaration rather. Whether we should prefer bounds on types or on "
"impls is related, but beyond the scope of this RFC."
msgstr ""

#: src/2089-implied-bounds.md:100
msgid "Traits"
msgstr ""

#: src/2089-implied-bounds.md:102
msgid ""
"Traits also currently support some form of implied bounds, namely super "
"traits bounds:"
msgstr ""

#: src/2089-implied-bounds.md:104
msgid "// Equivalent to `trait Foo where Self: From<Bar>`.\n"
msgstr ""

#: src/2089-implied-bounds.md:108
msgid "// `T: From<Bar>` is implied by `T: Foo`.\n"
msgstr ""

#: src/2089-implied-bounds.md:112
msgid "and bounds on projections:"
msgstr ""

#: src/2089-implied-bounds.md:114
msgid "// Equivalent to `trait Foo where Self::Item: Eq`.\n"
msgstr ""

#: src/2089-implied-bounds.md:122
msgid "// `T::Item: Eq` is implied by `T: Foo`.\n"
msgstr ""

#: src/2089-implied-bounds.md:126
msgid "However, this example does not compile:"
msgstr ""

#: src/2089-implied-bounds.md:134
msgid "//  ^ the trait `std::cmp::Eq` is not implemented for `U`\n"
msgstr ""

#: src/2089-implied-bounds.md:137
msgid ""
"Again we propose to uniformly support implied bounds for all where clauses "
"on trait definitions."
msgstr ""

#: src/2089-implied-bounds.md:139
msgid "Guide-Level Explanation"
msgstr ""

#: src/2089-implied-bounds.md:142
msgid ""
"When you declare bounds on a type, you don't have to repeat them when "
"writing impls and functions as soon as the type appear in the signature or "
"the impl header:"
msgstr ""

#: src/2089-implied-bounds.md:149
msgid "// You can rely on the fact that `T: Hash + Eq` inside here.\n"
msgstr ""

#: src/2089-implied-bounds.md:154
msgid ""
"// Same here, and you can also rely on the `T: Clone` bound of course.\n"
msgstr ""

#: src/2089-implied-bounds.md:161
msgid ""
"// We know that `T: Eq` because we have a `Set<T>` as an argument, and there "
"already is a\n"
"    // `T: Eq` bound on the declaration of `Set`.\n"
msgstr ""

#: src/2089-implied-bounds.md:165
msgid "// This also works for the return type: no need to repeat bounds.\n"
msgstr ""

#: src/2089-implied-bounds.md:172
msgid "Lifetime bounds are supported as well (this is already the case today):"
msgstr ""

#: src/2089-implied-bounds.md:179
msgid "// No need to repeat `where 'b: 'a`, it is assumed.\n"
msgstr ""

#: src/2089-implied-bounds.md:183
msgid ""
"However, you still have to write the bounds explicitly if the type does not "
"appear in the function signature or the impl header:"
msgstr ""

#: src/2089-implied-bounds.md:185
msgid ""
"// `Set<T>` does not appear in the fn signature: we need to explicitly write "
"the bounds.\n"
msgstr ""

#: src/2089-implied-bounds.md:191
msgid ""
"Similarly, you don't have to repeat bounds that you write on a trait "
"declaration as soon as you know that the trait reference holds:"
msgstr ""

#: src/2089-implied-bounds.md:198
msgid ""
"// We know that `T: Foo` holds so given the trait declaration, we know that "
"`Bar: Into<T>`.\n"
msgstr ""

#: src/2089-implied-bounds.md:203
msgid "Note that this is transitive:"
msgstr ""

#: src/2089-implied-bounds.md:212
msgid ""
"// We know that `T: Baz`, hence we know that `T: Bar`, hence we know that "
"`T: Foo`.\n"
msgstr ""

#: src/2089-implied-bounds.md:217
msgid "This also works for bounds on associated types:"
msgstr ""

#: src/2089-implied-bounds.md:224
msgid ""
"// We know that `<T as Foo>::Item` implements `Debug` because of the trait "
"declaration.\n"
"    // Moreover, we know that `<T as Foo>::Item` is `U`.\n"
"    // Hence, we know that `U` implements `Debug`.\n"
msgstr ""

#: src/2089-implied-bounds.md:227
msgid "\"{:?}\""
msgstr ""

#: src/2089-implied-bounds.md:229
msgid "/* do something else with `T` and `U`... */"
msgstr ""

#: src/2089-implied-bounds.md:233
msgid "Reference-Level Explanation"
msgstr ""

#: src/2089-implied-bounds.md:236
msgid ""
"This is the fully-detailed design and you probably don't need to read "
"everything. This design has already been experimented on [Chalk](https://"
"github.com/nikomatsakis/chalk), to some extent. The current design has been "
"driven by issue [\\#12](https://github.com/nikomatsakis/chalk/issues/12), it "
"is a good read to understand why we _need_ to expand where clauses as "
"described below."
msgstr ""

#: src/2089-implied-bounds.md:238
msgid ""
"We'll use the grammar from [RFC 1214](https://github.com/rust-lang/rfcs/blob/"
"master/text/1214-projections-lifetimes-and-wf.md) to detail the rules:"
msgstr ""

#: src/2089-implied-bounds.md:239
msgid ""
"```\n"
"T = scalar (i32, u32, ...)              // Boring stuff\n"
"  | X                                   // Type variable\n"
"  | Id<P0, ..., Pn>                     // Nominal type (struct, enum)\n"
"  | &r T                                // Reference (mut doesn't matter "
"here)\n"
"  | O0 + ... + On + r                   // Object type\n"
"  | [T]                                 // Slice type\n"
"  | for<r...> fn(T1, ..., Tn) -> T0     // Function pointer\n"
"  | <P0 as Trait<P1, ..., Pn>>::Id      // Projection\n"
"P = r                                   // Region name\n"
"  | T                                   // Type\n"
"O = for<r...> TraitId<P1, ..., Pn>      // Object type fragment\n"
"r = 'x                                  // Region name\n"
"```"
msgstr ""

#: src/2089-implied-bounds.md:254
msgid ""
"We'll use the same notations as [RFC 1214](https://github.com/rust-lang/rfcs/"
"blob/master/text/1214-projections-lifetimes-and-wf.md) for the set `R = "
"<r0, ..., rn>` denoting the set of lifetimes currently bound."
msgstr ""

#: src/2089-implied-bounds.md:256
msgid "Well-formedness rules"
msgstr ""

#: src/2089-implied-bounds.md:257
msgid ""
"Basically, we say that something (type or trait reference) is well-formed if "
"the bounds declared on it are met, _regardless of the well-formedness of its "
"parameters_: this is the main difference with [RFC 1214](https://github.com/"
"rust-lang/rfcs/blob/master/text/1214-projections-lifetimes-and-wf.md)."
msgstr ""

#: src/2089-implied-bounds.md:259
msgid "We will write:"
msgstr ""

#: src/2089-implied-bounds.md:260
msgid "`WF(T: Trait)` for a trait reference `T: Trait` being well-formed"
msgstr ""

#: src/2089-implied-bounds.md:261
msgid "`WF(T)` for a reference to the type `T` being well-formed"
msgstr ""

#: src/2089-implied-bounds.md:263
msgid "**Trait refs**"
msgstr ""

#: src/2089-implied-bounds.md:264
msgid ""
"We'll start with well-formedness for trait references. The important thing "
"is that we distinguish between `T: Trait` and `WF(T: Trait)`. The former "
"means that an impl for `T` has been found while the latter means that `T` "
"meets the bounds on trait `Trait`."
msgstr ""

#: src/2089-implied-bounds.md:266
msgid ""
"We'll also consider a function `Expanded` applying on where clauses like "
"this:"
msgstr ""

#: src/2089-implied-bounds.md:272
msgid ""
"We naturally extend `Expanded` so that it applies on a finite set of where "
"clauses:"
msgstr ""

#: src/2089-implied-bounds.md:276
msgid ""
"_**Every where clause**_ a user writes will be expanded through the "
"`Expanded` function. This means that the following impl:"
msgstr ""

#: src/2089-implied-bounds.md:280
msgid "will give the following rule:"
msgstr ""

#: src/2089-implied-bounds.md:287
msgid "Now let's see the actual rule for a trait reference being well-formed:"
msgstr ""

#: src/2089-implied-bounds.md:288
msgid ""
"```\n"
"WfTraitReference:\n"
"  C = Expanded(WhereClauses(TraitId))   // the conditions declared on "
"TraitId must hold...\n"
"  R, r... ⊢ [P0, ..., Pn] C             // ...after substituting parameters, "
"of course\n"
"  --------------------------------------------------\n"
"  R ⊢ WF(for<r...> P0: TraitId<P1, ..., Pn>)\n"
"```"
msgstr ""

#: src/2089-implied-bounds.md:296
msgid "And here is an example:"
msgstr ""

#: src/2089-implied-bounds.md:298
msgid "// `WF(Self: SuperTrait)` holds.\n"
msgstr ""

#: src/2089-implied-bounds.md:300
msgid ""
"// `WF(Self: Trait)` holds if `Self: SuperTrait`, `WF(Self: Supertrait)`.\n"
msgstr ""

#: src/2089-implied-bounds.md:303
msgid ""
"// `i32: Trait` holds but not `WF(i32: Trait)`.\n"
"// This would be flagged as an error.\n"
msgstr ""

#: src/2089-implied-bounds.md:307
msgid "// Both `f32: Trait` and `WF(f32: Trait)` hold.\n"
msgstr ""

#: src/2089-implied-bounds.md:313
msgid "**Types**"
msgstr ""

#: src/2089-implied-bounds.md:315
msgid "The well-formedness rules for types are given by:"
msgstr ""

#: src/2089-implied-bounds.md:316
msgid ""
"```\n"
"WfScalar:\n"
"  --------------------------------------------------\n"
"  R ⊢ WF(scalar)\n"
"\n"
"WfFn:                              // an fn pointer is always WF since it "
"only carries parameters\n"
"  --------------------------------------------------\n"
"  R ⊢ WF(for<r...> fn(T1, ..., Tn) -> T0)\n"
"\n"
"WfObject:\n"
"  rᵢ = union of implied region bounds from Oi\n"
"  ∀i. rᵢ: r\n"
"  --------------------------------------------------\n"
"  R ⊢ WF(O0 + ... + On + r)\n"
"\n"
"WfObjectFragment:\n"
"  TraitId is object safe\n"
"  --------------------------------------------------\n"
"  R ⊢ WF(for<r...> TraitId<P1, ..., Pn>)\n"
"\n"
"WfTuple:\n"
"  ∀i<n. R ⊢ Ti: Sized              // the *last* field may be unsized\n"
"  --------------------------------------------------\n"
"  R ⊢ WF((T1, ... ,Tn))\n"
"\n"
"WfNominalType:\n"
"  C = Expanded(WhereClauses(Id))   // the conditions declared on Id must "
"hold...\n"
"  R ⊢ [P1, ..., Pn] C              // ...after substituting parameters, of "
"course\n"
"  --------------------------------------------------\n"
"  R ⊢ WF(Id<P1, ..., Pn>)\n"
"\n"
"WfReference:\n"
"  R ⊢ T: 'x                        // T must outlive 'x\n"
"  --------------------------------------------------\n"
"  R ⊢ WF(&'x T)\n"
"\n"
"WfSlice:\n"
"  R ⊢ T: Sized\n"
"  --------------------------------------------------\n"
"  R ⊢ WF([T])\n"
"\n"
"WfProjection:\n"
"  R ⊢ P0: Trait<P1, ..., Pn>       // the trait reference holds\n"
"  R ⊢ WF(P0: Trait<P1, ..., Pn>)   // the trait reference is well-formed\n"
"  --------------------------------------------------\n"
"  R ⊢ WF(<P0 as Trait<P1, ..., Pn>>::Id)\n"
"```"
msgstr ""

#: src/2089-implied-bounds.md:363
msgid ""
"Taking again our `SuperTrait` and `Trait` from above, here is an example:"
msgstr ""

#: src/2089-implied-bounds.md:365
msgid "// `WF(Struct<T>)` holds if `T: Trait`, `WF(T: Trait)`.\n"
msgstr ""

#: src/2089-implied-bounds.md:369
msgid ""
"// `WF(Struct<i32>)` would not hold since `WF(i32: Trait)` doesn't.\n"
"// But `WF(Struct<f32>)` does hold.\n"
msgstr ""

#: src/2089-implied-bounds.md:374
msgid "Reverse rules"
msgstr ""

#: src/2089-implied-bounds.md:375
msgid ""
"This is a core element of this RFC. Morally, the well-formedness rules are "
"\"if and only if\" rules. We thus add reverse rules for each relevant WF "
"rule:"
msgstr ""

#: src/2089-implied-bounds.md:376
msgid ""
"```\n"
"ReverseWfTraitReferenceᵢ\n"
"  // Substitute parameters\n"
"  { WhereClause1, ..., WhereClauseN } = [P0, ..., Pn] "
"Expanded(WhereClauses(TraitId))\n"
"  R ⊢ WF(for<r...> P0: TraitId<P1, ..., Pn>)\n"
"  --------------------------------------------------\n"
"  R, r... ⊢ WhereClauseᵢ\n"
"\n"
"ReverseWfTupleᵢ, i < n:\n"
"  R ⊢ WF((T1, ..., Tn))\n"
"  --------------------------------------------------\n"
"  R ⊢ Ti: Sized   // not very useful since this bound is often implicit\n"
"\n"
"ReverseWfNominalTypeᵢ:\n"
"  // Substitute parameters\n"
"  { WhereClause1, ..., WhereClauseN } = [P1, ..., Pn] "
"Expanded(WhereClauses(id))\n"
"  R ⊢ WF(Id<P1, ..., Pn>)\n"
"  --------------------------------------------------\n"
"  R ⊢ WhereClauseᵢ\n"
"\n"
"ReverseWfReference:\n"
"  R ⊢ WF(&'x T)\n"
"  --------------------------------------------------\n"
"  R ⊢ T: 'x\n"
"\n"
"ReverseWfSlice:\n"
"  R ⊢ WF([T])\n"
"  --------------------------------------------------\n"
"  R ⊢ T: Sized    // same as above\n"
"```"
msgstr ""

#: src/2089-implied-bounds.md:407
msgid ""
"Note that we add reverse rules for all _**expanded**_ where clauses, this "
"means that given:"
msgstr ""

#: src/2089-implied-bounds.md:409
msgid "// Expands to `trait Foo where Self: Bar, WF(Self: Bar)`\n"
msgstr ""

#: src/2089-implied-bounds.md:412
msgid "we have two reverse rules given by:"
msgstr ""

#: src/2089-implied-bounds.md:423
msgid ""
"**Remark**: Reverse rules include implicit `Sized` bounds on type "
"declarations. However, they do not include (explicit) `?Sized` bounds since "
"those are not _real_ trait bounds, but only a way to disable the implicit "
"`Sized` bound."
msgstr ""

#: src/2089-implied-bounds.md:425
msgid "Input types"
msgstr ""

#: src/2089-implied-bounds.md:426
msgid ""
"We define the notion of input types of a type. Basically, input types refer "
"to all types that are accessible from referencing to a specific type. For "
"example, a function will assume that the input types of its arguments are "
"well-formed, hence in the body of that function we'll be able to derive "
"implied bounds thanks to the reverse rules described earlier."
msgstr ""

#: src/2089-implied-bounds.md:428
msgid ""
"We'll denote by `InputTypes` the function which maps a type to its input "
"types, defined by:"
msgstr ""

#: src/2089-implied-bounds.md:429
msgid ""
"```\n"
"// Scalar\n"
"InputTypes(scalar) = { scalar }\n"
"\n"
"// Type variable\n"
"InputTypes(X) = { X }\n"
"\n"
"// Region name\n"
"InputTypes(r) = { }\n"
"\n"
"// Reference\n"
"InputTypes(&r T) = Union({ &r T }, InputTypes(T))\n"
"\n"
"// Slice type\n"
"InputTypes([T]) = Union({ [T] }, InputTypes(T))\n"
"\n"
"// Nominal type\n"
"InputTypes(Id<P0, ..., Pn>) = Union({ Id<P0, ..., Pn> }, "
"InputTypes(P0), ..., InputTypes(Pn))\n"
"\n"
"// Object type\n"
"InputTypes(O0 + ... + On + r) = Union({ O0 + ... + On + r }, "
"InputTypes(O0), ..., InputTypes(On))\n"
"\n"
"// Object type fragment\n"
"InputTypes(for<r...> TraitId<P1, ..., Pn>) = { for<r...> TraitId<P1, ..., "
"Pn> }\n"
"\n"
"// Function pointer\n"
"InputTypes(for<r...> fn(T1, ..., Tn) -> T0) = { for<r...> fn(T1, ..., Tn) -> "
"T0 }\n"
"\n"
"// Projection\n"
"InputTypes(<P0 as Trait<P1, ..., Pn>>::Id) = Union(\n"
"    { <P0 as Trait<P1, ..., Pn>>::Id },\n"
"    InputTypes(P0),\n"
"    InputTypes(P1),\n"
"    ...,\n"
"    InputTypes(Pn)\n"
")\n"
"```"
msgstr ""

#: src/2089-implied-bounds.md:467
msgid ""
"Note that higher-ranked types (functions, object type fragments) do not "
"carry input types other than themselves. This is because they are unusable "
"_as such_, one will have to use them in a lower-ranked way at some point (e."
"g. calling a function) and will thus rely on `InputTypes` for normal types."
msgstr ""

#: src/2089-implied-bounds.md:469
msgid "Assumptions and checking well-formedness"
msgstr ""

#: src/2089-implied-bounds.md:470
msgid ""
"This is the other core element: how to use reverse rules. Basically, "
"functions and impls will assume that their input types are well-formed, and "
"that (expanded) where clauses hold."
msgstr ""

#: src/2089-implied-bounds.md:472
msgid "**Functions**"
msgstr ""

#: src/2089-implied-bounds.md:473
msgid "Given a function declaration:"
msgstr ""

#: src/2089-implied-bounds.md:476
msgid "/* body of the function inside here */"
msgstr ""

#: src/2089-implied-bounds.md:479
msgid "We rely on the following assumptions inside the body of `F`:"
msgstr ""

#: src/2089-implied-bounds.md:480 src/2089-implied-bounds.md:562
#: src/2089-implied-bounds.md:634
msgid "`Expanded({ WhereClause1, ..., WhereClausek })`"
msgstr ""

#: src/2089-implied-bounds.md:481
msgid ""
"`WF(T)` for all `T ∈ Union(InputTypes(T0), InputTypes(T1), ..., "
"InputTypes(Tm))`"
msgstr ""

#: src/2089-implied-bounds.md:482 src/2089-implied-bounds.md:564
#: src/2089-implied-bounds.md:636
msgid "`WF(Xi)` for all `i`"
msgstr ""

#: src/2089-implied-bounds.md:484
msgid ""
"Note that we assume that the input types of the return type `T0` are well-"
"formed."
msgstr ""

#: src/2089-implied-bounds.md:486
msgid ""
"With these assumptions, the function must be able to prove that everything "
"that appears in its body is well-formed (e.g. every type appearing in the "
"body, projections, etc)."
msgstr ""

#: src/2089-implied-bounds.md:488
msgid ""
"Moreover, a caller of `F` would have to prove that the where clauses on `F` "
"hold, after having substituted parameters."
msgstr ""

#: src/2089-implied-bounds.md:490
msgid ""
"**Remark**: Notice that we assume that the type variables `Xi` are well-"
"formed for all `i`. This way, type variables don't need a special treatment "
"regarding well-formedness. See example below."
msgstr ""

#: src/2089-implied-bounds.md:492 src/2089-implied-bounds.md:572
msgid "Examples:"
msgstr ""

#: src/2089-implied-bounds.md:501
msgid ""
"// Inside the body, we have to prove `WF(T)`, `WF(Box<T>)`, and `Box<T>: "
"Bar`.\n"
"    // Because we assume that `WF(T: Foo)`, we indeed have `Box<T>: Bar`.\n"
msgstr ""

#: src/2089-implied-bounds.md:507
msgid "// We have to prove `WF(i32)`, `i32: Foo`.\n"
msgstr ""

#: src/2089-implied-bounds.md:513
msgid ""
"/// Illustrate remark 2: no need for a special treatment for type "
"variables.\n"
msgstr ""

#: src/2089-implied-bounds.md:520
msgid ""
"// We have to prove `WF(T)`, `WF(Set<T>)`. `WF(T)` trivially holds because "
"of the assumption\n"
"    // made by the function `one_variable`. `WF(Set<T>)` holds because of "
"the `T: Hash` bound.\n"
msgstr ""

#: src/2089-implied-bounds.md:526
msgid "// We have to prove `WF(i32)`.\n"
msgstr ""

#: src/2089-implied-bounds.md:532
msgid "/// Illustrate \"inner\" input types and transitivity\n"
msgstr ""

#: src/2089-implied-bounds.md:542
msgid "/* do something with arg */"
msgstr ""

#: src/2089-implied-bounds.md:544
msgid ""
"// Since `Struct<T>` is an input type, we assume that `WF(Struct<T>)` hence "
"`WF(T: Baz)`\n"
"    // hence `WF(T: Bar)` hence `Box<T>: Eq`\n"
msgstr ""

#: src/2089-implied-bounds.md:550
msgid "**Trait impls**"
msgstr ""

#: src/2089-implied-bounds.md:551
msgid "Given a trait impl:"
msgstr ""

#: src/2089-implied-bounds.md:554
msgid "// body of the impl inside here\n"
msgstr ""

#: src/2089-implied-bounds.md:558
msgid "/* ... */"
msgstr ""

#: src/2089-implied-bounds.md:561 src/2089-implied-bounds.md:633
msgid "We rely on the following assumptions inside the body of the impl:"
msgstr ""

#: src/2089-implied-bounds.md:563
msgid ""
"`WF(T)` for all `T ∈ Union(InputTypes(T0), InputTypes(T1), ..., "
"InputTypes(Tn))`"
msgstr ""

#: src/2089-implied-bounds.md:566
msgid ""
"Based on these assumptions, the impl declaration has to prove `WF(T0: "
"Trait<r'..., T1, ..., Tn>)` and `WF(T)` for all `T ∈ "
"InputTypes(AssocTyValue)`. Note that associated fns can be seen as (higher-"
"kinded) associated types, but since fn pointers are always well-formed and "
"do not carry input types other than themselves, this is fine."
msgstr ""

#: src/2089-implied-bounds.md:568
msgid ""
"Associated fns make their normal assumptions + the set of assumptions made "
"by the impl. Things to prove inside associated fns do not differ from normal "
"fns."
msgstr ""

#: src/2089-implied-bounds.md:570
msgid ""
"Note that when projecting out of a type, one must automatically prove that "
"the trait reference holds because of the `WfProjection` rule."
msgstr ""

#: src/2089-implied-bounds.md:584
msgid ""
"// Inside here: we assume `WF(Set<K>)`, `K: Clone`, `WF(K: Clone)`, "
"`WF(K)`.\n"
"    // Also, we must prove `WF(Set<K>: Foo)`.\n"
msgstr ""

#: src/2089-implied-bounds.md:599
msgid ""
"// We need an explicit `K: Hash` bound in order to prove that the associated "
"type value `Set<K>` is WF.\n"
msgstr ""

#: src/2089-implied-bounds.md:616
msgid ""
"// We must prove `WF(<T as Foo>::Item)` hence prove that `T: Foo`: ok this "
"is in our assumptions.\n"
msgstr ""

#: src/2089-implied-bounds.md:621
msgid ""
"// We must prove `WF(<T as Foo>::Item)` hence prove that `T: Foo`: ok, use "
"the impl.\n"
msgstr ""

#: src/2089-implied-bounds.md:626
msgid "**Inherent impls**"
msgstr ""

#: src/2089-implied-bounds.md:627
msgid "Given an inherent impl:"
msgstr ""

#: src/2089-implied-bounds.md:630
msgid "/* body of the impl inside here */"
msgstr ""

#: src/2089-implied-bounds.md:635
msgid "`WF(T)` for all `T ∈ InputTypes(SelfTy)`"
msgstr ""

#: src/2089-implied-bounds.md:638
msgid ""
"Methods make their normal assumptions + the set of assumptions made by the "
"impl. Things to prove inside methods do not differ from normal fns."
msgstr ""

#: src/2089-implied-bounds.md:640
msgid ""
"A caller of a method has to prove that the where clauses defined on the impl "
"hold, in addition to the requirements for calling general fns."
msgstr ""

#: src/2089-implied-bounds.md:642
msgid "Proving well-formedness for input types"
msgstr ""

#: src/2089-implied-bounds.md:645
msgid ""
"One would have noticed that we only prove well-formedness for input types in "
"a lazy way (e.g., inside function bodies). This means that if we have a "
"function:"
msgstr ""

#: src/2089-implied-bounds.md:652
msgid ""
"then no error will be caught until someone actually tries to call `foo`. "
"Same thing for an impl:"
msgstr ""

#: src/2089-implied-bounds.md:656
msgid ""
"the error will not be caught until someone actually uses `Set<NotHash>`."
msgstr ""

#: src/2089-implied-bounds.md:658
msgid ""
"The idea is, when encountering an fn/trait impl/inherent impl, retrieve all "
"input types that appear in the signature / header and for each input type "
"`T`, do the following: retrieve type variables `X1, ..., Xn` bound by the "
"declaration and ask for `∃X1, ..., ∃Xn; WF(T)` in an empty environment (in "
"Chalk terms). If there is no possible substitution for the existentials, "
"output a warning."
msgstr ""

#: src/2089-implied-bounds.md:660
msgid "Example:"
msgstr ""

#: src/2089-implied-bounds.md:663
msgid ""
"// `NotHash` is local to this crate, so we know that there exists no `T`\n"
"// such that `NotHash<T>: Hash`.\n"
msgstr ""

#: src/2089-implied-bounds.md:667
msgid "// Warning: `foo` cannot be called whatever the value of `T`\n"
msgstr ""

#: src/2089-implied-bounds.md:672
msgid "Cycle detection"
msgstr ""

#: src/2089-implied-bounds.md:673
msgid "In Chalk this design often leads to cycles in the proof tree. Example:"
msgstr ""

#: src/2089-implied-bounds.md:675
msgid "// `WF(Self: Foo)` holds.\n"
msgstr ""

#: src/2089-implied-bounds.md:679
msgid "// Expanded to `trait Bar where Self: Foo, WF(Self: Foo)`\n"
msgstr ""

#: src/2089-implied-bounds.md:682
msgid ""
"// WF rule:\n"
"// `WF(Self: Bar)` holds if `Self: Foo`, `WF(Self: Foo)`.\n"
msgstr ""

#: src/2089-implied-bounds.md:685
msgid ""
"// Reverse WF rules:\n"
"// `Self: Foo` holds if `WF(Self: Bar)`\n"
"// `WF(Self: Foo)` holds if `WF(Self: Bar)`\n"
msgstr ""

#: src/2089-implied-bounds.md:690
msgid ""
"Now suppose we are asking whether `u8: Foo` holds. The following branch "
"exists in the proof tree: `u8: Foo` holds if `WF(u8: Bar)` holds if `u8: "
"Foo` holds."
msgstr ""

#: src/2089-implied-bounds.md:693
msgid ""
"I _think_ rustc would have the right behavior currently: just dismiss this "
"branch since it only leads to the tautological rule `(u8: Foo) if (u8: Foo)`."
msgstr ""

#: src/2089-implied-bounds.md:695
msgid ""
"In Chalk we have a more sophisticated cycle detection strategy based on "
"tabling, which basically enables us to correctly answer \"multiple "
"solutions\", instead of \"unique solution\" if a simple _error-on-cycle_ "
"strategy were used. Would rustc need such a thing?"
msgstr ""

#: src/2089-implied-bounds.md:697
msgid "Drawbacks"
msgstr ""

#: src/2089-implied-bounds.md:700
msgid ""
"Implied bounds on types can feel like \"implicit bounds\" (although they are "
"not: the types appear in the signature of a function / impl header, so it's "
"self-documenting)."
msgstr ""

#: src/2089-implied-bounds.md:701
msgid ""
"Removing a bound from a struct becomes a breaking change (note: this can "
"already be the case for functions and traits)."
msgstr ""

#: src/2089-implied-bounds.md:703
msgid "Rationale and Alternatives"
msgstr ""

#: src/2089-implied-bounds.md:706
msgid "Including parameters in well-formedness rules"
msgstr ""

#: src/2089-implied-bounds.md:708
msgid ""
"Specific to this design: instead of disregarding parameters in well-"
"formedness checks, we could have included them, and added reverse rules of "
"the form: \"`WF(T)` holds if `WF(Struct<T>)` holds\". From a theoretical "
"point of view, this would have had the same effects as the current design, "
"and would have avoided the whole `InputTypes` thing. However, implementation "
"in Chalk revealed some tricky issues. Writing in Chalk-style, suppose we "
"have rules like:"
msgstr ""

#: src/2089-implied-bounds.md:713
msgid ""
"then trying to prove `WF(i32)` gives birth to an infinite branch `WF(i32) :- "
"WF(Struct<i32>) :- WF(Struct<Struct<i32>>) :- ...` in the proof tree, which "
"is hard (at least that's what we believe) to dismiss."
msgstr ""

#: src/2089-implied-bounds.md:715
msgid "Trait aliases"
msgstr ""

#: src/2089-implied-bounds.md:717
msgid ""
"Trait aliases offer a way to factorize repeated constraints ([RFC 1733]"
"(https://github.com/rust-lang/rfcs/blob/master/text/1733-trait-alias.md)), "
"it's useful especially for bounds on types, but it does not overcome the "
"limitations for implied bounds on traits (the `where Bar: Into<Self>` "
"example is a good one)."
msgstr ""

#: src/2089-implied-bounds.md:719
msgid "Limiting the scope of implied bounds"
msgstr ""

#: src/2089-implied-bounds.md:721
msgid ""
"These essentially try to address the breaking change when removing a bound "
"on a type:"
msgstr ""

#: src/2089-implied-bounds.md:722
msgid "do not derive implied bounds for types"
msgstr ""

#: src/2089-implied-bounds.md:723
msgid ""
"limit the use of implied bounds for types that are in your current crate only"
msgstr ""

#: src/2089-implied-bounds.md:724
msgid "derive implied bounds in impl bodys only"
msgstr ""

#: src/2089-implied-bounds.md:725
msgid ""
"two distinct feature-gates, one for implied bounds on traits and another one "
"for types"
msgstr ""

#: src/2089-implied-bounds.md:727
msgid "Unresolved questions"
msgstr ""

#: src/2089-implied-bounds.md:730
msgid ""
"Should we try to limit the range of implied bounds to be crate-local (or "
"module-local, etc)?"
msgstr ""

#: src/2089-implied-bounds.md:731
msgid ""
"@nikomatsakis pointed [here](https://internals.rust-lang.org/t/lang-team-"
"minutes-implied-bounds/4905) that implied bounds can interact badly with "
"current inference rules."
msgstr ""
