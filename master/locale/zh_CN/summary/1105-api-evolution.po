msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:03Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1105-api-evolution.md:1
msgid "Feature Name: not applicable"
msgstr ""

#: src/1105-api-evolution.md:2
msgid "Start Date: 2015-05-04"
msgstr ""

#: src/1105-api-evolution.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1105](https://github.com/rust-lang/rfcs/pull/1105)"
msgstr ""

#: src/1105-api-evolution.md:4
msgid "Rust Issue: N/A"
msgstr ""

#: src/1105-api-evolution.md:6
msgid "Summary"
msgstr ""

#: src/1105-api-evolution.md:8
msgid ""
"This RFC proposes a comprehensive set of guidelines for which changes to "
"_stable_ APIs are considered breaking from a semver perspective, and which "
"are not.  These guidelines are intended for both the standard library and "
"for the crates.io ecosystem."
msgstr ""

#: src/1105-api-evolution.md:13
msgid ""
"This does _not_ mean that the standard library should be completely free to "
"make non-semver-breaking changes; there are sometimes still risks of "
"ecosystem pain that need to be taken into account. Rather, this RFC makes "
"explicit an initial set of changes that absolutely _cannot_ be made without "
"a semver bump."
msgstr ""

#: src/1105-api-evolution.md:18
msgid ""
"Along the way, it also discusses some interactions with potential language "
"features that can help mitigate pain for non-breaking changes."
msgstr ""

#: src/1105-api-evolution.md:21
msgid ""
"The RFC covers only API issues; other issues related to language features, "
"lints, type inference, command line arguments, Cargo, and so on are "
"considered out of scope."
msgstr ""

#: src/1105-api-evolution.md:25
msgid ""
"The stability promise specifically does _not_ apply to unstable features, "
"even if they are accidentally usable on the Stable release channel under "
"certain conditions such as because of bugs in the compiler."
msgstr ""

#: src/1105-api-evolution.md:29
msgid "Motivation"
msgstr ""

#: src/1105-api-evolution.md:31
msgid ""
"Both Rust and its library ecosystem have adopted [semver](http://semver."
"org/), a technique for versioning platforms/libraries partly in terms of the "
"effect on the code that uses them. In a nutshell, the versioning scheme has "
"three components::"
msgstr ""

#: src/1105-api-evolution.md:35
msgid "**Major**: must be incremented for changes that break client code."
msgstr ""

#: src/1105-api-evolution.md:36
msgid "**Minor**: incremented for backwards-compatible feature additions."
msgstr ""

#: src/1105-api-evolution.md:37
msgid "**Patch**: incremented for backwards-compatible bug fixes."
msgstr ""

#: src/1105-api-evolution.md:39
msgid ""
"[Rust 1.0.0](http://blog.rust-lang.org/2015/02/13/Final-1.0-timeline.html) "
"will mark the beginning of our [commitment to stability](http://blog.rust-"
"lang.org/2014/10/30/Stability.html), and from that point onward it will be "
"important to be clear about what constitutes a breaking change, in order for "
"semver to play a meaningful role. As we will see, this question is more "
"subtle than one might think at first -- and the simplest approach would make "
"it effectively impossible to grow the standard library."
msgstr ""

#: src/1105-api-evolution.md:48
msgid ""
"The goal of this RFC is to lay out a comprehensive policy for what _must_ be "
"considered a breaking API change from the perspective of semver, along with "
"some guidance about non-semver-breaking changes."
msgstr ""

#: src/1105-api-evolution.md:52
msgid "Detailed design"
msgstr ""

#: src/1105-api-evolution.md:54
msgid "For clarity, in the rest of the RFC, we will use the following terms:"
msgstr ""

#: src/1105-api-evolution.md:56
msgid "**Major change**: a change that requires a major semver bump."
msgstr ""

#: src/1105-api-evolution.md:57
msgid "**Minor change**: a change that requires only a minor semver bump."
msgstr ""

#: src/1105-api-evolution.md:58
msgid ""
"**Breaking change**: a change that, _strictly speaking_, can cause "
"downstream code to fail to compile."
msgstr ""

#: src/1105-api-evolution.md:61
msgid ""
"What we will see is that in Rust today, almost any change is technically a "
"breaking change. For example, given the way that globs currently work, "
"_adding any public item_ to a library can break its clients (more on that "
"later). But not all breaking changes are equal."
msgstr ""

#: src/1105-api-evolution.md:66
msgid ""
"So, this RFC proposes that **all major changes are breaking, but not all "
"breaking changes are major.**"
msgstr ""

#: src/1105-api-evolution.md:69
msgid "Overview"
msgstr ""

#: src/1105-api-evolution.md:71
msgid "Principles of the policy"
msgstr ""

#: src/1105-api-evolution.md:73
msgid ""
"The basic design of the policy is that **the same code should be able to run "
"against different minor revisions**. Furthermore, minor changes should "
"require at most a few local _annotations_ to the code you are developing, "
"and in principle no changes to your dependencies."
msgstr ""

#: src/1105-api-evolution.md:78
msgid "In more detail:"
msgstr ""

#: src/1105-api-evolution.md:80
msgid ""
"Minor changes should require at most minor amounts of work upon upgrade. For "
"example, changes that may require occasional type annotations or use of UFCS "
"to disambiguate are not automatically \"major\" changes. (But in such cases, "
"one must evaluate how widespread these \"minor\" changes are)."
msgstr ""

#: src/1105-api-evolution.md:85
msgid ""
"In principle, it should be possible to produce a version of dependency code "
"that _will not break_ when upgrading other dependencies, or Rust itself, to "
"a new minor revision. This goes hand-in-hand with the above bullet; as we "
"will see, it's possible to save a fully \"elaborated\" version of upstream "
"code that does not require any disambiguation. The \"in principle\" refers "
"to the fact that getting there may require some additional tooling or "
"language support, which this RFC outlines."
msgstr ""

#: src/1105-api-evolution.md:93
msgid ""
"That means that any breakage in a minor release must be very \"shallow\": it "
"must always be possible to locally fix the problem through some kind of "
"disambiguation _that could have been done in advance_ (by using more "
"explicit forms) or other annotation (like disabling a lint). It means that "
"minor changes can never leave you in a state that requires breaking changes "
"to your own code."
msgstr ""

#: src/1105-api-evolution.md:99
msgid ""
"**Although this general policy allows some (very limited) breakage in minor "
"releases, it is not a license to make these changes blindly**. The breakage "
"that this RFC permits, aside from being very simple to fix, is also unlikely "
"to occur often in practice. The RFC will discuss measures that should be "
"employed in the standard library to ensure that even these minor forms of "
"breakage do not cause widespread pain in the ecosystem."
msgstr ""

#: src/1105-api-evolution.md:106
msgid "Scope of the policy"
msgstr ""

#: src/1105-api-evolution.md:108
msgid ""
"The policy laid out by this RFC applies to _stable_, _public_ APIs in the "
"standard library. Eventually, stability attributes will be usable in "
"external libraries as well (this will require some design work), but for now "
"public APIs in external crates should be understood as de facto stable after "
"the library reaches 1.0.0 (per semver)."
msgstr ""

#: src/1105-api-evolution.md:114
msgid "Policy by language feature"
msgstr ""

#: src/1105-api-evolution.md:116
msgid ""
"Most of the policy is simplest to lay out with reference to specific "
"language features and the way that APIs using them can, and cannot, evolve "
"in a minor release."
msgstr ""

#: src/1105-api-evolution.md:120
msgid ""
"**Breaking changes are assumed to be major changes unless otherwise "
"stated**. The RFC covers many, but not all breaking changes that are major; "
"it covers _all_ breaking changes that are considered minor."
msgstr ""

#: src/1105-api-evolution.md:124
msgid "Crates"
msgstr ""

#: src/1105-api-evolution.md:126
msgid "Major change: going from stable to nightly"
msgstr ""

#: src/1105-api-evolution.md:128
msgid ""
"Changing a crate from working on stable Rust to _requiring_ a nightly is "
"considered a breaking change. That includes using `#[feature]` directly, or "
"using a dependency that does so. Crate authors should consider using Cargo "
"[\"features\"](http://doc.crates.io/manifest.html#the-[features]-section) "
"for their crate to make such use opt-in."
msgstr ""

#: src/1105-api-evolution.md:134
msgid "Minor change: altering the use of Cargo features"
msgstr ""

#: src/1105-api-evolution.md:136
msgid ""
"Cargo packages can provide [opt-in features](http://doc.crates.io/manifest."
"html#the-[features]-section), which enable `#[cfg]` options. When a common "
"dependency is compiled, it is done so with the _union_ of all features opted "
"into by any packages using the dependency. That means that adding or "
"removing a feature could technically break other, unrelated code."
msgstr ""

#: src/1105-api-evolution.md:143
msgid ""
"However, such breakage always represents a bug: packages are supposed to "
"support any combination of features, and if another client of the package "
"depends on a given feature, that client should specify the opt-in themselves."
msgstr ""

#: src/1105-api-evolution.md:147
msgid "Modules"
msgstr ""

#: src/1105-api-evolution.md:149
msgid "Major change: renaming/moving/removing any public items."
msgstr ""

#: src/1105-api-evolution.md:151
msgid ""
"Although renaming an item might seem like a minor change, according to the "
"general policy design this is not a permitted form of breakage: it's not "
"possible to annotate code in advance to avoid the breakage, nor is it "
"possible to prevent the breakage from affecting dependencies."
msgstr ""

#: src/1105-api-evolution.md:156
msgid ""
"Of course, much of the effect of renaming/moving/removing can be achieved by "
"instead using deprecation and `pub use`, and the standard library should not "
"be afraid to do so! In the long run, we should consider hiding at least some "
"old deprecated items from the docs, and could even consider putting out a "
"major version solely as a kind of \"garbage collection\" for long-deprecated "
"APIs."
msgstr ""

#: src/1105-api-evolution.md:162
msgid "Minor change: adding new public items."
msgstr ""

#: src/1105-api-evolution.md:164
msgid ""
"Note that adding new public items is currently a breaking change, due to "
"glob imports. For example, the following snippet of code will break if the "
"`foo` module introduces a public item called `bar`:"
msgstr ""

#: src/1105-api-evolution.md:173
msgid ""
"The problem here is that glob imports currently do not allow any of their "
"imports to be shadowed by an explicitly-defined item."
msgstr ""

#: src/1105-api-evolution.md:176
msgid ""
"This is considered a minor change because under the principles of this RFC: "
"the glob imports could have been written as more explicit (expanded) `use` "
"statements. It is also plausible to do this expansion automatically for a "
"crate's dependencies, to prevent breakage in the first place."
msgstr ""

#: src/1105-api-evolution.md:181
msgid ""
"(This RFC also suggests permitting shadowing of a glob import by any "
"explicit item. This has been the intended semantics of globs, but has not "
"been implemented. The details are left to a future RFC, however.)"
msgstr ""

#: src/1105-api-evolution.md:185
msgid "Structs"
msgstr ""

#: src/1105-api-evolution.md:187
msgid ""
"See \"[Signatures in type definitions](#signatures-in-type-definitions)\" "
"for some general remarks about changes to the actual types in a `struct` "
"definition."
msgstr ""

#: src/1105-api-evolution.md:190
msgid ""
"Major change: adding a private field when all current fields are public."
msgstr ""

#: src/1105-api-evolution.md:192
msgid ""
"This change has the effect of making external struct literals impossible to "
"write, which can break code irreparably."
msgstr ""

#: src/1105-api-evolution.md:195
msgid "Major change: adding a public field when no private field exists."
msgstr ""

#: src/1105-api-evolution.md:197
msgid ""
"This change retains the ability to use struct literals, but it breaks "
"existing uses of such literals; it likewise breaks exhaustive matches "
"against the struct."
msgstr ""

#: src/1105-api-evolution.md:200
msgid ""
"Minor change: adding or removing private fields when at least one already "
"exists (before and after the change)."
msgstr ""

#: src/1105-api-evolution.md:202
msgid ""
"No existing code could be relying on struct literals for the struct, nor on "
"exhaustively matching its contents, and client code will likewise be "
"oblivious to the addition of further private fields."
msgstr ""

#: src/1105-api-evolution.md:206
msgid ""
"For tuple structs, this is only a minor change if furthermore _all_ fields "
"are currently private. (Tuple structs with mixtures of public and private "
"fields are bad practice in any case.)"
msgstr ""

#: src/1105-api-evolution.md:210
msgid ""
"Minor change: going from a tuple struct with all private fields (with at "
"least one field) to a normal struct, or vice versa."
msgstr ""

#: src/1105-api-evolution.md:212
msgid "This is technically a breaking change:"
msgstr ""

#: src/1105-api-evolution.md:215
msgid "// in some other module:\n"
msgstr ""

#: src/1105-api-evolution.md:217
msgid "// in downstream code\n"
msgstr ""

#: src/1105-api-evolution.md:222
msgid ""
"Changing `Foo` to a normal struct can break code that matches on it -- but "
"there is never any real reason to match on it in that circumstance, since "
"you cannot extract any fields or learn anything of interest about the struct."
msgstr ""

#: src/1105-api-evolution.md:226
msgid "Enums"
msgstr ""

#: src/1105-api-evolution.md:228
msgid ""
"See \"[Signatures in type definitions](#signatures-in-type-definitions)\" "
"for some general remarks about changes to the actual types in an `enum` "
"definition."
msgstr ""

#: src/1105-api-evolution.md:231
msgid "Major change: adding new variants."
msgstr ""

#: src/1105-api-evolution.md:233
msgid ""
"Exhaustiveness checking means that a `match` that explicitly checks all the "
"variants for an `enum` will break if a new variant is added. It is not "
"currently possible to defend against this breakage in advance."
msgstr ""

#: src/1105-api-evolution.md:237
msgid ""
"A [postponed RFC](https://github.com/rust-lang/rfcs/pull/757) discusses a "
"language feature that allows an enum to be marked as \"extensible\", which "
"modifies the way that exhaustiveness checking is done and would make it "
"possible to extend the enum without breakage."
msgstr ""

#: src/1105-api-evolution.md:242
msgid "Major change: adding new fields to a variant."
msgstr ""

#: src/1105-api-evolution.md:244
msgid ""
"If the enum is public, so is the full contents of all of its variants. As "
"per the rules for structs, this means it is not allowed to add any new "
"fields (which will automatically be public)."
msgstr ""

#: src/1105-api-evolution.md:248
msgid ""
"If you wish to allow for this kind of extensibility, consider introducing a "
"new, explicit struct for the variant up front."
msgstr ""

#: src/1105-api-evolution.md:251
msgid "Traits"
msgstr ""

#: src/1105-api-evolution.md:253
msgid "Major change: adding a non-defaulted item."
msgstr ""

#: src/1105-api-evolution.md:255
msgid ""
"Adding any item without a default will immediately break all trait "
"implementations."
msgstr ""

#: src/1105-api-evolution.md:257
msgid ""
"It's possible that in the future we will allow some kind of \"[sealing]"
"(#thoughts-on-possible-language-changes-unofficial)\" to say that a trait "
"can only be used as a bound, not to provide new implementations; such a "
"trait _would_ allow arbitrary items to be added."
msgstr ""

#: src/1105-api-evolution.md:262
msgid "Major change: any non-trivial change to item signatures."
msgstr ""

#: src/1105-api-evolution.md:264
msgid ""
"Because traits have both implementors and consumers, any change to the "
"signature of e.g. a method will affect at least one of the two parties. So, "
"for example, abstracting a concrete method to use generics instead might "
"work fine for clients of the trait, but would break existing implementors. "
"(Note, as above, the potential for \"sealed\" traits to alter this dynamic.)"
msgstr ""

#: src/1105-api-evolution.md:270
msgid "Minor change: adding a defaulted item."
msgstr ""

#: src/1105-api-evolution.md:272
msgid "Adding a defaulted item is technically a breaking change:"
msgstr ""

#: src/1105-api-evolution.md:285
msgid ""
"If a `foo` method is added to `Trait1`, even with a default, it would cause "
"a dispatch ambiguity in `use_both`, since the call to `foo` could be "
"referring to either trait."
msgstr ""

#: src/1105-api-evolution.md:289
msgid "(Note, however, that existing _implementations_ of the trait are fine.)"
msgstr ""

#: src/1105-api-evolution.md:291
msgid ""
"According to the basic principles of this RFC, such a change is minor: it is "
"always possible to annotate the call `t.foo()` to be more explicit _in "
"advance_ using UFCS: `Trait2::foo(t)`. This kind of annotation could be done "
"automatically for code in dependencies (see [Elaborated source](#elaborated-"
"source)). And it would also be possible to mitigate this problem by allowing "
"[method renaming on trait import](#trait-item-renaming)."
msgstr ""

#: src/1105-api-evolution.md:299
msgid ""
"While the scenario of adding a defaulted method to a trait may seem somewhat "
"obscure, the exact same hazards arise with _implementing existing traits_ "
"(see below), which is clearly vital to allow; we apply a similar policy to "
"both."
msgstr ""

#: src/1105-api-evolution.md:303
msgid ""
"All that said, it is incumbent on library authors to ensure that such "
"\"minor\" changes are in fact minor in practice: if a conflict like `t."
"foo()` is likely to arise at all often in downstream code, it would be "
"advisable to explore a different choice of names. More guidelines for the "
"standard library are given later on."
msgstr ""

#: src/1105-api-evolution.md:309
msgid ""
"There are two circumstances when adding a defaulted item is still a major "
"change:"
msgstr ""

#: src/1105-api-evolution.md:311
msgid ""
"The new item would change the trait from object safe to non-object safe."
msgstr ""

#: src/1105-api-evolution.md:312
msgid ""
"The trait has a defaulted associated type and the item being added is a "
"defaulted function/method. In this case, existing impls that override the "
"associated type will break, since the function/method default will not "
"apply. (See [the associated item RFC](https://github.com/rust-lang/rfcs/blob/"
"master/text/0195-associated-items.md#defaults))."
msgstr ""

#: src/1105-api-evolution.md:317
msgid ""
"Adding a default to an existing associated type is likewise a major change "
"if the trait has defaulted methods, since it will invalidate use of those "
"defaults for the methods in existing trait impls."
msgstr ""

#: src/1105-api-evolution.md:321
msgid "Minor change: adding a defaulted type parameter."
msgstr ""

#: src/1105-api-evolution.md:323
msgid ""
"As with \"[Signatures in type definitions](#signatures-in-type-"
"definitions)\", traits are permitted to add new type parameters as long as "
"defaults are provided (which is backwards compatible)."
msgstr ""

#: src/1105-api-evolution.md:327
msgid "Trait implementations"
msgstr ""

#: src/1105-api-evolution.md:329
msgid "Major change: implementing any \"fundamental\" trait."
msgstr ""

#: src/1105-api-evolution.md:331
msgid ""
"A [recent RFC](https://github.com/rust-lang/rfcs/pull/1023) introduced the "
"idea of \"fundamental\" traits which are so basic that _not_ implementing "
"such a trait right off the bat is considered a promise that you will _never_ "
"implement the trait. The `Sized` and `Fn` traits are examples."
msgstr ""

#: src/1105-api-evolution.md:336
msgid ""
"The coherence rules take advantage of fundamental traits in such a way that "
"_adding a new implementation of a fundamental trait to an existing type can "
"cause downstream breakage_. Thus, such impls are considered major changes."
msgstr ""

#: src/1105-api-evolution.md:340
msgid "Minor change: implementing any non-fundamental trait."
msgstr ""

#: src/1105-api-evolution.md:342
msgid "Unfortunately, implementing any existing trait can cause breakage:"
msgstr ""

#: src/1105-api-evolution.md:345 src/1105-api-evolution.md:385
msgid "// Crate A\n"
msgstr ""

#: src/1105-api-evolution.md:350
msgid "// does not implement Trait1\n"
msgstr ""

#: src/1105-api-evolution.md:351 src/1105-api-evolution.md:387
msgid "// Crate B\n"
msgstr ""

#: src/1105-api-evolution.md:366
msgid ""
"If crate A adds an implementation of `Trait1` for `Foo`, the call to `f."
"foo()` in crate B will yield a dispatch ambiguity (much like the one we saw "
"for defaulted items). Thus _technically implementing any existing trait is a "
"breaking change!_ Completely prohibiting such a change is clearly a non-"
"starter."
msgstr ""

#: src/1105-api-evolution.md:371
msgid ""
"However, as before, this kind of breakage is considered \"minor\" by the "
"principles of this RFC (see \"Adding a defaulted item\" above)."
msgstr ""

#: src/1105-api-evolution.md:374
msgid "Inherent implementations"
msgstr ""

#: src/1105-api-evolution.md:376
msgid "Minor change: adding any inherent items."
msgstr ""

#: src/1105-api-evolution.md:378
msgid ""
"Adding an inherent item cannot lead to dispatch ambiguity, because inherent "
"items trump any trait items with the same name."
msgstr ""

#: src/1105-api-evolution.md:381
msgid ""
"However, introducing an inherent item _can_ lead to breakage if the "
"signature of the item does not match that of an in scope, implemented trait:"
msgstr ""

#: src/1105-api-evolution.md:400
msgid "If crate A adds a method:"
msgstr ""

#: src/1105-api-evolution.md:408
msgid ""
"then crate B would no longer compile, since dispatch would prefer the "
"inherent impl, which has the wrong type."
msgstr ""

#: src/1105-api-evolution.md:411
msgid ""
"Once more, this is considered a minor change, since UFCS can disambiguate "
"(see \"Adding a defaulted item\" above)."
msgstr ""

#: src/1105-api-evolution.md:414
msgid ""
"It's worth noting, however, that if the signatures _did_ happen to match "
"then the change would no longer cause a compilation error, but might "
"silently change runtime behavior. The case where the same method for the "
"same type has meaningfully different behavior is considered unlikely enough "
"that the RFC is willing to permit it to be labeled as a minor change -- and "
"otherwise, inherent methods could never be added after the fact."
msgstr ""

#: src/1105-api-evolution.md:421
msgid "Other items"
msgstr ""

#: src/1105-api-evolution.md:423
msgid "Most remaining items do not have any particularly unique items:"
msgstr ""

#: src/1105-api-evolution.md:425
msgid ""
"For type aliases, see \"[Signatures in type definitions](#signatures-in-type-"
"definitions)\"."
msgstr ""

#: src/1105-api-evolution.md:426
msgid ""
"For free functions, see \"[Signatures in functions](#signatures-in-"
"functions)\"."
msgstr ""

#: src/1105-api-evolution.md:428
msgid "Cross-cutting concerns"
msgstr ""

#: src/1105-api-evolution.md:430
msgid "Behavioral changes"
msgstr ""

#: src/1105-api-evolution.md:432
msgid ""
"This RFC is largely focused on API changes which may, in particular, cause "
"downstream code to stop compiling. But in some sense it is even more "
"pernicious to make a change that allows downstream code to continue "
"compiling, but causes its runtime behavior to break."
msgstr ""

#: src/1105-api-evolution.md:437
msgid ""
"This RFC does not attempt to provide a comprehensive policy on behavioral "
"changes, which would be extremely difficult. In general, APIs are expected "
"to provide explicit contracts for their behavior via documentation, and "
"behavior that is not part of this contract is permitted to change in minor "
"revisions. (Remember: this RFC is about setting a _minimum_ bar for when "
"major version bumps are required.)"
msgstr ""

#: src/1105-api-evolution.md:444
msgid ""
"This policy will likely require some revision over time, to become more "
"explicit and perhaps lay out some best practices."
msgstr ""

#: src/1105-api-evolution.md:447
msgid "Signatures in type definitions"
msgstr ""

#: src/1105-api-evolution.md:449
msgid "Major change: tightening bounds."
msgstr ""

#: src/1105-api-evolution.md:451
msgid ""
"Adding new constraints on existing type parameters is a breaking change, "
"since existing uses of the type definition can break. So the following is a "
"major change:"
msgstr ""

#: src/1105-api-evolution.md:456 src/1105-api-evolution.md:522
#: src/1105-api-evolution.md:607
msgid "// MAJOR CHANGE\n"
msgstr ""

#: src/1105-api-evolution.md:457 src/1105-api-evolution.md:474
#: src/1105-api-evolution.md:490 src/1105-api-evolution.md:506
#: src/1105-api-evolution.md:523 src/1105-api-evolution.md:539
#: src/1105-api-evolution.md:566 src/1105-api-evolution.md:593
#: src/1105-api-evolution.md:608 src/1105-api-evolution.md:627
msgid "// Before\n"
msgstr ""

#: src/1105-api-evolution.md:460 src/1105-api-evolution.md:477
#: src/1105-api-evolution.md:493 src/1105-api-evolution.md:509
#: src/1105-api-evolution.md:526 src/1105-api-evolution.md:542
#: src/1105-api-evolution.md:569 src/1105-api-evolution.md:597
#: src/1105-api-evolution.md:611 src/1105-api-evolution.md:630
msgid "// After\n"
msgstr ""

#: src/1105-api-evolution.md:465
msgid "Minor change: loosening bounds."
msgstr ""

#: src/1105-api-evolution.md:467
msgid ""
"Loosening bounds, on the other hand, cannot break code because when you "
"reference `Foo<A>`, you _do not learn anything about the bounds on `A`_. "
"(This is why you have to repeat any relevant bounds in `impl` blocks for "
"`Foo`, for example.) So the following is a minor change:"
msgstr ""

#: src/1105-api-evolution.md:473 src/1105-api-evolution.md:489
#: src/1105-api-evolution.md:505 src/1105-api-evolution.md:538
#: src/1105-api-evolution.md:592 src/1105-api-evolution.md:626
msgid "// MINOR CHANGE\n"
msgstr ""

#: src/1105-api-evolution.md:482
msgid "Minor change: adding defaulted type parameters."
msgstr ""

#: src/1105-api-evolution.md:484
msgid ""
"All existing references to a type/trait definition continue to compile and "
"work correctly after a new defaulted type parameter is added. So the "
"following is a minor change:"
msgstr ""

#: src/1105-api-evolution.md:498 src/1105-api-evolution.md:584
msgid "Minor change: generalizing to generics."
msgstr ""

#: src/1105-api-evolution.md:500
msgid ""
"A struct or enum field can change from a concrete type to a generic type "
"parameter, provided that the change results in an identical type for all "
"existing use cases. For example, the following change is permitted:"
msgstr ""

#: src/1105-api-evolution.md:514
msgid ""
"because existing uses of `Foo` are shorthand for `Foo<u8>` which yields the "
"identical field type. (Note: this is not actually true today, since [default "
"type parameters](https://github.com/rust-lang/rfcs/pull/213) are not fully "
"implemented. But this is the intended semantics.)"
msgstr ""

#: src/1105-api-evolution.md:519
msgid "On the other hand, the following is not permitted:"
msgstr ""

#: src/1105-api-evolution.md:531
msgid ""
"since there may be existing uses of `Foo` with a non-default type parameter "
"which would break as a result of the change."
msgstr ""

#: src/1105-api-evolution.md:534
msgid ""
"It's also permitted to change from a generic type to a more-generic one in a "
"minor revision:"
msgstr ""

#: src/1105-api-evolution.md:547
msgid ""
"since, again, all existing uses of the type `Foo<T>` will yield the same "
"field types as before."
msgstr ""

#: src/1105-api-evolution.md:550
msgid "Signatures in functions"
msgstr ""

#: src/1105-api-evolution.md:552
msgid ""
"All of the changes mentioned below are considered major changes in the "
"context of trait methods, since they can break implementors."
msgstr ""

#: src/1105-api-evolution.md:555
msgid "Major change: adding/removing arguments."
msgstr ""

#: src/1105-api-evolution.md:557
msgid ""
"At the moment, Rust does not provide defaulted arguments, so any change in "
"arity is a breaking change."
msgstr ""

#: src/1105-api-evolution.md:560
msgid "Minor change: introducing a new type parameter."
msgstr ""

#: src/1105-api-evolution.md:562
msgid "Technically, adding a (non-defaulted) type parameter can break code:"
msgstr ""

#: src/1105-api-evolution.md:565
msgid "// MINOR CHANGE (but causes breakage)\n"
msgstr ""

#: src/1105-api-evolution.md:574
msgid ""
"will break any calls like `foo::<u8>`. However, such explicit calls are rare "
"enough (and can usually be written in other ways) that this breakage is "
"considered minor. (However, one should take into account how likely it is "
"that the function in question is being called with explicit type "
"arguments).  This RFC also suggests adding a `...` notation to explicit "
"parameter lists to keep them open-ended (see suggested language changes)."
msgstr ""

#: src/1105-api-evolution.md:581
msgid ""
"Such changes are an important ingredient of abstracting to use generics, as "
"described next."
msgstr ""

#: src/1105-api-evolution.md:586
msgid ""
"The type of an argument to a function, or its return value, can be "
"_generalized_ to use generics, including by introducing a new type parameter "
"(as long as it can be instantiated to the original type). For example, the "
"following change is allowed:"
msgstr ""

#: src/1105-api-evolution.md:603
msgid ""
"because all existing uses are instantiations of the new signature. On the "
"other hand, the following isn't allowed in a minor revision:"
msgstr ""

#: src/1105-api-evolution.md:616
msgid ""
"because the generics include a constraint not satisfied by the original type."
msgstr ""

#: src/1105-api-evolution.md:618
msgid ""
"Introducing generics in this way can potentially create type inference "
"failures, but these are considered acceptable per the principles of the RFC: "
"they only require local annotations that could have been inserted in advance."
msgstr ""

#: src/1105-api-evolution.md:622
msgid ""
"Perhaps somewhat surprisingly, generalization applies to trait objects as "
"well, given that every trait implements itself:"
msgstr ""

#: src/1105-api-evolution.md:635
msgid ""
"(The use of `?Sized` is essential; otherwise you couldn't recover the "
"original signature)."
msgstr ""

#: src/1105-api-evolution.md:638
msgid "Lints"
msgstr ""

#: src/1105-api-evolution.md:640
msgid "Minor change: introducing new lint warnings/errors"
msgstr ""

#: src/1105-api-evolution.md:642
msgid ""
"Lints are considered advisory, and changes that cause downstream code to "
"receive additional lint warnings/errors are still considered \"minor\" "
"changes."
msgstr ""

#: src/1105-api-evolution.md:645
msgid ""
"Making this work well in practice will likely require some infrastructure "
"work along the lines of [this RFC issue](https://github.com/rust-lang/rfcs/"
"issues/1029)"
msgstr ""

#: src/1105-api-evolution.md:649
msgid "Mitigation for minor changes"
msgstr ""

#: src/1105-api-evolution.md:651
msgid "The Crater tool"
msgstr ""

#: src/1105-api-evolution.md:653
msgid ""
"@brson has been hard at work on a tool called \"Crater\" which can be used "
"to exercise changes on the entire crates.io ecosystem, looking for "
"regressions. This tool will be indispensable when weighing the costs of a "
"minor change that might cause some breakage -- we can actually gauge what "
"the breakage would look like in practice."
msgstr ""

#: src/1105-api-evolution.md:659
msgid ""
"While this would, of course, miss code not available publicly, the hope is "
"that code on crates.io is a broadly representative sample, good enough to "
"turn up problems."
msgstr ""

#: src/1105-api-evolution.md:663
msgid ""
"Any breaking, but minor change to the standard library must be evaluated "
"through Crater before being committed."
msgstr ""

#: src/1105-api-evolution.md:666
msgid "Nightlies"
msgstr ""

#: src/1105-api-evolution.md:668
msgid ""
"One line of defense against a \"minor\" change causing significant breakage "
"is the nightly release channel: we can get feedback about breakage long "
"before it makes even into a beta release. And of course the beta cycle "
"itself provides another line of defense."
msgstr ""

#: src/1105-api-evolution.md:673
msgid "Elaborated source"
msgstr ""

#: src/1105-api-evolution.md:675
msgid ""
"When compiling upstream dependencies, it is possible to generate an "
"\"elaborated\" version of the source code where all dispatch is resolved to "
"explicit UFCS form, all types are annotated, and all glob imports are "
"replaced by explicit imports."
msgstr ""

#: src/1105-api-evolution.md:679
msgid ""
"This fully-elaborated form is almost entirely immune to breakage due to any "
"of the \"minor changes\" listed above."
msgstr ""

#: src/1105-api-evolution.md:682
msgid ""
"You could imagine Cargo storing this elaborated form for dependencies upon "
"compilation. That would in turn make it easy to update Rust, or some subset "
"of dependencies, without breaking any upstream code (even in minor ways). "
"You would be left only with very small, local changes to make to the code "
"you own."
msgstr ""

#: src/1105-api-evolution.md:687
msgid ""
"While this RFC does not propose any such tooling change right now, the point "
"is mainly that there are a lot of options if minor changes turn out to cause "
"breakage more often than anticipated."
msgstr ""

#: src/1105-api-evolution.md:691
msgid "Trait item renaming"
msgstr ""

#: src/1105-api-evolution.md:693
msgid ""
"One very useful mechanism would be the ability to import a trait while "
"renaming some of its items, e.g. `use some_mod::SomeTrait with {foo_method "
"as bar}`. In particular, when methods happen to conflict across traits "
"defined in separate crates, a user of the two traits could rename one of the "
"methods out of the way."
msgstr ""

#: src/1105-api-evolution.md:698
msgid "Thoughts on possible language changes (unofficial)"
msgstr ""

#: src/1105-api-evolution.md:700
msgid ""
"The following is just a quick sketch of some focused language changes that "
"would help our API evolution story."
msgstr ""

#: src/1105-api-evolution.md:703
msgid "**Glob semantics**"
msgstr ""

#: src/1105-api-evolution.md:705
msgid ""
"As already mentioned, the fact that glob imports currently allow _no_ "
"shadowing is deeply problematic: in a technical sense, it means that the "
"addition of _any_ public item can break downstream code arbitrarily."
msgstr ""

#: src/1105-api-evolution.md:709
msgid ""
"It would be much better for API evolution (and for ergonomics and intuition) "
"if explicitly-defined items trump glob imports. But this is left to a future "
"RFC."
msgstr ""

#: src/1105-api-evolution.md:712
msgid "**Globs with fine-grained control**"
msgstr ""

#: src/1105-api-evolution.md:714
msgid ""
"Another useful tool for working with globs would be the ability to _exclude_ "
"certain items from a glob import, e.g. something like:"
msgstr ""

#: src/1105-api-evolution.md:721
msgid ""
"This is especially useful for the case where multiple modules being glob "
"imported happen to export items with the same name."
msgstr ""

#: src/1105-api-evolution.md:724
msgid ""
"Another possibility would be to not make it an error for two glob imports to "
"bring the same name into scope, but to generate the error only at the point "
"that the imported name was actually _used_. Then collisions could be "
"resolved simply by adding a single explicit, shadowing import."
msgstr ""

#: src/1105-api-evolution.md:729
msgid "**Default type parameters**"
msgstr ""

#: src/1105-api-evolution.md:731
msgid ""
"Some of the minor changes for moving to more generic code depends on an "
"interplay between defaulted type parameters and type inference, which has "
"been [accepted as an RFC](https://github.com/rust-lang/rfcs/pull/213) but "
"not yet implemented."
msgstr ""

#: src/1105-api-evolution.md:736
msgid "**\"Extensible\" enums**"
msgstr ""

#: src/1105-api-evolution.md:738
msgid ""
"There is already [an RFC](https://github.com/rust-lang/rfcs/pull/757) for an "
"`enum` annotation that would make it possible to add variants without ever "
"breaking downstream code."
msgstr ""

#: src/1105-api-evolution.md:742
msgid "**Sealed traits**"
msgstr ""

#: src/1105-api-evolution.md:744
msgid ""
"The ability to annotate a trait with some \"sealed\" marker, saying that no "
"external implementations are allowed, would be useful in certain cases where "
"a crate wishes to define a closed set of types that implements a particular "
"interface. Such an attribute would make it possible to evolve the interface "
"without a major version bump (since no downstream implementors can exist)."
msgstr ""

#: src/1105-api-evolution.md:750
msgid "**Defaulted parameters**"
msgstr ""

#: src/1105-api-evolution.md:752
msgid ""
"Also known as \"optional arguments\" -- an [oft-requested](https://github."
"com/rust-lang/rfcs/issues/323) feature. Allowing arguments to a function to "
"be optional makes it possible to add new arguments after the fact without a "
"major version bump."
msgstr ""

#: src/1105-api-evolution.md:757
msgid "**Open-ended explicit type parameters**"
msgstr ""

#: src/1105-api-evolution.md:759
msgid ""
"One hazard is that with today's explicit type parameter syntax, you must "
"always specify _all_ type parameters: `foo::<T, U>(x, y)`. That means that "
"adding a new type parameter to `foo` can break code, even if a default is "
"provided."
msgstr ""

#: src/1105-api-evolution.md:763
msgid ""
"This could be easily addressed by adding a notation like `...` to leave "
"additional parameters unspecified: `foo::<T, ...>(x, y)`."
msgstr ""

#: src/1105-api-evolution.md:766
msgid "\\[Amendment\\] Misuse of `accessible(..)`"
msgstr ""

#: src/1105-api-evolution.md:770
msgid ""
"[RFC 2523](https://github.com/rust-lang/rfcs/blob/master/text/2523-cfg-path-"
"version.md) introduces `#[cfg(accessible($path)]`. Based on the "
"accessibility of a to-the-current-crate external `$path`, the flag allows "
"conditional compilation. When combined with `#[cfg(feature = "
"\"unstable\")]`, this has certain breakage risks. Such breakage due to "
"misuse, as outlined in the RFC, is considered acceptable and not covered by "
"our stability promises. Please see the RFC for more details."
msgstr ""

#: src/1105-api-evolution.md:776
msgid "Drawbacks and Alternatives"
msgstr ""

#: src/1105-api-evolution.md:778
msgid ""
"The main drawback to the approach laid out here is that it makes the "
"stability and semver guarantees a bit fuzzier: the promise is not that code "
"will never break, full stop, but rather that minor release breakage is of an "
"extremely limited form, for which there are a variety of mitigation "
"strategies. This approach tries to strike a middle ground between a very "
"hard line for stability (which, for Rust, would rule out many forms of "
"extension) and willy-nilly breakage: it's an explicit, but pragmatic policy."
msgstr ""

#: src/1105-api-evolution.md:786
msgid ""
"An alternative would be to take a harder line and find some other way to "
"allow API evolution. Supposing that we resolved the issues around glob "
"imports, the main problems with breakage have to do with adding new inherent "
"methods or trait implementations -- both of which are vital forms of "
"evolution. It might be possible, in the standard library case, to provide "
"some kind of version-based opt in to this evolution: a crate could opt in to "
"breaking changes for a particular version of Rust, which might in turn be "
"provided only through some `cfg`\\-like mechanism."
msgstr ""

#: src/1105-api-evolution.md:795
msgid ""
"Note that these strategies are not mutually exclusive. Rust's development "
"processes involved a very steady, strong stream of breakage, and while we "
"need to be very serious about stabilization, it is possible to take an "
"iterative approach. The changes considered \"major\" by this RFC already "
"move the bar _very significantly_ from what was permitted pre-1.0. It may "
"turn out that even the minor forms of breakage permitted here are, in the "
"long run, too much to tolerate; at that point we could revise the policies "
"here and explore some opt-in scheme, for example."
msgstr ""

#: src/1105-api-evolution.md:804
msgid "Unresolved questions"
msgstr ""

#: src/1105-api-evolution.md:806
msgid "Behavioral issues"
msgstr ""

#: src/1105-api-evolution.md:808
msgid ""
"Is it permitted to change a contract from \"abort\" to \"panic\"? What about "
"from \"panic\" to \"return an `Err`\"?"
msgstr ""

#: src/1105-api-evolution.md:811
msgid ""
"Should we try to lay out more specific guidance for behavioral changes at "
"this point?"
msgstr ""
