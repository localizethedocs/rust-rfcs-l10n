msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:04Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2394-async_await.md:1
msgid "Feature Name: async_await"
msgstr ""

#: src/2394-async_await.md:2
msgid "Start Date: 2018-03-30"
msgstr ""

#: src/2394-async_await.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2394](https://github.com/rust-lang/rfcs/pull/2394)"
msgstr ""

#: src/2394-async_await.md:4
msgid "Rust Issues:"
msgstr ""

#: src/2394-async_await.md:5
msgid "[rust-lang/rust#50547](https://github.com/rust-lang/rust/issues/50547)"
msgstr ""

#: src/2394-async_await.md:6
msgid ""
"[rust-lang/rust#62290](https://github.com/rust-lang/rust/issues/62290) - #!"
"feature(async_closure)"
msgstr ""

#: src/2394-async_await.md:8
msgid "Summary"
msgstr ""

#: src/2394-async_await.md:11
msgid ""
"Add async & await syntaxes to make it more ergonomic to write code "
"manipulating futures."
msgstr ""

#: src/2394-async_await.md:14
msgid ""
"This has [a companion RFC](2592-futures.md) to add a small futures API to "
"libstd and libcore."
msgstr ""

#: src/2394-async_await.md:16
msgid "Motivation"
msgstr ""

#: src/2394-async_await.md:19
msgid ""
"High performance network services frequently use asynchronous IO, rather "
"than blocking IO, because it can be easier to get optimal performance when "
"handling many concurrent connections. Rust has seen some adoption in the "
"network services space, and we wish to continue to enable those users - and "
"to enable adoption by other users - by making it more ergonomic to write "
"asynchronous network services in Rust."
msgstr ""

#: src/2394-async_await.md:26
msgid ""
"The development of asynchronous IO in Rust has gone through multiple phases. "
"Prior to 1.0, we experimented with having a green-threading runtime built "
"into the language. However, this proved too opinionated - because it "
"impacted every program written in Rust - and it was removed shortly before "
"1.0. After 1.0, asynchronous IO initially focused around the mio library, "
"which provided a cross-platform abstraction over the async IO primitives of "
"Linux, Mac OS, and Windows. In mid-2016, the introduction of the futures "
"crate had a major impact by providing a convenient, shared abstraction for "
"asynchronous operations. The tokio library provided a mio-based event loop "
"that could execute code implemented using the futures interfaces."
msgstr ""

#: src/2394-async_await.md:37
msgid ""
"After gaining experience & user feedback with the futures-based ecosystem, "
"we discovered certain ergonomics challenges. Using state which needs to be "
"shared across await points was extremely unergonomic - requiring either Arcs "
"or join chaining - and while combinators were often more ergonomic than "
"manually writing a future, they still often led to messy sets of nested and "
"chained callbacks."
msgstr ""

#: src/2394-async_await.md:44
msgid ""
"Fortunately, the Future abstraction is well suited to use with a syntactic "
"sugar which has become common in many languages with async IO - the async "
"and await keywords. In brief, an asynchronous function returns a future, "
"rather than evaluating immediately when it is called. Inside the function, "
"other futures can be awaited using an await expression, which causes them to "
"yield control while the future is being polled. From a user's perspective, "
"they can use async/await as if it were synchronous code, and only need to "
"annotate their functions and calls."
msgstr ""

#: src/2394-async_await.md:53
msgid ""
"Async/await & futures can be a powerful abstraction for asynchronicity and "
"concurrency in general, and likely has applications outside of the "
"asynchronous IO space. The use cases we've experience with today are "
"generally tied to async IO, but by introducing first class syntax and libstd "
"support we believe more use cases for async & await will also flourish, that "
"are not tied directly to asynchronous IO."
msgstr ""

#: src/2394-async_await.md:60
msgid "Guide-level explanation"
msgstr ""

#: src/2394-async_await.md:63
msgid "Async functions"
msgstr ""

#: src/2394-async_await.md:65
msgid ""
"Functions can be annotated with the `async` keyword, making them \"async "
"functions\":"
msgstr ""

#: src/2394-async_await.md:70
msgid "// ...\n"
msgstr ""

#: src/2394-async_await.md:74
msgid ""
"Async functions work differently from normal functions. When an async "
"function is called, it does not enter the body immediately. Instead, it "
"evaluates to an anonymous type which implements `Future`. As that future is "
"polled, the function is evaluated up to the next `await` or return point "
"inside of it (see the await syntax section next)."
msgstr ""

#: src/2394-async_await.md:80
msgid ""
"An async function is a kind of delayed computation - nothing in the body of "
"the function actually runs until you begin polling the future returned by "
"the function. For example:"
msgstr ""

#: src/2394-async_await.md:86
msgid "\"Hello from print_async\""
msgstr ""

#: src/2394-async_await.md:91 src/2394-async_await.md:114
msgid "\"Hello from main\""
msgstr ""

#: src/2394-async_await.md:96
msgid ""
"This will print `\"Hello from main\"` before printing `\"Hello from "
"print_async\"`."
msgstr ""

#: src/2394-async_await.md:98
msgid ""
"An `async fn foo(args..) -> T` is a function of the type `fn(args..) -> impl "
"Future<Output = T>`. The return type is an anonymous type generated by the "
"compiler."
msgstr ""

#: src/2394-async_await.md:102
msgid "`async ||` closures"
msgstr ""

#: src/2394-async_await.md:104
msgid ""
"In addition to functions, async can also be applied to closures. Like an "
"async function, an async closure has a return type of `impl Future<Output = "
"T>`, rather than `T`. When you call that closure, it returns a future "
"immediately without evaluating any of the body (just like an async function)."
msgstr ""

#: src/2394-async_await.md:112
msgid "\"Hello from async closure.\""
msgstr ""

#: src/2394-async_await.md:116
msgid "\"Hello from main again\""
msgstr ""

#: src/2394-async_await.md:121
msgid ""
"This will print both \"Hello from main\" statements before printing \"Hello "
"from async closure.\""
msgstr ""

#: src/2394-async_await.md:124
msgid ""
"`async` closures can be annotated with `move` to capture ownership of the "
"variables they close over."
msgstr ""

#: src/2394-async_await.md:127
msgid "`async` blocks"
msgstr ""

#: src/2394-async_await.md:129
msgid ""
"You can create a future directly as an expression using an `async` block:"
msgstr ""

#: src/2394-async_await.md:133
msgid "\"Hello from an async block\""
msgstr ""

#: src/2394-async_await.md:137
msgid ""
"This form is almost equivalent to an immediately-invoked `async` closure. "
"That is:"
msgstr ""

#: src/2394-async_await.md:141 src/2394-async_await.md:145
msgid "/* body */"
msgstr ""

#: src/2394-async_await.md:142
msgid "// is equivalent to\n"
msgstr ""

#: src/2394-async_await.md:148
msgid ""
"except that control-flow constructs like `return`, `break` and `continue` "
"are not allowed within `body` (unless they appear within a fresh control-"
"flow context like a closure or a loop). How the `?`\\-operator and early "
"returns should work inside async blocks has not yet been established (see "
"unresolved questions)."
msgstr ""

#: src/2394-async_await.md:154
msgid ""
"As with `async` closures, `async` blocks can be annotated with `move` to "
"capture ownership of the variables they close over."
msgstr ""

#: src/2394-async_await.md:157
msgid "The `await!` compiler built-in"
msgstr ""

#: src/2394-async_await.md:159
msgid ""
"A builtin called `await!` is added to the compiler. `await!` can be used to "
"\"pause\" the computation of the future, yielding control back to the "
"caller. `await!` takes any expression which implements `IntoFuture`, and "
"evaluates to a value of the item type that that future has."
msgstr ""

#: src/2394-async_await.md:165
msgid "// future: impl Future<Output = usize>\n"
msgstr ""

#: src/2394-async_await.md:169
msgid ""
"The expansion of await repeatedly calls `poll` on the future it receives, "
"yielding control of the function when it returns `Poll::Pending` and "
"eventually evaluating to the item value when it returns `Poll::Ready`."
msgstr ""

#: src/2394-async_await.md:173
msgid ""
"`await!` can only be used inside of an async function, closure, or block. "
"Using it outside of that context is an error."
msgstr ""

#: src/2394-async_await.md:176
msgid ""
"(`await!` is a compiler built-in to leave space for deciding its exact "
"syntax later. See more information in the unresolved questions section.)"
msgstr ""

#: src/2394-async_await.md:179
msgid "Reference-level explanation"
msgstr ""

#: src/2394-async_await.md:182
msgid "Keywords"
msgstr ""

#: src/2394-async_await.md:184
msgid "Both `async` and `await` become keywords, gated on the 2018 edition."
msgstr ""

#: src/2394-async_await.md:186
msgid "Return type of `async` functions, closures, and blocks"
msgstr ""

#: src/2394-async_await.md:188
msgid ""
"The return type of an async function is a unique anonymous type generated by "
"the compiler, similar to the type of a closure. You can think of this type "
"as being like an enum, with one variant for every \"yield point\" of the "
"function - the beginning of it, the await expressions, and every return. "
"Each variant stores the state that is needed to be stored to resume control "
"from that yield point."
msgstr ""

#: src/2394-async_await.md:195
msgid ""
"When the function is called, this anonymous type is returned in its initial "
"state, which contains all of the arguments to this function."
msgstr ""

#: src/2394-async_await.md:198
msgid "Trait bounds"
msgstr ""

#: src/2394-async_await.md:200
msgid ""
"The anonymous return type implements `Future`, with the return type as its "
"`Item`. Polling it advances the state of the function, returning `Pending` "
"when it hits an `await` point, and `Ready` with the item when it hits a "
"`return` point. Any attempt to poll it after it has already returned `Ready` "
"once will panic."
msgstr ""

#: src/2394-async_await.md:206
msgid ""
"The anonymous return type has a negative impl for the `Unpin` trait - that "
"is `impl !Unpin`. This is because the future could have internal references "
"which means it needs to never be moved."
msgstr ""

#: src/2394-async_await.md:210
msgid "Lifetime capture in the anonymous future"
msgstr ""

#: src/2394-async_await.md:212
msgid ""
"All of the input lifetimes to this function are captured in the future "
"returned by the async function, because it stores all of the arguments to "
"the function in its initial state (and possibly later states). That is, "
"given a function like this:"
msgstr ""

#: src/2394-async_await.md:221
msgid "It has an equivalent type signature to this:"
msgstr ""

#: src/2394-async_await.md:227
msgid ""
"This is different from the default for `impl Trait`, which does not capture "
"the lifetime. This is a big part of why the return type is `T` instead of "
"`impl Future<Output = T>`."
msgstr ""

#: src/2394-async_await.md:231
msgid "\"Initialization\" pattern"
msgstr ""

#: src/2394-async_await.md:233
msgid ""
"One pattern that sometimes occurs is that a future has an \"initialization\" "
"step which should be performed during its construction. This is useful when "
"dealing with data conversion and temporary borrows. Because the async "
"function does not begin evaluating until you poll it, and it captures the "
"lifetimes of its arguments, this pattern cannot be expressed directly with "
"an `async fn`."
msgstr ""

#: src/2394-async_await.md:239
msgid ""
"One option is to write a function that returns `impl Future` using a closure "
"which is evaluated immediately:"
msgstr ""

#: src/2394-async_await.md:243
msgid "// only arg1's lifetime is captured in the returned future\n"
msgstr ""

#: src/2394-async_await.md:245
msgid "// do some initialization using arg2\n"
msgstr ""

#: src/2394-async_await.md:247
msgid "// closure which is evaluated immediately\n"
msgstr ""

#: src/2394-async_await.md:249
msgid "// asynchronous portion of the function\n"
msgstr ""

#: src/2394-async_await.md:254
msgid "The expansion of await"
msgstr ""

#: src/2394-async_await.md:256
msgid "The `await!` builtin expands roughly to this:"
msgstr ""

#: src/2394-async_await.md:269
msgid ""
"This is not a literal expansion, because the `yield` concept cannot be "
"expressed in the surface syntax within `async` functions. This is why `await!"
"` is a compiler builtin instead of an actual macro."
msgstr ""

#: src/2394-async_await.md:273
msgid "The order of `async` and `move`"
msgstr ""

#: src/2394-async_await.md:275
msgid ""
"Async closures and blocks can be annotated with `move` to capture ownership "
"of the variables they close over. The order of the keywords is fixed to "
"`async move`. Permitting only one ordering avoids confusion about whether it "
"is significant for the meaning."
msgstr ""

#: src/2394-async_await.md:282
msgid "// body\n"
msgstr ""

#: src/2394-async_await.md:286
msgid "Drawbacks"
msgstr ""

#: src/2394-async_await.md:289
msgid ""
"Adding async & await syntax to Rust is a major change to the language - "
"easily one of the most significant additions since 1.0. Though we have "
"started with the smallest beachhead of features, in the long term the set of "
"features it implies will grow as well (see the unresolved questions "
"section). Such a significant addition mustn't be taken lightly, and only "
"with strong motivation."
msgstr ""

#: src/2394-async_await.md:295
msgid ""
"We believe that an ergonomic asynchronous IO solution is essential to Rust's "
"success as a language for writing high performance network services, one of "
"our goals for 2018. Async & await syntax based on the Future trait is the "
"most expedient & low risk path to achieving that goal in the near future."
msgstr ""

#: src/2394-async_await.md:300
msgid ""
"This RFC, along with its companion lib RFC, makes a much firmer commitment "
"to futures & async/await than we have previously as a project. If we decide "
"to reverse course after stabilizing these features, it will be quite costly. "
"Adding an alternative mechanism for asynchronous programming would be more "
"costly because this exists. However, given our experience with futures, we "
"are confident that this is the correct path forward."
msgstr ""

#: src/2394-async_await.md:307
msgid ""
"There are drawbacks to several of the smaller decisions we have made as "
"well. There is a trade off between using the \"inner\" return type and the "
"\"outer\" return type, for example. We could have a different evaluation "
"model for async functions in which they are evaluated immediately up to the "
"first await point. The decisions we made on each of these questions are "
"justified in the appropriate section of the RFC."
msgstr ""

#: src/2394-async_await.md:314
msgid "Rationale and alternatives"
msgstr ""

#: src/2394-async_await.md:317
msgid ""
"This section contains alternative design decisions which this RFC rejects "
"(as opposed to those it merely postpones)."
msgstr ""

#: src/2394-async_await.md:320
msgid "The return type (`T` instead of `impl Future<Output = T>`)"
msgstr ""

#: src/2394-async_await.md:322
msgid ""
"The return type of an asynchronous function is a sort of complicated "
"question. There are two different perspectives on the return type of an "
"async fn: the \"interior\" return type - the type that you return with the "
"`return` keyword, and the \"exterior\" return type - the type that the "
"function returns when you call it."
msgstr ""

#: src/2394-async_await.md:328
msgid ""
"Most statically typed languages with async fns display the \"outer\" return "
"type in the function signature. This RFC proposes instead to display the "
"\"inner\" return type in the function signature. This has both advantages "
"and disadvantages."
msgstr ""

#: src/2394-async_await.md:333
msgid "The lifetime elision problem"
msgstr ""

#: src/2394-async_await.md:335
msgid ""
"As alluded to previously, the returned future captures all input lifetimes. "
"By default, `impl Trait` does not capture any lifetimes. To accurately "
"reflect the outer return type, it would become necessary to eliminate "
"lifetime elision:"
msgstr ""

#: src/2394-async_await.md:345
msgid ""
"This would be very unergonomic and make async both much less pleasant to use "
"and much less easy to learn. This issue weighs heavily in the decision to "
"prefer returning the interior type."
msgstr ""

#: src/2394-async_await.md:349
msgid ""
"We could have it return `impl Future` but have lifetime capture work "
"differently for the return type of `async fn` than other functions; this "
"seems worse than showing the interior type."
msgstr ""

#: src/2394-async_await.md:353
msgid "Polymorphic return (a non-factor for us)"
msgstr ""

#: src/2394-async_await.md:355
msgid ""
"According to the C# developers, one of the major factors in returning "
"`Task<T>` (their \"outer type\") was that they wanted to have async "
"functions which could return types other than `Task`. We do not have a "
"compelling use case for this:"
msgstr ""

#: src/2394-async_await.md:359
msgid ""
"In the 0.2 branch of futures, there is a distinction between `Future` and "
"`StableFuture`. However, this distinction is artificial and only because "
"object-safe custom self-types are not available on stable yet."
msgstr ""

#: src/2394-async_await.md:362
msgid ""
"The current `#[async]` macro has a `(boxed)` variant. We would prefer to "
"have async functions always be unboxed and only box them explicitly at the "
"call site. The motivation for the attribute variant was to support async "
"methods in object-safe traits. This is a special case of supporting `impl "
"Trait` in object-safe traits (probably by boxing the return type in the "
"object case), a feature we want separately from async fn."
msgstr ""

#: src/2394-async_await.md:368
msgid ""
"It has been proposed that we support `async fn` which return streams. "
"However, this mean that the semantics of the internal function would differ "
"significantly between those which return futures and streams. As discussed "
"in the unresolved questions section, a solution based on generators and "
"async generators seems more promising."
msgstr ""

#: src/2394-async_await.md:374
msgid ""
"For these reasons, we don't think there's a strong argument from "
"polymorphism to return the outer type."
msgstr ""

#: src/2394-async_await.md:377
msgid "Learnability / documentation trade off"
msgstr ""

#: src/2394-async_await.md:379
msgid ""
"There are arguments from learnability in favor of both the outer and inner "
"return type. One of the most compelling arguments in favor of the outer "
"return type is documentation: when you read automatically generated API "
"docs, you will definitely see what you get as the caller. In contrast, it "
"can be easier to understand how to write an async function using the inner "
"return type, because of the correspondence between the return type and the "
"type of the expressions you `return`."
msgstr ""

#: src/2394-async_await.md:387
msgid ""
"Rustdoc can handle async functions using the inner return type in a couple "
"of ways to make them easier to understand. At minimum we should make sure to "
"include the `async` annotation in the documentation, so that users who "
"understand async notation know that the function will return a future. We "
"can also perform other transformations, possibly optionally, to display the "
"outer signature of the function. Exactly how to handle API documentation for "
"async functions is left as an unresolved question."
msgstr ""

#: src/2394-async_await.md:395
msgid "Built-in syntax instead of using macros in generators"
msgstr ""

#: src/2394-async_await.md:397
msgid ""
"Another alternative is to focus on stabilizing procedural macros and "
"generators, rather than introducing built-in syntax for async functions. An "
"async function can be modeled as a generator which yields `()`."
msgstr ""

#: src/2394-async_await.md:401
msgid ""
"In the long run, we believe we will want dedicated syntax for async "
"functions, because it is more ergonomic & the use case is compelling and "
"significant enough to justify it (similar to - for example - having built in "
"for loops and if statements rather than having macros which compile to loops "
"and match statements). Given that, the only question is whether or not we "
"could have a more expedited stability by using generators for the time being "
"than by introducing async functions now."
msgstr ""

#: src/2394-async_await.md:409
msgid ""
"It seems unlikely that using macros which expand to generators will result "
"in a faster stabilization. Generators can express a wider range of "
"possibilities, and have a wider range of open questions - both syntactic and "
"semantic. This does not even address the open questions of stabilizing more "
"procedural macros. For this reason, we believe it is more expedient to "
"stabilize the minimal built-in async/await functionality than to attempt to "
"stabilize generators and proc macros."
msgstr ""

#: src/2394-async_await.md:417
msgid "`async` based on generators alone"
msgstr ""

#: src/2394-async_await.md:419
msgid ""
"Another alternative design would be to have async functions _be_ the syntax "
"for creating generators. In this design, we would write a generator like "
"this:"
msgstr ""

#: src/2394-async_await.md:426
msgid ""
"Both return and yield would be optional, default to `()`. An async fn that "
"yields `()` would implement `Future`, using a blanket impl. An async fn that "
"returns `()` would implement `Iterator`."
msgstr ""

#: src/2394-async_await.md:430
msgid ""
"The problem with this approach is that does not ergonomically handle "
"`Stream`s, which need to yield `Poll<Option<T>>`. It's unclear how `await` "
"inside of an async fn yielding something other than `()` (which would "
"include streams) would work.  For this reason, the \"matrix\" approach in "
"which we have independent syntax for generator functions, async functions, "
"and async generator functions, seems like a more promising approach."
msgstr ""

#: src/2394-async_await.md:437
msgid "\"Hot async functions\""
msgstr ""

#: src/2394-async_await.md:439
msgid ""
"As proposed by this RFC, all async functions return immediately, without "
"evaluating their bodies at all. As discussed above, this is not convenient "
"for use cases in which you have an immediate \"initialization\" step - those "
"use cases need to use a terminal async block, for example."
msgstr ""

#: src/2394-async_await.md:444
msgid ""
"An alternative would be to have async functions immediately evaluate up "
"until their first `await`, preserving their state until then. The "
"implementation of this would be quite complicated - they would need to have "
"an additional yield point within the `await`, prior to polling the future "
"being awaited, conditional on whether or not the await is the first await in "
"the body of the future."
msgstr ""

#: src/2394-async_await.md:451
msgid ""
"A fundamental difference between Rust's futures and those from other "
"languages is that Rust's futures do not do anything unless polled. The whole "
"system is built around this: for example, cancellation is dropping the "
"future for precisely this reason. In contrast, in other languages, calling "
"an async fn spins up a future that starts executing immediately. This "
"difference carries over to `async fn` and `async` blocks as well, where it's "
"vital that the resulting future be _actively polled_ to make progress. "
"Allowing for partial, eager execution is likely to lead to significant "
"confusion and bugs."
msgstr ""

#: src/2394-async_await.md:460
msgid ""
"This is also complicated from a user perspective - when a portion of the "
"body is evaluated depends on whether or not it appears before all `await` "
"statements (which could possibly be macro generated). The use of a terminal "
"async block provide a clearer mechanism for distinguishing between the "
"immediately evaluated and asynchronously evaluated portions of a future with "
"an initialization step."
msgstr ""

#: src/2394-async_await.md:467
msgid "Using async/await instead of alternative asynchronicity systems"
msgstr ""

#: src/2394-async_await.md:469
msgid ""
"A final - and extreme - alternative would be to abandon futures and async/"
"await as the mechanism for async/await in Rust and to adopt a different "
"paradigm. Among those suggested are a generalized effects system, monads & "
"do notation, green-threading, and stack-full coroutines."
msgstr ""

#: src/2394-async_await.md:474
msgid ""
"While it is hypothetically plausible that some generalization beyond async/"
"await could be supported by Rust, there has not enough research in this area "
"to support it in the near-term. Given our goals for 2018 - which emphasize "
"shipping - async/await syntax (a concept available widely in many languages "
"which interacts well with our existing async IO libraries) is the most "
"logical thing to implement at this stage in Rust's evolution."
msgstr ""

#: src/2394-async_await.md:481
msgid "Async blocks vs async closures"
msgstr ""

#: src/2394-async_await.md:483
msgid ""
"As noted in the main text, `async` blocks and `async` closures are closely "
"related, and are roughly inter-expressible:"
msgstr ""

#: src/2394-async_await.md:487 src/2394-async_await.md:490
msgid "// almost equivalent\n"
msgstr ""

#: src/2394-async_await.md:496
msgid "We could consider having only one of the two constructs. However:"
msgstr ""

#: src/2394-async_await.md:498
msgid ""
"There's a strong reason to have `async ||` for consistency with `async fn`; "
"such closures are often useful for higher-order constructs like constructing "
"a service."
msgstr ""

#: src/2394-async_await.md:502
msgid ""
"There's a strong reason to have `async` blocks: The initialization pattern "
"mentioned in the RFC text, and the fact that it provides a more direct/"
"primitive way of constructing futures."
msgstr ""

#: src/2394-async_await.md:506
msgid ""
"The RFC proposes to include both constructs up front, since it seems "
"inevitable that we will want both of them, but we can always reconsider this "
"question before stabilization."
msgstr ""

#: src/2394-async_await.md:510
msgid "Prior art"
msgstr ""

#: src/2394-async_await.md:513
msgid ""
"There is a lot of precedence from other languages for async/await syntax as "
"a way of handling asynchronous operation - notable examples include C#, "
"JavaScript, and Python."
msgstr ""

#: src/2394-async_await.md:517
msgid ""
"There are three paradigms for asynchronous programming which are dominant "
"today:"
msgstr ""

#: src/2394-async_await.md:520
msgid "Async and await notation."
msgstr ""

#: src/2394-async_await.md:521
msgid ""
"An implicit concurrent runtime, often called \"green-threading,\" such as "
"communicating sequential processes (e.g. Go) or an actor model (e.g. Erlang)."
msgstr ""

#: src/2394-async_await.md:523
msgid ""
"Monadic transformations on lazily evaluated code, such as do notation (e.g. "
"Haskell)."
msgstr ""

#: src/2394-async_await.md:526
msgid ""
"Async/await is the most compelling model for Rust because it interacts "
"favorably with ownership and borrowing (unlike systems based on monads) and "
"it enables us to have an entirely library-based asynchronicity model (unlike "
"green-threading)."
msgstr ""

#: src/2394-async_await.md:531
msgid ""
"One way in which our handling of async/await differs from most other "
"statically typed languages (such as C#) is that we have chosen to show the "
"\"inner\" return type, rather than the outer return type. As discussed in "
"the alternatives section, Rust's specific context (lifetime elision, the "
"lack of a need for return type polymorphism here) make this deviation well-"
"motivated."
msgstr ""

#: src/2394-async_await.md:537
msgid "Unresolved questions"
msgstr ""

#: src/2394-async_await.md:540
msgid ""
"This section contains design extensions which have been postponed & not "
"included in this initial RFC."
msgstr ""

#: src/2394-async_await.md:543
msgid "Final syntax for the `await` expression"
msgstr ""

#: src/2394-async_await.md:545
msgid ""
"Though this RFC proposes that `await` be a built-in macro, we'd prefer that "
"some day it be a normal control flow construct. The unresolved question "
"about this is how to handle its precedence & whether or not to require "
"delimiters of some kind."
msgstr ""

#: src/2394-async_await.md:550
msgid ""
"In particular, `await` has an interesting interaction with `?`. It is very "
"common to have a future which will evaluate to a `Result`, which the user "
"will then want to apply `?` to. This implies that await should have a "
"tighter precedence than `?`, so that the pattern will work how users wish it "
"to. However, because it introduces a space, it doesn't look like this is the "
"precedence you would get:"
msgstr ""

#: src/2394-async_await.md:561
msgid "There are a couple of possible solutions:"
msgstr ""

#: src/2394-async_await.md:563
msgid ""
"Require delimiters of some kind, maybe braces or parens or either, so that "
"it will look more like how you expect - `await { future }?` - this is rather "
"noisy."
msgstr ""

#: src/2394-async_await.md:566
msgid ""
"Define the precedence as the obvious, if inconvenient precedence, requiring "
"users to write `(await future)?` - this seems very surprising for users."
msgstr ""

#: src/2394-async_await.md:568
msgid ""
"Define the precedence as the inconvenient precedence - this seems equally "
"surprising as the other precedence."
msgstr ""

#: src/2394-async_await.md:570
msgid ""
"Introduce a special syntax to handle the multiple applications, such as "
"`await? future` - this seems very unusual in its own way."
msgstr ""

#: src/2394-async_await.md:573
msgid ""
"This is left as an unresolved question to find another solution or decide "
"which of these is least bad."
msgstr ""

#: src/2394-async_await.md:576
msgid "`for await` and processing streams"
msgstr ""

#: src/2394-async_await.md:578
msgid ""
"Another extension left out of the RFC for now is the ability to process "
"streams using a for loop. One could imagine a construct like `for await`, "
"which takes an `IntoStream` instead of an `IntoIterator`:"
msgstr ""

#: src/2394-async_await.md:584
msgid "\"{}\""
msgstr ""

#: src/2394-async_await.md:588
msgid ""
"This is left out of the initial RFC to avoid having to stabilize a "
"definition of `Stream` in the standard library (to keep the companion RFC to "
"this one as small as possible)."
msgstr ""

#: src/2394-async_await.md:592
msgid "Generators and Streams"
msgstr ""

#: src/2394-async_await.md:594
msgid ""
"In the future, we may also want to be able to define async functions that "
"evaluate to streams, rather than evaluating to futures. We propose to handle "
"this use case by way of generators. Generators can evaluate to a kind of "
"iterator, while async generators can evaluate to a kind of stream."
msgstr ""

#: src/2394-async_await.md:599
msgid "For example (using syntax which could change);"
msgstr ""

#: src/2394-async_await.md:602
msgid "// Returns an iterator of i32\n"
msgstr ""

#: src/2394-async_await.md:609
msgid "// Returns a stream of i32\n"
msgstr ""

#: src/2394-async_await.md:618
msgid "Async functions which implement `Unpin`"
msgstr ""

#: src/2394-async_await.md:620
msgid ""
"As proposed in this RFC, all async functions do not implement `Unpin`, "
"making it unsafe to move them out of a `Pin`. This allows them to contain "
"references across yield points."
msgstr ""

#: src/2394-async_await.md:624
msgid ""
"We could also, with an annotation, typecheck an async function to confirm "
"that it does not contain any references across yield points, allowing it to "
"implement `Unpin`. The annotation to enable this is left unspecified for the "
"time being."
msgstr ""

#: src/2394-async_await.md:628
msgid "`?`\\-operator and control-flow constructs in async blocks"
msgstr ""

#: src/2394-async_await.md:630
msgid ""
"This RFC does not propose how the `?`\\-operator and control-flow constructs "
"like `return`, `break` and `continue` should work inside async blocks."
msgstr ""

#: src/2394-async_await.md:633
msgid ""
"It was discussed that async blocks should act as a boundary for the `?`\\-"
"operator. This would make them suitable for fallible IO:"
msgstr ""

#: src/2394-async_await.md:644
msgid ""
"Also, it was discussed to allow the use of `break` to return early from an "
"async block:"
msgstr ""

#: src/2394-async_await.md:649
msgid "\"foo\""
msgstr ""

#: src/2394-async_await.md:653
msgid ""
"The use of the `break` keyword instead of `return` could be beneficial to "
"indicate that it applies to the async block and not its surrounding "
"function. On the other hand this would introduce a difference to closures "
"and async closures which make use the `return` keyword."
msgstr ""
