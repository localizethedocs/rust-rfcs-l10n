msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:43Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1238-nonparametric-dropck.md:1
msgid "Feature Name: dropck_parametricity"
msgstr ""

#: src/1238-nonparametric-dropck.md:2
msgid "Start Date: 2015-08-05"
msgstr ""

#: src/1238-nonparametric-dropck.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1238](https://github.com/rust-lang/rfcs/pull/1238)/"
msgstr ""

#: src/1238-nonparametric-dropck.md:4
msgid ""
"Rust Issue: [rust-lang/rust#28498](https://github.com/rust-lang/rust/"
"issues/28498)"
msgstr ""

#: src/1238-nonparametric-dropck.md:6
msgid "Summary"
msgstr ""

#: src/1238-nonparametric-dropck.md:8
msgid ""
"Revise the Drop Check (`dropck`) part of Rust's static analyses in two "
"ways.  In the context of this RFC, these revisions are respectively named "
"`cannot-assume-parametricity` and `unguarded-escape-hatch`."
msgstr ""

#: src/1238-nonparametric-dropck.md:12
msgid ""
"`cannot-assume-parametricity` (CAP): Make `dropck` analysis stop relying on "
"parametricity of type-parameters."
msgstr ""

#: src/1238-nonparametric-dropck.md:15
msgid ""
"`unguarded-escape-hatch` (UGEH): Add an attribute (with some name starting "
"with \"unsafe\") that a library designer can attach to a `drop` "
"implementation that will allow a destructor to side-step the `dropck`'s "
"constraints (unsafely)."
msgstr ""

#: src/1238-nonparametric-dropck.md:20
msgid "Motivation"
msgstr ""

#: src/1238-nonparametric-dropck.md:22
msgid "Background: Parametricity in `dropck`"
msgstr ""

#: src/1238-nonparametric-dropck.md:24
msgid ""
"The Drop Check rule (`dropck`) for [Sound Generic Drop](https://github.com/"
"rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md) relies on a "
"reasoning process that needs to infer that the behavior of a polymorphic "
"function (e.g. `fn foo<T>`) does not depend on the concrete type "
"instantiations of any of its _unbounded_ type parameters (e.g. `T` in `fn "
"foo<T>`), at least beyond the behavior of the destructor (if any) for those "
"type parameters."
msgstr ""

#: src/1238-nonparametric-dropck.md:33
msgid ""
"This property is a (weakened) form of a property known in academic circles "
"as _Parametricity_. (See e.g. [Reynolds, IFIP 1983](#reynolds), [Wadler, "
"FPCA 1989](#wadler).)"
msgstr ""

#: src/1238-nonparametric-dropck.md:37
msgid ""
"Parametricity, in this context, essentially says that the compiler can "
"reason about the body of `foo` (and the subroutines that `foo` invokes) "
"without having to think about the particular concrete types that the type "
"parameter `T` is instantiated with. `foo` cannot do anything with a `t: T` "
"except:"
msgstr ""

#: src/1238-nonparametric-dropck.md:43 src/1238-nonparametric-dropck.md:485
msgid "move `t` to some other owner expecting a `T` or,"
msgstr ""

#: src/1238-nonparametric-dropck.md:45 src/1238-nonparametric-dropck.md:487
msgid "drop `t`, running its destructor and freeing associated resources."
msgstr ""

#: src/1238-nonparametric-dropck.md:47
msgid ""
"For example, this allows the compiler to deduce that even if `T` is "
"instantiated with a concrete type like `&Vec<u32>`, the body of `foo` cannot "
"actually read any `u32` data out of the vector. More details about this are "
"available on the [Sound Generic Drop](https://github.com/rust-lang/rfcs/blob/"
"master/text/0769-sound-generic-drop.md) RFC."
msgstr ""

#: src/1238-nonparametric-dropck.md:52
msgid "\"Mistakes were made\""
msgstr ""

#: src/1238-nonparametric-dropck.md:54
msgid ""
"The parametricity-based reasoning in the [Drop Check analysis](https://"
"github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md) "
"(`dropck`) was clever, but fragile and unproven."
msgstr ""

#: src/1238-nonparametric-dropck.md:58
msgid ""
"Regarding its fragility, it has been shown to have [bugs](https://github.com/"
"rust-lang/rust/issues/26656); in particular, parametricity is a necessary "
"but _not_ sufficient condition to justify the inferences that `dropck` makes."
msgstr ""

#: src/1238-nonparametric-dropck.md:63
msgid ""
"Regarding its unproven nature, `dropck` violated the heuristic in Rust's "
"design to not incorporate ideas unless those ideas had already been proven "
"effective elsewhere."
msgstr ""

#: src/1238-nonparametric-dropck.md:69
msgid ""
"These issues might alone provide motivation for ratcheting back on "
"`dropck`'s rules in the short term, putting in a more conservative rule in "
"the stable release channel while allowing experimentation with more-"
"aggressive feature-gated rules in the development nightly release channel."
msgstr ""

#: src/1238-nonparametric-dropck.md:75
msgid ""
"However, there is also a specific reason why we want to ratchet back on the "
"`dropck` analysis as soon as possible."
msgstr ""

#: src/1238-nonparametric-dropck.md:78
msgid "Impl specialization is inherently non-parametric"
msgstr ""

#: src/1238-nonparametric-dropck.md:80
msgid ""
"The parametricity requirement in the Drop Check rule over-restricts the "
"design space for future language changes."
msgstr ""

#: src/1238-nonparametric-dropck.md:83
msgid ""
"In particular, the [impl specialization](https://github.com/rust-lang/rfcs/"
"pull/1210) RFC describes a language change that will allow the invocation of "
"a polymorphic function `f` to end up in different sequences of code based "
"solely on the concrete type of `T`, _even_ when `T` has no trait bounds "
"within its declaration in `f`."
msgstr ""

#: src/1238-nonparametric-dropck.md:91
msgid "Detailed design"
msgstr ""

#: src/1238-nonparametric-dropck.md:93
msgid ""
"Revise the Drop Check (`dropck`) part of Rust's static analyses in two "
"ways.  In the context of this RFC, these revisions are respectively named "
"`cannot-assume-parametricity` (CAP) and `unguarded-escape-hatch` (UGEH)."
msgstr ""

#: src/1238-nonparametric-dropck.md:97
msgid ""
"Though the revisions are given distinct names, they both fall under the "
"feature gate `dropck_parametricity`. (Note however that this might be "
"irrelevant to CAP; see [CAP stabilization details](#cap-stabilization-"
"details))."
msgstr ""

#: src/1238-nonparametric-dropck.md:101
msgid "cannot-assume-parametricity"
msgstr ""

#: src/1238-nonparametric-dropck.md:103
msgid ""
"The heart of CAP is this: make `dropck` analysis stop relying on "
"parametricity of type-parameters."
msgstr ""

#: src/1238-nonparametric-dropck.md:106
msgid "Changes to the Drop-Check Rule"
msgstr ""

#: src/1238-nonparametric-dropck.md:108
msgid ""
"The Drop-Check Rule (both in its original form and as revised here) dictates "
"when a lifetime `'a` must strictly outlive some value `v`, where `v` owns "
"data of type `D`; the rule gave two circumstances where `'a` must strictly "
"outlive the scope of `v`."
msgstr ""

#: src/1238-nonparametric-dropck.md:113
msgid ""
"The first circumstance (`D` is directly instantiated at `'a`) remains "
"unchanged by this RFC."
msgstr ""

#: src/1238-nonparametric-dropck.md:116
msgid ""
"The second circumstance (`D` has some type parameter with trait-provided "
"methods, i.e. that could be invoked within `Drop`) is broadened by this RFC "
"to simply say \"`D` has some type parameter.\""
msgstr ""

#: src/1238-nonparametric-dropck.md:121
msgid ""
"That is, under the changes of this RFC, whether the type parameter has a "
"trait-bound is irrelevant to the Drop-Check Rule. The reason is that any "
"type parameter, regardless of whether it has a trait bound or not, may end "
"up participating in [impl specialization](https://github.com/rust-lang/rfcs/"
"pull/1210), and thus could expose an otherwise invisible reference `&'a "
"AlreadyDroppedData`."
msgstr ""

#: src/1238-nonparametric-dropck.md:127
msgid ""
"`cannot-assume-parametricity` is a breaking change, since the language will "
"start assuming that a destructor for a data-type definition such as `struct "
"Parametri<C>` may read from data held in its `C` parameter, even though the "
"`fn drop` formerly appeared to be parametric with respect to `C`. This will "
"cause `rustc` to reject code that it had previously accepted (below are some "
"examples that [continue to work](#examples-of-code-that-must-continue-to-"
"work) and some that [start being rejected](#examples-of-code-that-will-start-"
"to-be-rejected))."
msgstr ""

#: src/1238-nonparametric-dropck.md:136
msgid "CAP stabilization details"
msgstr ""

#: src/1238-nonparametric-dropck.md:139
msgid ""
"`cannot-assume-parametricity` will be incorporated into the beta and stable "
"Rust channels, to ensure that destructor code atop stable channels in the "
"wild stop relying on parametricity as soon as possible. This will enable new "
"language features such as [impl specialization](https://github.com/rust-lang/"
"rfcs/pull/1210)."
msgstr ""

#: src/1238-nonparametric-dropck.md:145
msgid ""
"It is not yet clear whether it is feasible to include a warning cycle for "
"CAP."
msgstr ""

#: src/1238-nonparametric-dropck.md:148
msgid ""
"For now, this RFC is proposing to remove the parts of Drop-Check that "
"attempted to prove that the `impl<T> Drop` was parametric with respect to "
"`T`. This would mean that there would be more warning cycle; `dropck` would "
"simply start rejecting more code. There would be no way to opt back into the "
"old `dropck` rules."
msgstr ""

#: src/1238-nonparametric-dropck.md:154
msgid ""
"(However, during implementation of this change, we should double-check "
"whether a warning-cycle is in fact feasible.)"
msgstr ""

#: src/1238-nonparametric-dropck.md:157
msgid "unguarded-escape-hatch"
msgstr ""

#: src/1238-nonparametric-dropck.md:159
msgid ""
"The heart of `unguarded-escape-hatch` (UGEH) is this: Provide a new, unsafe "
"(and unstable) attribute-based escape hatch for use in the standard library "
"for cases where Drop Check is too strict."
msgstr ""

#: src/1238-nonparametric-dropck.md:163
msgid "Why we need an escape hatch"
msgstr ""

#: src/1238-nonparametric-dropck.md:165
msgid ""
"The original motivation for the parametricity special-case in the original "
"Drop-Check rule was due to an observation that collection types such as "
"`TypedArena<T>` or `Vec<T>` were often used to contain values that wanted to "
"refer to each other."
msgstr ""

#: src/1238-nonparametric-dropck.md:170
msgid ""
"An example would be an element type like `struct Concrete<'a>(u32, "
"Cell<Option<&'a Concrete<'a>>>);`, and then instantiations of "
"`TypedArena<Concrete>` or `Vec<Concrete>`. This pattern has been used within "
"`rustc`, for example, to store elements of a linked structure within an "
"arena."
msgstr ""

#: src/1238-nonparametric-dropck.md:176
msgid ""
"Without the parametricity special-case, the existence of a destructor on "
"`TypedArena<T>` or `Vec<T>` led the Drop-Check analysis to conclude that "
"those destructors might hypothetically read from the references held within "
"`T` -- forcing `dropck` to reject those destructors."
msgstr ""

#: src/1238-nonparametric-dropck.md:181
msgid ""
"(Note that `Concrete` itself has no destructor; if it did, then `dropck`, "
"both as originally stated and under the changes of this RFC, _would_ force "
"the `'a` parameter of any instance to strictly outlive the instance value, "
"thus ruling out cross-references in the same `TypedArena` or `Vec`.)"
msgstr ""

#: src/1238-nonparametric-dropck.md:187
msgid ""
"Of course, the whole point of this RFC is that using parametricity as the "
"escape hatch seems like it does not suffice. But we still need _some_ escape "
"hatch."
msgstr ""

#: src/1238-nonparametric-dropck.md:191
msgid "The new escape hatch: an unsafe attribute"
msgstr ""

#: src/1238-nonparametric-dropck.md:193
msgid ""
"This leads us to the second component of the RFC, `unguarded-escape-hatch` "
"(UGEH): Add an attribute (with a name starting with \"unsafe\") that a "
"library designer can attach to a `drop` implementation that will allow a "
"destructor to side-step the `dropck`'s constraints (unsafely)."
msgstr ""

#: src/1238-nonparametric-dropck.md:198
msgid ""
"This RFC proposes the attribute name `unsafe_destructor_blind_to_params`. "
"This name was specifically chosen to be long and ugly; see [UGEH "
"stabilization details](#ugeh-stabilization-details) for further discussion."
msgstr ""

#: src/1238-nonparametric-dropck.md:202
msgid ""
"Much like the `unsafe_destructor` attribute that we had in the past, this "
"attribute relies on the programmer to ensure that the destructor cannot "
"actually be used unsoundly. It states an (unproven) assumption that the "
"given implementation of `drop` (and all functions that this `drop` may "
"transitively call) will never read or modify a value of any type parameter, "
"apart from the trivial operations of either dropping the value or moving the "
"value from one location to another."
msgstr ""

#: src/1238-nonparametric-dropck.md:210
msgid ""
"(In particular, it certainly must not dereference any `&`\\-reference within "
"such a value, though this RFC is adopts a somewhat stronger requirement to "
"encourage the attribute to only be used for the limited case of parametric "
"collection types, where one need not do anything more than move or drop "
"values.)"
msgstr ""

#: src/1238-nonparametric-dropck.md:216
msgid ""
"The above assumption must hold regardless of what impact [impl "
"specialization](https://github.com/rust-lang/rfcs/pull/1210) has on the "
"resolution of all function calls."
msgstr ""

#: src/1238-nonparametric-dropck.md:219
msgid "UGEH stabilization details"
msgstr ""

#: src/1238-nonparametric-dropck.md:222
msgid ""
"The proposed attribute is only a _short-term_ patch to work-around a bug "
"exposed by the combination of two desirable features (namely [impl "
"specialization](https://github.com/rust-lang/rfcs/pull/1210) and [`dropck`]"
"(https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop."
"md))."
msgstr ""

#: src/1238-nonparametric-dropck.md:226
msgid ""
"In particular, using the attribute in cases where control-flow in the "
"destructor can reach functions that may be specialized on a type-parameter "
"`T` may expose the system to use-after-free scenarios or other unsound "
"conditions. This may a non-trivial thing for the programmer to prove."
msgstr ""

#: src/1238-nonparametric-dropck.md:232
msgid ""
"Short term strategy: The working assumption of this RFC is that the standard "
"library developers will use the proposed attribute in cases where the "
"destructor _is_ parametric with respect to all type parameters, even though "
"the compiler cannot currently prove this to be the case."
msgstr ""

#: src/1238-nonparametric-dropck.md:238
msgid ""
"The new attribute will be restricted to non-stable channels, like any other "
"new feature under a feature-gate."
msgstr ""

#: src/1238-nonparametric-dropck.md:241
msgid ""
"Long term strategy: This RFC does not make any formal guarantees about the "
"long-term strategy for including an escape hatch. In particular, this RFC "
"does _not_ propose that we stabilize the proposed attribute"
msgstr ""

#: src/1238-nonparametric-dropck.md:246
msgid ""
"It may be possible for future language changes to allow us to directly "
"express the necessary parametricity properties. See further discussion in "
"the [continue supporting parametricity](#continue-supporting-parametricity) "
"alternative."
msgstr ""

#: src/1238-nonparametric-dropck.md:250
msgid ""
"The suggested attribute name (`unsafe_destructor_blind_to_params` above) was "
"deliberately selected to be long and ugly, in order to discourage it from "
"being stabilized in the future without at least some significant discussion. "
"(Likewise, the acronym \"UGEH\" was chosen for its likely pronunciation "
"\"ugh\", again a reminder that we do not _want_ to adopt this approach for "
"the long term.)"
msgstr ""

#: src/1238-nonparametric-dropck.md:258
msgid "Examples of code changes under the RFC"
msgstr ""

#: src/1238-nonparametric-dropck.md:260
msgid ""
"This section shows some code examples, starting with code that works today "
"and must continue to work tomorrow, then showing an example of code that "
"will start being rejected, and ending with an example of the UGEH attribute."
msgstr ""

#: src/1238-nonparametric-dropck.md:265
msgid "Examples of code that must continue to work"
msgstr ""

#: src/1238-nonparametric-dropck.md:268
msgid ""
"Here is some code that works today and must continue to work in the future:"
msgstr ""

#: src/1238-nonparametric-dropck.md:285
msgid ""
"In the above, we are building up a vector, pushing `Concrete` elements onto "
"it, and then later linking those concrete elements together via optional "
"references held in a cell in each concrete element."
msgstr ""

#: src/1238-nonparametric-dropck.md:289
msgid ""
"We can even wrap the vector in a struct that holds it.  This also must "
"continue to work (and will do so under this RFC); such structural "
"composition is a common idiom in Rust code."
msgstr ""

#: src/1238-nonparametric-dropck.md:310
msgid "Examples of code that will start to be rejected"
msgstr ""

#: src/1238-nonparametric-dropck.md:313
msgid ""
"The main change injected by this RFC is this: due to `cannot-assume-"
"parametricity`, an attempt to add a destructor to the `struct Foo` above "
"will cause the code above to be rejected, because we will assume that the "
"destructor for `Foo` may invoke methods on the concrete elements that "
"dereferences their links."
msgstr ""

#: src/1238-nonparametric-dropck.md:318
msgid "Thus, this code will be rejected:"
msgstr ""

#: src/1238-nonparametric-dropck.md:326
msgid "// This is the new `impl Drop`\n"
msgstr ""

#: src/1238-nonparametric-dropck.md:342
msgid ""
"NOTE: Based on a preliminary crater run, it seems that mixing together "
"destructors with this sort of cyclic structure is sufficiently rare that "
"_no_ crates on `crates.io` actually regressed under the new rule: everything "
"that compiled before the change continued to compile after it."
msgstr ""

#: src/1238-nonparametric-dropck.md:348
msgid "Example of the unguarded-escape-hatch"
msgstr ""

#: src/1238-nonparametric-dropck.md:351
msgid ""
"If the developer of `Foo` has access to the feature-gated escape-hatch, and "
"is willing to assert that the destructor for `Foo` does nothing with the "
"links in the data, then the developer can work around the above rejection of "
"the code by adding the corresponding attribute."
msgstr ""

#: src/1238-nonparametric-dropck.md:366
msgid "// This is the UGEH attribute\n"
msgstr ""

#: src/1238-nonparametric-dropck.md:380
msgid "Drawbacks"
msgstr ""

#: src/1238-nonparametric-dropck.md:382
msgid ""
"As should be clear by the tone of this RFC, the `unguarded-escape-hatch` is "
"clearly a hack. It is subtle and unsafe, just as `unsafe_destructor` was "
"(and for the most part, the whole point of [Sound Generic Drop](https://"
"github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md) was "
"to remove `unsafe_destructor` from the language)."
msgstr ""

#: src/1238-nonparametric-dropck.md:388
msgid ""
"However, the expectation is that most clients will have no need to ever use "
"the `unguarded-escape-hatch`."
msgstr ""

#: src/1238-nonparametric-dropck.md:391
msgid ""
"It may suffice to use the escape hatch solely within the collection types of "
"`libstd`."
msgstr ""

#: src/1238-nonparametric-dropck.md:394
msgid ""
"Otherwise, if clients outside of `libstd` determine that they _do_ need to "
"be able to write destructors that need to bypass `dropck` safely, then we "
"can (and _should_) investigate one of the [sound alternatives](#continue-"
"supporting-parametricity), rather than stabilize the unsafe hackish escape "
"hatch.."
msgstr ""

#: src/1238-nonparametric-dropck.md:400
msgid "Alternatives"
msgstr ""

#: src/1238-nonparametric-dropck.md:403
msgid "CAP without UGEH"
msgstr ""

#: src/1238-nonparametric-dropck.md:405
msgid ""
"One might consider adopting `cannot-assume-parametricity` without `unguarded-"
"escape-hatch`.  However, unless some other sort of escape hatch were added, "
"this path would break much more code."
msgstr ""

#: src/1238-nonparametric-dropck.md:409
msgid "UGEH for lifetime parameters"
msgstr ""

#: src/1238-nonparametric-dropck.md:411
msgid ""
"Since we're already being unsafe here, one might consider having the "
"`unsafe_destructor_blind_to_params` apply to lifetime parameters as well as "
"type parameters."
msgstr ""

#: src/1238-nonparametric-dropck.md:415
msgid ""
"However, given that the `unsafe_destructor_blind_to_params` attribute is "
"only intended as a short-term band-aid (see [UGEH stabilization details]"
"(#ugeh-stabilization-details)) it seems better to just make it only as broad "
"as it needs to be (and no broader)."
msgstr ""

#: src/1238-nonparametric-dropck.md:420
msgid "\"Sort-of Guarded\" Escape Hatch"
msgstr ""

#: src/1238-nonparametric-dropck.md:422
msgid ""
"We could add the escape hatch but continue employing the current dropck "
"analysis to it. This would essentially mean that code would have to apply "
"the unsafe attribute to be considered for parametricity, but if there were "
"obvious problems (namely, if the type parameter had a trait bound) then the "
"attempt to opt into parametricity would be ignored and the strict ordering "
"restrictions on the lifetimes would be imposed."
msgstr ""

#: src/1238-nonparametric-dropck.md:429
msgid ""
"I only mention this because it occurred to me in passing; I do not really "
"think it has much of a benefit. It would potentially lead someone to think "
"that their code has been proven sound (since the `dropck` would catch some "
"mistakes in programmer reasoning) but the pitfalls with respect to "
"specialization would remain."
msgstr ""

#: src/1238-nonparametric-dropck.md:435
msgid "Continue Supporting Parametricity"
msgstr ""

#: src/1238-nonparametric-dropck.md:437
msgid ""
"There may be ways to revise the language so that functions can declare that "
"they must be parametric with respect to their type parameters. Here we "
"sketch two potential ideas for how one might do this, mostly to give a hint "
"of why this is not a trivial change to the language."
msgstr ""

#: src/1238-nonparametric-dropck.md:442
msgid ""
"Neither design is likely to be adopted, at least as described here, because "
"both of them impose significant burdens on implementors of parametric "
"destructors, as we will see."
msgstr ""

#: src/1238-nonparametric-dropck.md:446
msgid ""
"(Also, if we go down this path, we will need to fix other bugs in the Drop "
"Check rule, where, as previously noted, parametricity is a [necessary but "
"_insufficient_ condition](https://github.com/rust-lang/rust/issues/26656) "
"for soundness.)"
msgstr ""

#: src/1238-nonparametric-dropck.md:450
msgid "Parametricity via effect-system attributes"
msgstr ""

#: src/1238-nonparametric-dropck.md:452
msgid ""
"One feature of the [impl specialization](https://github.com/rust-lang/rfcs/"
"pull/1210) RFC is that all functions that can be specialized must be "
"declared as such, via the `default` keyword."
msgstr ""

#: src/1238-nonparametric-dropck.md:455
msgid ""
"This leads us to one way that a function could declare that its body must "
"not be allows to call into specialized methods: an attribute like "
"`#[unspecialized]`. The `#[unspecialized]` attribute, when applied to a "
"function `fn foo()`, would mean two things:"
msgstr ""

#: src/1238-nonparametric-dropck.md:460
msgid ""
"`foo` is not allowed to call any functions that have the `default` keyword."
msgstr ""

#: src/1238-nonparametric-dropck.md:462
msgid ""
"`foo` is only allowed to call functions that are also marked "
"`#[unspecialized]`"
msgstr ""

#: src/1238-nonparametric-dropck.md:464
msgid "All `fn drop` methods would be required to be `#[unspecialized]`."
msgstr ""

#: src/1238-nonparametric-dropck.md:466
msgid ""
"It is the second bullet that makes this an ad-hoc effect system: it provides "
"a recursive property ensuring that during the extent of the call to `foo`, "
"we will never invoke a function marked as `default` (and therefore, I "
"_think_, will never even potentially invoke a method that has been "
"specialized)."
msgstr ""

#: src/1238-nonparametric-dropck.md:471
msgid ""
"It is also this second bullet that represents a significant burden on the "
"destructor implementor. In particular, it immediately rules out using any "
"library routine unless that routine has been marked as `#[unspecialized]`. "
"The attribute is unlikely to be included on any function unless the its "
"developer is making a destructor that calls it in tandem."
msgstr ""

#: src/1238-nonparametric-dropck.md:478
msgid "Parametricity via some `?`\\-bound"
msgstr ""

#: src/1238-nonparametric-dropck.md:480
msgid ""
"Another approach starts from another angle: As described earlier, "
"parametricity in `dropck` is the requirement that `fn drop` cannot do "
"anything with a `t: T` (where `T` is some relevant type parameter) except:"
msgstr ""

#: src/1238-nonparametric-dropck.md:489
msgid ""
"So, perhaps it would be more natural to express this requirement via a bound."
msgstr ""

#: src/1238-nonparametric-dropck.md:492
msgid ""
"We would start with the assumption that functions may be non-parametric (and "
"thus their implementations may be specialized to specific types)."
msgstr ""

#: src/1238-nonparametric-dropck.md:496
msgid ""
"But then if you want to declare a function as having a stronger constraint "
"on its behavior (and thus expanding its potential callers to ones that "
"require parametricity), you could add a bound `T: ?Special`."
msgstr ""

#: src/1238-nonparametric-dropck.md:500
msgid ""
"The Drop-check rule would treat `T: ?Special` type-parameters as parametric, "
"and other type-parameters as non-parametric."
msgstr ""

#: src/1238-nonparametric-dropck.md:503
msgid ""
"The marker trait `Special` would be an OIBIT that all sized types would get."
msgstr ""

#: src/1238-nonparametric-dropck.md:505
msgid ""
"Any expression in the context of a type-parameter binding of the form `<T: ?"
"Special>` would not be allowed to call any `default` method where `T` could "
"affect the specialization process."
msgstr ""

#: src/1238-nonparametric-dropck.md:509
msgid ""
"(The careful reader will probably notice the potential sleight-of-hand here: "
"is this really any different from the effect-system attributes proposed "
"earlier? Perhaps not, though it seems likely that the finer grain parameter-"
"specific treatment proposed here is more expressive, at least in theory.)"
msgstr ""

#: src/1238-nonparametric-dropck.md:515
msgid ""
"Like the previous proposal, this design represents a significant burden on "
"the destructor implementor: Again, the `T: ?Special` attribute is unlikely "
"to be included on any function unless the its developer is making a "
"destructor that calls it in tandem."
msgstr ""

#: src/1238-nonparametric-dropck.md:520
msgid "Unresolved questions"
msgstr ""

#: src/1238-nonparametric-dropck.md:522
msgid ""
"What name to use for the attribute? Is `unsafe_destructor_blind_to_params` "
"sufficiently long and ugly? ;)"
msgstr ""

#: src/1238-nonparametric-dropck.md:525
msgid "What is the real long-term plan?"
msgstr ""

#: src/1238-nonparametric-dropck.md:527
msgid ""
"Should we consider merging the discussion of alternatives into the [impl "
"specialization](https://github.com/rust-lang/rfcs/pull/1210) RFC?"
msgstr ""

#: src/1238-nonparametric-dropck.md:530
msgid "Bibliography"
msgstr ""

#: src/1238-nonparametric-dropck.md:532
msgid "Reynolds"
msgstr ""

#: src/1238-nonparametric-dropck.md:534
msgid ""
"John C. Reynolds. \"Types, abstraction and parametric polymorphism\". IFIP "
"1983 http://www.cse.chalmers.se/edu/year/2010/course/DAT140_Types/"
"Reynolds_typesabpara.pdf"
msgstr ""

#: src/1238-nonparametric-dropck.md:537
msgid "Wadler"
msgstr ""

#: src/1238-nonparametric-dropck.md:539
msgid ""
"Philip Wadler. \"Theorems for free!\". FPCA 1989 http://ttic.uchicago.edu/"
"~dreyer/course/papers/wadler.pdf"
msgstr ""
