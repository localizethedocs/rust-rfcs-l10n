msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:02Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0255-object-safety.md:1
msgid "Start Date: 2014-09-22"
msgstr ""

#: src/0255-object-safety.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#255](https://github.com/rust-lang/rfcs/pull/255)"
msgstr ""

#: src/0255-object-safety.md:3
msgid ""
"Rust Issue: [rust-lang/rust#17670](https://github.com/rust-lang/rust/"
"issues/17670)"
msgstr ""

#: src/0255-object-safety.md:5
msgid "Summary"
msgstr ""

#: src/0255-object-safety.md:7
msgid "Restrict which traits can be used to make trait objects."
msgstr ""

#: src/0255-object-safety.md:9
msgid ""
"Currently, we allow any traits to be used for trait objects, but restrict "
"the methods which can be called on such objects. Here, we propose instead "
"restricting which traits can be used to make objects. Despite being less "
"flexible, this will make for better error messages, less surprising software "
"evolution, and (hopefully) better design. The motivation for the proposed "
"change is stronger due to part of the DST changes."
msgstr ""

#: src/0255-object-safety.md:16
msgid "Motivation"
msgstr ""

#: src/0255-object-safety.md:18
msgid ""
"Part of the planned, in progress DST work is to allow trait objects where a "
"trait is expected. Example:"
msgstr ""

#: src/0255-object-safety.md:29
msgid ""
"Previous to DST the call to `foo` was not expected to work because "
"`SomeTrait` was not a type, so it could not instantiate `T`. With DST this "
"is possible, and it makes intuitive sense for this to work (an alternative "
"is to require `impl SomeTrait for SomeTrait { ... }`, but that seems weird "
"and confusing and rather like boilerplate. Note that the precise mechanism "
"here is out of scope for this RFC)."
msgstr ""

#: src/0255-object-safety.md:36
msgid ""
"This is only sound if the trait is object-safe. We say a method `m` on trait "
"`T` is object-safe if it is legal (in current Rust) to call `x.m(...)` where "
"`x` has type `&T`, i.e., `x` is a trait object. If all methods in `T` are "
"object-safe, then we say `T` is object-safe."
msgstr ""

#: src/0255-object-safety.md:41
msgid ""
"If we ignore this restriction we could allow code such as the following:"
msgstr ""

#: src/0255-object-safety.md:45
msgid "// assume self and other have the same concrete type\n"
msgstr ""

#: src/0255-object-safety.md:49
msgid ""
"// x and y may have different concrete types, pre-DST we could\n"
"        // assume that x and y had the same concrete types.\n"
msgstr ""

#: src/0255-object-safety.md:54
msgid "// x and y may have different concrete types\n"
msgstr ""

#: src/0255-object-safety.md:58
msgid ""
"This RFC proposes enforcing object-safety when trait objects are created, "
"rather than where methods on a trait object are called or where we attempt "
"to match traits. This makes both method call and using trait objects with "
"generic code simpler. The downside is that it makes Rust less flexible, "
"since not all traits can be used to create trait objects."
msgstr ""

#: src/0255-object-safety.md:64
msgid ""
"Software evolution is improved with this proposal: imagine adding a non-"
"object-safe method to a previously object-safe trait. With this proposal, "
"you would then get errors wherever a trait-object is created. The error "
"would explain why the trait object could not be created and point out "
"exactly which method was to blame and why. Without this proposal, the only "
"errors you would get would be where a trait object is used with a generic "
"call and would be something like \"type error: SomeTrait does not implement "
"SomeTrait\" - no indication that the non-object-safe method were to blame, "
"only a failure in trait matching."
msgstr ""

#: src/0255-object-safety.md:73
msgid ""
"Another advantage of this proposal is that it implies that all method-calls "
"can always be rewritten into an equivalent [UFCS](0132-ufcs.md) call. This "
"simplifies the \"core language\" and makes method dispatch notation -- which "
"involves some non-trivial inference -- into a kind of \"sugar\" for the more "
"explicit UFCS notation."
msgstr ""

#: src/0255-object-safety.md:79
msgid "Detailed design"
msgstr ""

#: src/0255-object-safety.md:81
msgid ""
"To be precise about object-safety, an object-safe method must meet one of "
"the following conditions:"
msgstr ""

#: src/0255-object-safety.md:84
msgid "require `Self : Sized`; or,"
msgstr ""

#: src/0255-object-safety.md:85
msgid "meet all of the following conditions:"
msgstr ""

#: src/0255-object-safety.md:86
msgid "must not have any type parameters; and,"
msgstr ""

#: src/0255-object-safety.md:87
msgid ""
"must have a receiver that has type `Self` or which dereferences to the "
"`Self` type;"
msgstr ""

#: src/0255-object-safety.md:88
msgid ""
"for now, this means `self`, `&self`, `&mut self`, or `self: Box<Self>`, but "
"eventually this should be extended to custom types like `self: Rc<Self>` and "
"so forth."
msgstr ""

#: src/0255-object-safety.md:91
msgid ""
"must not use `Self` (in the future, where we allow arbitrary types for the "
"receiver, `Self` may only be used for the type of the receiver and only "
"where we allow `Sized?` types)."
msgstr ""

#: src/0255-object-safety.md:95
msgid "A trait is object-safe if all of the following conditions hold:"
msgstr ""

#: src/0255-object-safety.md:97
msgid "all of its methods are object-safe; and,"
msgstr ""

#: src/0255-object-safety.md:98
msgid ""
"the trait does not require that `Self : Sized` (see also [RFC 546](0546-Self-"
"not-sized-by-default.md))."
msgstr ""

#: src/0255-object-safety.md:100
msgid ""
"When an expression with pointer-to-concrete type is coerced to a trait "
"object, the compiler will check that the trait is object-safe (in addition "
"to the usual check that the concrete type implements the trait). It is an "
"error for the trait to be non-object-safe."
msgstr ""

#: src/0255-object-safety.md:105
msgid ""
"Note that a trait can be object-safe even if some of its methods use "
"features that are not supported with an object receiver. This is true when "
"code that attempted to use those features would only work if the `Self` type "
"is `Sized`. This is why all methods that require `Self:Sized` are exempt "
"from the typical rules. This is also why by-value self methods are "
"permitted, since currently one cannot invoke pass an unsized type by-value "
"(though we consider that a useful future extension)."
msgstr ""

#: src/0255-object-safety.md:114
msgid "Drawbacks"
msgstr ""

#: src/0255-object-safety.md:116
msgid ""
"This is a breaking change and forbids some safe code which is legal today. "
"This can be addressed in two ways: splitting traits, or adding `where Self:"
"Sized` clauses to methods that cannot not be used with objects."
msgstr ""

#: src/0255-object-safety.md:121
msgid "Example problem"
msgstr ""

#: src/0255-object-safety.md:123
msgid "Here is an example trait that is not object safe:"
msgstr ""

#: src/0255-object-safety.md:129
msgid "// Object-safe methods may not return `Self`:\n"
msgstr ""

#: src/0255-object-safety.md:134
msgid "Splitting a trait"
msgstr ""

#: src/0255-object-safety.md:136
msgid ""
"One option is to split a trait into object-safe and non-object-safe parts. "
"We hope that this will lead to better design. We are not sure how much code "
"this will affect, it would be good to have data about this."
msgstr ""

#: src/0255-object-safety.md:151
msgid "Adding a where-clause"
msgstr ""

#: src/0255-object-safety.md:153
msgid ""
"Sometimes adding a second trait feels like overkill. In that case, it is "
"often an option to simply add a `where Self:Sized` clause to the methods of "
"the trait that would otherwise violate the object safety rule."
msgstr ""

#: src/0255-object-safety.md:163
msgid "// this condition is new\n"
msgstr ""

#: src/0255-object-safety.md:167
msgid ""
"The reason that this makes sense is that if one were writing a generic "
"function with a type parameter `T` that may range over the trait object, "
"that type parameter would have to be declared `?Sized`, and hence would not "
"have access to the `new` method:"
msgstr ""

#: src/0255-object-safety.md:174
msgid "// illegal because `T : Sized` is not known to hold\n"
msgstr ""

#: src/0255-object-safety.md:178
msgid ""
"However, if one writes a function with sized type parameter, which could "
"never be a trait object, then the `new` function becomes available."
msgstr ""

#: src/0255-object-safety.md:184
msgid "// OK\n"
msgstr ""

#: src/0255-object-safety.md:188
msgid "Alternatives"
msgstr ""

#: src/0255-object-safety.md:190
msgid ""
"We could continue to check methods rather than traits are object-safe. When "
"checking the bounds of a type parameter for a function call where the "
"function is called with a trait object, we would check that all methods are "
"object-safe as part of the check that the actual type parameter satisfies "
"the formal bounds.  We could probably give a different error message if the "
"bounds are met, but the trait is not object-safe."
msgstr ""

#: src/0255-object-safety.md:198
msgid ""
"We might in the future use finer-grained reasoning to permit more non-object-"
"safe methods from appearing in the trait. For example, we might permit `fn "
"foo() -> Self` because it (implicitly) requires that `Self` be sized. "
"Similarly, we might permit other tests beyond just sized-ness. Any such "
"extension would be backwards compatible."
msgstr ""

#: src/0255-object-safety.md:204
msgid "Unresolved questions"
msgstr ""

#: src/0255-object-safety.md:206
msgid "N/A"
msgstr ""

#: src/0255-object-safety.md:208
msgid "Edits"
msgstr ""

#: src/0255-object-safety.md:210
msgid ""
"2014-02-09. Edited by Nicholas Matsakis to (1) include the requirement that "
"object-safe traits do not require `Self:Sized` and (2) specify that methods "
"may include `where Self:Sized` to overcome object safety restrictions."
msgstr ""
