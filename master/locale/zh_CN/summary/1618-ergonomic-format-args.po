msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:43Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1618-ergonomic-format-args.md:1
msgid "Feature Name: (not applicable)"
msgstr ""

#: src/1618-ergonomic-format-args.md:2
msgid "Start Date: 2016-05-17"
msgstr ""

#: src/1618-ergonomic-format-args.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1618](https://github.com/rust-lang/rfcs/pull/1618)"
msgstr ""

#: src/1618-ergonomic-format-args.md:4
msgid ""
"Rust Issue: [rust-lang/rust#33642](https://github.com/rust-lang/rust/"
"pull/33642)"
msgstr ""

#: src/1618-ergonomic-format-args.md:6
msgid "Summary"
msgstr ""

#: src/1618-ergonomic-format-args.md:9
msgid ""
"Removes the one-type-only restriction on `format_args!` arguments. "
"Expressions like `format_args!(\"{0:x} {0:o}\", foo)` now work as intended, "
"where each argument is still evaluated only once, in order of appearance (i."
"e. left-to-right)."
msgstr ""

#: src/1618-ergonomic-format-args.md:14
msgid "Motivation"
msgstr ""

#: src/1618-ergonomic-format-args.md:17
msgid ""
"The `format_args!` macro and its friends historically only allowed a single "
"type per argument, such that trivial format strings like `\"{0:?} == {0:"
"x}\"` or `\"rgb({r}, {g}, {b}) is #{r:02x}{g:02x}{b:02x}\"` are illegal. "
"This is massively inconvenient and counter-intuitive, especially considering "
"the formatting syntax is borrowed from Python where such things are "
"perfectly valid."
msgstr ""

#: src/1618-ergonomic-format-args.md:24
msgid ""
"Upon closer investigation, the restriction is in fact an artificial "
"implementation detail. For mapping format placeholders to macro arguments "
"the `format_args!` implementation did not bother to record type information "
"for all the placeholders sequentially, but rather chose to remember only one "
"type per argument. Also the formatting logic has not received significant "
"attention since after its conception, but the uses have greatly expanded "
"over the years, so the mechanism as a whole certainly needs more love."
msgstr ""

#: src/1618-ergonomic-format-args.md:32
msgid "Detailed design"
msgstr ""

#: src/1618-ergonomic-format-args.md:35
msgid ""
"Formatting is done during both compile-time (expansion-time to be pedantic) "
"and runtime in Rust. As we are concerned with format string parsing, not "
"outputting, this RFC only touches the compile-time side of the existing "
"formatting mechanism which is `libsyntax_ext` and `libfmt_macros`."
msgstr ""

#: src/1618-ergonomic-format-args.md:40
msgid ""
"Before continuing with the details, it is worth noting that the core flow of "
"current Rust formatting is _mapping arguments to placeholders to format "
"specs_. For clarity, we distinguish among _placeholders_, _macro arguments_ "
"and _argument objects_. They are all _italicized_ to provide some visual "
"hint for distinction."
msgstr ""

#: src/1618-ergonomic-format-args.md:46
msgid ""
"To implement the proposed design, the following changes in behavior are made:"
msgstr ""

#: src/1618-ergonomic-format-args.md:48
msgid "implicit references are resolved during parse of format string;"
msgstr ""

#: src/1618-ergonomic-format-args.md:49
msgid "named _macro arguments_ are resolved into positional ones;"
msgstr ""

#: src/1618-ergonomic-format-args.md:50
msgid ""
"placeholder types are remembered and de-duplicated for each _macro argument_,"
msgstr ""

#: src/1618-ergonomic-format-args.md:51
msgid ""
"the _argument objects_ are emitted with information gathered in steps above."
msgstr ""

#: src/1618-ergonomic-format-args.md:53
msgid ""
"As most of the details is best described in the code itself, we only "
"illustrate some of the high-level changes below."
msgstr ""

#: src/1618-ergonomic-format-args.md:56
msgid "Implicit reference resolution"
msgstr ""

#: src/1618-ergonomic-format-args.md:58
msgid ""
"Currently two forms of implicit references exist: `ArgumentNext` and "
"`CountIsNextParam`. Both take a positional _macro argument_ and advance the "
"same internal pointer, but format is parsed before position, as shown in "
"format strings like `\"{foo:.*} {} {:.*}\"` which is in every way equivalent "
"to `\"{foo:.0$} {1} {3:.2$}\"`."
msgstr ""

#: src/1618-ergonomic-format-args.md:64
msgid ""
"As the rule is already known even at compile-time, and does not require the "
"whole format string to be known beforehand, the resolution can happen just "
"inside the parser after a _placeholder_ is successfully parsed. As a natural "
"consequence, both forms can be removed from the rest of the compiler, "
"simplifying work later."
msgstr ""

#: src/1618-ergonomic-format-args.md:70
msgid "Named argument resolution"
msgstr ""

#: src/1618-ergonomic-format-args.md:72
msgid ""
"Not seen elsewhere in Rust, named arguments in format macros are best seen "
"as syntactic sugar, and we'd better actually treat them as such. Just after "
"successfully parsing the _macro arguments_, we immediately rewrite every "
"name to its respective position in the argument list, which again simplifies "
"the process."
msgstr ""

#: src/1618-ergonomic-format-args.md:78
msgid "Processing and expansion"
msgstr ""

#: src/1618-ergonomic-format-args.md:80
msgid ""
"We only have absolute positional references to _macro arguments_ at this "
"point, and it's straightforward to remember all unique _placeholders_ "
"encountered for each. The unique _placeholders_ are emitted into _argument "
"objects_ in order, to preserve evaluation order, but no difference in "
"behavior otherwise."
msgstr ""

#: src/1618-ergonomic-format-args.md:85
msgid "Drawbacks"
msgstr ""

#: src/1618-ergonomic-format-args.md:88
msgid ""
"Due to the added data structures and processing, time and memory costs of "
"compilations may slightly increase. However this is mere speculation without "
"actual profiling and benchmarks. Also the ergonomical benefits alone "
"justifies the additional costs."
msgstr ""

#: src/1618-ergonomic-format-args.md:93
msgid "Alternatives"
msgstr ""

#: src/1618-ergonomic-format-args.md:96
msgid "Do nothing"
msgstr ""

#: src/1618-ergonomic-format-args.md:98
msgid ""
"One can always write a little more code to simulate the proposed behavior, "
"and this is what people have most likely been doing under today's "
"constraints. As in:"
msgstr ""

#: src/1618-ergonomic-format-args.md:108
msgid ""
"// rgb(102, 204, 255) == #66ccff\n"
"\t// println!(\"rgb({r}, {g}, {b}) == #{r:02x}{g:02x}{b:02x}\", r=r, g=g, "
"b=b);\n"
msgstr ""

#: src/1618-ergonomic-format-args.md:110
msgid "\"rgb({}, {}, {}) == #{:02x}{:02x}{:02x}\""
msgstr ""

#: src/1618-ergonomic-format-args.md:114
msgid "Or slightly more verbose when side effects are in play:"
msgstr ""

#: src/1618-ergonomic-format-args.md:126
msgid ""
"// 0b1001000110100 0o11064 0x1234\n"
"\t// 0x1235\n"
"\t// println!(\"{0:#b} {0:#o} {0:#x}\", do_something(&mut i));\n"
"\t// println!(\"{:#x}\", i);\n"
msgstr ""

#: src/1618-ergonomic-format-args.md:131
msgid "// need to consider side effects, hence a temp var\n"
msgstr ""

#: src/1618-ergonomic-format-args.md:134
msgid "\"{:#b} {:#o} {:#x}\""
msgstr ""

#: src/1618-ergonomic-format-args.md:135
msgid "\"{:#x}\""
msgstr ""

#: src/1618-ergonomic-format-args.md:140
msgid ""
"While the effects are the same and nothing requires modification, the "
"ergonomics is simply bad and the code becomes unnecessarily convoluted."
msgstr ""

#: src/1618-ergonomic-format-args.md:143
msgid "Unresolved questions"
msgstr ""

#: src/1618-ergonomic-format-args.md:146
msgid "None."
msgstr ""
