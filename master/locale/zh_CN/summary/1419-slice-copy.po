msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:43Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1419-slice-copy.md:1
msgid "Feature Name: slice\\_copy\\_from"
msgstr ""

#: src/1419-slice-copy.md:2
msgid "Start Date: 2015-12-20"
msgstr ""

#: src/1419-slice-copy.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1419](https://github.com/rust-lang/rfcs/pull/1419)"
msgstr ""

#: src/1419-slice-copy.md:4
msgid ""
"Rust Issue: [rust-lang/rust#31755](https://github.com/rust-lang/rust/"
"issues/31755)"
msgstr ""

#: src/1419-slice-copy.md:6
msgid "Summary"
msgstr ""

#: src/1419-slice-copy.md:9
msgid "Safe `memcpy` from one slice to another of the same type and length."
msgstr ""

#: src/1419-slice-copy.md:11
msgid "Motivation"
msgstr ""

#: src/1419-slice-copy.md:14
msgid ""
"Currently, the only way to quickly copy from one non-`u8` slice to another "
"is to use a loop, or unsafe methods like `std::ptr::copy_nonoverlapping`. "
"This allows us to guarantee a `memcpy` for `Copy` types, and is safe."
msgstr ""

#: src/1419-slice-copy.md:18
msgid "Detailed design"
msgstr ""

#: src/1419-slice-copy.md:21
msgid "Add one method to Primitive Type `slice`."
msgstr ""

#: src/1419-slice-copy.md:29
msgid ""
"`copy_from_slice` asserts that `src.len() == self.len()`, then `memcpy`s the "
"members into `self` from `src`. Calling `copy_from_slice` is semantically "
"equivalent to a `memcpy`.  `self` shall have exactly the same members as "
"`src` after a call to `copy_from_slice`."
msgstr ""

#: src/1419-slice-copy.md:34
msgid "Drawbacks"
msgstr ""

#: src/1419-slice-copy.md:37
msgid "One new method on `slice`."
msgstr ""

#: src/1419-slice-copy.md:39
msgid "Alternatives"
msgstr ""

#: src/1419-slice-copy.md:42
msgid ""
"`copy_from_slice` could be called `copy_to`, and have the order of the "
"arguments switched around. This would follow `ptr::copy_nonoverlapping` "
"ordering, and not `dst = src` or `.clone_from_slice()` ordering."
msgstr ""

#: src/1419-slice-copy.md:46
msgid ""
"`copy_from_slice` could panic only if `dst.len() < src.len()`. This would be "
"the same as what came before, but we would also lose the guarantee that an "
"uninitialized slice would be fully initialized."
msgstr ""

#: src/1419-slice-copy.md:50
msgid ""
"`copy_from_slice` could be a free function, as it was in the original draft "
"of this document. However, there was overwhelming support for it as a method."
msgstr ""

#: src/1419-slice-copy.md:53
msgid ""
"`copy_from_slice` could be not merged, and `clone_from_slice` could be "
"specialized to `memcpy` in cases of `T: Copy`. I think it's good to have a "
"specific function to do this, however, which asserts that `T: Copy`."
msgstr ""

#: src/1419-slice-copy.md:57
msgid "Unresolved questions"
msgstr ""

#: src/1419-slice-copy.md:60
msgid "None, as far as I can tell."
msgstr ""
