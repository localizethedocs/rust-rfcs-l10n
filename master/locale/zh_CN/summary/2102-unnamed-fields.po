msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-01T05:53:04Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2102-unnamed-fields.md:1
msgid "Feature Name: `unnamed_fields`"
msgstr ""

#: src/2102-unnamed-fields.md:2
msgid "Start Date: 2017-08-05"
msgstr ""

#: src/2102-unnamed-fields.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2102](https://github.com/rust-lang/rfcs/pull/2102)"
msgstr ""

#: src/2102-unnamed-fields.md:4
msgid ""
"Rust Issue: [rust-lang/rust#49804](https://github.com/rust-lang/rust/"
"issues/49804)"
msgstr ""

#: src/2102-unnamed-fields.md:6
msgid "Summary"
msgstr ""

#: src/2102-unnamed-fields.md:9
msgid ""
"Allow unnamed fields of `struct` and `union` type, contained within an outer "
"struct or union; the fields they contain appear directly within the "
"containing structure, with the use of `union` and `struct` determining which "
"fields have non-overlapping storage (making them usable at the same time).  "
"This allows grouping and laying out fields in arbitrary ways, to match C "
"data structures used in FFI. The C11 standard allows this, and C compilers "
"have allowed it for decades as an extension. This proposal allows Rust to "
"represent such types using the same names as the C structures, without "
"interposing artificial field names that will confuse users of well-"
"established interfaces from existing platforms."
msgstr ""

#: src/2102-unnamed-fields.md:20
msgid "Motivation"
msgstr ""

#: src/2102-unnamed-fields.md:23
msgid ""
"Numerous C interfaces follow a common pattern, consisting of a `struct` "
"containing discriminants and common fields, and an unnamed `union` of fields "
"specific to certain values of the discriminants. To group together fields "
"used together as part of the same variant, these interfaces also often use "
"unnamed `struct` types."
msgstr ""

#: src/2102-unnamed-fields.md:29
msgid ""
"Thus, `struct` defines a set of fields that can appear at the same time, and "
"`union` defines a set of mutually exclusive overlapping fields."
msgstr ""

#: src/2102-unnamed-fields.md:32
msgid ""
"This pattern appears throughout many C APIs. The Windows and POSIX APIs both "
"use this pattern extensively. However, Rust currently can't represent this "
"pattern in a straightforward way. While Rust supports structs and unions, "
"every such struct and union must have a field name. When creating a binding "
"to such an interface, whether manually or using a binding generator, the "
"binding must invent an artificial field name that does not appear in the "
"original interface."
msgstr ""

#: src/2102-unnamed-fields.md:39
msgid ""
"This RFC proposes a minimal mechanism to support such interfaces in Rust. "
"This feature exists primarily to support ergonomic FFI interfaces that match "
"the layout of data structures for the native platform; this RFC "
"intentionally limits itself to the `repr(C)` structure representation, and "
"does not provide support for using this feature in Rust data structures "
"using `repr(Rust)`. As precedent, Rust's support for variadic argument lists "
"only permits its use on `extern \"C\"` functions."
msgstr ""

#: src/2102-unnamed-fields.md:47
msgid "Guide-level explanation"
msgstr ""

#: src/2102-unnamed-fields.md:50
msgid ""
"This explanation should appear after the definition of `union`, and after an "
"explanation of the rationale for `union` versus `enum` in Rust."
msgstr ""

#: src/2102-unnamed-fields.md:53
msgid ""
"Please note that most Rust code will want to use an `enum` to define types "
"that contain a discriminant and various disjoint fields. The unnamed field "
"mechanism here exist primarily for compatibility with interfaces defined by "
"non-Rust languages, such as C. Types declared with this mechanism require "
"`unsafe` code to access."
msgstr ""

#: src/2102-unnamed-fields.md:59
msgid ""
"A `struct` defines a set of fields all available at the same time, with "
"storage available for each. A `union` defines (in an unsafe, unchecked "
"manner) a set of mutually exclusive fields, with overlapping storage. Some "
"types and interfaces may require nesting such groupings. For instance, a "
"`struct` may contain a set of common fields and a `union` of fields needed "
"for different variations of the structure; conversely, a `union` contain a "
"`struct` grouping together fields needed simultaneously."
msgstr ""

#: src/2102-unnamed-fields.md:67
msgid ""
"Such groupings, however, do not always have associated types and names. A "
"structure may contain groupings of fields where the fields have meaningful "
"names, but the groupings of fields do not. In this case, the structure can "
"contain _unnamed fields_ of `struct` or `union` type, to group the fields "
"together, and determine which fields overlap."
msgstr ""

#: src/2102-unnamed-fields.md:73
msgid ""
"As an example, when defining a `struct`, you may have a set of fields that "
"will never be used at the same time, so you could overlap the storage of "
"those fields. This pattern often occurs within C APIs, when defining an "
"interface similar to a Rust `enum`. You could do so by declaring a separate "
"`union` type and a field of that type. With the unnamed fields mechanism, "
"you can also define an unnamed grouping of overlapping fields inline within "
"the `struct`, using the `union` keyword:"
msgstr ""

#: src/2102-unnamed-fields.md:93
msgid ""
"The underscore `_` indicates the absence of a field name; the fields within "
"the unnamed union will appear directly with the containing structure. Given "
"a struct `s` of this type, code can access `s.a`, `s.d`, and either `s.b` or "
"`s.c`. Accesses to `a` and `d` can occur in safe code; accesses to `b` and "
"`c` require unsafe code, and `b` and `c` overlap, requiring care to access "
"only the field whose contents make sense at the time. As with any `union`, "
"borrows of any `union` field borrow the entire union, so code cannot borrow "
"`s.b` and `s.c` simultaneously if any of the borrows uses `&mut`."
msgstr ""

#: src/2102-unnamed-fields.md:102
msgid ""
"Conversely, sometimes when defining a `union`, you may want to group "
"multiple fields together and make them available simultaneously, with non-"
"overlapping storage. You could do so by defining a separate `struct`, and "
"placing an instance of that `struct` within the `union`. With the unnamed "
"fields mechanism, you can also define an unnamed grouping of non-overlapping "
"fields inline within the `union`, using the `struct` keyword:"
msgstr ""

#: src/2102-unnamed-fields.md:121
msgid ""
"Given a union `u` of this type, code can access `u.a`, or `u.d`, or both `u."
"b` and `u.c`. Since all of these fields can potentially overlap with others, "
"accesses to any of them require unsafe code; however, `b` and `c` do not "
"overlap with each other. Code can borrow `u.b` and `u.c` simultaneously, but "
"cannot borrow any other fields at the same time."
msgstr ""

#: src/2102-unnamed-fields.md:127
msgid ""
"Structs can also contain unnamed structs, and unions can contain unnamed "
"unions."
msgstr ""

#: src/2102-unnamed-fields.md:130
msgid "Unnamed fields can contain other unnamed fields. For example:"
msgstr ""

#: src/2102-unnamed-fields.md:148
msgid ""
"This structure contains six fields: `a`, `b`, `c`, `d`, `e`, and `f`. Safe "
"code can access fields `a` and `f`, at any time, since those fields do not "
"lie within a union and do not overlap with any other field. Unsafe code can "
"access the remaining fields. This definition effectively acts as the overlap "
"of the following three structures:"
msgstr ""

#: src/2102-unnamed-fields.md:155
msgid "// variant 1\n"
msgstr ""

#: src/2102-unnamed-fields.md:162
msgid "// variant 2\n"
msgstr ""

#: src/2102-unnamed-fields.md:171
msgid "// variant 3\n"
msgstr ""

#: src/2102-unnamed-fields.md:181
msgid "Unnamed fields with named types"
msgstr ""

#: src/2102-unnamed-fields.md:183
msgid ""
"An unnamed field may also use a named `struct` or `union` type. For instance:"
msgstr ""

#: src/2102-unnamed-fields.md:199
msgid ""
"Given these declarations, `S` would contain fields `x`, `y`, and `z`, with "
"`x` and `y` overlapping. Such a declaration behaves in every way like the "
"equivalent declaration with an unnamed type declared within `S`, except that "
"this version of the declaration also defines a named union type `U`."
msgstr ""

#: src/2102-unnamed-fields.md:204
msgid ""
"This syntax makes it possible to give a name to the intermediate type, while "
"still leaving the field unnamed. While C11 does not directly support "
"inlining of separately defined structures, compilers do support it as an "
"extension, and this addition allows the translation of such code."
msgstr ""

#: src/2102-unnamed-fields.md:209
msgid ""
"This syntax allows for the common definition of sets of fields inlined into "
"several structures, such as a common header."
msgstr ""

#: src/2102-unnamed-fields.md:212
msgid ""
"This syntax would also support an obvious translation of inline-declared "
"structures with names, by moving the declaration out-of-line; a macro could "
"easily perform such a translation."
msgstr ""

#: src/2102-unnamed-fields.md:216
msgid ""
"Note that the intermediate type name in the declaration must resolve to a "
"concrete type, and cannot involve a generic type parameter of the containing "
"structure."
msgstr ""

#: src/2102-unnamed-fields.md:220
msgid "Mental model"
msgstr ""

#: src/2102-unnamed-fields.md:222
msgid ""
"In the memory layout of a structure, the alternating uses of `struct { ... }"
"` and `union { ... }` change the \"direction\" that fields are being laid "
"out: if you think of memory addresses as going vertically, `struct` lays out "
"fields vertically, in sequence, and `union` lays out fields horizontally, "
"overlapping with each other. The following definition:"
msgstr ""

#: src/2102-unnamed-fields.md:244
msgid "corresponds to the following structure layout in memory:"
msgstr ""

#: src/2102-unnamed-fields.md:258
msgid ""
"The top-level `struct` lays out `a`, the unnamed `union`, and `f`, in "
"sequential order. The unnamed `union` lays out `b`, the unnamed `struct`, "
"and `e`, in parallel. The unnamed `struct` lays out `c` and `d` in "
"sequential order."
msgstr ""

#: src/2102-unnamed-fields.md:263
msgid "Instantiation"
msgstr ""

#: src/2102-unnamed-fields.md:265
msgid "Given the following declaration:"
msgstr ""

#: src/2102-unnamed-fields.md:283
msgid "All of the following will instantiate a value of type `S`:"
msgstr ""

#: src/2102-unnamed-fields.md:285
msgid "`S { a: 1, b: 2, f: 3.0 }`"
msgstr ""

#: src/2102-unnamed-fields.md:286
msgid "`S { a: 1, c: 2, d: 3.0, f: 4.0 }`"
msgstr ""

#: src/2102-unnamed-fields.md:287
msgid "`S { a: 1, e: 2.0, f: 3.0 }`"
msgstr ""

#: src/2102-unnamed-fields.md:289
msgid "Pattern matching"
msgstr ""

#: src/2102-unnamed-fields.md:291
msgid ""
"Code can pattern match on a structure containing unnamed fields as though "
"all the fields appeared at the top level. For instance, the following code "
"matches a discriminant and extracts the corresponding field."
msgstr ""

#: src/2102-unnamed-fields.md:312
msgid "\"b: {}, f: {}\""
msgstr ""

#: src/2102-unnamed-fields.md:313
msgid "\"c: {}, d: {}, f: {}\""
msgstr ""

#: src/2102-unnamed-fields.md:314
msgid "\"e: {}, f: {}\""
msgstr ""

#: src/2102-unnamed-fields.md:315
msgid "\"a: {} (unknown), f: {}\""
msgstr ""

#: src/2102-unnamed-fields.md:320
msgid ""
"If a match goes through one or more `union` fields (named or unnamed), it "
"requires unsafe code; a match that goes through only `struct` fields can "
"occur in safe code."
msgstr ""

#: src/2102-unnamed-fields.md:324
msgid ""
"Checks for exhaustiveness work identically to matches on structures with "
"named fields. For instance, if the above match omitted the last case, it "
"would receive a warning for a non-exhaustive match."
msgstr ""

#: src/2102-unnamed-fields.md:328
msgid ""
"A pattern must include a `..` if it does not match all fields, other than "
"union fields for which it matches another branch of the union. Failing to do "
"so will produce error E0027 (pattern does not mention field). For example:"
msgstr ""

#: src/2102-unnamed-fields.md:332
msgid ""
"Omitting the `f` from any of the first three cases would require adding `..`"
msgstr ""

#: src/2102-unnamed-fields.md:333
msgid ""
"Omitting `b` from the first case, or `e` from the third case, would require "
"adding `..`"
msgstr ""

#: src/2102-unnamed-fields.md:335
msgid ""
"Omitting _either_ `c` or `d` from the second case would require adding `..`"
msgstr ""

#: src/2102-unnamed-fields.md:337
msgid ""
"Effectively, the pattern acts as if it groups all matches of the fields "
"within an unnamed struct or union into a sub-pattern that matches those "
"fields out of the unnamed struct or union, and then produces errors "
"accordingly if a sub-pattern matching an unnamed struct doesn't mention all "
"fields of that struct, or if a pattern doesn't mention _any_ fields in an "
"unnamed union."
msgstr ""

#: src/2102-unnamed-fields.md:343
msgid "Representation"
msgstr ""

#: src/2102-unnamed-fields.md:345
msgid ""
"This feature exists to support the layout of native platform data "
"structures. Structures using the default `repr(Rust)` layout cannot use this "
"feature, and the compiler should produce an error when attempting to do so."
msgstr ""

#: src/2102-unnamed-fields.md:349
msgid ""
"When using this mechanism to define a C interface, always use the `repr(C)` "
"attribute to match C's data structure layout. For convenience, `repr(C)` "
"applied to the top-level structure will automatically apply to every unnamed "
"struct within that declaration, since unnamed fields only permit `repr(C)`. "
"This only applies to `repr(C)`, not to any other attribute."
msgstr ""

#: src/2102-unnamed-fields.md:355
msgid ""
"Such a structure defined with `repr(C)` will use a representation identical "
"to the same structure with all unnamed fields transformed to equivalent "
"named fields of a struct or union type with the same fields."
msgstr ""

#: src/2102-unnamed-fields.md:359
msgid ""
"However, applying `repr(packed)` (or any other attribute) to the top-level "
"data structure does not automatically apply it to all the contained "
"structures. To apply `repr(packed)` to an unnamed field, place the attribute "
"before the field declaration:"
msgstr ""

#: src/2102-unnamed-fields.md:380
msgid ""
"In this declaration, the first unnamed struct uses `repr(packed)`, while the "
"second does not."
msgstr ""

#: src/2102-unnamed-fields.md:383
msgid ""
"Unnamed fields with named types use the representation attributes attached "
"to the named type. The named type must use `repr(C)`."
msgstr ""

#: src/2102-unnamed-fields.md:386
msgid "Derive"
msgstr ""

#: src/2102-unnamed-fields.md:388
msgid ""
"A `struct` or `union` containing unnamed fields may derive `Copy`, `Clone`, "
"or both, if all the fields it contains (including within unnamed fields) "
"also implement `Copy`."
msgstr ""

#: src/2102-unnamed-fields.md:392
msgid ""
"A `struct` containing unnamed fields may derive `Clone` if every field "
"contained directly in the `struct` implements `Clone`, and every field "
"contained within an unnamed `union` (directly or indirectly) implements "
"`Copy`."
msgstr ""

#: src/2102-unnamed-fields.md:396
msgid "Ambiguous field names"
msgstr ""

#: src/2102-unnamed-fields.md:398
msgid ""
"You cannot use this feature to define multiple fields with the same name. "
"For instance, the following definition will produce an error:"
msgstr ""

#: src/2102-unnamed-fields.md:412
msgid ""
"The error will identify the duplicate `a` fields as the sources of the error."
msgstr ""

#: src/2102-unnamed-fields.md:414
msgid "Generics and type parameters"
msgstr ""

#: src/2102-unnamed-fields.md:416
msgid ""
"You can use this feature with a struct or union that has a generic type:"
msgstr ""

#: src/2102-unnamed-fields.md:429
msgid ""
"You may also use a generic struct or union parameterized by a type as the "
"named type of an unnamed field, since the compiler can know all the "
"resulting field names at declaration time without knowing the generic type:"
msgstr ""

#: src/2102-unnamed-fields.md:442
msgid ""
"However, you cannot use a type parameter itself as the named type of an "
"unnamed field:"
msgstr ""

#: src/2102-unnamed-fields.md:449
msgid "// error\n"
msgstr ""

#: src/2102-unnamed-fields.md:453
msgid ""
"This avoids situations in which the compiler must delay producing an error "
"on a field name conflict between `T` and `S` (or on the use of a non-struct, "
"non-union type for `T`) until it knows a specific type for `T`."
msgstr ""

#: src/2102-unnamed-fields.md:457
msgid "Reference-level explanation"
msgstr ""

#: src/2102-unnamed-fields.md:460
msgid "Parsing"
msgstr ""

#: src/2102-unnamed-fields.md:462
msgid ""
"Within a struct or union's fields, in place of a field name and value, allow "
"`_: struct { fields }` or `_: union { fields }`, where `fields` allows "
"everything allowed within a `struct` or `union` declaration, respectively."
msgstr ""

#: src/2102-unnamed-fields.md:466
msgid ""
"Additionally, allow `_` as the name of a field whose type refers to a "
"`struct` or `union`. All of the fields of that `struct` or `union` must be "
"visible to the current module."
msgstr ""

#: src/2102-unnamed-fields.md:470
msgid ""
"The name `_` cannot currently appear as a field name, so this will not "
"introduce any compatibility issues with existing code. The keyword `struct` "
"cannot appear as a field type, making it entirely unambiguous. The "
"contextual keyword `union` could theoretically appear as a type name, but an "
"open brace cannot appear immediately after a field type, allowing "
"disambiguation via a single token of context (`union {`)."
msgstr ""

#: src/2102-unnamed-fields.md:477
msgid "Layout and Alignment"
msgstr ""

#: src/2102-unnamed-fields.md:479
msgid ""
"The layout and alignment of a `struct` or `union` containing unnamed fields "
"must match the C ABI for the equivalent structure. In particular, it should "
"have the same layout that it would if each unnamed field had a separately "
"declared type and a named field of that type, rather than as if the fields "
"appeared directly within the containing `struct` or `union`. This may, in "
"particular, affect alignment."
msgstr ""

#: src/2102-unnamed-fields.md:486
msgid "Simultaneous Borrows"
msgstr ""

#: src/2102-unnamed-fields.md:488
msgid ""
"An unnamed `struct` within a `union` should behave the same with respect to "
"borrows as a named and typed `struct` within a `union`, allowing borrows of "
"multiple fields from within the `struct`, while not permitting borrows of "
"other fields in the `union`."
msgstr ""

#: src/2102-unnamed-fields.md:493
msgid "Visibility"
msgstr ""

#: src/2102-unnamed-fields.md:495
msgid ""
"Each field within an unnamed `struct` or `union` may have an attached "
"visibility. An unnamed field itself does not have its own visibility; all of "
"its fields appear directly within the containing structure, and their own "
"visibilities apply."
msgstr ""

#: src/2102-unnamed-fields.md:500
msgid "Documentation"
msgstr ""

#: src/2102-unnamed-fields.md:502
msgid ""
"Public fields within an unnamed `struct` or `union` should appear in the "
"rustdoc documentation of the outer structure, along with any doc comment or "
"attribute attached to those fields. The rendering should include all unnamed "
"fields that contain (at any level of nesting) a public field, and should "
"include the `// some fields omitted` note within any `struct` or `union` "
"that has non-public fields, including unnamed fields."
msgstr ""

#: src/2102-unnamed-fields.md:509
msgid ""
"Any unnamed field that contains only non-public fields should be omitted "
"entirely, rather than included with its fields omitted. Omitting an unnamed "
"field should trigger the `// some fields omitted` note."
msgstr ""

#: src/2102-unnamed-fields.md:513
msgid "Drawbacks"
msgstr ""

#: src/2102-unnamed-fields.md:516
msgid ""
"This introduces additional complexity in structure definitions. Strictly "
"speaking, C interfaces do not _require_ this mechanism; any such interface "
"_could_ define named struct or union types, and define named fields of that "
"type. This RFC provides a usability improvement for such interfaces."
msgstr ""

#: src/2102-unnamed-fields.md:521
msgid "Rationale and Alternatives"
msgstr ""

#: src/2102-unnamed-fields.md:524
msgid "Not implementing this feature at all"
msgstr ""

#: src/2102-unnamed-fields.md:526
msgid ""
"Choosing not to implement this feature would force binding generators (and "
"the authors of manual bindings) to invent new names for these groupings of "
"fields. Users would need to look up the names for those groupings, and would "
"not be able to rely on documentation for the underlying interface. "
"Furthermore, binding generators would not have any basis on which to "
"generate a meaningful name."
msgstr ""

#: src/2102-unnamed-fields.md:533
msgid "Not implementable as a macro"
msgstr ""

#: src/2102-unnamed-fields.md:535
msgid ""
"We cannot implement this feature as a macro, because it affects the names "
"used to reference the fields contained within an unnamed field. A macro "
"could extract and define types for the unnamed fields, but that macro would "
"have to give a name to those unnamed fields, and accesses would have to "
"include the intermediate name."
msgstr ""

#: src/2102-unnamed-fields.md:541
msgid "Leaving out the `_: ` in unnamed fields"
msgstr ""

#: src/2102-unnamed-fields.md:543
msgid ""
"Rather than declaring unnamed fields with an `_`, as in `_: union { fields }"
"` and `_: struct { fields }`, we could omit the field name entirely, and "
"write `union { fields }` and `struct { fields }` directly. This would more "
"closely match the C syntax. However, this does not provide as natural an "
"extension to support references to named structures."
msgstr ""

#: src/2102-unnamed-fields.md:549
msgid "Allowing type parameters"
msgstr ""

#: src/2102-unnamed-fields.md:551
msgid ""
"We could allow the type parameters of generic types as the named type of an "
"unnamed field. This could allow creative flexibility in API design, such as "
"having a generic type that adds a field alongside the fields of the type it "
"contains. However, this could also lead to much more complex errors that do "
"not arise until the point that code references the generic type. Prohibiting "
"the use of type parameters in this way will not impact common uses of this "
"feature."
msgstr ""

#: src/2102-unnamed-fields.md:558
msgid "Field aliases"
msgstr ""

#: src/2102-unnamed-fields.md:560
msgid ""
"Rather than introducing unnamed fields, we could introduce a mechanism to "
"define field aliases for a type, such that for `struct S`, `s.b` desugars to "
"`s.b_or_c.b`. However, such a mechanism does not seem any simpler than "
"unnamed fields, and would not align as well with the potential future "
"introduction of full anonymous structure types. Furthermore, such a "
"mechanism would need to allow hiding the underlying paths for portability; "
"for example, the `siginfo_t` type on POSIX platforms allows portable access "
"to certain named fields, but different platforms overlap those fields "
"differently using unnamed unions. Finally, such a mechanism would make it "
"harder to create bindings for this common pattern in C interfaces."
msgstr ""

#: src/2102-unnamed-fields.md:571
msgid "Alternate syntax"
msgstr ""

#: src/2102-unnamed-fields.md:573
msgid ""
"Several alternative syntaxes could exist to designate the equivalent of "
"`struct` and `union`. Such syntaxes would declare the same underlying types. "
"However, inventing a novel syntax for this mechanism would make it less "
"familiar both to Rust users accustomed to structs and unions as well as to C "
"users accustomed to unnamed struct and union fields."
msgstr ""

#: src/2102-unnamed-fields.md:579
msgid "Arbitrary field positioning"
msgstr ""

#: src/2102-unnamed-fields.md:581
msgid ""
"We could introduce a mechanism to declare arbitrarily positioned fields, "
"such as attributes declaring the offset of each field. The same mechanism "
"was also proposed in response to the original union RFC. However, as in that "
"case, using struct and union syntax has the advantage of allowing the "
"compiler to implement the appropriate positioning and alignment of fields."
msgstr ""

#: src/2102-unnamed-fields.md:587
msgid "General anonymous types"
msgstr ""

#: src/2102-unnamed-fields.md:589
msgid ""
"In addition to introducing just this narrow mechanism for defining unnamed "
"fields, we could introduce a fully general mechanism for anonymous `struct` "
"and `union` types that can appear anywhere a type can appear, including in "
"function arguments and return values, named structure fields, or local "
"variables. Such an anonymous type mechanism would _not_ replace the need for "
"unnamed fields, however, and vice versa. Furthermore, anonymous types would "
"interact extensively with far more aspects of Rust. Such a mechanism should "
"appear in a subsequent RFC."
msgstr ""

#: src/2102-unnamed-fields.md:598
msgid ""
"This mechanism intentionally does not provide any means to reference an "
"unnamed field as a whole, or its type. That intentional limitation avoids "
"allowing such unnamed types to propagate."
msgstr ""

#: src/2102-unnamed-fields.md:602
msgid "Unresolved questions"
msgstr ""

#: src/2102-unnamed-fields.md:605
msgid ""
"This proposal does _not_ support anonymous `struct` and `union` types that "
"can appear anywhere a type can appear, such as in the type of an arbitrary "
"named field or variable. Doing so would further simplify some C interfaces, "
"as well as native Rust constructs."
msgstr ""

#: src/2102-unnamed-fields.md:610
msgid ""
"However, such a change would also cascade into numerous other changes, such "
"as anonymous struct and union literals. Unlike this proposal, anonymous "
"aggregate types for named fields have a reasonable alternative, namely "
"creating and using separate types; binding generators could use that "
"mechanism, and a macro could allow declaring those types inline next to the "
"fields that use them."
msgstr ""

#: src/2102-unnamed-fields.md:616
msgid ""
"Furthermore, during the pre-RFC process, that portion of the proposal proved "
"more controversial. And such a proposal would have a much more expansive "
"impact on the language as a whole, by introducing a new construct that works "
"anywhere a type can appear. Thus, this proposal provides the minimum change "
"necessary to enable bindings to these types of C interfaces."
msgstr ""

#: src/2102-unnamed-fields.md:622
msgid ""
"C structures can still include other constructs that Rust does not currently "
"represent, including bitfields, and variable-length arrays at the end of a "
"structure. Future RFCs may wish to introduce support for those constructs as "
"well. However, I do not believe it makes sense to require a solution for "
"every problem of interfacing with C simultaneously, nor to gate a solution "
"for one common issue on solutions for others."
msgstr ""
