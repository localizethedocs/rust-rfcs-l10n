<!DOCTYPE HTML>
<html lang="zh_CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2523-cfg-path-version - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-b61d75f0.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Feature Name: <code>cfg_version</code> and <code>cfg_accessible</code></li>
<li>Start Date: 2018-08-12</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2523">rust-lang/rfcs#2523</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/64796">rust-lang/rust#64796</a> and <a href="https://github.com/rust-lang/rust/issues/64797">rust-lang/rust#64797</a></li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Permit users to <code>#[cfg(..)]</code> on whether:</p>
<ul>
<li>they have a certain minimum Rust version (<code>#[cfg(version(1.27.0))]</code>).</li>
<li>a certain external path is accessible (<code>#[cfg(accessible(::std::mem::ManuallyDrop))]</code>).</li>
</ul>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>A core tenet of Rust’s story is <a href="https://blog.rust-lang.org/2014/10/30/Stability.html"><em>“stability without stagnation”</em></a>. We have made great strides sticking to this story while continuously improving the language and the community. This is especially the case with the coming <a href="https://blog.rust-lang.org/2018/07/27/what-is-rust-2018.html">Rust 2018 edition</a>.</p>
<p>However, while the situation for evolving the language is doing well, the situation for library authors is not as good as it could be. Today, crate authors often face a dilemma: - <em>“Shall I provide more features and implementations for later versions of Rust, or should I stay compatible with more versions of the compiler”</em>.</p>
<p>While <a href="http://aturon.github.io/2018/07/25/cargo-version-selection/">much thought</a> has been given to how we can reduce “dependency hell” by enhancing cargo for:</p>
<ul>
<li>the <strong>control</strong> users have over their dependencies.</li>
<li>the <strong>compatibility</strong> of crates with each other.</li>
<li>reducing the <strong>maintainability</strong> burden of having to make sure that versions work with each other.</li>
</ul>
<p>…not much focus has been given to how conditional compilation can be improved to extend how many versions back a crate supports. This becomes critically important if and when we gain LTS channels as proposed by <a href="https://github.com/rust-lang/rfcs/pull/2483">RFC 2483</a>.</p>
<p>The current support for such conditional compilation is lacking. While <a href="https://crates.io/crates/version_check">it is possible</a> to check if you are above a certain compiler version, such facilities are not particularly ergonomic at the moment. In particular, they require the setting up of a <code>build.rs</code> file and declaring up-front which versions you are interested in knowing about. These tools are also unable to check, without performing canary builds of simple programs with <code>use ::std::some::path;</code>, if a certain path exists and instead force you to know which version they were introduced in.</p>
<p><em>We can do better.</em> In this RFC we aim to rectify this by giving library authors the tools they need in the language itself. With the features proposed in the <a href="#summary">summary</a> we aim to make retaining <em>compatibility</em> and supporting more compiler versions <em>pain-free</em> and to give authors a lot of <em>control</em> over what is supported and what is not.</p>
<p>Another use case this RFC supports is to work around compiler bugs by checking if we are on a particular version. An example where this occurred is documented in <a href="https://github.com/rust-lang-nursery/error-chain/issues/101">rust-lang-nursery/error-chain#101</a>.</p>
<h2 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h2>
<h3 id="cfgaccessiblepath"><a class="header" href="#cfgaccessiblepath"><code>#[cfg(accessible($path))]</code></a></h3>
<p>Consider for a moment that we would like to use the <code>Iterator::flatten</code> method of the standard library if it exists (because it has become soon in a certain Rust version), but otherwise fall back to <code>Itertools::flatten</code>. We can do that with the following snippet:</p>
<pre><code class="language-rust">#[cfg(accessible(::std::iter::Flatten))]
fn make_iter(limit: u8) -&gt; impl Iterator&lt;Item = u8&gt; {
    (0..limit).map(move |x| (x..limit)).flatten()
}

#[cfg(not(accessible(::std::iter::Flatten)))]
fn make_iter(limit: u8) -&gt; impl Iterator&lt;Item = u8&gt; {
    use itertools::Itertools;
    (0..limit).map(move |x| (x..limit)).flatten()
}

// Even better
fn make_iter(limit: u8) -&gt; impl Iterator&lt;Item = u8&gt; {
    #[cfg(not(accessible(::std::iter::Flatten)))]
    use itertools::Itertools;
    (0..limit).map(move |x| (x..limit)).flatten()
}

fn main() {
    println!("{:?}", make_iter(10).collect::&lt;Vec&lt;_&gt;&gt;());
}</code></pre>
<p>What this snippet does is the following:</p>
<ol>
<li>If the path <code>::std::iter::Flatten</code> exists, the compiler will compile the first version of <code>make_iter</code>. If the path does not exist, the compiler will instead compile the second version of <code>make_iter</code>.</li>
</ol>
<p>The result of 1. is that your crate will use <code>Iterator::flatten</code> on newer versions of Rust and <code>Itertools::flatten</code> on older compilers. The result of this is that as a crate author, you don’t have to publish any new versions of your crate for the compiler to switch to the libstd version when people use a newer version of Rust.</p>
<p>Once the standard library has stabilized <code>iter::Flatten</code>, future stable compilers will start using the first version of the function.</p>
<p>In this case we used the <code>accessible</code> flag to handle a problem that the addition of <code>Iterator::flatten</code> caused for us if we had used <code>Itertools::flatten</code>. We can also use these mechanisms for strictly additive cases as well. Consider for example the <a href="https://github.com/altsysrq/proptest"><code>proptest</code></a> crate <a href="https://github.com/AltSysrq/proptest/blob/67945c89e09f8223ae945cc8da029181822ce27e/src/num.rs#L66-L76">adding support</a> for <code>RangeInclusive</code>:</p>
<pre><code class="language-rust">// #[cfg_attr(feature = "unstable", feature(inclusive_range))]
// ^-- If you include this line; then `cargo build --features unstable`
//     would cause nightly compilers to activate the feature gate.
//     Note that this has some inherent risks similar to those for
//     `#[cfg(nightly)]` (as discussed later in this RFC).

macro_rules! numeric_api {
    ($typ:ident) =&gt; {
        ...

        #[cfg(accessible(::core::ops::RangeInclusive))]
        impl Strategy for ::core::ops::RangeInclusive&lt;$typ&gt; {
            type Tree = BinarySearch;
            type Value = $typ;

            fn new_tree(&amp;self, runner: &amp;mut TestRunner) -&gt; NewTree&lt;Self&gt; {
                Ok(BinarySearch::new_clamped(
                    *self.start(),
                    $crate::num::sample_uniform_incl(runner, *self.start(), *self.end()),
                    *self.end()))
            }
        }

        ...
    }
}

macro_rules! unsigned_integer_bin_search {
    ($typ:ident) =&gt; {
        pub mod $typ {
            use rand::Rng;

            use strategy::*;
            use test_runner::TestRunner;

            int_any!($typ);
        }
    }
}

unsigned_integer_bin_search!(u8);
unsigned_integer_bin_search!(u16);
...</code></pre>
<p>This means that <code>proptest</code> can continue to evolve and add support for <code>RangeInclusive</code> from the standard library and the <code>x..=y</code> syntax in the language without having to release a new breaking change version. Dependents of <code>proptest</code> simply need to be on a compiler version where <code>::core::ops::RangeInclusive</code> is defined to take advantage of this.</p>
<p>So far we have only used <code>accessible(..)</code> to refer to paths in the standard library. However, while it will be a less likely use case, you can use the flag to test if a path exists in some library in the ecosystem. This can for example be useful if you need to support lower minor versions of a library but also add support for features in a higher minor version.</p>
<h3 id="cfgversion1270"><a class="header" href="#cfgversion1270"><code>#[cfg(version(1.27.0))]</code></a></h3>
<p>Until now, we have only improved our support for library features but never any language features. By checking if we are on a certain minimum version of Rust or any version above it, we can conditionally support such new features. For example:</p>
<pre><code class="language-rust">#[cfg_attr(version(1.27), must_use)]
fn double(x: i32) -&gt; i32 {
    2 * x
}

fn main() {
    double(4);
    // warning: unused return value of `double` which must be used
    // ^--- This warning only happens if we are on Rust &gt;= 1.27.
}</code></pre>
<p>Another example is opting into the system allocator on Rust 1.28 and beyond:</p>
<pre><code class="language-rust">#[cfg(version(1.28))]
// or: #[cfg(accessible(::std::alloc::System))]
use std::alloc::System;

#[cfg_attr(version(1.28), global_allocator)]
static GLOBAL: System = System;

fn main() {
    let mut v = Vec::new();
    // This will allocate memory using the system allocator.
    // ^--- But only on Rust 1.28 and beyond!
    v.push(1);
}</code></pre>
<p>Note that you won’t be able to make use of <code>#[cfg(version(..))]</code> for these particular features since they were introduced before this RFC’s features get stabilized. This means that you can’t for example add <code>version(1.28)</code> to your code and expect Rust 1.28 compilers to enable the code. However, there will be features in the future to use this mechanism on.</p>
<h2 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h2>
<h3 id="cfgversionsemver"><a class="header" href="#cfgversionsemver"><code>#[cfg(version(&lt;semver&gt;))]</code></a></h3>
<p>To the <code>cfg</code> attribute, a <code>version</code> flag is added. This flag has the following grammar (where <code>\d</code> is any digit in <code>0</code> to <code>9</code>):</p>
<pre><code class="language-rust">flag : "version" "(" semver ")" ;
semver : digits ("." digits ("." digits)?)? ;
digits : \d+ ;</code></pre>
<p>If and only if a Rust compiler considers itself to have a version which is greater or equal to the version in the <code>semver</code> string will the <code>#[cfg(version(&lt;semver&gt;)]</code> flag be considered active. Greater or equal is defined in terms of <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#caret-requirements">caret requirements</a>.</p>
<h3 id="cfgaccessiblepath-1"><a class="header" href="#cfgaccessiblepath-1"><code>#[cfg(accessible($path))]</code></a></h3>
<p>To the <code>cfg</code> attribute, an <code>accessible</code> flag is added.</p>
<h4 id="syntactic-form"><a class="header" href="#syntactic-form">Syntactic form</a></h4>
<p>This flag requires that a <code>path</code> fragment be specified in it inside parenthesis but not inside a string literal. The <code>$path</code> must start with leading <code>::</code> and may not refer to any parts of the own crate (e.g. with <code>::crate::foo</code>, <code>::self::foo</code>, or <code>::super::foo</code> if such paths are legal). This restriction exists to ensure that the user does not try to conditionally compile against parts of their own crate because that crate has not been compiled when the <code>accessible</code> flag is checked on an item.</p>
<h4 id="basic-semantics"><a class="header" href="#basic-semantics">Basic semantics</a></h4>
<p>If and only if the path referred to by <code>$path</code> does exist and is public will the <code>#[cfg(accessible($path))]</code> flag be considered active.</p>
<h4 id="feature-gating"><a class="header" href="#feature-gating"><code>#![feature(..)]</code> gating</a></h4>
<p>In checking whether the path exists or not, the compiler will consider feature gated items to exist if the gate has been enabled.</p>
<p><strong>NOTE:</strong> In the section on <code>#[cfg(nightly)]</code> and in the <a href="#guide-level-explanation">guide level explanation</a> we note that there are some risks when combining <code>cfg(feature = "unstable")</code> and <code>accessible(..)</code> to add conditional support for an unstable feature that is expected to stabilize. With respect to such usage:</p>
<ol>
<li>
<p>User-facing documentation, regarding <code>accessible(..)</code> should highlight risky scenarios, including with examples, with respect to possible breakage.</p>
</li>
<li>
<p>Our stability policy is updated to state that breakage caused due to misuse of <code>accessible(..)</code> is <em>allowed</em> breakage. Consequently, rust teams will not delay releases or un-stabilize features because they broke a crate using <code>accessible(..)</code> to gate on those features.</p>
</li>
</ol>
<h4 id="inherent-implementations"><a class="header" href="#inherent-implementations">Inherent implementations</a></h4>
<p>If a path refers to an item inside an inherent implementation, the path will be considered to exist if any configuration of generic parameters can lead to the item. To check whether an item exists for an implementation with a specific sequence of concrete types applied to a type constructor, it is possible to use the <code>::foo::bar::&lt;T&gt;::item</code> syntax.</p>
<h4 id="fields"><a class="header" href="#fields">Fields</a></h4>
<p>It is also possible to refer to fields of <code>struct</code>s, <code>enum</code>s, and <code>unions</code>. Assuming that we have the following definitions in the <code>foobar</code> crate:</p>
<pre><code class="language-rust">pub struct Person { pub ssn: SSN, age: u16 }

pub enum Shape&lt;Unit&gt; {
    Triangle { pub sides: [Unit; 3] },
    ...
}

pub union MaybeUninit&lt;T&gt; { uninit: (), pub value: T }</code></pre>
<p>We can then refer to them like so:</p>
<pre><code class="language-rust">#[cfg(all(
    accessible(::foobar::Person::ssn),
    accessible(::foobar::Shape::Triangle::sides),
    accessible(::foobar::Shape::MaybeUninit::value)
))]
fn do_stuff() {
    ...
}</code></pre>
<h4 id="macros"><a class="header" href="#macros">Macros</a></h4>
<p>Finally, bang macros, derive macros, attributes of all sorts including built-in, user provided, as well as latent derive helper attributes, will be considered when determining if a path is accessible.</p>
<h3 id="cfg_attr-and-cfg"><a class="header" href="#cfg_attr-and-cfg"><code>cfg_attr</code> and <code>cfg!</code></a></h3>
<p>Note that the above sections also apply to the attribute <code>#[cfg_attr(..)]</code> as well as the special macro <code>cfg!(..)</code> in that <code>version(..)</code> and <code>accessible(..)</code> are added to those as well.</p>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>One argument is that hypothetically, if the standard library removed some unstable item, then we might “not notice” if everyone uses it through <code>#[cfg(accessible(..))]</code>.</p>
<h3 id="incremental-garbage-code-and-its-collection"><a class="header" href="#incremental-garbage-code-and-its-collection">Incremental garbage code and its collection</a></h3>
<p>It sometimes happens that feature gates never make it to stable and that they instead get scrapped. This occurs infrequently. However, when this does happen, code that is conditionally compiled under <code>#[cfg(accessible(::std::the::obsoleted::path))]</code> will become garbage that just sits around. Over time, this garbage can grow to a non-trivial amount.</p>
<p>However, if we provide LTS channels in the style of <a href="https://github.com/rust-lang/rfcs/pull/2483">RFC 2483</a>, then there are opportunities to perform some “garbage collection” of definitions that won’t be used when the LTS version changes.</p>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<h3 id="accessible"><a class="header" href="#accessible"><code>accessible(..)</code></a></h3>
<p>The primary rationale for the <code>accessible</code> mechanism is that when you want to support some library feature, it is some path you are thinking of rather than what version it was added. For example, if you want to use <code>ManuallyDrop</code>, you can just ask if it exists. The <code>version</code> is instead a proxy for the feature. Instead of detecting if the path we want is available or not via an indirection, we can just check if the path exists directly. This way, a user does not have to look up the minimum version number for the feature.</p>
<p>You may think that <code>version(..)</code> subsumes <code>accessible(..)</code>. However, we argue that it does not. This is the case because at the time of enabling the <code>feature = "unstable"</code> feature that enables the path in libstd, we do not yet know what minimum version it will be supported under. If we try to support it with <code>version(..)</code>, it is possible that we may need to update the minimum version some small number of times. However, doing so even once means that you will need to release new versions of your crate. If you instead use <code>accessible(..)</code> you won’t need to use it even once unless the name of the path changes in-between.</p>
<p>Another use case <code>accessible(..)</code> supports that <code>version(..)</code> doesn’t is checking support for atomic types, e.g. <code>accessible(::std::sync::atomic::AtomicU8)</code>. This subsumes the proposed <code>#[cfg(target_has_atomic = "..")]</code> construct.</p>
<h4 id="preventing-relative-paths"><a class="header" href="#preventing-relative-paths">Preventing relative paths</a></h4>
<p>The reason why we have enforced that all paths must start with <code>::</code> inside <code>accessible(..)</code> is that if we allow relative paths, and users write <code>accessible(self::foo)</code>, then they can construct situations such as:</p>
<pre><code class="language-rust">#[cfg(accessible(self::bar)]
fn foo() {}

#[cfg(accessible(self::foo)]
fn bar() {}</code></pre>
<p>One way around this is to collect all items before <code>cfg</code>-stripping, but this can cause problems with respect to stage separation. Therefore, we prevent this from occurring with a simple syntactic check.</p>
<p>One mechanism we could use to make relative paths work is to use a different resolution algorithm for <code>accessible(..)</code> than for <code>use</code>. We would first syntactically reject <code>self::$path</code>, <code>super::$path</code>, and <code>crate::$path</code>. The resolution algorithm would then need to deal with situations such as:</p>
<pre><code class="language-rust">#[cfg(accessible(bar)]
fn foo() {}

#[cfg(accessible(foo)]
fn bar() {}</code></pre>
<p>by simply not considering local items and assuming that <code>bar</code> and <code>foo</code> are crates. While that would make <code>accessible($path)</code> a bit more ergonomic by shaving off two characters, chances are, assuming the <code>uniform_paths</code> system, that it would lead to surprises for some users who think that <code>bar</code> and <code>foo</code> refer to the local crate. This is problematic because it is not immediately evident for the user which is which since a different crate is needed to observe the difference.</p>
<p>Also do note that requiring absolute paths with leading <code>::</code> is fully forward-compatible with not requiring leading <code>::</code>. If we experience that this restriction is a problem in the future, we may remove the restriction.</p>
<h4 id="cfgaccessible-or-cfgaccessible--"><a class="header" href="#cfgaccessible-or-cfgaccessible--"><code>#[cfg(accessible(..))</code> or <code>#[cfg(accessible = ..)</code></a></h4>
<p>We need to decide between the syntax <code>accessible(..)</code> or <code>accessible = ..</code>. The reason we’ve opted for the former rather than the latter is that the former syntax looks more like a question/query whilst the latter looks more like a statement of fact.</p>
<p>In addition, if we would like to enable <code>accessible = $path</code> we would need to extend the meta grammar. We could justify that change in and of itself by observing that crates such as <code>serde_derive</code> permit users to write things like <code>#[serde(default = "some::function")]</code>. By changing the grammar we can allow users to instead write: <code>#[serde(default = some::function)]</code>. However, in this case, <code>accessible($path)</code> seems the optimal notation.</p>
<p>If we would like to extend the meta grammar, we could do so by changing:</p>
<pre><code>named_value : "=" lit ;

meta_or_lit : meta | lit ;
meta_or_lit_list : meta_or_lit "," meta_or_lit_list ","? ;
meta_list : "(" meta_or_lit_list ")" ;
meta : path ( named_value | meta_list )? ;
</code></pre>
<p>into:</p>
<pre><code>lit_or_path : path | lit ;
named_value : "=" lit_or_path ;

meta_or_lit : meta | lit ;
meta_or_lit_list : meta_or_lit "," meta_or_lit_list ","? ;
meta_list : "(" meta_or_lit_list ")" ;
meta : path ( named_value | meta_list )? ;
</code></pre>
<h4 id="the-bikeshed"><a class="header" href="#the-bikeshed">The bikeshed</a></h4>
<p>One might consider other names for the flag instead of <code>accessible</code>. Some contenders are:</p>
<ul>
<li><code>reachable</code></li>
<li><code>path_accessible</code></li>
<li><code>usable</code></li>
<li><code>can_use</code></li>
<li><code>path_exists</code></li>
<li><code>have_path</code> (or <code>has_path</code>)</li>
<li><code>have</code></li>
<li><code>have_item</code></li>
<li><code>path_reachable</code></li>
<li><code>item_reachable</code></li>
<li><code>item_exists</code></li>
</ul>
<h5 id="accessible-1"><a class="header" href="#accessible-1"><code>accessible</code></a></h5>
<p>Currently <code>accessible</code> is the choice because it clearly signals the intent while also being short enough to remain ergonomic to use. In particular, while <code>path_accessible</code> might be somewhat more unambiguous, we argue that from the context of seeing <code>accessible(::std::foo::bar)</code> it is clear that it is paths we are talking about because the argument is a path and not something else.</p>
<h5 id="reachable"><a class="header" href="#reachable"><code>reachable</code></a></h5>
<p>The word <code>reachable</code> is also a synonym of <code>accessible</code> and is one character shorter. However, it tends to have a different meaning in code. Examples include:</p>
<ul>
<li><code>std::hint::unreachable_unchecked</code></li>
<li><code>std::unreachable</code></li>
</ul>
<p>All in all, we have chosen to go with <code>accessible</code> instead as the more intuitive option.</p>
<h5 id="usable"><a class="header" href="#usable"><code>usable</code></a></h5>
<p>While <code>can_use</code> and <code>usable</code> are also strong contenders, we reject these options because they may imply to the user that only things that you may <code>use $path;</code> can go in there. Meanwhile, you may <code>#[cfg(accessible(::foo::MyTrait::my_method))</code> which is <em>not</em> possible as <code>use ::foo::MyTrait::my_method;</code>. This also applies to other associated items and inherent methods as well as <code>struct</code> fields.</p>
<h5 id="has_path"><a class="header" href="#has_path"><code>has_path</code></a></h5>
<p>Another strong contender is <code>has_path</code> or <code>have_path</code>.</p>
<p>However, this variant is vague with respect to what “having” something means. In other words, it does not say whether it refers to being accessible and public, or whether it is usable, and so on.</p>
<p>As we previously noted, having <code>path</code> in the name is also somewhat redundant because it is clear that <code>::std::bar</code> is a path.</p>
<p>Another small wrinkle is that it is unclear whether it should be <code>have</code> or <code>has</code>. That choice depends on what one things the subject is. For example, if one considers a module to be an “it”, then it should probably be <code>has</code>.</p>
<p>One upside to <code>has_path</code> is that it has precedent from the <code>clang</code> compiler. For example, a user may write: <code>#if __has_feature(cxx_rvalue_references)</code> or <code>__has_feature(c_generic_selections)</code>.</p>
<p>Another benefit is that <code>has_</code> gives us the opportunity to introduce a family of <code>has_path</code>, <code>has_feature</code>, and <code>has_$thing</code> if we so wish.</p>
<h3 id="cfgversion"><a class="header" href="#cfgversion"><code>#[cfg(version(..))</code></a></h3>
<p>When it comes to <code>version(..)</code>, it is needed to support conditional compilation of language features as opposed to library features as previously shown. Also, as we’ve seen, <code>version(..)</code> does not subsume <code>accessible(..)</code> but is rather a complementary mechanism.</p>
<p>One problem specific to <code>version(..)</code> is that it might get too <code>rustc</code> specific. It might be difficult for other Rust implementations than <code>rustc</code> to work with this version numbering as libraries will compile against <code>rustc</code>s release numbering. However, it is possible for other implementations to follow <code>rustc</code> in the numbering and what features it provides. This is probably not too unreasonable as we can expect <code>rustc</code> to be the reference implementation and that other ones will probably lag behind. Indeed, this is the experience with <code>GHC</code> and alternative Haskell compilers.</p>
<h4 id="the-bikeshed---argument-syntax"><a class="header" href="#the-bikeshed---argument-syntax">The bikeshed - Argument syntax</a></h4>
<p>We have roughly two options with respect to how the <code>version</code> flag may be specified:</p>
<ol>
<li><code>version = "&lt;semver&gt;"</code></li>
<li><code>version(&lt;semver&gt;)</code></li>
</ol>
<p>The syntax in 2. is currently an error in <code>#[cfg(..)]</code> as you may witness with:</p>
<pre><code class="language-rust">// error[E0565]: unsupported literal
#[cfg(abracadabra(1.27))] fn bar() {}
                  ^^^^</code></pre>
<p>However, the attribute grammar is <a href="https://github.com/rust-lang/rust/blob/097c40cf6e1defc2fc49d521374254ee27f5f1fb/src/libsyntax/parse/attr.rs#L141-L149">technically</a>:</p>
<pre><code class="language-rust">attribute  : "#" "!"? "[" path attr_inner? "]" ;
attr_inner : "[" token_stream "]"
           | "(" token_stream ")"
           | "{" token_stream "}"
           | "=" token_tree
           ;</code></pre>
<p>Note in particular that <code>#[my_attribute(&lt;token_stream&gt;)]</code> is a legal production in the grammar wherefore we can support <code>#[cfg(version(1.27.0))]</code> if we so wish.</p>
<p>Given that syntax 2. is possible, we have decided to use it because as <a href="https://github.com/eddyb">@eddyb</a> has noted, the <code>cfg</code> flags that use the <code>flag = ".."</code> syntax are all static as opposed to dynamic. In other words, the semantics of <code>cfg(x = "y")</code> is that of checking for a membership test within a fixed set determined ahead of time. This set is also available through <code>rustc --print=cfg</code>.</p>
<p>What a user may infer from how other <code>cfg(flag = "..")</code> flags work is that <code>version = ".."</code> checks for an <em>exact</em> version. But as we’ve seen before, this interpretation is not the one in this RFC.</p>
<p>However, one reason to pick syntax 1. is that <code>version(..)</code> looks like a list.</p>
<h4 id="the-bikeshed---attribute-name"><a class="header" href="#the-bikeshed---attribute-name">The bikeshed - Attribute name</a></h4>
<p>Naturally, there are other possible names for the flag. For example:</p>
<ul>
<li><code>rustc_version</code></li>
<li><code>compiler_version</code></li>
<li><code>min_version</code></li>
</ul>
<p>We pick the current naming because we believe it is sufficiently clear while also short and sweet. However, <code>min_version</code> is a good alternative to consider because it telegraphs the <code>&gt;=</code> nature of the flag.</p>
<p>As for the <code>&lt;semver&gt;</code> syntax, it could also be adjusted such that you could write <code>version(&gt;= 1.27)</code>. We could also support exact version checking (<code>==</code>) as well as checking if the compiler is below a certain version (<code>&lt;=</code>). There are also the “tilde requirements” and “wildcard requirements” that Cargo features that we could add. However, as a first iteration, <code>version(1.27.0)</code> is simple and covers most use cases.</p>
<h3 id="version_check-as-an-alternative"><a class="header" href="#version_check-as-an-alternative"><a href="https://crates.io/crates/version_check">version_check</a> as an alternative</a></h3>
<p>Using the crate <code>version_check</code> we may conditionally compile using a <code>build.rs</code> file. For example, the <a href="https://crates.io/crates/dbg">dbg</a> crate does this:</p>
<pre><code class="language-rust">// src/lib.rs:
// -----------------------------------------------------------------------------

#![cfg_attr(use_nightly, feature(core_intrinsics, specialization))]

// Deal with specialization:
// On nightly: typeof(expr) doesn't need to be Debug.
#[allow(dead_code)]
#[doc(hidden)]
pub struct WrapDebug&lt;T&gt;(pub T);
use std::fmt::{Debug, Formatter, Result};

#[cfg(use_nightly)]
impl&lt;T&gt; Debug for WrapDebug&lt;T&gt; {
    default fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result {
        use ::std::intrinsics::type_name;
        write!(f, "[&lt;unknown&gt; of type {} is !Debug]",
            unsafe { type_name::&lt;T&gt;() })
    }
}

...

// build.rs:
// -----------------------------------------------------------------------------

//!
//! This build script detects if we are nightly or not
//!

extern crate version_check;

fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    if let Some(true) = version_check::is_nightly() {
        println!("cargo:rustc-cfg=use_nightly");
    }
}</code></pre>
<p>The <a href="https://crates.io/crates/version_check">version_check</a> crate also supports testing for a minimum <code>version(..)</code> with:</p>
<pre><code class="language-rust">extern crate version_check;

if let Some((true, _)) = version_check::is_min_version("1.13.0") {
    println!("cargo:rustc-cfg=MIN_COMPILER_1_13");
}</code></pre>
<p>However, this is quite verbose in comparison and requires you to invent ad-hoc and crate-specific names for your <code>#[cfg(..)]</code> flags such as <code>MIN_COMPILER_1_13</code> that will not be the same for every crate. You will also need to repeat this per version you want to support. This causes the mechanism to scale poorly as compared to <code>version(1.27)</code> which we argue is simple and intuitive.</p>
<h3 id="conditional-compilation-on-feature-gates"><a class="header" href="#conditional-compilation-on-feature-gates">Conditional compilation on feature gates</a></h3>
<p>An alternative to <code>version(..)</code> and <code>accessible(..)</code> is to allow users to query where a certain feature gate is stable or not. However, it has been argued that allowing this would essentially stabilize the names of the gates which we’ve historically not done.</p>
<p>We also argue that <code>accessible(..)</code> is more intuitive because it is more natural to think of a feature in terms of how you would make use of it (via its path) rather than the sometimes somewhat arbitrarily named feature gate.</p>
<h2 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h2>
<h3 id="crates"><a class="header" href="#crates">Crates</a></h3>
<p>As previously mentioned, the <a href="https://crates.io/crates/version_check">version_check</a> crate provides precedent for doing the desired conditional compilation in this RFC. There is also the <a href="https://crates.io/crates/rustc_version">rustc_version</a> crate. Together, these crates have 18 + 67 direct reverse dependencies. This suggests that the feature is both desired and used.</p>
<h3 id="haskell"><a class="header" href="#haskell">Haskell</a></h3>
<p>Using the Glasgow Haskell Compiler (GHC), it is possible to conditionally compile using it’s provided preprocessor:</p>
<pre><code class="language-haskell">{-# LANGUAGE CPP #-}

module Main where

version :: String
#if __GLASGOW_HASKELL__ &gt;= 706
version = "Version 7.0.6"
#else
version = "Below."
#endif

main :: IO ()
main = putStrLn version
</code></pre>
<h3 id="clang"><a class="header" href="#clang">Clang</a></h3>
<p>The <code>clang</code> compiler gives you a <a href="https://clang.llvm.org/docs/LanguageExtensions.html#feature-checking-macros">suite of feature checking macros</a> with which you can for example check whether a certain feature, extension, or attribute is supported. An example of this is:</p>
<pre><code class="language-cpp">#if __has_feature(cxx_rvalue_references)

// This code will only be compiled with the -std=c++11 and -std=gnu++11
// options, because rvalue references are only standardized in C++11.

#endif
</code></pre>
<p>This would be analogous to checking for the existence of a feature gate in Rust.</p>
<p>Clang also supports checking whether an <a href="https://clang.llvm.org/docs/LanguageExtensions.html#include-file-checking-macros">include</a> will succeed. For example, you may write:</p>
<pre><code class="language-cpp">#if __has_include("myinclude.h") &amp;&amp; __has_include(&lt;stdint.h&gt;)
#include "myinclude.h"
#endif
</code></pre>
<p>This is similar in spirit to <code>accessible($path)</code>.</p>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<p>The ability to have optional cargo dependencies is out of scope for this RFC.</p>
<ol>
<li>
<p>Is it technically feasible to implement <code>accessible(..)</code>? For example it could be hard if cfg-stripping runs before resolving things.</p>
<p>@eddyb has indicated that:</p>
<blockquote>
<p>The good news is that we should be able to resolve that during macro expansion nowadays. The bad news is I don’t know how hard early stability checking would be although, no, we should be able to easily add a <code>DefId -&gt; Option&lt;Stability&gt;</code> method somewhere, with enough information to check against feature-gates (assuming the set of <code>#![feature(...)]</code>s in the local crate is known at <code>cfg</code>-stripping time).</p>
</blockquote>
</li>
<li>
<p>Should we allow referring to fields of type definitions in <code>accessible(..)</code>?</p>
</li>
<li>
<p>In the <a href="#reference-level-explanation">reference-level-explanation</a>, we note that:</p>
<blockquote>
<p>If and only if a Rust compiler considers itself to have a version which is greater or equal to the version in the <code>semver</code> string will the <code>#[cfg(version(&lt;semver&gt;)]</code> flag be considered active.</p>
</blockquote>
<p>However, it is currently not well specified what “considers itself” exactly means. To be more precise, if querying a mid-cycle nightly compiler with <code>rustc --version</code> results in <code>rustc 1.29.0-nightly (31f1bc7b4 2018-07-15)</code>, but 1.29.0 has not been released on the stable channel, will then <code>version(1.29.0)</code> be active for this nightly or will it not?</p>
<p>The reason this question matters is because on one 1.29.0-nightly compiler, a feature may not have been stabilized. Some days later, but before 1.29.0 hits a beta or stable compiler, a feature does get stabilized.</p>
<p>To resolve this question, there are broadly 3 approaches:</p>
<ol>
<li>
<p>Answer the question in the affirmative. This entails that some breakage might sometimes occur when using a nightly compiler.</p>
</li>
<li>
<p>Answer it in the negative by changing the date when the version constant is bumped in the compiler. That is, a version would only be bumped when releasing new stable or beta compilers and nightly compilers would always be versioned as the latest stable/beta. This also means that given <code>#[stable(feature = "foobar", since = "1.42.0")]</code> for some feature <code>foobar</code>, the feature would not be available first when the feature actually reaches stable/beta.</p>
</li>
<li>
<p>As 2. but separate versions reported by <code>rustc --version</code> and to <code>version(..)</code>. This would for example mean that if the last stable compiler is <code>1.42.0</code>, then that would be used by <code>version(..)</code> while <code>rustc --version</code> would report <code>1.43.0-nightly</code>. This approach could be technically achieved by for example maintaining one version constant that tracks the last stable/beta compiler as <code>x.y.z</code> and then <code>--version</code> would report <code>x.(y + 1).0-nightly</code>.</p>
</li>
</ol>
<p>Two arguments in favour of either 2. or 3. is that they would be more principled as we have not really stabilized something until it reaches stable or beta.</p>
<p>We consider this unresolved question to be a matter of implementation detail which may be resolved during implementation.</p>
</li>
</ol>
<h2 id="possible-future-work"><a class="header" href="#possible-future-work">Possible future work</a></h2>
<h3 id="cfgrust_feature"><a class="header" href="#cfgrust_feature"><code>#[cfg(rust_feature(..))]</code></a></h3>
<p>One possible extension we might want to do in the future is to allow users to check whether a certain <code>rustc</code> feature gate is enabled or not. For example, we might write <code>#[cfg(rustc_feature(generic_associated_types))]</code> to check whether the <a href="https://github.com/rust-lang/rust/issues/44265">GAT</a> feature is supported in the compiler or not.</p>
<p>The main benefit of such an approach is that it is more direct than checking for a particular version. Also note that <code>clang</code> uses this approach as noted in the <a href="#prior-art">prior art</a>.</p>
<p>However, there are some drawbacks as well:</p>
<ol>
<li>
<p>The names of feature gates are not always aptly named and usually do not follow a coherent naming system. As a frequent author of RFCs, the author of this one knows that they do not have a principled approach to naming RFCs. The feature name that is then used in the compiler is usually drawn directly from the RFC, so we would either need to accept the random naming of feature gates, or we would need to impose some system.</p>
</li>
<li>
<p>Permitting dependence on the names of feature gates on stable would require us to be more principled with feature gates. For example, <code>rustc</code>, or any other Rust compiler, would be unable to remove gates or drastically change their implementations without changing their names. Being more principled could potentially add an undue burden on the library and compiler teams.</p>
</li>
</ol>
<h3 id="cfghas_attrattribute"><a class="header" href="#cfghas_attrattribute"><code>#[cfg(has_attr($attribute))]</code></a></h3>
<p>One possible extension would be to introduce a <code>has_attr(..)</code> feature. <code>has_attr</code> would check if the specified attribute would be usable on the item the <code>cfg</code> (or <code>cfg_attr</code>) directive is attached to. For instance:</p>
<pre><code class="language-rust">#[cfg_attr(have_attr(must_use), must_use)]
fn double(x: i32) -&gt; i32 {
    2 * x
}</code></pre>
<p>This would allow code to detect the availability of an attribute before using it, while not failing if the attribute did not exist.</p>
<p>Using <code>has_attr</code> in a <code>cfg</code> block may be useful for conditionally compiling code that only makes sense if a given attribute exists (e.g. <code>global_allocator</code>), while using <code>has_attr</code> in a <code>cfg_attr</code> block may be useful for adding an attribute to an item if supported but still support compilers that don’t support that attribute.</p>
<p>As previously discussed, currently, the names of feature gates do not tend to appear in code targeting stable versions of Rust. Allowing code to detect the availability of specified feature gates by name would require committing to stable names for these features, and would require that those names refer to a fixed set of functionality. This would require additional curation. However, as attribute names already have to be standardized, <code>has_attr(..)</code> would not suffer the same problems wherefore it may be the better solution.</p>
<h3 id="cfgnightly"><a class="header" href="#cfgnightly"><code>#[cfg(nightly)]</code></a></h3>
<p>In a previous iteration of this RFC, a <code>#[cfg(nightly)]</code> flag was included. However, this flag has since been removed from the RFC. We may still add such a feature in the future if we wish. Therefore, we have outlined what <code>nightly</code> would have meant and some upsides and drawbacks to adding it.</p>
<h4 id="technical-specification"><a class="header" href="#technical-specification">Technical specification</a></h4>
<p>To the <code>cfg</code> attribute, a <code>nightly</code> flag is added.</p>
<p>If and only if a Rust compiler permits a user to specify <code>#![feature(..)]</code> will the <code>nightly</code> flag be considered active.</p>
<h4 id="drawbacks-combining-nightly-and-accessible"><a class="header" href="#drawbacks-combining-nightly-and-accessible">Drawbacks: Combining <code>nightly</code> and <code>accessible(..)</code></a></h4>
<p>Consider that a popular library writes:</p>
<pre><code class="language-rust">#![cfg_attr(nightly, feature(some_feature))]
#[cfg(accessible(::std::foo:SomeFeature))]
use std::foo::SomeFeature;

#[cfg(not(accessible(::std::foo:SomeFeature)))]
struct SomeFeature { ... }</code></pre>
<p>One potential hazard when writing this migrating construct is that once <code>SomeFeature</code> finally gets stabilized, it may have been shipped in a modified form. Such modification may include changing the names of <code>SomeFeature</code>’s methods, their type signatures, or what trait implementations exist for <code>SomeFeature</code>.</p>
<p>This problem only occurs when you combine <code>nightly</code> and <code>accessible(..)</code> or indeed <code>nightly</code> and <code>version(..)</code>. However, there is a risk of breaking code that worked on one stable release of Rust in one or more versions after.</p>
<p>A few mitigating factors to consider are:</p>
<ul>
<li>
<p>It is possible to check if the methods of <code>SomeFeature</code> are <code>accessible</code> or not by using their paths. This reduces the risk somewhat.</p>
</li>
<li>
<p>If a crate author runs continuous integration (CI) builds that include testing the crate on a nightly toolchain, breakage can be detected well before any crates are broken and a patch release of the crate can be made which either removes the nightly feature or adjusts the usage of it. The remaining problem is that dependent crates may have <code>Cargo.lock</code> files that have pinned the patch versions of the crate.</p>
</li>
<li>
<p>Users should take care not to use this mechanism unless they are fairly confident that no consequential changes will be made to the library. A risk still exists, but it is opt-in.</p>
</li>
</ul>
<p>However, at the end, compared to <code>feature = "unstable"</code>, which reverse dependencies may opt out of, <code>nightly</code> can’t be opted out of (unless we add a mechanism to Cargo to perform such an override, but this would be anti-modular). This is the fundamental reason that for the time being, we have not included <code>nightly</code> in the proposal.</p>
<h4 id="upsides"><a class="header" href="#upsides">Upsides</a></h4>
<p>One reason for the inclusion of <code>#[cfg(nightly)]</code> is that it is useful on its own to conditionally compile based on nightly/not as opposed to providing an <code>unstable</code> feature in <code>Cargo.toml</code>. An example of this is provided by the <a href="https://crates.io/crates/dbg">dbg</a> crate which currently uses <a href="https://crates.io/crates/version_check">version_check</a> to provide this automation.</p>
<h4 id="alternative-if_possible_featurefeature"><a class="header" href="#alternative-if_possible_featurefeature">Alternative <code>#![if_possible_feature(&lt;feature&gt;)]</code></a></h4>
<p>As an alternative to <code>#[cfg_attr(nightly, feature(&lt;feature&gt;))]</code> we could permit the user to write <code>#![if_possible_feature(&lt;feature&gt;)]</code>. The advantage of this is that it is quite direct with respect to intent. However, adding this in terms of <code>nightly</code> already has precedent in <a href="https://crates.io/crates/version_check">version_check</a>. In addition, <code>nightly</code> also composes with other flags using <code>any</code>, <code>not</code>, and <code>all</code>.</p>
<p>This alternative also suffers from the problems previously noted.</p>
<h4 id="naming-of-the-attribute"><a class="header" href="#naming-of-the-attribute">Naming of the attribute</a></h4>
<p>If this flag were to be proposed again, it would probably be proposed under a different name than <code>nightly</code>. Instead, a more apt name with respect to intent would be <code>unstable_features</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="2521-c_void-reunification.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="2526-const-wildcard.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="2521-c_void-reunification.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="2526-const-wildcard.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
