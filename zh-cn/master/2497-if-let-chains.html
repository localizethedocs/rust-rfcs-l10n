<!DOCTYPE HTML>
<html lang="zh_CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2497-if-let-chains - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-b61d75f0.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Feature Name: <code>let_chains_2</code></li>
<li>Start Date: 2018-07-13</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2497">rust-lang/rfcs#2497</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/53667">rust-lang/rust#53667</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/53668">rust-lang/rust#53668</a></li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Extends <code>if let</code> and <code>while let</code>-expressions with chaining, allowing you to combine multiple <code>let</code>s and <code>bool</code>-typed conditions together naturally. After implementing this RFC, you’ll be able to write, among other things:</p>
<pre><code class="language-rust">fn param_env&lt;'a, 'tcx&gt;(tcx: TyCtxt&lt;'a, 'tcx, 'tcx&gt;, def_id: DefId) -&gt; ParamEnv&lt;'tcx&gt; {
    if let Some(Def::Existential(_)) = tcx.describe_def(def_id)
        &amp;&amp; let Some(node_id) = tcx.hir.as_local_node_id(def_id)
        &amp;&amp; let hir::map::NodeItem(item) = tcx.hir.get(node_id)
        &amp;&amp; let hir::ItemExistential(ref exist_ty) = item.node
        &amp;&amp; let Some(parent) = exist_ty.impl_trait_fn
    {
        return param_env(tcx, parent);
    }

    ...
}</code></pre>
<p>and with side effects:</p>
<pre><code class="language-rust">while let Ok(user) = read_user(::std::io::stdin())
    &amp;&amp; user.name == "Alan Turing"
    &amp;&amp; let Ok(hobby) = read_hobby_of(&amp;user)
{
    if hobby == "Hacking Enigma" {
        println!("Yep, It's you.");
        return Some(read_encrypted_stuff());
    } else {
        println!("You can't be Alan! ");
    }
}

return None;</code></pre>
<p>The main aim of this RFC is to decide that this is a problem worth solving as well as discussing a few available options. <strong>Most importantly, we want to make <code>if let PAT = EXPR &amp;&amp; ..</code> a possible option for Rust 2018.</strong></p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>The main motivation for this RFC is improving readability, ergonomics, and reducing paper cuts.</p>
<h3 id="right-ward-drift"><a class="header" href="#right-ward-drift">Right-ward drift</a></h3>
<p>Today, each <code>if let</code> needs a brace, which means that you usually, to keep the code readable, indent once to the right each time. Thus, matching multiple things quickly leads to way too much indent that overflows the typical text editor or IDE horizontally. This is in particular bad for readers that can only fit around 80-100 characters per line in their editor. Keeping in mind that code is read more than written, it is important to improve readability where possible.</p>
<h4 id="other-solution-tuples"><a class="header" href="#other-solution-tuples">Other solution: Tuples</a></h4>
<p>One solution is matching a tuple, but that is a poor solution when there are side effects or expensive computations involved, and doesn’t necessarily work as <em>DSTs</em> and <em>lvalues</em> can’t go in tuples.</p>
<h4 id="other-solution-break-"><a class="header" href="#other-solution-break-">Other solution: <code>break ...</code></a></h4>
<p>Another solution to avoid right-ward drift is to create a new function for part of the indentation. When the inner scopes depend on a lot of variables and state from outer scopes, all of these variables have to be passed on to the newly created function, which may not even be a natural unit to abstract into a function. Creating a new function, especially one that feels artificial, can also inhibit local reasoning. A new level of function (or <a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">IIFE</a>) also changes the behaviour of <code>return</code>, <code>break</code>, <code>?</code>, and friends.</p>
<p>A third solution involves using the expression form <code>break '&lt;label&gt;</code>. You may then rewrite the snippet from the <a href="#summary">summary</a> as:</p>
<pre><code class="language-rust">fn param_env&lt;'a, 'tcx&gt;(tcx: TyCtxt&lt;'a, 'tcx, 'tcx&gt;, def_id: DefId) -&gt; ParamEnv&lt;'tcx&gt; {
    'stop: {
        if let Some(Def::Existential(_)) = tcx.describe_def(def_id) {
        } else {
            break 'stop;
        };

        let node_id = if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {
            node_id
        } else {
            break 'stop;
        }

        let item = if let hir::map::NodeItem(item) = tcx.hir.get(node_id) {
            item
        } else {
            break 'stop;
        };

        let exists_ty = if let hir::ItemExistential(ref exist_ty) = item.node {
            exists_ty
        } else {
            break 'stop;
        }

        if let Some(parent) = exist_ty.impl_trait_fn {
            return param_env(tcx, parent);
        }
    }

    ...
}</code></pre>
<p>while right-ward drift has been reduced, a significant amount of line noise has been introduced. The user is also forced to track the label <code>'stop</code>. All in all, this alternative significantly reduces readability wherefore we discourage from this way of writing.</p>
<h5 id="boiler-plate-reduction-using-macros"><a class="header" href="#boiler-plate-reduction-using-macros">Boiler-plate reduction using macros</a></h5>
<p>One way to reduce the noise from the above alternative solution is to refactor some commonalities into a macro. However, refactoring into a macro means that you need to understand the macro. In comparison, chained <code>if let</code>s constitute something simpler that all Rust programmers will understand, as opposed to a specialized macro.</p>
<h3 id="mixing-conditions-and-pattern-matching"><a class="header" href="#mixing-conditions-and-pattern-matching">Mixing conditions and pattern matching</a></h3>
<p>A <code>match</code> expression can have <code>if</code> guards, but <code>if let</code> currently requires another level of conditionals.  This is particularly troublesome for cases that can’t be matched, like <code>x.fract() == 0</code>, or error <code>enum</code>s that disallow matching, like <code>std::io::ErrorKind</code>.</p>
<h3 id="duplicating-code-in-else-clauses"><a class="header" href="#duplicating-code-in-else-clauses">Duplicating code in <code>else</code> clauses</a></h3>
<p>In some cases, you may have written something like:</p>
<pre><code class="language-rust">if let A(x) = foo() {
    if let B(y) = bar(x) {
        do_stuff_with(x, y)
    } else {
        some_long_expression
    }
} else {
    some_long_expression
}</code></pre>
<p>In this example <code>foo()</code> and <code>bar(x)</code> have side effects, but more crucially, there is a dependency between matching on the result of <code>foo()</code> to execute <code>bar(x)</code>. Therefore, matching on <code>(foo(), bar(x))</code> is not possible in this case because there’s no <code>x</code> in scope. So you have no choice but to write it in this way (or use <code>break 'label..</code>).</p>
<p>However, now <code>some_long_expression</code> is repeated, and if more <code>let</code> bindings are added, more repetition ensues. To avoid repeating the long expression, you might encapsulate this in a new function, but that new function may feel like an artificial abstraction as discussed above.</p>
<p>This is problematic even with a macro to simplify, as it results in more code emitted that LLVM commonly cannot simplify.</p>
<h3 id="bringing-the-language-closer-to-the-mental-model"><a class="header" href="#bringing-the-language-closer-to-the-mental-model">Bringing the language closer to the mental model</a></h3>
<p>The readability of programs is often about the degree to which the code corresponds to the mental model the reader has of said program. Therefore, we should aim to bring the language closer to the mental model of the reader. With respect to <code>if let</code>-expressions, rather than saying (out loud):</p>
<blockquote>
<p>if A matches, and</p>
<blockquote>
<p>if x holds and</p>
<blockquote>
<p>if B matches</p>
<blockquote>
<p>do X, Y, and Z</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>..it is more common to say:</p>
<blockquote>
<p>If A matches, x holds, and B matches, do X, Y, and Z</p>
</blockquote>
<p>This RFC is more in line with the latter formulation and thus brings the language closer to the readers mental model.</p>
<h3 id="instead-of-macros"><a class="header" href="#instead-of-macros">Instead of macros</a></h3>
<p>As we’ve previously touched upon, we may define and use a macro to reduce boilerplate. A macro like <a href="https://crates.io/crates/if_chain"><code>if_chain!</code></a> as a solution however has the problem of not being part of the language specification. Thus, it is not part of the common syntax that experienced Rust programmers are familiar with and is instead local to the project itself. The non-universality of syntax therefore hurts readability.</p>
<h3 id="plenty-of-real-world-use-cases"><a class="header" href="#plenty-of-real-world-use-cases">Plenty of Real-world use cases</a></h3>
<p>We have already seen a real world example from the compiler in the <a href="#summary">summary</a>. By taking a look at the <a href="https://crates.io/crates/if_chain/reverse_dependencies">reverse dependencies</a> of <a href="https://crates.io/crates/if_chain"><code>if_chain!</code></a> we can find more real-world use cases that this RFC facilitates.</p>
<p>As an example, <code>clippy</code> <a href="https://github.com/rust-lang-nursery/rust-clippy/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints/src/print.rs#L207-L219">defines a function</a>:</p>
<pre><code class="language-rust">/// Returns the slice of format string parts in an `Arguments::new_v1` call.
fn get_argument_fmtstr_parts(expr: &amp;Expr) -&gt; Option&lt;(InternedString, usize)&gt; {
    if_chain! {
        if let ExprAddrOf(_, ref expr) = expr.node; // &amp;["…", "…", …]
        if let ExprArray(ref exprs) = expr.node;
        if let Some(expr) = exprs.last();
        if let ExprLit(ref lit) = expr.node;
        if let LitKind::Str(ref lit, _) = lit.node;
        then {
            return Some((lit.as_str(), exprs.len()));
        }
    }
    None
}</code></pre>
<p>with this RFC, this would be written, without any external dependencies, as:</p>
<pre><code class="language-rust">/// Returns the slice of format string parts in an `Arguments::new_v1` call.
fn get_argument_fmtstr_parts(expr: &amp;Expr) -&gt; Option&lt;(InternedString, usize)&gt; {
    if let ExprAddrOf(_, ref expr) = expr.node // &amp;["…", "…", …]
        &amp;&amp; let ExprArray(ref exprs) = expr.node
        &amp;&amp; let Some(expr) = exprs.last()
        &amp;&amp; let ExprLit(ref lit) = expr.node
        &amp;&amp; let LitKind::Str(ref lit, _) = lit.node
    {
        Some((lit.as_str(), exprs.len()))
    } else {
        None
    }
}</code></pre>
<p>This kind of deep pattern matching is common for parsers and when dealing with ASTs. One place which deals with ASTs is the compiler itself as seen above. Thus, with this RFC, some compiler internals may be simplified. Another common place is when authoring with custom derive macros using the <code>syn</code> crate.</p>
<h3 id="an-expected-feature"><a class="header" href="#an-expected-feature">An expected feature</a></h3>
<p>As demonstrated in <a href="#appendix-b">Appendix B</a>, the syntax proposed in this RFC is already expected to be allowed in Rust by users today. Indeed, the author of this RFC made this assumption at some point.</p>
<h3 id="unification"><a class="header" href="#unification"><em>Unification</em></a></h3>
<p>In today’s Rust, there is both a grammatical and conceptual distinction between <code>if</code> and <code>if let</code> as well as <code>while</code> and <code>while let</code>. This RFC aims to erase the divide and unify concepts. Henceforth, there is just <code>if</code> and <code>while</code>. Thus <code>if let</code> is no longer the unit.</p>
<h3 id="why-now"><a class="header" href="#why-now">“Why now?”</a></h3>
<p>A legitimate question to ask is:</p>
<blockquote>
<p>Why implement this now?</p>
</blockquote>
<p>In this case, the answer is simple: We can’t wait.</p>
<p>Because Rust takes stability seriously, we would like to avoid any breakage in-between editions even if the breakage is exceedingly (as in the case of this RFC) unlikely. Instead, we want to deal with the vanishingly tiny degree of breakage, as explained in the <a href="#reference-level-explanation">reference-level-explanation</a>, introduced by this RFC with the edition mechanism.</p>
<p>As it happens, a new edition “Rust 2018” is in the works at the moment (as of 2018-07-12). This is an excellent opportunity to take advantage of, and that is precisely what we aim to do here.</p>
<h2 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h2>
<p>This section examines the features proposed by this RFC.</p>
<h3 id="if-let-chains"><a class="header" href="#if-let-chains"><code>if let</code>-chains</a></h3>
<p>An <em><code>if let</code> chain</em>, refers to a chain of multiple <code>let</code> bindings, which may mixed with conditionals in an <code>if</code> expression.</p>
<p>An example of such a chain is:</p>
<pre><code class="language-rust">if let A(x) = foo()
    &amp;&amp; let B(y) = bar()
{
    computation_with(x, y)
}</code></pre>
<p>It is important to note that this is <em>not</em> generally equivalent to the following expression:</p>
<pre><code class="language-rust">if let (A(x), B(y)) = (foo(), bar()) {
    computation_with(x, y)
}</code></pre>
<p>Unlike the first example, there is no short circuiting logic in the example using tuples. Assuming that there are no panics, which is usually the case, both functions are always executed in the latter example.</p>
<p>If we desugar the first example, we can clearly see the difference:</p>
<pre><code class="language-rust">if let A(x) = foo() {
    if let B(y) = bar() {
        computation_with(x, y)
    }
}</code></pre>
<p>What is the practical difference, and why is short circuiting behaviour an important distinction? The call to <code>bar()</code> may be an expensive one. Avoiding useless work is beneficial to performance. There is however a more fundamental reason. Assuming that <code>bar()</code> has side effects, the meaning of the tuple example is different from the nested <code>if let</code> expressions because in the case of the former, the side effect of <code>bar()</code> always happens while it will not if <code>let A(x) = foo()</code> does not match.</p>
<p>The difference between the tuple example and <code>if let</code>-chains become even greater if we also consider a dependence between <code>foo()</code> and <code>bar(..)</code> as in the following example:</p>
<pre><code class="language-rust">if let A(x) = foo() {
    if let B(y) = bar(x) {
        computation_with(x, y)
    }
}</code></pre>
<p>Calling <code>bar(x)</code> is now dependent on having an <code>x</code> that is only available to us by first pattern matching on <code>foo()</code>. Therefore, there is no tuple-based equivalent to the above example. With this RFC implemented, you can more ergonomically write the same expression as:</p>
<pre><code class="language-rust">if let A(x) = foo()
    &amp;&amp; let B(y) = bar(x)
{
    computation_with(x, y)
}</code></pre>
<p>The new expression form introduced by this RFC is also not limited to simple <code>if let</code> expressions, you may of course also add <code>else</code> branches as seen in the example below.</p>
<pre><code class="language-rust">if let A(x) = foo()
   &amp;&amp; let B(y) = bar()
{
    computation_with(x, y)
} else {
    alternative_computation()
}</code></pre>
<p>While the below snippet is not what the compiler would desugar the above one to, you can think of the former as semantically equivalent to it. The compiler is free to not actually emit two calls to <code>alternative_computation()</code> in your compiled binary. For details, please see the <a href="#reference-level-explanation">reference-level-explanation</a>.</p>
<pre><code class="language-rust">if let A(x) = foo() {
    if let B(y) = bar(x) {
        computation_with(x, y)
    } else {
        alternative_computation()
    }
} else {
    alternative_computation()
}</code></pre>
<p>As briefly explained above, the <code>if let</code>-chain expression form is also not limited to pattern matching. You can also mix in any number of conditionals in any place you like, as done in the example below:</p>
<pre><code class="language-rust">if independent_condition
   &amp;&amp; let A(x) = foo()
   &amp;&amp; let B(y) = bar()
   &amp;&amp; y.has_really_cool_property()
{
    computation_with(x, y)
}</code></pre>
<p>The above example example is semantically equivalent to:</p>
<pre><code class="language-rust">if independent_condition {
   if let A(x) = foo() {
       if let B(y) = bar() {
           if y.has_really_cool_property() {
                computation_with(x, y)
            }
        }
    }
}</code></pre>
<p>Naturally, inside an <code>if-let</code>-chain expression, a <code>let</code> binding must come before it is referred to. As such, the following snippet would be ill-formed since we haven’t implemented time-travel (yet):</p>
<pre><code class="language-rust">if y.has_really_cool_property() // &lt;-- y used before bound.
   &amp;&amp; let B(y) = bar(x) // &lt;-- x used before bound.
   &amp;&amp; let A(x) = foo()
{
    computation_with(x, y)
}</code></pre>
<h3 id="while-let-chains"><a class="header" href="#while-let-chains"><code>while let</code>-chains</a></h3>
<p>A <strong><code>while let</code>-chain</strong> is similar to an <code>if let</code>-chain but instead applies to <code>while let</code> expressions.</p>
<p>Since we’ve already introduced the basic idea previously with <em><code>if let</code>-chains</em>, we will jump straight into a more complex example.</p>
<p>The popular <a href="https://docs.rs/itertools/0.7.8/itertools/macro.izip.html"><code>itertools</code></a> crate has an <code>izip</code> macro that allows you to <em>“Create an iterator running multiple iterators in lockstep”</em>. An example of this, taken from the documentation of <code>izip</code> is:</p>
<pre><code class="language-rust">#[macro_use] extern crate itertools;

// iterate over three sequences side-by-side
let mut results = [0, 0, 0, 0];
let inputs = [3, 7, 9, 6];

for (r, index, input) in izip!(&amp;mut results, 0..10, &amp;inputs) {
    *r = index * 10 + input;
}

assert_eq!(results, [0 + 3, 10 + 7, 29, 36]);</code></pre>
<p>With this RFC, we can write this, admittedly not as succinctly, as:</p>
<pre><code class="language-rust">let mut results = [0, 0, 0, 0];
let inputs = [3, 7, 9, 6];

let r_iter = results.iter_mut();
let c_iter = 0..10;
let i_iter = inputs.iter();

while let Some(r) = r_iter.next()
    &amp;&amp; let Some(index) = c_iter.next()
    &amp;&amp; let Some(input) = i_iter.next()
{
    *r = index * 10 + input;
}

assert_eq!(results, [0 + 3, 10 + 7, 29, 36]);</code></pre>
<p>The loop in the above snippet is equivalent to:</p>
<pre><code class="language-rust">loop {
    if let Some(r) = r_iter.next()
        &amp;&amp; let Some(index) = c_iter.next()
        &amp;&amp; let Some(input) = i_iter.next()
    {
        *r = index * 10 + input;
        continue;
    }
    break;
}</code></pre>
<p>Notice in particular here that just as we could rewrite <code>while let</code> in terms of <code>loop</code> + <code>if let</code>, so too can we rewrite <code>while let</code>-chains with <code>loop</code> + <code>if let</code>-chains.</p>
<p>While these two first snippets are equivalent in this example, this does not generally hold. If <code>i_iter.next()</code> has side effects, then those will not happen when <code>Some(index)</code> does not match. This is important to keep in mind. Short-circuiting still applies to <code>while let</code>-chains as with <code>if let</code>-chains.</p>
<h2 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h2>
<p>This RFC introduces <code>if let</code>-chains and <code>while let</code>-chains in <em>Rust 2018</em> and makes some enabling preparation for such chains in Rust 2015.</p>
<h3 id="grammar"><a class="header" href="#grammar">Grammar</a></h3>
<p>We replace the following productions:</p>
<pre><code class="language-bnf">block_expr
: expr_match
| expr_if
| expr_if_let
| expr_while
| expr_while_let
| expr_loop
| expr_for
| UNSAFE block
| path_expr "!" maybe_ident braces_delimited_token_trees
;

expr_if
: IF expr_nostruct block
| IF expr_nostruct block ELSE block_or_if
;

expr_if_let
: IF LET pat "=" expr_nostruct block
| IF LET pat "=" expr_nostruct block ELSE block_or_if
;

block_or_if : block | expr_if | expr_if_let ;

expr_while : maybe_label WHILE expr_nostruct block ;
expr_while_let : maybe_label WHILE LET pat "=" expr_nostruct block ;
</code></pre>
<p>with:</p>
<pre><code class="language-bnf">block_expr
: expr_match
| expr_if
| expr_while
| expr_loop
| expr_for
| UNSAFE block
| path_expr "!" maybe_ident braces_delimited_token_trees
;

expr_if
: IF in_if_list block
| IF in_if_list block ELSE block_or_if
;

block_or_if : block | expr_if ;

expr_while : maybe_label WHILE in_if_list block ;

in_if
: "let" pat "=" expr_nostruct
| expr_nostruct
| "(" in_if ")"
;

in_if_list : in_if [ ANDAND in_if ]*
</code></pre>
<h4 id="dealing-with-ambiguity"><a class="header" href="#dealing-with-ambiguity">Dealing with ambiguity</a></h4>
<p>There exists an ambiguity in this new grammar in how to parse:</p>
<pre><code class="language-rust">if let PAT = EXPR &amp;&amp; EXPR { .. }</code></pre>
<p>It can either be parsed as (1):</p>
<pre><code class="language-rust">if let PAT = (EXPR &amp;&amp; EXPR) { .. }</code></pre>
<p>or instead as (2):</p>
<pre><code class="language-rust">if (let PAT = EXPR) &amp;&amp; EXPR { .. }</code></pre>
<p>In the interest of succinctness, we do not encode a grammar here that resolves this ambiguity. Nonetheless, interpretation (2) is <em>always</em> chosen.</p>
<p>As specified in the reference in the section on <a href="https://github.com/rust-lang-nursery/reference/blob/master/src/expressions.md#expression-precedence">expression operator precedence</a>, the following operators all have a lower precedence than <code>&amp;&amp;</code>:</p>
<ul>
<li><code>||</code></li>
<li><code>..</code> and <code>..=</code></li>
<li><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code></li>
<li><code>return</code>, <code>break</code></li>
</ul>
<p>To be precise, the changes in this RFC entail that <code>||</code> has the lowest precedence at the top level of <code>if STUFF { .. }</code>. The operator <code>&amp;&amp;</code> has then the 2nd lowest precedence and binds more tightly than <code>||</code>. If the user wants to disambiguate, they can write <code>(EXPR &amp;&amp; EXPR)</code> or <code>{ EXPR &amp;&amp; EXPR }</code> explicitly. The same applies to <code>while</code> expressions.</p>
<h5 id="a-few-more-examples"><a class="header" href="#a-few-more-examples">A few more examples</a></h5>
<p>Given:</p>
<pre><code class="language-rust">if let Range { start: _, end: _ } = true..true &amp;&amp; false { ... }

if let PAT = break true &amp;&amp; false { ... }

if let PAT = F..|| false { ... }

if let PAT = t..&amp;&amp;false { ... }</code></pre>
<p>it is currently interpreted as:</p>
<pre><code class="language-rust">if let Range { start: _, end: _ } = true..(true &amp;&amp; false) { ... }

if let PAT = break (true &amp;&amp; false) { ... }

if let PAT = F..(|| false) { ... }

if let PAT = t..(&amp;&amp;false) { ... }</code></pre>
<p>but will be interpreted as:</p>
<pre><code class="language-rust">if (let Range { start: _, end: _ } = true..true) &amp;&amp; false { ... }

if (let PAT = break true) &amp;&amp; false { ... }

if (let PAT = F..) || false { ... }

if (let PAT = t..) &amp;&amp; false { ... }</code></pre>
<h4 id="rollout-plan-and-transitioning-to-rust-2018"><a class="header" href="#rollout-plan-and-transitioning-to-rust-2018">Rollout Plan and Transitioning to Rust 2018</a></h4>
<p>Everything in this section also applies to <code>while let</code> expressions.</p>
<p>To enable the second interpretation in the previous section a warning must be emitted in Rust 2015 informing the user that:</p>
<pre><code class="language-rust">if let PAT = EXPR &amp;&amp; EXPR ...? { .. }

if let PAT = EXPR || EXPR ...? { .. }</code></pre>
<p>will both become <em>hard errors</em>, in the first version of Rust where the 2018 edition is stable, without the <code>let_chains</code> features having been stabilized.</p>
<p>Note that this applies when there’s at least one <code>&amp;&amp;</code> or <code>||</code> operator at the top level of the RHS. This means that it does <em>not</em> apply in, among others, the following cases:</p>
<pre><code class="language-rust">if let PAT = ( EXPR &amp;&amp; EXPR ) { .. }

if let PAT = { EXPR &amp;&amp; EXPR } { .. }

if let PAT = ( EXPR || EXPR ) { .. }

if let PAT = { EXPR || EXPR } { .. }</code></pre>
<p>since the user has disambiguated the intent explicitly.</p>
<p>Pending the stabilization of the features in this RFC, to opt into the new semantics, users will need to use a nightly compiler and add the usual feature gate opt-in.</p>
<h4 id="facilitating-for-macro-authors"><a class="header" href="#facilitating-for-macro-authors">Facilitating for macro authors</a></h4>
<p>To facilitate for macro authors, we permit the following:</p>
<pre><code class="language-rust">if (let PAT = EXPR) &amp;&amp; ... { ... }</code></pre>
<h4 id="let-pat--expr-is-not-an-expression"><a class="header" href="#let-pat--expr-is-not-an-expression"><code>let PAT = EXPR</code> is <em>not</em> an expression</a></h4>
<p>Note that <code>let PAT = EXPR</code> does <em>not</em> become an expression (typed at <code>bool</code>) with this RFC. Thus, you may not write:</p>
<pre><code class="language-rust">let foo: bool = let Some(_) = None;
let bar: bool = let Some(_) = Some(1);
assert_eq!(foo, false);
assert_eq!(bar, true);</code></pre>
<h3 id="semantics-of-if-let-chains"><a class="header" href="#semantics-of-if-let-chains">Semantics of <code>if let</code>-chains</a></h3>
<p>The semantics of <code>if let</code>-chains can be understood by an in-surface-language desugaring using only <a href="https://github.com/rust-lang/rfcs/pull/2046">RFC 2046</a> and <code>if let</code>.</p>
<p>The following:</p>
<pre><code class="language-rust">if let PAT_1 = EXPR_1
    &amp;&amp; let PAT_2 = EXPR_2
    &amp;&amp; EXPR_3
    ...
    &amp;&amp; let PAT_N = EXPR_N
{
    EXPR_IF
} else {
    EXPR_ELSE
}</code></pre>
<p>desugars into:</p>
<pre><code class="language-rust">'FRESH_LABEL: {
    if let PAT_1 = EXPR_1 {
        if let PAT_2 = EXPR_2 {
            if EXPR_3 {
                ...
                if let PAT_N = EXPR_N {
                    break 'FRESH_LABEL { EXPR_IF }
                }
            }
        }
    }
    { EXPR_ELSE }
}</code></pre>
<p>This avoids any code duplication and requires no new semantics. The rules for borrowing and scoping are just those that result directly from the desugar.</p>
<p>The <code>else if</code> branches:</p>
<pre><code class="language-rust">if let PAT_1 = EXPR_1
    &amp;&amp; let PAT_2 = EXPR_2
{
    EXPR_IF
} else if let PAT_3 = EXPR_3
    &amp;&amp; EXPR_4
{
    EXPR_ELSE_IF
} else {
    EXPR_ELSE
}</code></pre>
<p>are defined by their desugaring to:</p>
<pre><code class="language-rust">'FRESH_LABEL: {
    if let PAT_1 = EXPR_1 {
        if let PAT_2 = EXPR_2 {
            break 'FRESH_LABEL { EXPR_IF }
        }
    }

    if let PAT_3 = EXPR_3 {
        if EXPR_4 {
            break 'FRESH_LABEL { EXPR_ELSE_IF }
        }
    }

    { EXPR_ELSE }
}</code></pre>
<p>Having an <code>else</code> branch is optional. The following example without an <code>else</code> branch:</p>
<pre><code class="language-rust">if let PAT_1 = EXPR_1
    &amp;&amp; let PAT_2 = EXPR_2
{
    EXPR_IF
}</code></pre>
<p>is simply desugared into:</p>
<pre><code class="language-rust">if let PAT_1 = EXPR_1 {
    if let PAT_2 = EXPR_2 {
        EXPR_IF
    }
}</code></pre>
<p>If we have an <code>else if</code> branch but no <code>else</code> branch, such as in this example:</p>
<pre><code class="language-rust">if let PAT_1 = EXPR_1
    &amp;&amp; let PAT_2 = EXPR_2
{
    EXPR_IF
} else if let PAT_3 = EXPR_3
    &amp;&amp; EXPR_4
{
    EXPR_ELSE_IF
}</code></pre>
<p>the semantics are defined by the following desugaring:</p>
<pre><code class="language-rust">'FRESH_LABEL: {
    if let PAT_1 = EXPR_1 {
        if let PAT_2 = EXPR_2 {
            break 'FRESH_LABEL { EXPR_IF }
        }
    }

    if let PAT_3 = EXPR_3 {
        if EXPR_4 {
            break 'FRESH_LABEL { EXPR_ELSE_IF }
        }
    }
}</code></pre>
<h3 id="semantics-of-while-let-chains"><a class="header" href="#semantics-of-while-let-chains">Semantics of <code>while let</code>-chains</a></h3>
<p>The semantics of <code>while let</code>-chains can be understood by an in-surface-language desugaring using only <a href="https://github.com/rust-lang/rfcs/pull/2046">RFC 2046</a>, <code>loop</code> and <code>if let</code>.</p>
<p>For example:</p>
<pre><code class="language-rust">while EXPR_1
    &amp;&amp; let PAT_2 = EXPR_2
    &amp;&amp; let PAT_3 = EXPR_3
    &amp;&amp; EXPR_4
{
    EXPR_WHILE
}</code></pre>
<p>is defined by desugaring into:</p>
<pre><code class="language-rust">loop {
    if EXPR_1
        &amp;&amp; let PAT_2 = EXPR_2
        &amp;&amp; let PAT_3 = EXPR_3
        &amp;&amp; EXPR_4
    {
        { EXPR_WHILE }
        continue;
    }
    break;
}</code></pre>
<p>This desugaring relies on the previously discussed desugaring for <code>if let</code>-chains.</p>
<p>More generally, we may desugar:</p>
<pre><code class="language-rust">while in_if_list {
    EXPR_WHILE
}</code></pre>
<p>into:</p>
<pre><code class="language-rust">loop {
    if in_if_list {
        { EXPR_WHILE }
        continue;
    }
    break;
}</code></pre>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>This RFC mandates additions to the grammar as well as adding syntax lowering passes. These are small additions, but nonetheless the language specification is possibly made more complex by it. While this complexity will be used by some and therefore, the RFC argues, motivates the added complexity, it will not be used all users of the language. However, as discussed in the <a href="#motivation">motivation</a>, by unifying constructs in the language conceptually and grammatically, we may also say that complexity is <em>reduced</em>.</p>
<p>When it comes to <code>if let</code>-chains, the feature is already supported by the macro <code>if_chain!</code>. Some may feel that this is enough.</p>
<p>It should also be taken into account that some breakage will occur as a result of this RFC. Sergio Benitez has however done some review of the crates.io ecosystem and found zero cases of actual breakage. At any rate, writing <code>let PAT = EXPR &amp;&amp; ..</code> as a user is a bad thing to do.</p>
<p>Finally, some may argue, <a href="https://github.com/rust-lang/rfcs/pull/2260#issuecomment-353780537">as done by @petrochenkov</a>, that this is <em>“a lot of ad-hoc syntax to deprecate when the proper solution solving all the listed problems is implemented”</em>.</p>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<p>We will now discuss how and why this RFC came about in its current form.</p>
<h3 id="the-impact-of-not-doing-this"><a class="header" href="#the-impact-of-not-doing-this">The impact of not doing this</a></h3>
<p>There are at least two sides to power in language expressivity:</p>
<ol>
<li>
<p>The ability to express something in a language at all.</p>
</li>
<li>
<p>The ability to express something with ease.</p>
</li>
</ol>
<p>Nothing proposed in this RFC adds to point 1. While this is the case, it is not sufficient. The second point is important to make the language pleasurable to use and this is what this RFC is about. Not including the changes proposed here would keep some paper cuts around.</p>
<h3 id="design-considerations"><a class="header" href="#design-considerations">Design considerations</a></h3>
<p>There are some design considerations on this feature. These are:</p>
<ol>
<li>
<p>the syntax mixes well with normal <code>bool</code>ean conditionals.</p>
</li>
<li>
<p>the additions be simple conceptually and build on what language<br>users already know.</p>
</li>
<li>
<p>as little of the complexity budget as possible is used.</p>
</li>
<li>
<p>the bindings bound in the pattern have a clear and consistent scope.</p>
</li>
<li>
<p>the short-circuiting nature is clear.</p>
</li>
<li>
<p>instead of a heap of special cases, the grammar should be simple.</p>
</li>
</ol>
<p>With these considerations in mind, the RFC was developed.</p>
<p>Note that these are considerations and have different levels of importance. Note also that it is likely impossible to meet all of them, but we’d like to tick as many boxers as possible.</p>
<h3 id="keeping-the-door-open-for-if-let-or-expressions"><a class="header" href="#keeping-the-door-open-for-if-let-or-expressions">Keeping the door open for <code>if-let-or</code>-expressions</a></h3>
<p>Should a user be able to write something like the following snippet?</p>
<pre><code class="language-rust">if let A(x) = e1
    || let B(x) = e2 {
    do_stuff_with(x)
} else {
    do_other_stuff()
}</code></pre>
<p>What does this expression even mean? It means that if one of the patterns match, then the first one of those will bind a value to <code>x</code> and the expression evaluates to <code>do_stuff_with(x)</code>. If no patterns match, the expression instead evaluates to <code>do_other_stuff()</code>.</p>
<p>This RFC does not propose such a facility, but does not foreclose such a possibility, making the feature future proof and allowing discussion on such a facility in the future to continue. Alternatives should similarly try to retain this ability.</p>
<h3 id="alternative-rfc-2046-label-break-value"><a class="header" href="#alternative-rfc-2046-label-break-value">Alternative: <a href="https://github.com/rust-lang/rfcs/pull/2046">RFC 2046</a>, label break value</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/pull/2046">RFC 2046</a>, which has been merged but not stabilized, is a more general <em>control flow graph</em> (<a href="https://en.wikipedia.org/wiki/Control_flow_graph">CFG</a>) control feature. While it doesn’t as straightforwardly solve the rightward drift or ergonomic issues as this RFC does, it allows <a href="https://github.com/rust-lang/rfcs/pull/2046#issuecomment-320483246">the macros to be improved</a> by removing duplication of <code>else</code> blocks. The closest syntax today for that is <code>loop-break</code>, but that doesn’t work as <code>continue</code> is intentionally non-hygienic.</p>
<p>RFC 2046 is also a bit orthogonal in the sense that it’s fully compatible with this RFC. The general label break is useful and powerful, as seen in the <a href="#reference-level-explanation">reference-level-explanation</a> of this RFC and of <code>catch</code>’s, but is verbose and unfamiliar. Having a substantially more ergonomic feature for this particularly common case is valuable regardless. As such, we argue that this RFC is mostly complementary wrt. RFC 2046.</p>
<p>Furthermore, as we’ve noted in the <a href="#motivation">motivation</a>, a macro based approach is not a construct that is universal among Rust programmers, which is an important property for control flow in particular to improve the legibility of programs.</p>
<h3 id="the-main-alternatives"><a class="header" href="#the-main-alternatives">The main alternatives</a></h3>
<p>There are some alternatives to consider. Let’s go through some of the main ones.</p>
<p>First, there’s the choice of a separator to use in-between <code>let</code>s and <code>bool</code> typed condition expressions. We consider 3 different separators:</p>
<ol>
<li>logical and (<code>&amp;&amp;</code>)</li>
<li>comma (<code>,</code>)</li>
<li><code>if</code></li>
</ol>
<p>We also consider two different ways to bind inside <code>if</code>:</p>
<ol>
<li><code>let PAT = EXPR</code></li>
<li><code>EXPR is PAT</code></li>
</ol>
<p>Additionally, instead of the keyword <code>is</code>, we consider <code>match</code>. In total, we have 6 (or 9 if we count <code>match</code>) variants to pick from. These 6 alternatives are:</p>
<p>In this RFC, we propose the combination of <code>&amp;&amp;</code> and <code>let PAT = EXPR</code>.</p>
<h4 id="a-survey---method"><a class="header" href="#a-survey---method">A survey - Method</a></h4>
<p>To gain some data on what users of Rust think about the 6 different variants, a multi-answer survey was done using Google Forms. The survey ran from 2017-12-31 06:25 to ~2018-01-06 ~14:00 and received 373 answers. Participants were also able to provide free-form motivation (“comments”) to their answers if they so wished.</p>
<p>To decrease the risk of bias in favour of a particular alternative, the order of the answers as presented to survey participants were randomized. Furthermore, to make the survey more fair, all alternatives were syntax highlighted as a normal IDE would do.</p>
<p>The survey answers had the following distribution in origin:</p>
<ul>
<li>Reddit, 68.4%</li>
<li>internals.rust-lang.org, 16.6%</li>
<li>users.rust-lang.org, 7.5%</li>
<li>IRC, 5.1%</li>
<li>The RFC, 2.4%</li>
</ul>
<h4 id="a-survey---data"><a class="header" href="#a-survey---data">A survey - Data</a></h4>
<p>For those interested in reading the survey answers you can do so by reading:</p>
<ul>
<li><a href="https://docs.google.com/forms/d/e/1FAIpQLScwG0Y3ynA9aJZ-iprOey_GyCNeFMO9MSDJR1kiskpjsjL1Mw/viewanalytics">A summary of the survey</a></li>
<li><a href="https://drive.google.com/file/d/1awyvryblSHFH9J77TPutW5BrRlKr0EKZ/view?usp=sharing">A CVS file of the survey</a></li>
<li><a href="https://drive.google.com/file/d/14ofF5on_Z_XLvhPr1I4dVgCfcybQO2GY/view?usp=sharing">A PDF for the survey</a></li>
</ul>
<p>The breakdown of preferences were:</p>
<ol>
<li>
<p>Using <code>&amp;&amp;</code> and <code>let PAT = EXPR</code> - liked: 66.2%, disliked: 16.9%</p>
<pre><code class="language-rust">if let PAT = EXPR
    &amp;&amp; let PAT = EXPR
    &amp;&amp; EXPR
{
    ..
}</code></pre>
</li>
<li>
<p>Using <code>&amp;&amp;</code> and <code>EXPR is PAT</code> - liked: 24.9%, disliked: 48.5%</p>
<pre><code class="language-rust">if EXPR is PAT
    &amp;&amp; EXPR is PAT
    &amp;&amp; EXPR {
    ..
}</code></pre>
</li>
<li>
<p>Using <code>,</code> and <code>let PAT = EXPR</code> - liked: 16.9%, disliked: 56.3%</p>
<pre><code class="language-rust">if let PAT = EXPR,
   let PAT = EXPR,
   EXPR {
    ..
}</code></pre>
</li>
<li>
<p>Using <code>if</code> and <code>let PAT = EXPR</code> - liked: 12.3%, disliked: 66%</p>
<pre><code class="language-rust">if let PAT = EXPR
if let PAT = EXPR
if EXPR {
    ..
}</code></pre>
</li>
<li>
<p>Using <code>,</code> and <code>EXPR is PAT</code> - liked: 4.3%, disliked: 74.5%</p>
<pre><code class="language-rust">if EXPR is PAT,
   EXPR is PAT,
   EXPR {
     ..
}</code></pre>
</li>
<li>
<p>Using <code>if</code> and <code>EXPR is PAT</code> - liked: 2.4%, disliked: 80.4%</p>
<pre><code class="language-rust">if EXPR is PAT
if EXPR is PAT
if EXPR {
    ..
}</code></pre>
</li>
</ol>
<p>Finally, 9.7% liked none of the options and 1.9% liked all of them.</p>
<h4 id="a-survey---analysis-of-comments"><a class="header" href="#a-survey---analysis-of-comments">A survey - Analysis of Comments</a></h4>
<p>There are too many answers to include here, instead, we select some of the most interesting ones and highlight them.</p>
<h5 id="tried-before"><a class="header" href="#tried-before">Tried before</a></h5>
<p>One participant, among 6 (see <a href="#appendix-b1">Appendix B.1</a>) others who all positively inclined, explicitly commented that they had tried the syntax proposed in this RFC before.</p>
<blockquote>
<p>The “<code>if let .. &amp;&amp; let .. &amp;&amp; ..</code>” feels like the intuitive way to do it if you don’t think about the language syntax too much. It’s definitely the way I tried doing it when I thought it was possible at the start of my Rust path.</p>
</blockquote>
<p>This substantiates the claim made in the <a href="#an-expected-feature">motivation</a>.</p>
<h5 id="consistency"><a class="header" href="#consistency">Consistency</a></h5>
<p>An even greater number of people (48, see <a href="#appendix-b2">Appendix B.2</a>) commented that they thought that the proposed syntax was the <em>consistent</em> alternative. This was by far the most frequent comment made in the survey.</p>
<blockquote>
<p>So I like that using <code>&amp;&amp;</code> is how we currently use it in the language, and everyone is already used to using <code>let A(x) = foo()</code>. Honestly, the one I chose feels the most consistent with the language.</p>
</blockquote>
<h5 id="intuitiveness"><a class="header" href="#intuitiveness">Intuitiveness</a></h5>
<p>A lesser number (8, see <a href="#appendix-b3">Appendix B.3</a>) of participants said did not explicitly say that the proposed syntax was <em>consistent</em>, but that they found it <em>intuitive</em> nonetheless.</p>
<blockquote>
<p><code>&amp;&amp;</code> makes the logic relationship clearer, and using <code>let</code> for binding is the same. Conjunction is more readable with <code>&amp;&amp;</code></p>
</blockquote>
<p>This, and in particular the consistency, goes a long way to satisfy points 2-3 in the <a href="#design-considerations">design considerations</a>.</p>
<h5 id="expectation-that-let-pat--expr--bool"><a class="header" href="#expectation-that-let-pat--expr--bool">Expectation that <code>(let PAT = EXPR) : bool</code></a></h5>
<p>A few participants (3, see <a href="#appendix-b4">Appendix B.4</a>) hinted at that using <code>&amp;&amp;</code> together with <code>let PAT = EXPR</code> set up the expectation that the latter is a <code>bool</code> typed expression.</p>
<blockquote>
<p>Using <code>&amp;&amp;</code> for conjunction with <code>let PATTERN = EXPR</code> feels consistent with the existing <code>if let</code> syntax, however it causes potentially some confusion about data types and its existing function as a <code>boolean</code> operator, so that leads me to considering <code>,</code> as the conjunction instead. However, if “<code>let PATTERN = EXPR</code>” is an expression returning a boolean as well as setting up the pattern bindings then there’s no issue with <code>&amp;&amp;</code> at all, and it’s then preferable to me provided it’s available where you’d expect expressions to be available and not treated particularly specially.</p>
</blockquote>
<p>If that were the case you’d be able to write:</p>
<pre><code class="language-rust">let is_some: bool = let Some(_) = the_option;</code></pre>
<p>However, this is not the case in this proposal.</p>
<p>We expect that this will be one of the most frequent misconceptions in relation to the proposed syntax. However, such misconceptions can be put to bed simply when the user tries to write a snippet like the one above. They will then get an error message that clears up that misconception. It should also be noted that <code>if let</code>, which exists in the language today, also suffers from this problem. That is, given <code>if let PAT = EXPR { .. }</code>, a user may get the impression that it is the composition of <code>if EXPR { .. }</code> and <code>let PAT = EXPR</code> while it is <em>not</em>. While the syntax changes in this RFC does enhance the risk of misconception somewhat, ultimately we do not feel that it poses a critical problem.</p>
<h5 id="commas-and-if-as-separators---conjunction"><a class="header" href="#commas-and-if-as-separators---conjunction">Commas and <code>if</code> as separators - conjunction?</a></h5>
<p>There were many people (19, see <a href="#appendix-b5">Appendix B.5</a>) who felt that using <code>,</code> or <code>if</code> as the separator did not clearly enough signal conjunction and thought that the symbols may be mistaken for disjunction.</p>
<blockquote>
<p>Commas just aren’t clear enough: on their own, to many people, they could easily be interpreted as logical ORs or logical ANDs.</p>
</blockquote>
<p>In most cases, these comments were directed towards <code>,</code>, but there were also some who thought this about <code>if</code>:</p>
<blockquote>
<p><code>if</code> after <code>if</code> with no logical operator? is this AND? is this OR?</p>
</blockquote>
<p>On the other hand, it could be argued that Rust already uses <code>if</code> for conjunction since you can use <code>PAT if EXPR =&gt; ..</code> inside <code>match</code> expressions. Indeed, a few people hinted at this:</p>
<ol>
<li>
<blockquote>
<p>Clear and unambiguous, and similar to existing guards in match statements, so it does not introduce completely new syntax.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>This is already basically how match arms work.</p>
</blockquote>
</li>
</ol>
<p>Our conclusion is that this at least presents a serious enough of a problem for <code>,</code> as the separator for conjunction to rule it out while also being problematic for <code>if</code>.</p>
<h5 id="commas-and-short-circuiting"><a class="header" href="#commas-and-short-circuiting">Commas and short-circuiting</a></h5>
<p>A number of participants (5, see <a href="#appendix-b6">Appendix B.6</a>) noted that using <code>,</code> as the separator was not clearly enough indicating short-circuiting behaviour.</p>
<blockquote>
<p>On the other hand the comma’d version felt the least clear in meaning and execution order. I’m more used to things-separated-by-commas being roughly equivalent instead of being something that ends up short circuiting the evaluation.</p>
</blockquote>
<p>This is a further blow to <code>,</code> in terms of our <a href="#design-considerations">design considerations</a>.</p>
<h5 id="if-as-separator-is-noisy"><a class="header" href="#if-as-separator-is-noisy"><code>if</code> as separator is noisy</a></h5>
<p>Some people argued that <code>if</code> as a separator felt noisy or that it felt like there were missing braces. One also noted that multiple <code>if</code>s on one line wouldn’t work well on a single line. However, one respondent said that the “eliding of braces”-interpretation was a <em>good</em> thing.</p>
<p>As an aside, we would like to note here that <code>if</code> as a separator would need to be matched with <code>while</code> as a separator as well. This makes the separator too context dependent in our view.</p>
<h5 id="patterns-unexpectedly-on-the-rhs"><a class="header" href="#patterns-unexpectedly-on-the-rhs">Patterns unexpectedly on the RHS</a></h5>
<p>Some people (10, see <a href="#appendix-b8">Appendix B.8</a>) thought that bindings introduced on the RHS as in <code>EXPR is PAT</code> as opposed to <code>let PAT = EXPR</code> was backwards and weird.</p>
<blockquote>
<p><code>expr is pat</code> reverses the directionality for pattern bindings seen everywhere else in Rust;</p>
</blockquote>
<p>One could argue that bindings introduced in the arms of <code>match</code> expressions are to the right if one formats such expressions as:</p>
<pre><code class="language-rust">match EXPR { PAT =&gt; ... }
   // LHS // RHS</code></pre>
<p>However, this is not the typical formatting of <code>match</code> expressions as they tend to include more than one arm. When using the normal formatting of such expressions, the match arms, and therefore the bindings, are introduced on the LHS.</p>
<p>This inconsistency does not have to be an insurmountable problem as we believe that <code>EXPR is PAT</code> generally reads well. However, having the pattern consistently on LHS everywhere makes introductions of bindings more readily scannable, which is a valuable property when reading code quickly.</p>
<h5 id="the-is-operator-introduces-bindings"><a class="header" href="#the-is-operator-introduces-bindings">The <code>is</code> operator introduces bindings</a></h5>
<p>However, a more serious problem that some survey participants (15, see <a href="#appendix-b9">Appendix B.9</a>) identified was that <code>EXPR is PAT</code>, according to the respondents, confusingly introduces a binding and that it could be misconstrued as an equality test of some sort.</p>
<blockquote>
<p><code>is</code> doesn’t make any sense since we already have <code>if let PATTERN</code> and <code>is</code> in other languages is typically a reference equality check (e.g. Dart and Python).</p>
</blockquote>
<blockquote>
<p>I dislike the <code>EXPR is PATTERN</code> syntax because while the word <code>let</code> indicates that there is some binding going on, I read the word <code>is</code> as passively checking whether the expression fits a pattern without binding. I also dislike <code>is</code> because it is new syntax that does the same thing as existing syntax.</p>
</blockquote>
<p>We believe this problem to be more serious. As an alternative to <code>EXPR is PAT</code>, some have proposed using the existing keyword <code>match</code> instead. You would then instead write the example in the <a href="#motivation">motivation</a> as:</p>
<pre><code class="language-rust">fn param_env&lt;'a, 'tcx&gt;(tcx: TyCtxt&lt;'a, 'tcx, 'tcx&gt;, def_id: DefId) -&gt; ParamEnv&lt;'tcx&gt; {
    if tcx.describe_def(def_id) match Some(Def::Existential(_))
        &amp;&amp; tcx.hir.as_local_node_id(def_id) match Some(node_id)
        &amp;&amp; tcx.hir.get(node_id) match hir::map::NodeItem(item)
        &amp;&amp; item.node match hir::ItemExistential(ref exist_ty)
        &amp;&amp; exist_ty.impl_trait_fn match Some(parent)
    {
        return param_env(tcx, parent);
    }

    ...
}</code></pre>
<p>As previously noted, using <code>is</code> is less scannable. This also applies to <code>match</code>.</p>
<p>As an aside, one survey participant confused <code>is</code> for <code>as</code>; This does seem like a mistake that is likely to happen due to the similarity of these two words.</p>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>We believe that the case for <code>&amp;&amp;</code> and <code>let PAT = EXPR</code> is strong. As demonstrated by the survey, which we believe is statistically significant, it is both consistent and intuitive for most users. The syntax also satisfies most of the points in the <a href="#design-considerations">design considerations</a>.</p>
<p>The only main drawbacks to this proposal is some tiny bit of breakage as well as an increase in implementation complexity. The breakage is considered OK, because writing <code>let true = p &amp;&amp; q</code> is at any rate a terrible style and because it is so infrequent. As for the increased grammar complexity, we believe this is less important in this case than making control flow more ergonomic and readable for users.</p>
<p>Some may view the fact that <code>let PAT = EXPR</code> is not an expression typed at <code>bool</code> as an ad-hoc solution. However, we believe that we should live within our means wrt. the complexity budget and spend it on more important things. Furthermore, as evidenced in <a href="https://github.com/rust-lang/rfcs/pull/2260">RFC 2260</a>, making <code>EXPR is PAT</code>, which has other problems we’ve previously noted, an expression is also tricky due to the non-obvious scoping rules for bindings it entails. Mainly because of this, support for <code>EXPR is PAT</code> has been slow to develop.</p>
<p>For the use case of having some pattern matching construct that is typed at <code>bool</code>, we could later introduce the form <code>EXPR is PAT</code> but prohibit  <code>PAT</code> from introducing bindings.</p>
<h2 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h2>
<h3 id="swift"><a class="header" href="#swift">Swift</a></h3>
<p>The expression form <code>if let PAT = EXPR { .. }</code> was introduced to Rust by accepting <a href="https://github.com/rust-lang/rfcs/pull/160">RFC 160</a>. That RFC noted that:</p>
<blockquote>
<p>The if let construct is based on the precedent set by Swift, which introduced its own if let statement. In Swift, <code>if let var = expr { ... }</code> is directly tied to the notion of optional values, and unwraps the optional value that <code>expr</code> evaluates to. In this proposal, the equivalent is <code>if let Some(var) = expr { ... }</code>.</p>
</blockquote>
<p>As the construct <code>if let</code> was inspired by Swift, it therefore makes sense to consult Swift to see how the language deals with multiple <code>let</code>s in <code>if</code>.</p>
<p>It turns out that you can by writing:</p>
<pre><code class="language-swift">if let g = greetings, let s = salutations {
    print(g)
    print(s)
}
</code></pre>
<p>which with the syntax proposed in this RFC would be equivalent to:</p>
<pre><code class="language-rust">if let Some(g) = greetings
    &amp;&amp; let Some(s) = salutations
{
    print(g)
    print(s)
}</code></pre>
<p>You can also use <code>case let</code> for more general pattern matching:</p>
<pre><code class="language-swift">if case let Media.movie(_, _, year) = m, year &lt; 1888 {
    ...
}
</code></pre>
<p>Previously in Swift, you would instead write:</p>
<pre><code class="language-swift">if case let Media.movie(_, _, year) = m, where year &lt; 1888 {
    ...
}
</code></pre>
<p>but this was changed in favour of omitting <code>where</code> in <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md">SE-0099</a>.</p>
<p>Interestingly, the separator token that Swift uses for conjunctive chaining in <code>if</code> is <code>,</code> (comma). <a href="https://github.com/rust-lang/rfcs/pull/2260">RFC 2260</a> proposed this, but this turned out not to be as intuitive for many users as <code>&amp;&amp;</code> is (see <a href="#rationale-and-alternatives">alternatives</a> for a discussion).</p>
<h3 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h3>
<p>In <a href="https://github.com/rust-lang/rfcs/pull/2260">RFC 2260</a> <a href="https://github.com/matklad">@matklad</a> said that:</p>
<blockquote>
<p>It’s interesting to compare it with Kotlin, which also uses is operator for the similar purpose: https://kotlinlang.org/docs/reference/typecasts.html#smart-casts.</p>
<p>The differences is that instead of destructing, Kotlin’s is supplies a flow-sensitive type information. The compiler indeed uses pretty smart control-flow analysis to check if every use of a variable is dominated by the is check.</p>
<p>However, as long as the compiler does all the inference work for you, actually using this feature is easy: you don’t have to replay the analysis in your head when reading or writing code, because the compiler catches all errors.</p>
</blockquote>
<h3 id="rfc-160"><a class="header" href="#rfc-160"><a href="https://github.com/rust-lang/rfcs/pull/160">RFC 160</a></a></h3>
<p>Interestingly, the <code>EXPR is PAT</code> idea was floated in the original RFC 160 that introduced <code>if let</code> expressions in the first place. There, the notion that an operator named <code>is</code>, which introduces bindings, is confusing was brought up.</p>
<p>It was also mentioned by <a href="https://github.com/rust-lang/rfcs/pull/160#issuecomment-48515260">@lilyball</a> that it would be appropriate if, and only if, it was limited to pattern matching, but not introducing any bindings. We make the same argument in this RFC. The issue of unintuitive scopes was also mentioned <a href="https://github.com/rust-lang/rfcs/pull/160#issuecomment-48551196">by @lilyball</a> there.</p>
<p>Even the idea of <code>if EXPR match PAT</code> was floated by <a href="https://github.com/rust-lang/rfcs/pull/160#issuecomment-49234092">@liigo</a> at the time but that idea was ultimately also rejected. <a href="https://github.com/rust-lang/rfcs/pull/160#issuecomment-49242255">@lilyball</a> opined that using <code>match</code> as a binary operator would be <em>“very confusing”</em> but did not elaborate further at the time.</p>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<h3 id="the-final-syntax"><a class="header" href="#the-final-syntax">The final syntax</a></h3>
<p>The main goal of this RFC is threefold:</p>
<ol>
<li>
<p>Decide that this is a problem that needs to be solved <em>somehow</em>.</p>
</li>
<li>
<p>Make the proposed syntax in the RFC an option that is available in Rust 2018.</p>
</li>
<li>
<p>Adopt the proposed syntax in the RFC.</p>
</li>
</ol>
<p>Of these points, the 1st and the 2nd are the most important for the time being. The 3rd point is not unimportant, but it is not as time sensitive. Thus, one path ahead of least resistance is to adopt the syntax in the RFC and make it available in Rust 2018 while leaving the final syntax unresolved. We can then debate alternatives, in particular using <code>EXPR match PAT</code>, more rigorously post shipping Rust 2018. Finalizing the syntax and can then be decided in a tracking issue or another RFC.</p>
<h3 id="irrefutable-let-bindings-after-the-first-refutable-binding"><a class="header" href="#irrefutable-let-bindings-after-the-first-refutable-binding">Irrefutable let bindings after the first refutable binding</a></h3>
<p>Should temporary and irrefutable <code>let</code>s without patterns be allowed as in the following example?</p>
<pre><code class="language-rust">if let &amp;List(_, ref list) = meta
    &amp;&amp; let mut iter = list.iter().filter_map(extract_word) // &lt;-- Irrefutable
    &amp;&amp; let Some(ident) = iter.next()
    &amp;&amp; let None = iter.next()
{
    *set = Some(syn::Ty::Path(None, ident.clone().into()));
} else {
    error::param_malformed();
}</code></pre>
<p>With normal <code>if let</code> expressions, this is an error as seen with the following example:</p>
<pre><code class="language-rust">fn main() {
    if let x = 1 { 2 } else { 3 };
}</code></pre>
<p>Compiling the above ill-formed program results in:</p>
<pre><code>error[E0162]: irrefutable if-let pattern
</code></pre>
<p>However, with the implementation of <a href="https://github.com/rust-lang/rfcs/pull/2086">RFC 2086</a>, this error will instead become a warning.  This is understandable - while the program could have perfectly well defined semantics, where the value of the expression is always 2, allowing the form would invite some developers to write in a non-obvious way. A warning is however a good middle ground.</p>
<p>However, when let bindings in the middle are irrefutable, there is some value in not warning against the construct. In the case of the initial example in this subsection, it would be written as follows without irrefutable let bindings:</p>
<pre><code class="language-rust">if let &amp;List(_, ref list) = meta {
   let mut iter = list.iter().filter_map(extract_word);
    if let Some(ident) = iter.next()
        &amp;&amp; let None = iter.next()
    {
        *set = Some(syn::Ty::Path(None, ident.clone().into()));
    } else {
        error::param_malformed();
    }
} else {
    error::param_malformed();
}</code></pre>
<p>However, now we have introduced rightward drift and duplication again, which we wanted to avoid.</p>
<p>On the other hand, allowing irrefutable patterns in the middle without a warning may give the impression that the irrefutable pattern is refutable, or cast doubt on it making semantics possibly harder to grasp quickly.</p>
<p>This is a tricky question, which we leave open for consideration during the stabilization period or even after stabilization.</p>
<h3 id="chained-if-lets-inside-match-arms"><a class="header" href="#chained-if-lets-inside-match-arms">Chained <code>if let</code>s inside <code>match</code> arms</a></h3>
<p>Would the following be accepted by a Rust compiler?</p>
<pre><code class="language-rust">match EXPR {
    PAT if let PAT = EXPR &amp;&amp; EXPR &amp;&amp; ... =&gt; { .. }
    _ =&gt; { .. }
}</code></pre>
<p>The combination of the accepted, but yet to be stabilized, <a href="https://github.com/rust-lang/rfcs/pull/2294">RFC 2294</a>, and this RFC would entail that it would be accepted. However, at this point, and in the interest of time, we leave this for a future RFC or for pre-stabilization.</p>
<h2 id="appendix-a---style-considerations"><a class="header" href="#appendix-a---style-considerations">Appendix A - Style considerations</a></h2>
<p>How should the features introduced in this RFC be formatted? This is not a make or break question but rather a style question for <code>rustfmt</code>. What you read here should not be taken as prescriptive but rather as discussion material and to generate ideas. Any eventual decision on style will be made by a separate style RFC.</p>
<p>Here are a few variants on indentation to consider for <code>rustfmt</code> while may or may not be mutually compatible:</p>
<h3 id="1--on-a-new-line-and-indented--open-brace-after-newline"><a class="header" href="#1--on-a-new-line-and-indented--open-brace-after-newline">1. <code>&amp;&amp;</code> on a new line and indented + Open-brace after newline</a></h3>
<pre><code class="language-rust">if independent_condition
    &amp;&amp; let Alan(x) = turing()
    &amp;&amp; let Alonzo(y) = church(x)
    &amp;&amp; y.has_really_cool_property()
{
    computation_with(x, y)
}</code></pre>
<p>This style is maximally consistent with how conditions in <code>if</code> expressions are currently formatted.</p>
<p>Moving the open brace down a line may help emphasize the split between a lengthy condition and the block body.</p>
<h3 id="2--after-bindings"><a class="header" href="#2--after-bindings">2. <code>&amp;&amp;</code> after bindings</a></h3>
<pre><code class="language-rust">if independent_condition &amp;&amp;
   let Haskell(x) = curry() &amp;&amp;
   let Alonzo(y) = church(x) &amp;&amp;
   y.has_really_cool_property() {
    computation_with(x, y)
}</code></pre>
<p>This style is consistent with how separators, such as <code>,</code>, are currently formatted in Rust.</p>
<h3 id="3--at-the-start-of-lines"><a class="header" href="#3--at-the-start-of-lines">3. <code>&amp;&amp;</code> at the start of lines</a></h3>
<pre><code class="language-rust">if independent_condition
&amp;&amp; let Alan(x) = turing()
&amp;&amp; let Alonzo(y) = church(x)
&amp;&amp; y.has_really_cool_property() {
    computation_with(x, y)
}</code></pre>
<p>This style of leading separators is inconsistent with current formatting.</p>
<h3 id="4-aligning-the-equals-sign-together"><a class="header" href="#4-aligning-the-equals-sign-together">4. Aligning the equals sign together</a></h3>
<pre><code class="language-rust">if independent_condition &amp;&amp;
   let Alan(x)   = turing() &amp;&amp;
   let Alonzo(y) = church(x) &amp;&amp;
   y.has_really_cool_property() {
    computation_with(x, y)
}</code></pre>
<p>While this might look visually pleasing, visual indent like this is against the <a href="https://github.com/rust-lang-nursery/fmt-rfcs/blob/master/guide/principles.md#overarching-guidelines">rustfmt guidelines</a>.</p>
<h3 id="5-newline-after-else-if"><a class="header" href="#5-newline-after-else-if">5. Newline after <code>else if</code></a></h3>
<pre><code class="language-rust">if independent_condition &amp;&amp;
   let Conor(x) = mcbride() &amp;&amp;
   let Euginia(y) = cheng(x) &amp;&amp;
   y.has_really_cool_property() {
    computation_with(x, y)
} else if // &lt;-- Notice newline.
    let Stephanie(x) = weirich() &amp;&amp;
    let Thierry(y) = coquand() {
    computation_with(x, y)
}</code></pre>
<p>In this version we look at whether or not a newline should be inserted after an <code>else if</code> branch. The benefit of inserting a newline is that it aligns well with the <code>let</code> bindings in the <code>if</code> branch.</p>
<h3 id="6-no-indent-at-all-just-a-list-of-conditions"><a class="header" href="#6-no-indent-at-all-just-a-list-of-conditions">6. No indent at all, just a list of conditions</a></h3>
<pre><code class="language-rust">if independent_condition &amp;&amp;
let Alan(x)   = turing() &amp;&amp;
let Alonzo(y) = church(x) &amp;&amp;
y.has_really_cool_property() {
    computation_with(x, y)
}</code></pre>
<p>In this version, we do not indent the <code>let</code>s and the boolean side-conditions. But we do place the <code>&amp;&amp;</code> on the end of lines. One benefit here is that the body of the <code>if</code> expression more clearly stands out. However, a drawback is that the <code>if</code> token stands less out.</p>
<p>There are of course more versions one can contemplate and the various combination of them, but in the interest of brevity, we keep to this list here.</p>
<h2 id="appendix-b"><a class="header" href="#appendix-b">Appendix B</a></h2>
<p>This appendix groups some survey answers together for the purposes of analysis. Please note that this appendix is by no means complete and is only offered on a best-effort basis. The comments cited below have also been cleaned up to fix obvious spelling mistakes, etc.</p>
<h3 id="appendix-b1"><a class="header" href="#appendix-b1">Appendix B.1</a></h3>
<p>Here are a number of participants in the survey commenting that they expected the proposed syntax in this RFC to work.</p>
<ol>
<li>
<blockquote>
<p>The “<code>if let .. &amp;&amp; let .. &amp;&amp; ..</code>” feels like the intuitive way to do it if you don’t think about the language syntax too much. It’s definitely the way I tried doing it when I thought it was possible at the start of my Rust path.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>I tried to write this one and then realized it’s not supported.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>I’ve already tried to do this before and find it didn’t work.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>I was surprised to find that this syntax wasn’t already supported.  Principle of least surprise for the win.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>I would expect “Using <code>&amp;&amp;</code> for conjunction and <code>let PATTERN = EXPR</code>” to work already today</p>
</blockquote>
</li>
<li>
<blockquote>
<p>I tried to used this specific syntax and I expected it to work already.</p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>let …</code> matches the current <code>if let</code>, and the <code>&amp;&amp;</code> matches the way I would write it. I’ve tried to write <code>if let Some(x) = foo &amp;&amp; x.bar() { … }</code> before.</p>
</blockquote>
</li>
</ol>
<h3 id="appendix-b2"><a class="header" href="#appendix-b2">Appendix B.2</a></h3>
<p>Many participants in the survey opined that the proposed syntax was consistent with current Rust. They thought that this was positive.</p>
<ol>
<li>
<blockquote>
<p>It is the <em>only</em> option consistent with what we have today and expect once we learn about <code>let PATTERN = EXPR</code>.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Close to current Rust syntax</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Most similar to existing syntaxes, which increases orthogonality.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>This seems most consistent with existing Rust syntax.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>consistency with current Rust</p>
</blockquote>
</li>
<li>
<blockquote>
<p>consistency with current syntax</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Consistency with current syntax</p>
</blockquote>
</li>
<li>
<blockquote>
<p>It’s the least surprising syntax. It’s obvious.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Should be consistent and similar to how match patterns/existing <code>let A(x) = b</code> works.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Seems to most closely match existing syntax and style</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Seems consistent with existing syntax</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Consistent with current Rust syntax.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Consistency with the syntax we already have.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>compatibility with current syntax</p>
</blockquote>
</li>
<li>
<blockquote>
<p>It’s feels consistent with the rest of the language.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Consistency with existing Rust constructs and familiarity with C and Swift syntax.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>consistent with already existing <code>if</code> and <code>let</code> patterns. intuitive</p>
</blockquote>
</li>
<li>
<blockquote>
<p>close to current rust syntax (same assign syntax as in <code>match</code> and <code>if let</code>)</p>
</blockquote>
</li>
<li>
<blockquote>
<p>I chose “Using <code>&amp;&amp;</code> for conjunction and <code>let PATTERN = EXPR</code>” because it seems like the only choice that is consistent with Rust syntax as it is today. The rest are… strange.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>we already have while <code>let A(x) = foo()</code> and <code>&amp;&amp;</code> in <code>if</code> statements, I don’t see how any other syntax makes sense</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Using <code>&amp;&amp;</code> unambiguously means conjunction and is, IMO, easier to read. <code>let PATTERN = EXPR</code> does not introduce a new form of pattern matching to the language.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>The “<code>let(x) = expr</code>” is consistent with the current syntax, the “<code>&amp;&amp;</code>” makes it clear it’s an AND (and in most languages it’s short-circuited).</p>
</blockquote>
</li>
<li>
<blockquote>
<p>So I like that using <code>&amp;&amp;</code> is how we currently use it in the language, and everyone is already used to using <code>let A(x) = foo()</code>. Honestly, the one I chose feels the most consistent with the language.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>double <code>&amp;</code> is standard for logical AND, “<code>if let foo(x) = bar</code>” is just as good as the other syntax but is already standard in rust, so might as well keep it</p>
</blockquote>
</li>
<li>
<blockquote>
<p>using <code>&amp;&amp;</code> and <code>let PATTERN = EXPR</code> is more intuitive because you’re checking a condition <em>and</em> whether a pattern matches.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>follows standard “<code>&amp;&amp;</code>” pattern and “<code>if-let</code>” pattern as well</p>
</blockquote>
</li>
<li>
<blockquote>
<p>uses existing syntax</p>
</blockquote>
</li>
<li>
<blockquote>
<p>It’s what I already know in Rust</p>
</blockquote>
</li>
<li>
<blockquote>
<p>this is the most similar to rust’s current <code>if let</code> syntax</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Uses already established keywords and operators in a semantically similar way.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>It just looks like normal rust we’re all used to (<code>if let</code> destructuring syntactic sugar)</p>
</blockquote>
</li>
<li>
<blockquote>
<p>The most natural extension of <code>let</code> expressions and <code>boolean</code> conditions</p>
</blockquote>
</li>
<li>
<blockquote>
<p>The <code>&amp;&amp;</code> operator and “<code>if let</code>” are already in the language. No reason to pick something totally different. More on that on the next page.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>I don’t really like any of them. I prefer <code>;</code> for conjunction because that’s more similar to how Go does it, though <code>&amp;&amp;</code> for conjunction and <code>let PATTERN = ...</code> is okay because it’s intuitive given other language features in Rust.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Using <code>&amp;&amp;</code> for conjunction is consistent with other languages I know, using <code>let</code> for pattern matching is explicit about introducing new names.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Seems the most natural. If I knew <code>if let x = y</code> could be combined with other conditions, my first thought would be <code>&amp;&amp; z == z1</code></p>
</blockquote>
</li>
<li>
<blockquote>
<p>Smallest delta from current syntax. <code>&amp;&amp;</code> already exists, <code>let PATTERN = EXPR</code> exists, just allowing the two in composition.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>The option I chose (<code>if expr &amp;&amp; let pat = expr &amp;&amp; let pat = expr &amp;&amp; expr { body }</code>) is the most consistent with existing Rust syntax. It’s a fairly natural extension of the <code>if let</code> syntax since it uses <code>let pat = expr</code> in a place where you could otherwise use <code>expr</code>. Using <code>&amp;&amp;</code> as a conjunction most clearly expresses the intention IMO, and it also clearly follows short-circuit evaluation.</p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>EXPR is PATTERN</code> is introducing new alternative syntax which is useless when we already have the <code>let PATTERN = EXPR</code> syntax. <code>&amp;&amp;</code> is also clearly the best choice for joining conditions because that is what it is already used for!</p>
</blockquote>
</li>
<li>
<blockquote>
<p>“<code>if let</code>” is already a well-known thing in Rust, so keep it. Conjunction is already a well-known thing in Rust, so keep it. In short, make minimal changes to the language that make the example work.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Using <code>&amp;&amp;</code> for conjunction along with the existing syntax for <code>let</code> bindings is the most intuitive and feels the least like it’s special-casing. I think this is less likely to confuse beginners, and makes it feel more cohesive.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Follows the standards of current syntax relatively closely without introducing new symbols, and builds on the existing understanding of <code>let</code>-deconstruction while clearing showing (through the use of <code>let</code>) that we have assigned <code>x</code> and <code>y</code>.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>This is the syntax that I would expect without reading the manual.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>I feel that including <code>let</code> is important to make it clear that the pattern is exposing the variables <code>x</code> and <code>y</code> for use in the block body and <code>&amp;&amp;</code> is by far the most intuitive way to AND together test conditions. In fact, presenting alternatives to Rust’s existing <code>&amp;&amp;</code> syntax for ANDing together terms made even the use of <code>&amp;&amp;</code> confusing because the claim that they were all equivalent meant that it “couldn’t possibly be” the existing meaning of <code>&amp;&amp;</code>. I didn’t know what was going on until I realized I’d glossed over tiny (ie. unimportant) text which actually explained the meaning in plain English… at which point, I realized that the syntaxes other than <code>&amp;&amp;</code> had set up a mistaken assumption that ruled out the actual proper interpretation.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>I like Using <code>&amp;&amp;</code> for conjunction and <code>let PATTERN = EXPR</code>  because it, for me, has the least surprises syntactically. <code>&amp;&amp;</code> indicates conjunction of the predicate, and including <code>x</code> and <code>y</code> in subsequent scopes is something I wish existed, but if we’re not clear about it, it could get messy.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>it does not introduce anything fancy new stuff</p>
</blockquote>
</li>
<li>
<blockquote>
<p>I like the “<code>let</code>” syntax better than the <code>EXPR is PATTERN</code> syntax, since it’s used in other places already.</p>
</blockquote>
</li>
<li>
<blockquote>
<ol>
<li><code>&amp;&amp;</code> is already a familiar concept for working with boolean expressions</li>
<li><code>if let</code> is how we already achieve conditional binding
The combination of “<code>is</code>” and <code>&amp;&amp;</code> is the only other choice I could consider, albeit begrudgingly. I’m kind of uncomfortable with giving up keyword real estate and having another way of doing <code>if let</code>.</li>
</ol>
<p>Other than that, I feel like the other choices alienate both new and old Rust programmers alike. We should be focusing on keeping things as simple and familiar as possible.</p>
</blockquote>
</li>
</ol>
<h3 id="appendix-b3"><a class="header" href="#appendix-b3">Appendix B.3</a></h3>
<p>Some survey participants did not explicitly say that the RFC’s proposed syntax was <em>consistent</em>, but they did say, in some way, that it was <em>intuitive</em>.</p>
<ol>
<li>
<blockquote>
<p><code>&amp;&amp;</code> is the logical conjunction operator and <code>let A(x) = foo</code> clearly destructures for pattern matching</p>
</blockquote>
</li>
<li>
<blockquote>
<p>The most intuitive</p>
</blockquote>
</li>
<li>
<blockquote>
<p>It is not surprising</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Looks like straightforward boolean logic, the rest seem like arcane syntax.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Reminiscent of boolean algebra</p>
</blockquote>
</li>
<li>
<blockquote>
<p>It fits with my mental model of how patterns and Boolean logic work</p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>&amp;&amp;</code> makes the logic relationship clearer, and using <code>let</code> for binding is the same. Conjunction is more readable with <code>&amp;&amp;</code></p>
</blockquote>
</li>
<li>
<blockquote>
<p>We already have “<code>if let</code>” elsewhere. Don’t introduce a new “<code>is</code>” syntax here, it’s not any more intuitive.</p>
</blockquote>
</li>
</ol>
<h3 id="appendix-b4"><a class="header" href="#appendix-b4">Appendix B.4</a></h3>
<p>Some survey participants felt that the proposed syntax set up the expectation of <code>let PAT = EXPR</code> being an expression typed at <code>bool</code> as opposed to a statement which is currently the case.</p>
<ol>
<li>
<blockquote>
<p><code>&amp;&amp;</code> as separator would require boolean expressions.</p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>&amp;&amp;</code> is for boolean expressions, and won’t work right in generic usage. <code>let</code> would have to return a boolean which is weird and probably a breaking change.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Using <code>&amp;&amp;</code> for conjunction with <code>let PATTERN = EXPR</code> feels consistent with the existing <code>if let</code> syntax, however it causes potentially some confusion about data types and its existing function as a <code>boolean</code> operator, so that leads me to considering <code>,</code> as the conjunction instead. However, if “<code>let PATTERN = EXPR</code>” is an expression returning a boolean as well as setting up the pattern bindings then there’s no issue with <code>&amp;&amp;</code> at all, and it’s then preferable to me provided it’s available where you’d expect expressions to be available and not treated particularly specially.</p>
</blockquote>
</li>
</ol>
<h3 id="appendix-b5"><a class="header" href="#appendix-b5">Appendix B.5</a></h3>
<p>Another group of people opined that <code>,</code> and <code>if</code> did not clearly imply conjunction and that it could be construed as disjunction instead. The majority of these comments were directed towards <code>,</code> as opposed to <code>if</code>.</p>
<ol>
<li>
<blockquote>
<p>Commas do not feel like natural <code>and</code> separators.</p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>,</code> is bad because it already means “separate things”, and now it suddenly means “join things”.</p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>,</code> does not mean and to me</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Comma is not <code>&amp;&amp;</code>.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>“<code>,</code>” doesn’t seem like a conjunction (usually means tuple)</p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>,</code> as conjunction is ambiguous (could just as well be disjunction)</p>
</blockquote>
</li>
<li>
<blockquote>
<p>using a comma to mean conjunction is <em>very</em> unclear.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>I find the comma ambiguous (is it AND or OR?).</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Commas just aren’t clear enough: on their own, to many people, they could easily be interpreted as logical ORs or logical ANDs.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Although really the only reasonable interpretation of <code>,</code> is conjunction, it’s still not immediately obvious that that is the case.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>The tower of <code>if</code>s is quite ugly (although it seems less ambiguous than using commas, which to some people might be construed as disjunction).</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Ambiguous, are they ‘or’ or ‘and’?</p>
</blockquote>
<p>note: this refers to <code>,</code> and not <code>if</code> as a separator.</p>
</li>
<li>
<blockquote>
<p>Commas don’t imply conjunction to me and chained ifs just feel a bit unnatural too</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Using <code>,</code> is a bad idea because, with Rust already having a perfectly good <code>&amp;&amp;</code>, adding <code>,</code> is likely to evoke <em>“OK, I know <code>&amp;&amp;</code>, so <code>.</code> must be OR”</em> or <em>“I know <code>&amp;&amp;</code> and <code>||</code>, so what the heck is <code>,</code>? I’m so confused.”</em> …not to mention that it runs against the Rust design philosophy to needlessly introduce alternative syntax and I can’t see any practical reason it would be necessary to distinguish between tests and pattern matches in this context which can’t be handled by putting <code>let</code> before the matches.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>these syntaxes don’t make it clear that there is an ‘and’ relationship between the conditions</p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>if</code> after <code>if</code> with no logical operator? is this AND? is this OR?</p>
</blockquote>
</li>
<li>
<blockquote>
<p>They either imply ‘or’ or remind me of a switch fall through in other languages (and thus also ‘or’)</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Stacking repeated uses of “<code>if</code>” at the top level feels very confusing to visually scan; it doesn’t distinguish a conjunction very well.</p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>if</code> for conjunction is confusing</p>
</blockquote>
</li>
</ol>
<h3 id="appendix-b6"><a class="header" href="#appendix-b6">Appendix B.6</a></h3>
<p>Does <code>,</code> entail short-circuiting behaviour or not? Some survey participants did not think this was clear.</p>
<ol>
<li>
<blockquote>
<p>I would also expect the comma options to not follow short-circuit evaluation.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>For users coming from other languages, comma is unclear about whether short-circuiting will take place.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Syntax does not fit in with other usages of ‘<code>,</code>’ in rust (especially tuples). It’s non-obvious what the order of execution of sub-expressions are.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>The commas are out of left field: they bear no relation to anything currently in Rust or any other language. The conditional looks like some sort of tupling expression.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>On the other hand the comma’d version felt the least clear in meaning and execution order. I’m more used to things-separated-by-commas being roughly equivalent instead of being something that ends up short circuiting the evaluation.</p>
</blockquote>
</li>
</ol>
<h3 id="appendix-b7"><a class="header" href="#appendix-b7">Appendix B.7</a></h3>
<p>A number of survey participants noted that separating with <code>if</code> is noisy and looks as if braces are missing.</p>
<ol>
<li>
<blockquote>
<p>Using multiple <code>if</code>s feels very weird (it looks like there are some missing braces and the indentation is wrong).</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Chaining <code>if</code> statements is unclear since in most languages you can leaves off the curly braces for an <code>if</code> with a single statement body.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>chaining “if” keywords without braces or separators doesn’t convey the meaning of the statement well and seems out of place in rusts present syntax, even more so if contracted to a single line.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Using a bunch of <code>if</code> in a column within the same <code>if</code> statement should stoke uncertainty about the intended meaning in anyone who remembers that Rust is very forgiving about where you put your whitespace.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Too many <code>if</code>s making it noisy.</p>
</blockquote>
</li>
</ol>
<h3 id="appendix-b8"><a class="header" href="#appendix-b8">Appendix B.8</a></h3>
<p>A number of survey participants noted that bindings introduced in <code>EXPR is PAT</code> were unexpectedly on the RHS while they were used to it being on the LHS.</p>
<ol>
<li>
<blockquote>
<p>Don’t like ‘<code>is</code>’ since it puts variable binding on the right.</p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>is</code> seems backwards.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>The ‘<code>is</code>’ operator creates new variables, but the pattern is on the right, where variables are usually read from.</p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>foo() is A(x)</code> is backwards to binding in most other places.</p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>expr is pat</code> reverses the directionality for pattern bindings seen everywhere else in Rust;</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Very unreadable, swapped order of unpacking confusing</p>
</blockquote>
</li>
<li>
<blockquote>
<p>The “<code>is</code>” formulation is backwards from current <code>if let</code>.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>I really do no like how the <code>is</code> syntax has the left and right sides reversed from the <code>if let ... = ...</code> syntax. It seems very odd to have that sort of pattern matching written in opposite directions depending on the syntax you choose.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>The “<code>is</code>”-destructuring/pattern matching looks really weird because normally names have to be located on the left side of a statement to be bound to a value. The right side is there to retrieve the value.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>extracting with a pattern match is confusing when the pattern match is to the right of the variable being matched. it looks like a statement of fact, not the introduction of a new identifier.</p>
</blockquote>
</li>
</ol>
<h3 id="appendix-b9"><a class="header" href="#appendix-b9">Appendix B.9</a></h3>
<p>Some survey participants opined that they found it surprising that an operator named <code>is</code> introduces bindings. Another group found that <code>is</code> could easily be confused for some sort of equality test (as in the operator <code>==</code>) as in Python.</p>
<ol>
<li>
<blockquote>
<p>using <code>is</code> to introduce new bindings is very surprising.</p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>is</code> is weird because it can bind variables.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>The “<code>is</code>” syntax is confusing, since it does an implicit pattern binding. I think folks would get it wrong by trying to pass a bound variable there and being surprised to find that it’s a pattern instead.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>I dislike the <code>EXPR is PATTERN</code> syntax because while the word <code>let</code> indicates that there is some binding going on, I read the word <code>is</code> as passively checking whether the expression fits a pattern without binding. I also dislike <code>is</code> because it is new syntax that does the same thing as existing syntax.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Without <code>let</code> it isn’t clear that we are declaring a new variable via <code>is</code>. Now we could introduce new keywords, but <code>is</code> still isn’t clear about what it’s doing. It seems odd to introduce <code>is</code> when <code>if let</code> does the same thing.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>The ‘is’ keyword suggests a boolean operation but silently behaves like a ‘<code>let</code>’.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>If <code>expr is pattern</code> doesn’t actually bind, and just pattern matches, then I like it. This should have been a language feature imo.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>I don’t like <code>is</code> because it doesn’t look like a binding operator</p>
</blockquote>
</li>
<li>
<blockquote>
<p>The “<code>is A(x)</code>” syntax looked nice on first sight, but it’s backwards, as in this case it’s an assignment (to <code>x</code> and <code>y</code>) and not just a comparison. Maybe it’s ok as “<code>if foo() is A</code>” (like for “<code>if foo().is_some()</code>” but more generic) but not in this case.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>I don’t like using “<code>is</code>” for assignment. It sounds like equality (<code>==</code>), but with an assignment as a side effect. “<code>if let</code>” is the established way of doing equality and assignment together, and I think we should stick with one way of doing it. I also think “<code>if let</code>” better highlights that both equality and assignment happens, even when it is nested inside the expression as here.</p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>is</code> doesn’t make any sense since we already have <code>if let PATTERN</code> and <code>is</code> in other languages is typically a reference equality check (e.g. Dart and Python).</p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>is</code> operator can be confusing (is the same as <code>==</code> or something else entirely?);</p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>is</code> I don’t like because it looks too much like subclass testing and/or identity testing from other languages. <code>let</code> I like for uniformity with <code>if let</code> and <code>while let</code>, but it needs <em>something</em> to make clear that the <code>&amp;&amp;</code> isn’t part of the thing being bound; maybe parens around the whole thing? Require parens around the whole RHS if there’s an <code>&amp;&amp;</code> anywhere in there? I don’t know how to resolve the ambiguity… use <code>match</code>, instead?</p>
</blockquote>
</li>
<li>
<blockquote>
<p>The “<code>is</code>” keyword is not in Rust yet (afaik) but if we wanted to use it, we should ponder that it means “reference equality” to Python people. I would thus be hesitant about using it for pattern matching expressions, especially given that we already have “<code>let</code>” for pattern matching. If possible, I would prefer making <code>let</code>-bindings an expression.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Rust already has meanings for <code>&amp;&amp;</code> and <code>let</code> which can be applied here. Replacing <code>let ...</code> with <code>... is ...</code> is too different from existing pattern syntax and too similar to Python’s identity testing operator.</p>
</blockquote>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="2495-min-rust-version.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="2500-needle.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="2495-min-rust-version.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="2500-needle.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
