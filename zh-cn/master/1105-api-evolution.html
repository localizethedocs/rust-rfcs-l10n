<!DOCTYPE HTML>
<html lang="zh_CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>1105-api-evolution - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-b61d75f0.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Feature Name: not applicable</li>
<li>Start Date: 2015-05-04</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/1105">rust-lang/rfcs#1105</a></li>
<li>Rust Issue: N/A</li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This RFC proposes a comprehensive set of guidelines for which changes to <em>stable</em> APIs are considered breaking from a semver perspective, and which are not.  These guidelines are intended for both the standard library and for the crates.io ecosystem.</p>
<p>This does <em>not</em> mean that the standard library should be completely free to make non-semver-breaking changes; there are sometimes still risks of ecosystem pain that need to be taken into account. Rather, this RFC makes explicit an initial set of changes that absolutely <em>cannot</em> be made without a semver bump.</p>
<p>Along the way, it also discusses some interactions with potential language features that can help mitigate pain for non-breaking changes.</p>
<p>The RFC covers only API issues; other issues related to language features, lints, type inference, command line arguments, Cargo, and so on are considered out of scope.</p>
<p>The stability promise specifically does <em>not</em> apply to unstable features, even if they are accidentally usable on the Stable release channel under certain conditions such as because of bugs in the compiler.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Both Rust and its library ecosystem have adopted <a href="http://semver.org/">semver</a>, a technique for versioning platforms/libraries partly in terms of the effect on the code that uses them. In a nutshell, the versioning scheme has three components::</p>
<ol>
<li><strong>Major</strong>: must be incremented for changes that break client code.</li>
<li><strong>Minor</strong>: incremented for backwards-compatible feature additions.</li>
<li><strong>Patch</strong>: incremented for backwards-compatible bug fixes.</li>
</ol>
<p><a href="http://blog.rust-lang.org/2015/02/13/Final-1.0-timeline.html">Rust 1.0.0</a> will mark the beginning of our <a href="http://blog.rust-lang.org/2014/10/30/Stability.html">commitment to stability</a>, and from that point onward it will be important to be clear about what constitutes a breaking change, in order for semver to play a meaningful role. As we will see, this question is more subtle than one might think at first – and the simplest approach would make it effectively impossible to grow the standard library.</p>
<p>The goal of this RFC is to lay out a comprehensive policy for what <em>must</em> be considered a breaking API change from the perspective of semver, along with some guidance about non-semver-breaking changes.</p>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed design</a></h2>
<p>For clarity, in the rest of the RFC, we will use the following terms:</p>
<ul>
<li><strong>Major change</strong>: a change that requires a major semver bump.</li>
<li><strong>Minor change</strong>: a change that requires only a minor semver bump.</li>
<li><strong>Breaking change</strong>: a change that, <em>strictly speaking</em>, can cause downstream code to fail to compile.</li>
</ul>
<p>What we will see is that in Rust today, almost any change is technically a breaking change. For example, given the way that globs currently work, <em>adding any public item</em> to a library can break its clients (more on that later). But not all breaking changes are equal.</p>
<p>So, this RFC proposes that <strong>all major changes are breaking, but not all breaking changes are major.</strong></p>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<h4 id="principles-of-the-policy"><a class="header" href="#principles-of-the-policy">Principles of the policy</a></h4>
<p>The basic design of the policy is that <strong>the same code should be able to run against different minor revisions</strong>. Furthermore, minor changes should require at most a few local <em>annotations</em> to the code you are developing, and in principle no changes to your dependencies.</p>
<p>In more detail:</p>
<ul>
<li>
<p>Minor changes should require at most minor amounts of work upon upgrade. For example, changes that may require occasional type annotations or use of UFCS to disambiguate are not automatically “major” changes. (But in such cases, one must evaluate how widespread these “minor” changes are).</p>
</li>
<li>
<p>In principle, it should be possible to produce a version of dependency code that <em>will not break</em> when upgrading other dependencies, or Rust itself, to a new minor revision. This goes hand-in-hand with the above bullet; as we will see, it’s possible to save a fully “elaborated” version of upstream code that does not require any disambiguation. The “in principle” refers to the fact that getting there may require some additional tooling or language support, which this RFC outlines.</p>
</li>
</ul>
<p>That means that any breakage in a minor release must be very “shallow”: it must always be possible to locally fix the problem through some kind of disambiguation <em>that could have been done in advance</em> (by using more explicit forms) or other annotation (like disabling a lint). It means that minor changes can never leave you in a state that requires breaking changes to your own code.</p>
<p><strong>Although this general policy allows some (very limited) breakage in minor releases, it is not a license to make these changes blindly</strong>. The breakage that this RFC permits, aside from being very simple to fix, is also unlikely to occur often in practice. The RFC will discuss measures that should be employed in the standard library to ensure that even these minor forms of breakage do not cause widespread pain in the ecosystem.</p>
<h4 id="scope-of-the-policy"><a class="header" href="#scope-of-the-policy">Scope of the policy</a></h4>
<p>The policy laid out by this RFC applies to <em>stable</em>, <em>public</em> APIs in the standard library. Eventually, stability attributes will be usable in external libraries as well (this will require some design work), but for now public APIs in external crates should be understood as de facto stable after the library reaches 1.0.0 (per semver).</p>
<h3 id="policy-by-language-feature"><a class="header" href="#policy-by-language-feature">Policy by language feature</a></h3>
<p>Most of the policy is simplest to lay out with reference to specific language features and the way that APIs using them can, and cannot, evolve in a minor release.</p>
<p><strong>Breaking changes are assumed to be major changes unless otherwise stated</strong>. The RFC covers many, but not all breaking changes that are major; it covers <em>all</em> breaking changes that are considered minor.</p>
<h4 id="crates"><a class="header" href="#crates">Crates</a></h4>
<h5 id="major-change-going-from-stable-to-nightly"><a class="header" href="#major-change-going-from-stable-to-nightly">Major change: going from stable to nightly</a></h5>
<p>Changing a crate from working on stable Rust to <em>requiring</em> a nightly is considered a breaking change. That includes using <code>#[feature]</code> directly, or using a dependency that does so. Crate authors should consider using Cargo <a href="http://doc.crates.io/manifest.html#the-[features]-section">“features”</a> for their crate to make such use opt-in.</p>
<h5 id="minor-change-altering-the-use-of-cargo-features"><a class="header" href="#minor-change-altering-the-use-of-cargo-features">Minor change: altering the use of Cargo features</a></h5>
<p>Cargo packages can provide <a href="http://doc.crates.io/manifest.html#the-[features]-section">opt-in features</a>, which enable <code>#[cfg]</code> options. When a common dependency is compiled, it is done so with the <em>union</em> of all features opted into by any packages using the dependency. That means that adding or removing a feature could technically break other, unrelated code.</p>
<p>However, such breakage always represents a bug: packages are supposed to support any combination of features, and if another client of the package depends on a given feature, that client should specify the opt-in themselves.</p>
<h4 id="modules"><a class="header" href="#modules">Modules</a></h4>
<h5 id="major-change-renamingmovingremoving-any-public-items"><a class="header" href="#major-change-renamingmovingremoving-any-public-items">Major change: renaming/moving/removing any public items.</a></h5>
<p>Although renaming an item might seem like a minor change, according to the general policy design this is not a permitted form of breakage: it’s not possible to annotate code in advance to avoid the breakage, nor is it possible to prevent the breakage from affecting dependencies.</p>
<p>Of course, much of the effect of renaming/moving/removing can be achieved by instead using deprecation and <code>pub use</code>, and the standard library should not be afraid to do so! In the long run, we should consider hiding at least some old deprecated items from the docs, and could even consider putting out a major version solely as a kind of “garbage collection” for long-deprecated APIs.</p>
<h5 id="minor-change-adding-new-public-items"><a class="header" href="#minor-change-adding-new-public-items">Minor change: adding new public items.</a></h5>
<p>Note that adding new public items is currently a breaking change, due to glob imports. For example, the following snippet of code will break if the <code>foo</code> module introduces a public item called <code>bar</code>:</p>
<pre><code class="language-rust">use foo::*;
fn bar() { ... }</code></pre>
<p>The problem here is that glob imports currently do not allow any of their imports to be shadowed by an explicitly-defined item.</p>
<p>This is considered a minor change because under the principles of this RFC: the glob imports could have been written as more explicit (expanded) <code>use</code> statements. It is also plausible to do this expansion automatically for a crate’s dependencies, to prevent breakage in the first place.</p>
<p>(This RFC also suggests permitting shadowing of a glob import by any explicit item. This has been the intended semantics of globs, but has not been implemented. The details are left to a future RFC, however.)</p>
<h4 id="structs"><a class="header" href="#structs">Structs</a></h4>
<p>See “<a href="#signatures-in-type-definitions">Signatures in type definitions</a>” for some general remarks about changes to the actual types in a <code>struct</code> definition.</p>
<h5 id="major-change-adding-a-private-field-when-all-current-fields-are-public"><a class="header" href="#major-change-adding-a-private-field-when-all-current-fields-are-public">Major change: adding a private field when all current fields are public.</a></h5>
<p>This change has the effect of making external struct literals impossible to write, which can break code irreparably.</p>
<h5 id="major-change-adding-a-public-field-when-no-private-field-exists"><a class="header" href="#major-change-adding-a-public-field-when-no-private-field-exists">Major change: adding a public field when no private field exists.</a></h5>
<p>This change retains the ability to use struct literals, but it breaks existing uses of such literals; it likewise breaks exhaustive matches against the struct.</p>
<h5 id="minor-change-adding-or-removing-private-fields-when-at-least-one-already-exists-before-and-after-the-change"><a class="header" href="#minor-change-adding-or-removing-private-fields-when-at-least-one-already-exists-before-and-after-the-change">Minor change: adding or removing private fields when at least one already exists (before and after the change).</a></h5>
<p>No existing code could be relying on struct literals for the struct, nor on exhaustively matching its contents, and client code will likewise be oblivious to the addition of further private fields.</p>
<p>For tuple structs, this is only a minor change if furthermore <em>all</em> fields are currently private. (Tuple structs with mixtures of public and private fields are bad practice in any case.)</p>
<h5 id="minor-change-going-from-a-tuple-struct-with-all-private-fields-with-at-least-one-field-to-a-normal-struct-or-vice-versa"><a class="header" href="#minor-change-going-from-a-tuple-struct-with-all-private-fields-with-at-least-one-field-to-a-normal-struct-or-vice-versa">Minor change: going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa.</a></h5>
<p>This is technically a breaking change:</p>
<pre><code class="language-rust">// in some other module:
pub struct Foo(SomeType);

// in downstream code
let Foo(_) = foo;</code></pre>
<p>Changing <code>Foo</code> to a normal struct can break code that matches on it – but there is never any real reason to match on it in that circumstance, since you cannot extract any fields or learn anything of interest about the struct.</p>
<h4 id="enums"><a class="header" href="#enums">Enums</a></h4>
<p>See “<a href="#signatures-in-type-definitions">Signatures in type definitions</a>” for some general remarks about changes to the actual types in an <code>enum</code> definition.</p>
<h5 id="major-change-adding-new-variants"><a class="header" href="#major-change-adding-new-variants">Major change: adding new variants.</a></h5>
<p>Exhaustiveness checking means that a <code>match</code> that explicitly checks all the variants for an <code>enum</code> will break if a new variant is added. It is not currently possible to defend against this breakage in advance.</p>
<p>A <a href="https://github.com/rust-lang/rfcs/pull/757">postponed RFC</a> discusses a language feature that allows an enum to be marked as “extensible”, which modifies the way that exhaustiveness checking is done and would make it possible to extend the enum without breakage.</p>
<h5 id="major-change-adding-new-fields-to-a-variant"><a class="header" href="#major-change-adding-new-fields-to-a-variant">Major change: adding new fields to a variant.</a></h5>
<p>If the enum is public, so is the full contents of all of its variants. As per the rules for structs, this means it is not allowed to add any new fields (which will automatically be public).</p>
<p>If you wish to allow for this kind of extensibility, consider introducing a new, explicit struct for the variant up front.</p>
<h4 id="traits"><a class="header" href="#traits">Traits</a></h4>
<h5 id="major-change-adding-a-non-defaulted-item"><a class="header" href="#major-change-adding-a-non-defaulted-item">Major change: adding a non-defaulted item.</a></h5>
<p>Adding any item without a default will immediately break all trait implementations.</p>
<p>It’s possible that in the future we will allow some kind of “<a href="#thoughts-on-possible-language-changes-unofficial">sealing</a>” to say that a trait can only be used as a bound, not to provide new implementations; such a trait <em>would</em> allow arbitrary items to be added.</p>
<h5 id="major-change-any-non-trivial-change-to-item-signatures"><a class="header" href="#major-change-any-non-trivial-change-to-item-signatures">Major change: any non-trivial change to item signatures.</a></h5>
<p>Because traits have both implementors and consumers, any change to the signature of e.g. a method will affect at least one of the two parties. So, for example, abstracting a concrete method to use generics instead might work fine for clients of the trait, but would break existing implementors. (Note, as above, the potential for “sealed” traits to alter this dynamic.)</p>
<h5 id="minor-change-adding-a-defaulted-item"><a class="header" href="#minor-change-adding-a-defaulted-item">Minor change: adding a defaulted item.</a></h5>
<p>Adding a defaulted item is technically a breaking change:</p>
<pre><code class="language-rust">trait Trait1 {}
trait Trait2 {
    fn foo(&amp;self);
}

fn use_both&lt;T: Trait1 + Trait2&gt;(t: &amp;T) {
    t.foo()
}</code></pre>
<p>If a <code>foo</code> method is added to <code>Trait1</code>, even with a default, it would cause a dispatch ambiguity in <code>use_both</code>, since the call to <code>foo</code> could be referring to either trait.</p>
<p>(Note, however, that existing <em>implementations</em> of the trait are fine.)</p>
<p>According to the basic principles of this RFC, such a change is minor: it is always possible to annotate the call <code>t.foo()</code> to be more explicit <em>in advance</em> using UFCS: <code>Trait2::foo(t)</code>. This kind of annotation could be done automatically for code in dependencies (see <a href="#elaborated-source">Elaborated source</a>). And it would also be possible to mitigate this problem by allowing <a href="#trait-item-renaming">method renaming on trait import</a>.</p>
<p>While the scenario of adding a defaulted method to a trait may seem somewhat obscure, the exact same hazards arise with <em>implementing existing traits</em> (see below), which is clearly vital to allow; we apply a similar policy to both.</p>
<p>All that said, it is incumbent on library authors to ensure that such “minor” changes are in fact minor in practice: if a conflict like <code>t.foo()</code> is likely to arise at all often in downstream code, it would be advisable to explore a different choice of names. More guidelines for the standard library are given later on.</p>
<p>There are two circumstances when adding a defaulted item is still a major change:</p>
<ul>
<li>The new item would change the trait from object safe to non-object safe.</li>
<li>The trait has a defaulted associated type and the item being added is a defaulted function/method. In this case, existing impls that override the associated type will break, since the function/method default will not apply. (See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md#defaults">the associated item RFC</a>).</li>
<li>Adding a default to an existing associated type is likewise a major change if the trait has defaulted methods, since it will invalidate use of those defaults for the methods in existing trait impls.</li>
</ul>
<h5 id="minor-change-adding-a-defaulted-type-parameter"><a class="header" href="#minor-change-adding-a-defaulted-type-parameter">Minor change: adding a defaulted type parameter.</a></h5>
<p>As with “<a href="#signatures-in-type-definitions">Signatures in type definitions</a>”, traits are permitted to add new type parameters as long as defaults are provided (which is backwards compatible).</p>
<h4 id="trait-implementations"><a class="header" href="#trait-implementations">Trait implementations</a></h4>
<h5 id="major-change-implementing-any-fundamental-trait"><a class="header" href="#major-change-implementing-any-fundamental-trait">Major change: implementing any “fundamental” trait.</a></h5>
<p>A <a href="https://github.com/rust-lang/rfcs/pull/1023">recent RFC</a> introduced the idea of “fundamental” traits which are so basic that <em>not</em> implementing such a trait right off the bat is considered a promise that you will <em>never</em> implement the trait. The <code>Sized</code> and <code>Fn</code> traits are examples.</p>
<p>The coherence rules take advantage of fundamental traits in such a way that <em>adding a new implementation of a fundamental trait to an existing type can cause downstream breakage</em>. Thus, such impls are considered major changes.</p>
<h5 id="minor-change-implementing-any-non-fundamental-trait"><a class="header" href="#minor-change-implementing-any-non-fundamental-trait">Minor change: implementing any non-fundamental trait.</a></h5>
<p>Unfortunately, implementing any existing trait can cause breakage:</p>
<pre><code class="language-rust">// Crate A
    pub trait Trait1 {
        fn foo(&amp;self);
    }

    pub struct Foo; // does not implement Trait1

// Crate B
    use crateA::Trait1;

    trait Trait2 {
        fn foo(&amp;self);
    }

    impl Trait2 for crateA::Foo { .. }

    fn use_foo(f: &amp;crateA::Foo) {
        f.foo()
    }</code></pre>
<p>If crate A adds an implementation of <code>Trait1</code> for <code>Foo</code>, the call to <code>f.foo()</code> in crate B will yield a dispatch ambiguity (much like the one we saw for defaulted items). Thus <em>technically implementing any existing trait is a breaking change!</em> Completely prohibiting such a change is clearly a non-starter.</p>
<p>However, as before, this kind of breakage is considered “minor” by the principles of this RFC (see “Adding a defaulted item” above).</p>
<h4 id="inherent-implementations"><a class="header" href="#inherent-implementations">Inherent implementations</a></h4>
<h5 id="minor-change-adding-any-inherent-items"><a class="header" href="#minor-change-adding-any-inherent-items">Minor change: adding any inherent items.</a></h5>
<p>Adding an inherent item cannot lead to dispatch ambiguity, because inherent items trump any trait items with the same name.</p>
<p>However, introducing an inherent item <em>can</em> lead to breakage if the signature of the item does not match that of an in scope, implemented trait:</p>
<pre><code class="language-rust">// Crate A
    pub struct Foo;

// Crate B
    trait Trait {
        fn foo(&amp;self);
    }

    impl Trait for crateA::Foo { .. }

    fn use_foo(f: &amp;crateA::Foo) {
        f.foo()
   }</code></pre>
<p>If crate A adds a method:</p>
<pre><code class="language-rust">impl Foo {
    fn foo(&amp;self, x: u8) { ... }
}</code></pre>
<p>then crate B would no longer compile, since dispatch would prefer the inherent impl, which has the wrong type.</p>
<p>Once more, this is considered a minor change, since UFCS can disambiguate (see “Adding a defaulted item” above).</p>
<p>It’s worth noting, however, that if the signatures <em>did</em> happen to match then the change would no longer cause a compilation error, but might silently change runtime behavior. The case where the same method for the same type has meaningfully different behavior is considered unlikely enough that the RFC is willing to permit it to be labeled as a minor change – and otherwise, inherent methods could never be added after the fact.</p>
<h4 id="other-items"><a class="header" href="#other-items">Other items</a></h4>
<p>Most remaining items do not have any particularly unique items:</p>
<ul>
<li>For type aliases, see “<a href="#signatures-in-type-definitions">Signatures in type definitions</a>”.</li>
<li>For free functions, see “<a href="#signatures-in-functions">Signatures in functions</a>”.</li>
</ul>
<h3 id="cross-cutting-concerns"><a class="header" href="#cross-cutting-concerns">Cross-cutting concerns</a></h3>
<h4 id="behavioral-changes"><a class="header" href="#behavioral-changes">Behavioral changes</a></h4>
<p>This RFC is largely focused on API changes which may, in particular, cause downstream code to stop compiling. But in some sense it is even more pernicious to make a change that allows downstream code to continue compiling, but causes its runtime behavior to break.</p>
<p>This RFC does not attempt to provide a comprehensive policy on behavioral changes, which would be extremely difficult. In general, APIs are expected to provide explicit contracts for their behavior via documentation, and behavior that is not part of this contract is permitted to change in minor revisions. (Remember: this RFC is about setting a <em>minimum</em> bar for when major version bumps are required.)</p>
<p>This policy will likely require some revision over time, to become more explicit and perhaps lay out some best practices.</p>
<h4 id="signatures-in-type-definitions"><a class="header" href="#signatures-in-type-definitions">Signatures in type definitions</a></h4>
<h5 id="major-change-tightening-bounds"><a class="header" href="#major-change-tightening-bounds">Major change: tightening bounds.</a></h5>
<p>Adding new constraints on existing type parameters is a breaking change, since existing uses of the type definition can break. So the following is a major change:</p>
<pre><code class="language-rust">// MAJOR CHANGE

// Before
struct Foo&lt;A&gt; { .. }

// After
struct Foo&lt;A: Clone&gt; { .. }</code></pre>
<h5 id="minor-change-loosening-bounds"><a class="header" href="#minor-change-loosening-bounds">Minor change: loosening bounds.</a></h5>
<p>Loosening bounds, on the other hand, cannot break code because when you reference <code>Foo&lt;A&gt;</code>, you <em>do not learn anything about the bounds on <code>A</code></em>. (This is why you have to repeat any relevant bounds in <code>impl</code> blocks for <code>Foo</code>, for example.) So the following is a minor change:</p>
<pre><code class="language-rust">// MINOR CHANGE

// Before
struct Foo&lt;A: Clone&gt; { .. }

// After
struct Foo&lt;A&gt; { .. }</code></pre>
<h5 id="minor-change-adding-defaulted-type-parameters"><a class="header" href="#minor-change-adding-defaulted-type-parameters">Minor change: adding defaulted type parameters.</a></h5>
<p>All existing references to a type/trait definition continue to compile and work correctly after a new defaulted type parameter is added. So the following is a minor change:</p>
<pre><code class="language-rust">// MINOR CHANGE

// Before
struct Foo { .. }

// After
struct Foo&lt;A = u8&gt; { .. }</code></pre>
<h5 id="minor-change-generalizing-to-generics"><a class="header" href="#minor-change-generalizing-to-generics">Minor change: generalizing to generics.</a></h5>
<p>A struct or enum field can change from a concrete type to a generic type parameter, provided that the change results in an identical type for all existing use cases. For example, the following change is permitted:</p>
<pre><code class="language-rust">// MINOR CHANGE

// Before
struct Foo(pub u8);

// After
struct Foo&lt;T = u8&gt;(pub T);</code></pre>
<p>because existing uses of <code>Foo</code> are shorthand for <code>Foo&lt;u8&gt;</code> which yields the identical field type. (Note: this is not actually true today, since <a href="https://github.com/rust-lang/rfcs/pull/213">default type parameters</a> are not fully implemented. But this is the intended semantics.)</p>
<p>On the other hand, the following is not permitted:</p>
<pre><code class="language-rust">// MAJOR CHANGE

// Before
struct Foo&lt;T = u8&gt;(pub T, pub u8);

// After
struct Foo&lt;T = u8&gt;(pub T, pub T);</code></pre>
<p>since there may be existing uses of <code>Foo</code> with a non-default type parameter which would break as a result of the change.</p>
<p>It’s also permitted to change from a generic type to a more-generic one in a minor revision:</p>
<pre><code class="language-rust">// MINOR CHANGE

// Before
struct Foo&lt;T&gt;(pub T, pub T);

// After
struct Foo&lt;T, U = T&gt;(pub T, pub U);</code></pre>
<p>since, again, all existing uses of the type <code>Foo&lt;T&gt;</code> will yield the same field types as before.</p>
<h4 id="signatures-in-functions"><a class="header" href="#signatures-in-functions">Signatures in functions</a></h4>
<p>All of the changes mentioned below are considered major changes in the context of trait methods, since they can break implementors.</p>
<h5 id="major-change-addingremoving-arguments"><a class="header" href="#major-change-addingremoving-arguments">Major change: adding/removing arguments.</a></h5>
<p>At the moment, Rust does not provide defaulted arguments, so any change in arity is a breaking change.</p>
<h5 id="minor-change-introducing-a-new-type-parameter"><a class="header" href="#minor-change-introducing-a-new-type-parameter">Minor change: introducing a new type parameter.</a></h5>
<p>Technically, adding a (non-defaulted) type parameter can break code:</p>
<pre><code class="language-rust">// MINOR CHANGE (but causes breakage)

// Before
fn foo&lt;T&gt;(...) { ... }

// After
fn foo&lt;T, U&gt;(...) { ... }</code></pre>
<p>will break any calls like <code>foo::&lt;u8&gt;</code>. However, such explicit calls are rare enough (and can usually be written in other ways) that this breakage is considered minor. (However, one should take into account how likely it is that the function in question is being called with explicit type arguments).  This RFC also suggests adding a <code>...</code> notation to explicit parameter lists to keep them open-ended (see suggested language changes).</p>
<p>Such changes are an important ingredient of abstracting to use generics, as described next.</p>
<h5 id="minor-change-generalizing-to-generics-1"><a class="header" href="#minor-change-generalizing-to-generics-1">Minor change: generalizing to generics.</a></h5>
<p>The type of an argument to a function, or its return value, can be <em>generalized</em> to use generics, including by introducing a new type parameter (as long as it can be instantiated to the original type). For example, the following change is allowed:</p>
<pre><code class="language-rust">// MINOR CHANGE

// Before
fn foo(x: u8) -&gt; u8;
fn bar&lt;T: Iterator&lt;Item = u8&gt;&gt;(t: T);

// After
fn foo&lt;T: Add&gt;(x: T) -&gt; T;
fn bar&lt;T: IntoIterator&lt;Item = u8&gt;&gt;(t: T);</code></pre>
<p>because all existing uses are instantiations of the new signature. On the other hand, the following isn’t allowed in a minor revision:</p>
<pre><code class="language-rust">// MAJOR CHANGE

// Before
fn foo(x: Vec&lt;u8&gt;);

// After
fn foo&lt;T: Copy + IntoIterator&lt;Item = u8&gt;&gt;(x: T);</code></pre>
<p>because the generics include a constraint not satisfied by the original type.</p>
<p>Introducing generics in this way can potentially create type inference failures, but these are considered acceptable per the principles of the RFC: they only require local annotations that could have been inserted in advance.</p>
<p>Perhaps somewhat surprisingly, generalization applies to trait objects as well, given that every trait implements itself:</p>
<pre><code class="language-rust">// MINOR CHANGE

// Before
fn foo(t: &amp;Trait);

// After
fn foo&lt;T: Trait + ?Sized&gt;(t: &amp;T);</code></pre>
<p>(The use of <code>?Sized</code> is essential; otherwise you couldn’t recover the original signature).</p>
<h4 id="lints"><a class="header" href="#lints">Lints</a></h4>
<h5 id="minor-change-introducing-new-lint-warningserrors"><a class="header" href="#minor-change-introducing-new-lint-warningserrors">Minor change: introducing new lint warnings/errors</a></h5>
<p>Lints are considered advisory, and changes that cause downstream code to receive additional lint warnings/errors are still considered “minor” changes.</p>
<p>Making this work well in practice will likely require some infrastructure work along the lines of <a href="https://github.com/rust-lang/rfcs/issues/1029">this RFC issue</a></p>
<h3 id="mitigation-for-minor-changes"><a class="header" href="#mitigation-for-minor-changes">Mitigation for minor changes</a></h3>
<h4 id="the-crater-tool"><a class="header" href="#the-crater-tool">The Crater tool</a></h4>
<p>@brson has been hard at work on a tool called “Crater” which can be used to exercise changes on the entire crates.io ecosystem, looking for regressions. This tool will be indispensable when weighing the costs of a minor change that might cause some breakage – we can actually gauge what the breakage would look like in practice.</p>
<p>While this would, of course, miss code not available publicly, the hope is that code on crates.io is a broadly representative sample, good enough to turn up problems.</p>
<p>Any breaking, but minor change to the standard library must be evaluated through Crater before being committed.</p>
<h4 id="nightlies"><a class="header" href="#nightlies">Nightlies</a></h4>
<p>One line of defense against a “minor” change causing significant breakage is the nightly release channel: we can get feedback about breakage long before it makes even into a beta release. And of course the beta cycle itself provides another line of defense.</p>
<h4 id="elaborated-source"><a class="header" href="#elaborated-source">Elaborated source</a></h4>
<p>When compiling upstream dependencies, it is possible to generate an “elaborated” version of the source code where all dispatch is resolved to explicit UFCS form, all types are annotated, and all glob imports are replaced by explicit imports.</p>
<p>This fully-elaborated form is almost entirely immune to breakage due to any of the “minor changes” listed above.</p>
<p>You could imagine Cargo storing this elaborated form for dependencies upon compilation. That would in turn make it easy to update Rust, or some subset of dependencies, without breaking any upstream code (even in minor ways). You would be left only with very small, local changes to make to the code you own.</p>
<p>While this RFC does not propose any such tooling change right now, the point is mainly that there are a lot of options if minor changes turn out to cause breakage more often than anticipated.</p>
<h4 id="trait-item-renaming"><a class="header" href="#trait-item-renaming">Trait item renaming</a></h4>
<p>One very useful mechanism would be the ability to import a trait while renaming some of its items, e.g. <code>use some_mod::SomeTrait with {foo_method as bar}</code>. In particular, when methods happen to conflict across traits defined in separate crates, a user of the two traits could rename one of the methods out of the way.</p>
<h3 id="thoughts-on-possible-language-changes-unofficial"><a class="header" href="#thoughts-on-possible-language-changes-unofficial">Thoughts on possible language changes (unofficial)</a></h3>
<p>The following is just a quick sketch of some focused language changes that would help our API evolution story.</p>
<p><strong>Glob semantics</strong></p>
<p>As already mentioned, the fact that glob imports currently allow <em>no</em> shadowing is deeply problematic: in a technical sense, it means that the addition of <em>any</em> public item can break downstream code arbitrarily.</p>
<p>It would be much better for API evolution (and for ergonomics and intuition) if explicitly-defined items trump glob imports. But this is left to a future RFC.</p>
<p><strong>Globs with fine-grained control</strong></p>
<p>Another useful tool for working with globs would be the ability to <em>exclude</em> certain items from a glob import, e.g. something like:</p>
<pre><code class="language-rust">use some_module::{* without Foo};</code></pre>
<p>This is especially useful for the case where multiple modules being glob imported happen to export items with the same name.</p>
<p>Another possibility would be to not make it an error for two glob imports to bring the same name into scope, but to generate the error only at the point that the imported name was actually <em>used</em>. Then collisions could be resolved simply by adding a single explicit, shadowing import.</p>
<p><strong>Default type parameters</strong></p>
<p>Some of the minor changes for moving to more generic code depends on an interplay between defaulted type parameters and type inference, which has been <a href="https://github.com/rust-lang/rfcs/pull/213">accepted as an RFC</a> but not yet implemented.</p>
<p><strong>“Extensible” enums</strong></p>
<p>There is already <a href="https://github.com/rust-lang/rfcs/pull/757">an RFC</a> for an <code>enum</code> annotation that would make it possible to add variants without ever breaking downstream code.</p>
<p><strong>Sealed traits</strong></p>
<p>The ability to annotate a trait with some “sealed” marker, saying that no external implementations are allowed, would be useful in certain cases where a crate wishes to define a closed set of types that implements a particular interface. Such an attribute would make it possible to evolve the interface without a major version bump (since no downstream implementors can exist).</p>
<p><strong>Defaulted parameters</strong></p>
<p>Also known as “optional arguments” – an <a href="https://github.com/rust-lang/rfcs/issues/323">oft-requested</a> feature. Allowing arguments to a function to be optional makes it possible to add new arguments after the fact without a major version bump.</p>
<p><strong>Open-ended explicit type parameters</strong></p>
<p>One hazard is that with today’s explicit type parameter syntax, you must always specify <em>all</em> type parameters: <code>foo::&lt;T, U&gt;(x, y)</code>. That means that adding a new type parameter to <code>foo</code> can break code, even if a default is provided.</p>
<p>This could be easily addressed by adding a notation like <code>...</code> to leave additional parameters unspecified: <code>foo::&lt;T, ...&gt;(x, y)</code>.</p>
<h3 id="amendment-misuse-of-accessible"><a class="header" href="#amendment-misuse-of-accessible">[Amendment] Misuse of <code>accessible(..)</code></a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/2523-cfg-path-version.md">RFC 2523</a> introduces <code>#[cfg(accessible($path)]</code>. Based on the accessibility of a to-the-current-crate external <code>$path</code>, the flag allows conditional compilation. When combined with <code>#[cfg(feature = "unstable")]</code>, this has certain breakage risks. Such breakage due to misuse, as outlined in the RFC, is considered acceptable and not covered by our stability promises. Please see the RFC for more details.</p>
<h2 id="drawbacks-and-alternatives"><a class="header" href="#drawbacks-and-alternatives">Drawbacks and Alternatives</a></h2>
<p>The main drawback to the approach laid out here is that it makes the stability and semver guarantees a bit fuzzier: the promise is not that code will never break, full stop, but rather that minor release breakage is of an extremely limited form, for which there are a variety of mitigation strategies. This approach tries to strike a middle ground between a very hard line for stability (which, for Rust, would rule out many forms of extension) and willy-nilly breakage: it’s an explicit, but pragmatic policy.</p>
<p>An alternative would be to take a harder line and find some other way to allow API evolution. Supposing that we resolved the issues around glob imports, the main problems with breakage have to do with adding new inherent methods or trait implementations – both of which are vital forms of evolution. It might be possible, in the standard library case, to provide some kind of version-based opt in to this evolution: a crate could opt in to breaking changes for a particular version of Rust, which might in turn be provided only through some <code>cfg</code>-like mechanism.</p>
<p>Note that these strategies are not mutually exclusive. Rust’s development processes involved a very steady, strong stream of breakage, and while we need to be very serious about stabilization, it is possible to take an iterative approach. The changes considered “major” by this RFC already move the bar <em>very significantly</em> from what was permitted pre-1.0. It may turn out that even the minor forms of breakage permitted here are, in the long run, too much to tolerate; at that point we could revise the policies here and explore some opt-in scheme, for example.</p>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<h3 id="behavioral-issues"><a class="header" href="#behavioral-issues">Behavioral issues</a></h3>
<ul>
<li>
<p>Is it permitted to change a contract from “abort” to “panic”? What about from “panic” to “return an <code>Err</code>”?</p>
</li>
<li>
<p>Should we try to lay out more specific guidance for behavioral changes at this point?</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="1102-rename-connect-to-join.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="1119-result-expect.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="1102-rename-connect-to-join.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="1119-result-expect.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
