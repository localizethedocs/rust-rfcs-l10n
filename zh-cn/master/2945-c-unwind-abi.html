<!DOCTYPE HTML>
<html lang="zh_CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2945-c-unwind-abi - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-b61d75f0.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Feature Name: <code>"C-unwind" ABI</code></li>
<li>Start Date: 2019-04-03</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2945">rust-lang/rfcs#2945</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/74990">rust-lang/rust#74990</a></li>
<li>Project group: <a href="https://github.com/rust-lang/project-ffi-unwind">FFI-unwind</a></li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>We introduce a new ABI string, <code>"C-unwind"</code>, to enable unwinding from other languages (such as C++) into Rust frames and from Rust into other languages.</p>
<p>Additionally, we define the behavior for a limited number of previously-undefined cases when an unwind operation reaches a Rust function boundary with a non-<code>"Rust"</code>, non-<code>"C-unwind"</code> ABI.</p>
<p>As part of this specification, we introduce the term <a href="#plain-old-frames">“Plain Old Frame” (POF)</a>. These are frames that have no pending destructors and can be trivially deallocated.</p>
<p>This RFC does not define the behavior of <code>catch_unwind</code> in a Rust frame being unwound by a foreign exception. This is something the <a href="https://github.com/rust-lang/project-ffi-unwind">project group</a> would like to specify in a future RFC; as such, it is “TBD” (see <a href="#unresolved-questions">“Unresolved questions”</a>).</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>There are some Rust projects that need cross-language unwinding to provide their desired functionality. One major example is Wasm interpreters, including the Lucet and Wasmer projects.</p>
<p>There are also existing Rust crates (notably, wrappers around the <code>libpng</code> and <code>libjpeg</code> C libraries) that <code>panic</code> across C frames. The safety of such unwinding relies on compatibility between Rust’s unwinding mechanism and the native exception mechanisms in GCC, LLVM, and MSVC. Despite using a compatible unwinding mechanism, the current <code>rustc</code> implementation assumes that <code>extern "C"</code> functions cannot unwind, which permits LLVM to optimize with the assumption that such unwinding constitutes undefined behavior.</p>
<p>The desire for this feature has been previously discussed on other RFCs, including <a href="https://github.com/rust-lang/rfcs/pull/2699">#2699</a> and <a href="https://github.com/rust-lang/rfcs/pull/2753">#2753</a>.</p>
<h3 id="key-design-goals"><a class="header" href="#key-design-goals">Key design goals</a></h3>
<p>As explained in <a href="https://blog.rust-lang.org/inside-rust/2020/02/27/ffi-unwind-design-meeting.html#requirements-for-any-cross-language-unwinding-specification">this Inside Rust blog post</a>, we have several requirements for any cross-language unwinding design.</p>
<p>The <a href="#analysis-of-design-goals">“Analysis of key design goals”</a> section analyzes how well the current design satisfies these constraints.</p>
<ul>
<li><strong>Changing from <code>panic=unwind</code> to <code>panic=abort</code> cannot cause undefined behavior:</strong> We wish to ensure that changing from <code>panic=unwind</code> to <code>panic=abort</code> never creates undefined behavior (relate to <code>panic=unwind</code>), even if one is relying on a library that triggers a panic or a foreign exception.</li>
<li><strong>Optimization with <code>panic=abort</code>:</strong> when using <code>panic=abort</code>, we wish to enable as many code-size optimizations as possible. This means that we shouldn’t have to generate unwinding tables or other such constructs, at least in most cases.</li>
<li><strong>Preserve the ability to change how Rust panics are propagated when using the Rust ABI:</strong> Currently, Rust panics are propagated using the native unwinding mechanism, but we would like to keep the freedom to change that.</li>
<li><strong>Enable Rust panics to traverse through foreign frames:</strong> Several projects would like the ability to have Rust panics propagate through foreign frames.  Those frames may or may not register destructors of their own with the native unwinding mechanism.</li>
<li><strong>Enable foreign exceptions to propagate through Rust frames:</strong> Similarly, we would like to make it possible for C++ code (or other languages) to raise exceptions that will propagate through Rust frames “as if” they were Rust panics (i.e., running destructors or, in the case of <code>unwind=abort</code>, aborting the program).</li>
<li><strong>Enable error handling with <code>longjmp</code>:</strong> As mentioned above, some existing Rust libraries rely on the ability to <code>longjmp</code> across Rust frames to interoperate with Ruby, Lua, and other C APIs. The behavior of <code>longjmp</code> traversing Rust frames is not specified or guaranteed to be safe; in the current implementation of <code>rustc</code>, however, it <a href="https://github.com/rust-lang/rust/pull/48572">is safe</a>. On Windows, <code>longjmp</code> is implemented as a form of unwinding called <a href="#forced-unwinding">“forced unwinding”</a>, so any specification of the behavior of forced unwinding across FFI boundaries should be forward-compatible with a <a href="#unresolved-questions">future RFC</a> that will provide a well-defined way to interoperate with longjmp-based APIs.</li>
<li><strong>Do not change the ABI of functions in the <code>libc</code> crate:</strong> Some <code>libc</code> functions may invoke <code>pthread_exit</code>, which uses <a href="#forced-unwinding">a form of unwinding</a> in the GNU libc implementation. Such functions must be safe to use with the existing <code>"C"</code> ABI, because changing the types of these functions would be a breaking change.</li>
</ul>
<h2 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h2>
<p>When declaring an external function that may unwind, such as an entrypoint to a C++ library, use <code>extern "C-unwind"</code> instead of <code>extern "C"</code>:</p>
<pre><code>extern "C-unwind" {
  fn may_throw();
}
</code></pre>
<p>Rust functions that call a possibly-unwinding external function should either use the default Rust ABI (which can be made explicit with <code>extern "Rust"</code>) or the <code>"C-unwind"</code> ABI:</p>
<pre><code>extern "C-unwind" fn can_unwind() {
  may_throw();
}
</code></pre>
<p>Using the <code>"C-unwind"</code> ABI to “sandwich” Rust frames between frames from another language (such as C++) allows an exception initiated in a callee frame in the other language to traverse the intermediate Rust frames before being caught in the caller frames. I.e., a C++ exception may be thrown, cross into Rust via an <code>extern "C-unwind"</code> function declaration, safely unwind the Rust frames, and cross back into C++ (where it may be caught) via a Rust <code>"C-unwind"</code> function definition.</p>
<p>Conversely, languages that support the native unwinding mechanism, such as C++, may be “sandwiched” between Rust frames, so that Rust <code>panic</code>s may safely unwind the C++ frames, if the Rust code declares both the C++ entrypoint and the Rust entrypoint using <code>"C-unwind"</code>.</p>
<h3 id="other-unwind-abi-strings"><a class="header" href="#other-unwind-abi-strings">Other <code>unwind</code> ABI strings</a></h3>
<p>Because the <code>C</code> ABI is not appropriate for all use cases, we also introduce these <code>unwind</code> ABI strings, which will only differ from their non-<code>unwind</code> variants by permitting unwinding, with the same semantics as <code>"C-unwind"</code>:</p>
<ul>
<li><code>"system-unwind"</code> - available on all platforms</li>
<li><code>"stdcall-unwind"</code> and <code>"thiscall-unwind"</code> - available only on platforms where <code>"stdcall"</code> and <code>"thiscall"</code> are supported</li>
</ul>
<p>More <code>unwind</code> variants of existing ABI strings may be introduced, with the same semantics, without an additional RFC.</p>
<h3 id="plain-old-frames"><a class="header" href="#plain-old-frames">“Plain Old Frames”</a></h3>
<p>A “POF”, or “Plain Old Frame”, is defined as a frame that can be trivially deallocated: returning from or unwinding a POF cannot cause any observable effects. This means that POFs do not contain any pending destructors (live <code>Drop</code> objects) or <code>catch_unwind</code> calls.</p>
<p>The terminology is intentionally akin to <a href="https://en.cppreference.com/w/cpp/named_req/PODType">C++’s “Plain Old Data” types</a>, which are types that, among other requirements, are trivially destructible (their destructors do not cause any observable effects, and may be elided as an optimization).</p>
<p>Rust frames that do contain pending destructors or <code>catch_unwind</code> calls are called non-POFs.</p>
<p>Note that a non-POF may <em>become</em> a POF during execution of the corresponding function, for instance if all <code>Drop</code> objects are moved out of scope, or if its only <code>catch_unwind</code> call is in a code path that will not be executed. The next section provides an example.</p>
<h3 id="forced-unwinding"><a class="header" href="#forced-unwinding">Forced unwinding</a></h3>
<p>This is a special kind of unwinding used to implement <code>longjmp</code> on Windows and <code>pthread_exit</code> in <code>glibc</code>. A brief explanation is provided in <a href="https://blog.rust-lang.org/inside-rust/2020/02/27/ffi-unwind-design-meeting.html#forced-unwinding">this Inside Rust blog post</a>. This RFC distinguishes forced unwinding from other types of foreign unwinding.</p>
<p>Since language features and library functions implemented using forced unwinding on some platforms use other mechanisms on other platforms, Rust code cannot rely on forced unwinding to invoke destructors (calling <code>drop</code> on <code>Drop</code> types). In other words, a forced unwind operation on one platform will simply deallocate Rust frames without true unwinding on other platforms.</p>
<p>This RFC specifies that, regardless of the platform or the ABI string (<code>"C"</code> or <code>"C-unwind"</code>), any platform features that may rely on forced unwinding will always be considered undefined behavior if they cross non-<a href="#plain-old-frames">POFs</a>. Crossing only POFs is necessary but not sufficient, however, to make forced unwinding safe, and for now we do not specify any safe form of forced unwinding; we will specify this in <a href="#unresolved-questions">a future RFC</a>.</p>
<h3 id="changes-to-the-behavior-of-existing-abi-strings"><a class="header" href="#changes-to-the-behavior-of-existing-abi-strings">Changes to the behavior of existing ABI strings</a></h3>
<p>Prior to this RFC, any unwinding operation that crossed an <code>extern "C"</code> boundary, either from a <code>panic!</code> “escaping” from a Rust function defined with <code>extern "C"</code> or by entering Rust from another language via an entrypoint declared with <code>extern "C"</code>, caused undefined behavior.</p>
<p>This RFC retains most of that undefined behavior, with one exception: with the <code>panic=unwind</code> runtime, <code>panic!</code> will cause an <code>abort</code> if it would otherwise “escape” from a function defined with <code>extern "C"</code>.</p>
<p>This change will be applied to all ABI strings other than <code>"Rust"</code>, such as <code>"system"</code>.</p>
<h3 id="interaction-with-panicabort"><a class="header" href="#interaction-with-panicabort">Interaction with <code>panic=abort</code></a></h3>
<p>If a non-forced foreign unwind would enter a Rust frame via an <code>extern "C-unwind"</code> ABI boundary, but the Rust code is compiled with <code>panic=abort</code>, the unwind will be caught and the process aborted.</p>
<p>Conversely, non-forced unwinding from another language into Rust through an FFI entrypoint declared with <code>extern "C"</code> is always undefined behavior, and is not guaranteed to cause the program to abort under <code>panic=abort</code>. As noted <a href="#abi-boundaries-and-forced-unwinding">below</a>, however, when compiling in debug mode, the compiler may be able to guarantee an abort in this case.</p>
<p><code>panic=abort</code> will have no impact on the behavior of forced unwinding.</p>
<h2 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h2>
<h3 id="abi-boundaries-and-unforced-unwinding"><a class="header" href="#abi-boundaries-and-unforced-unwinding">ABI boundaries and unforced unwinding</a></h3>
<p>This table shows the behavior of an unwinding operation reaching each type of ABI boundary (function declaration or definition). “UB” stands for undefined behavior. <code>"C"</code>-like ABIs are <code>"C"</code> itself but also related ABIs such as <code>"system"</code>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>panic runtime</th><th>ABI</th><th><code>panic</code>-unwind</th><th>Unforced foreign unwind</th></tr>
</thead>
<tbody>
<tr><td><code>panic=unwind</code></td><td><code>"C-unwind"</code></td><td>unwind</td><td>unwind</td></tr>
<tr><td><code>panic=unwind</code></td><td><code>"C"</code>-like</td><td>abort</td><td>UB</td></tr>
<tr><td><code>panic=abort</code></td><td><code>"C-unwind"</code></td><td><code>panic!</code> aborts</td><td>abort</td></tr>
<tr><td><code>panic=abort</code></td><td><code>"C"</code>-like</td><td><code>panic!</code> aborts (no unwinding occurs)</td><td>UB</td></tr>
</tbody>
</table>
</div>
<p>In debug mode, the compiler could insert code to catch unwind attempts at <code>extern "C"</code> boundaries and <code>abort</code>; this would provide a safe way to discover (and fix) instances of this form of UB.</p>
<h3 id="frame-deallocation-and-forced-unwinding"><a class="header" href="#frame-deallocation-and-forced-unwinding">Frame deallocation and forced unwinding</a></h3>
<p>The interaction of Rust frames with C functions that deallocate frames (i.e. functions that may use forced unwinding on specific platforms) is independent of the panic runtime, ABI, or platform.</p>
<ul>
<li><strong>When deallocating Rust non-POFs:</strong> this is explicitly undefined behavior.</li>
<li><strong>When deallocating Rust <a href="#plain-old-frames">POFs</a>:</strong> for now, this is not specified, and must be considered undefined behavior. However, we do plan to specify a safe way to deallocate POFs with <code>longjmp</code> or <code>pthread_exit</code> in <a href="#unresolved-questions">a future RFC</a>.</li>
</ul>
<h3 id="additional-limitations"><a class="header" href="#additional-limitations">Additional limitations</a></h3>
<p>In order to limit the scope of this RFC, the following limitations are imposed:</p>
<ul>
<li>No subtype relationship is defined between functions or function pointers using different ABIs.</li>
<li>Coercions are not defined between <code>"C"</code> and <code>"C-unwind"</code>.</li>
<li>As noted in the <a href="#summary">summary</a>, if a Rust frame containing a pending <code>catch_unwind</code> call is unwound by a foreign exception, the behavior is undefined for now.</li>
<li>The behavior of asynchronous exceptions, such as SEH on Windows, interrupting Rust code is not defined.</li>
</ul>
<p>These may be addressed in <a href="#future-possibilities">future RFCs</a>.</p>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>Forced unwinding is treated as universally unsafe across <a href="#plain-old-frames">non-POFs</a>, but on some platforms it could theoretically be well-defined. As noted <a href="forced-unwind">above</a>, however, this would make the UB inconsistent across platforms, which is not desirable.</p>
<p>This design imposes some burden on existing codebases (mentioned <a href="#motivation">above</a>) to change their <code>extern</code> annotations to use the new ABI.</p>
<p>Having separate ABIs for <code>"C"</code> and <code>"C-unwind"</code> may make interface design more difficult, especially since this RFC <a href="#unresolved-questions">postpones</a> introducing coercions between function types using different ABIs. Conversely, a single ABI that “just works” with C++ (or any other language that may throw exceptions) would be simpler to learn and use than two separate ABIs.</p>
<p>This RFC preserves an existing inconsistency between the <code>"Rust"</code> ABI (which is the default for all functions without an explicit ABI string) and the other existing ABIs: no ABI string without the word <code>unwind</code> will permit unwinding, except the <code>"Rust"</code> ABI, which will permit unwinding, but only when compiled with <code>panic=unwind</code>. Making other ABIs consistent with the <code>"Rust"</code> ABI by permitting them to unwind by default (and possibly either introducing a new <code>"C-unwind"</code> ABI or an annotation akin to C++’s <code>noexcept</code> to explicitly prohibit unwinding) would also be a safer default, since it would prevent undefined behavior when interfacing with external libraries that may throw exceptions.</p>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<h3 id="other-proposals-discussed-with-the-lang-team"><a class="header" href="#other-proposals-discussed-with-the-lang-team">Other proposals discussed with the lang team</a></h3>
<p>Two other potential designs have been discussed in depth; they are explained in <a href="https://blog.rust-lang.org/inside-rust/2020/02/27/ffi-unwind-design-meeting.html#three-specific-proposals">this Inside Rust blog post</a>. The design in this RFC is referred to as “option 2” in that post.</p>
<p>“Option 1” in that blog post only differs from the current proposal in the behavior of a forced unwind across a <code>"C-unwind"</code> boundary under <code>panic=abort</code>. Under the current proposal, this type of unwind is permitted, allowing <code>longjmp</code> and <code>pthread_exit</code> to behave “normally” with both the <code>"C"</code> and the <code>"C-unwind"</code> ABI across all platforms regardless of panic runtime. If <a href="#plain-old-frames">non-POFs</a> are unwound, this results in undefined behavior. Under “option 1”, however, all foreign unwinding, forced or unforced, is caught at <code>"C-unwind"</code> boundaries under <code>panic=abort</code>, and the process is aborted. This gives <code>longjmp</code> and <code>pthread_exit</code> surprising behavior on some platforms, but avoids that cause of undefined behavior in the current proposal.</p>
<p>The other proposal in the blog post, “option 3”, is dramatically different. In that proposal, foreign exceptions are permitted to cross <code>extern "C"</code> boundaries, and no new ABI is introduced.</p>
<h3 id="reasons-for-the-current-proposal"><a class="header" href="#reasons-for-the-current-proposal">Reasons for the current proposal</a></h3>
<p>Our reasons for preferring the current proposal are:</p>
<ul>
<li>Introducing a new ABI makes reliance on cross-language exception handling more explicit.</li>
<li><code>panic=abort</code> can be safely used with <code>extern "C-unwind"</code> (there is no undefined behavior except with improperly used forced unwinding), but <code>extern "C"</code> has more optimization potential (eliding landing pads). Having two ABIs puts this choice in the hands of users.
<ul>
<li>The single-ABI proposal (“option 3”) causes any foreign exception entering Rust to have undefined behavior under <code>panic=abort</code>, whereas the current proposal does not permit the <code>panic=abort</code> runtime to introduce undefined behavior to a program that is well-defined under <code>panic=unwind</code>.</li>
<li>This optimization could be made available with a single ABI by means of a function attribute indicating that a function cannot unwind (similar to C++’s <code>noexcept</code>). Such attributes <a href="#attributes-on-nightly-rust-and-prior-rfcs">are already available in nightly Rust</a>. However, Rust does not yet support attributes for function pointers, so until that feature is added, there would be no way to indicate whether function pointers unwind using an attribute.</li>
</ul>
</li>
<li>This design has simpler forward compatibility with alternate <code>panic!</code> implementations. Any well-defined cross-language unwinding will require shims to translate between the Rust unwinding mechanism and the natively provided mechanism. In this proposal, only <code>"C-unwind"</code> boundaries would require shims.</li>
</ul>
<h3 id="analysis-of-key-design-goals"><a class="header" href="#analysis-of-key-design-goals">Analysis of key design goals</a></h3>
<p>This section revisits the key design goals to assess how well they are met by the proposed design.</p>
<h4 id="changing-from-panicunwind-to-panicabort-cannot-cause-ub"><a class="header" href="#changing-from-panicunwind-to-panicabort-cannot-cause-ub">Changing from <code>panic=unwind</code> to <code>panic=abort</code> cannot cause UB</a></h4>
<p>This constraint is met:</p>
<ul>
<li>Unwinding across a “C” boundary is UB regardless of whether one is using <code>panic=unwind</code> or <code>panic=abort</code>.</li>
<li>Unwinding across a “C-unwind” boundary is always defined, though it is defined to abort if <code>panic=abort</code> is used.</li>
<li>Forced exceptions behave the same regardless of panic mode.</li>
</ul>
<h4 id="optimization-with-panicabort"><a class="header" href="#optimization-with-panicabort">Optimization with panic=abort</a></h4>
<p>Using this proposal, the compiler is <strong>almost always</strong> able to reduce overhead related to unwinding when using panic=abort. The one exception is that invoking a “C-unwind” ABI still requires some kind of minimal landing pad to trigger an abort. The expectation is that very few functions will use the “C-unwind” boundary unless they truly intend to unwind – and, in that case, those functions are likely using panic=unwind anyway, so this is not expected to make much difference in practice.</p>
<h4 id="preserve-the-ability-to-change-how-rust-panics-are-propagated-when-using-the-rust-abi"><a class="header" href="#preserve-the-ability-to-change-how-rust-panics-are-propagated-when-using-the-rust-abi">Preserve the ability to change how Rust panics are propagated when using the Rust ABI</a></h4>
<p>This constraint is met. If we were to change Rust panics to a different mechanism from the mechanism used by the native ABI, however, there would have to be a conversion step that interconverts between Rust panics and foreign exceptions at “C-unwind” ABI boundaries.</p>
<h4 id="enable-rust-panics-to-traverse-through-foreign-frames"><a class="header" href="#enable-rust-panics-to-traverse-through-foreign-frames">Enable Rust panics to traverse through foreign frames</a></h4>
<p>This constraint is met.</p>
<h4 id="enable-foreign-exceptions-to-propagate-through-rust-frame"><a class="header" href="#enable-foreign-exceptions-to-propagate-through-rust-frame">Enable foreign exceptions to propagate through Rust frame</a></h4>
<p>This constraint is partially met: the behavior of foreign exceptions with respect to <code>catch_unwind</code> is currently undefined, and left for future work.</p>
<h4 id="enable-error-handling-with-longjmp"><a class="header" href="#enable-error-handling-with-longjmp">Enable error handling with <code>longjmp</code></a></h4>
<p>This constraint has been <a href="#unresolved-questions">deferred</a>.</p>
<h4 id="do-not-change-the-abi-of-functions-in-the-libc-crate"><a class="header" href="#do-not-change-the-abi-of-functions-in-the-libc-crate">Do not change the ABI of functions in the <code>libc</code> crate</a></h4>
<p>This constraint has been <a href="#unresolved-questions">deferred</a>.</p>
<h2 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h2>
<p>C++ as specified has no concept of “foreign” exceptions or of an underlying exception mechanism. However, in practice, the C++ exception mechanism is the “native” unwinding mechanism used by compilers.</p>
<p>On Microsoft platforms, when using MSVC, unwinding is always supported for both C++ and C code; this is very similar to “option 3” described in <a href="https://blog.rust-lang.org/inside-rust/2020/02/27/ffi-unwind-design-meeting.html#three-specific-proposals">the inside-rust post</a> mentioned <a href="#other-proposals-discussed-with-the-lang-team">above</a>.</p>
<p>On other platforms, GCC, LLVM, and any related compilers provide a flag, <code>-fexceptions</code>, for explicitly ensuring that stack frames have unwinding support regardless of the language being compiled. Conversely, <code>-fno-exceptions</code> removes unwinding support even from C++. This is somewhat similar to how Rust’s <code>panic=unwind</code> and <code>panic=abort</code> work for <code>panic!</code> unwinds, and under the “option 3” proposal, the behavior would be similar for foreign exceptions as well. In the current proposal, though, such foreign exception support is not enabled by default with <code>panic=unwind</code> but requires the new <code>"C-unwind"</code> ABI.</p>
<h3 id="attributes-on-nightly-rust-and-prior-rfcs"><a class="header" href="#attributes-on-nightly-rust-and-prior-rfcs">Attributes on nightly Rust and prior RFCs</a></h3>
<p>Currently, nightly Rust provides attributes, <code>#[unwind(allowed)]</code> and <code>#[unwind(abort)]</code>, that permit users to select a well-defined behavior when a <code>panic</code> reaches an <code>extern "C"</code> function boundary. Stabilization of these attributes has <a href="https://github.com/rust-lang/rust/issues/58760">a tracking issue</a>, but most of the discussion about whether this was the best approach took place in two RFC PR threads, <a href="https://github.com/rust-lang/rfcs/pull/2699">#2699</a> and <a href="https://github.com/rust-lang/rfcs/pull/2753">#2753</a>.</p>
<p>The attribute approach was deemed insufficient for the following reasons:</p>
<ul>
<li>Currently, Rust does not support attributes on function pointers. This may change in the future, but until then, attributes cannot provide any way to differentiate function pointers that may unwind from those that are guaranteed not to. Assuming that no function pointers may unwind is not viable, because that severely limits the utility of cross-FFI unwinding. Conversely, assuming that all <code>extern "C"</code> function pointers may unwind is inconsistent with the no-unwind default for <code>extern "C"</code> functions.</li>
<li>The existence of a compatible unwind mechanism on both sides of a function invocation boundary is part of the binary interface for that invocation, so the ABI string is a more appropriate part of the language syntax than function attributes to indicate that unwinding may occur.</li>
<li>The ability of a function to unwind must be part of the type system to ensure that callers that cannot unwind don’t invoke functions that can unwind. Although attributes are sometimes part of a function’s type, a function’s ABI string is always part of its type, so we are not introducing any new elements to the type system.</li>
</ul>
<h3 id="older-discussions-about-unwinding-through-extern-c-boundaries"><a class="header" href="#older-discussions-about-unwinding-through-extern-c-boundaries">Older discussions about unwinding through <code>extern "C"</code> boundaries</a></h3>
<p>As mentioned <a href="#motivation">above</a>, it is currently undefined behavior for <code>extern "C"</code> functions to unwind. As documented in <a href="https://github.com/rust-lang/rust/issues/52652">this issue</a>, the lang team has long intended to make <code>panic!</code> cause the runtime to abort rather than unwind through an <code>extern "C"</code> boundary (which the current proposal <a href="#changes-to-extern-c-behavior">also specifies</a>).</p>
<p>The abort-on-unwind behavior was <a href="https://blog.rust-lang.org/2018/02/15/Rust-1.24.html#other-good-stuff">stabilized in 1.24</a> and <a href="https://blog.rust-lang.org/2018/03/01/Rust-1.24.1.html#do-not-abort-when-unwinding-through-ffi">reverted in 1.24.1</a>; the team originally planned to <a href="https://github.com/rust-lang/rust/pull/55982">stabilize it again</a> in 1.33, but ultimately <a href="https://github.com/rust-lang/rust/issues/58794">decided not to</a>. Community discussion <a href="https://internals.rust-lang.org/t/unwinding-through-ffi-after-rust-1-33/9521?u=batmanaod">on discourse</a> was largely concerned with the lack of any stable language feature to permit unwinding across FFI boundaries, and this contributed to the decision to block the re-stabilization of the abort-on-unwind behavior until such a feature could be introduced.</p>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<p>The behavior of <code>catch_unwind</code> when a foreign exception encounters it is currently <a href="#reference-level-explanation">left undefined</a>. We would like to provide a well-defined behavior for this case, which will probably be either to let the exception pass through uncaught or to catch some or all foreign exceptions.</p>
<p>We would also like to specify conditions under which <code>longjmp</code> and <code>pthread_exit</code> may safely deallocate Rust frames. This RFC specifies that frames deallocated in this way <a href="#reference-level-explanation">must be POFs</a>. However, this condition is merely necessary rather than sufficient to ensure well-defined behavior.</p>
<p>Within the context of this RFC and in discussions among members of the <a href="https://github.com/rust-lang/project-ffi-unwind">FFI-unwind project group</a>, this class of formally-undefined behavior which we plan to define in future RFCs is referred to as “TBD behavior”.</p>
<h2 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h2>
<p>The <a href="https://github.com/rust-lang/project-ffi-unwind">FFI-unwind project group</a> intends to remain active at least until all <a href="#unresolved-questions">“TBD behavior”</a> is defined. We may also address some or all of the current proposal’s <a href="#additional-limitations">limitations</a> in future RFCs.</p>
<p>We may want to provide more means of interaction with foreign exceptions. For instance, it may be possible to provide a way for Rust to catch C++ exceptions and rethrow them from another thread. Such a mechanism may either be incorporated into the functionality of <code>catch_unwind</code> or provided as a separate language or standard library feature.</p>
<p>Coercions between <code>"C-unwind"</code> function types (such as function pointers) and the other ABIs are not part of this RFC. However, they will probably be indispensable for API design, so we plan to provide them in a future RFC.</p>
<p>As mentioned <a href="#reasons-for-the-current-proposal">above</a>, shims will be required if Rust changes its unwind mechanism.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="2930-read-buf.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="2947-crates-io-token-scopes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="2930-read-buf.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="2947-crates-io-token-scopes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
