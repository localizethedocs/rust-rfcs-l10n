<!DOCTYPE HTML>
<html lang="zh_CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>1210-impl-specialization - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-b61d75f0.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Feature Name: specialization</li>
<li>Start Date: 2015-06-17</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/1210">rust-lang/rfcs#1210</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/31844">rust-lang/rust#31844</a></li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This RFC proposes a design for <em>specialization</em>, which permits multiple <code>impl</code> blocks to apply to the same type/trait, so long as one of the blocks is clearly “more specific” than the other. The more specific <code>impl</code> block is used in a case of overlap. The design proposed here also supports refining default trait implementations based on specifics about the types involved.</p>
<p>Altogether, this relatively small extension to the trait system yields benefits for performance and code reuse, and it lays the groundwork for an “efficient inheritance” scheme that is largely based on the trait system (described in a forthcoming companion RFC).</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Specialization brings benefits along several different axes:</p>
<ul>
<li>
<p><strong>Performance</strong>: specialization expands the scope of “zero cost abstraction”, because specialized impls can provide custom high-performance code for particular, concrete cases of an abstraction.</p>
</li>
<li>
<p><strong>Reuse</strong>: the design proposed here also supports refining default (but incomplete) implementations of a trait, given details about the types involved.</p>
</li>
<li>
<p><strong>Groundwork</strong>: the design lays the groundwork for supporting <a href="https://internals.rust-lang.org/t/summary-of-efficient-inheritance-rfcs/494">“efficient inheritance”</a> through the trait system.</p>
</li>
</ul>
<p>The following subsections dive into each of these motivations in more detail.</p>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>The simplest and most longstanding motivation for specialization is performance.</p>
<p>To take a very simple example, suppose we add a trait for overloading the <code>+=</code> operator:</p>
<pre><code class="language-rust">trait AddAssign&lt;Rhs=Self&gt; {
    fn add_assign(&amp;mut self, rhs: Rhs);
}</code></pre>
<p>It’s tempting to provide an impl for any type that you can both <code>Clone</code> and <code>Add</code>:</p>
<pre><code class="language-rust">impl&lt;R, T: Add&lt;R&gt; + Clone&gt; AddAssign&lt;R&gt; for T {
    fn add_assign(&amp;mut self, rhs: R) {
        let tmp = self.clone() + rhs;
        *self = tmp;
    }
}</code></pre>
<p>This impl is especially nice because it means that you frequently don’t have to bound separately by <code>Add</code> and <code>AddAssign</code>; often <code>Add</code> is enough to give you both operators.</p>
<p>However, in today’s Rust, such an impl would rule out any more specialized implementation that, for example, avoids the call to <code>clone</code>. That means there’s a tension between simple abstractions and code reuse on the one hand, and performance on the other. Specialization resolves this tension by allowing both the blanket impl, and more specific ones, to coexist, using the specialized ones whenever possible (and thereby guaranteeing maximal performance).</p>
<p>More broadly, traits today can provide static dispatch in Rust, but they can still impose an abstraction tax. For example, consider the <code>Extend</code> trait:</p>
<pre><code class="language-rust">pub trait Extend&lt;A&gt; {
    fn extend&lt;T&gt;(&amp;mut self, iterable: T) where T: IntoIterator&lt;Item=A&gt;;
}</code></pre>
<p>Collections that implement the trait are able to insert data from arbitrary iterators. Today, that means that the implementation can assume nothing about the argument <code>iterable</code> that it’s given except that it can be transformed into an iterator. That means the code must work by repeatedly calling <code>next</code> and inserting elements one at a time.</p>
<p>But in specific cases, like extending a vector with a slice, a much more efficient implementation is possible – and the optimizer isn’t always capable of producing it automatically. In such cases, specialization can be used to get the best of both worlds: retaining the abstraction of <code>extend</code> while providing custom code for specific cases.</p>
<p>The design in this RFC relies on multiple, overlapping trait impls, so to take advantage for <code>Extend</code> we need to refactor a bit:</p>
<pre><code class="language-rust">pub trait Extend&lt;A, T: IntoIterator&lt;Item=A&gt;&gt; {
    fn extend(&amp;mut self, iterable: T);
}

// The generic implementation
impl&lt;A, T&gt; Extend&lt;A, T&gt; for Vec&lt;A&gt; where T: IntoIterator&lt;Item=A&gt; {
    // the `default` qualifier allows this method to be specialized below
    default fn extend(&amp;mut self, iterable: T) {
        ... // implementation using push (like today's extend)
    }
}

// A specialized implementation for slices
impl&lt;'a, A&gt; Extend&lt;A, &amp;'a [A]&gt; for Vec&lt;A&gt; {
    fn extend(&amp;mut self, iterable: &amp;'a [A]) {
        ... // implementation using ptr::write (like push_all)
    }
}</code></pre>
<p>Other kinds of specialization are possible, including using marker traits like:</p>
<pre><code class="language-rust">unsafe trait TrustedSizeHint {}</code></pre>
<p>that can allow the optimization to apply to a broader set of types than slices, but are still more specific than <code>T: IntoIterator</code>.</p>
<h3 id="reuse"><a class="header" href="#reuse">Reuse</a></h3>
<p>Today’s default methods in traits are pretty limited: they can assume only the <code>where</code> clauses provided by the trait itself, and there is no way to provide conditional or refined defaults that rely on more specific type information.</p>
<p>For example, consider a different design for overloading <code>+</code> and <code>+=</code>, such that they are always overloaded together:</p>
<pre><code class="language-rust">trait Add&lt;Rhs=Self&gt; {
    type Output;
    fn add(self, rhs: Rhs) -&gt; Self::Output;
    fn add_assign(&amp;mut self, rhs: Rhs);
}</code></pre>
<p>In this case, there’s no natural way to provide a default implementation of <code>add_assign</code>, since we do not want to restrict the <code>Add</code> trait to <code>Clone</code> data.</p>
<p>The specialization design in this RFC also allows for <em>default impls</em>, which can provide specialized defaults without actually providing a full trait implementation:</p>
<pre><code class="language-rust">// the `default` qualifier here means (1) not all items are implied
// and (2) those that are can be further specialized
default impl&lt;T: Clone, Rhs&gt; Add&lt;Rhs&gt; for T {
    fn add_assign(&amp;mut self, rhs: Rhs) {
        let tmp = self.clone() + rhs;
        *self = tmp;
    }
}</code></pre>
<p>This default impl does <em>not</em> mean that <code>Add</code> is implemented for all <code>Clone</code> data, but just that when you do impl <code>Add</code> and <code>Self: Clone</code>, you can leave off <code>add_assign</code>:</p>
<pre><code class="language-rust">#[derive(Copy, Clone)]
struct Complex {
    // ...
}

impl Add&lt;Complex&gt; for Complex {
    type Output = Complex;
    fn add(self, rhs: Complex) {
        // ...
    }
    // no fn add_assign necessary
}</code></pre>
<p>A particularly nice case of refined defaults comes from trait hierarchies: you can sometimes use methods from subtraits to improve default supertrait methods. For example, consider the relationship between <code>size_hint</code> and <code>ExactSizeIterator</code>:</p>
<pre><code class="language-rust">default impl&lt;T&gt; Iterator for T where T: ExactSizeIterator {
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (self.len(), Some(self.len()))
    }
}</code></pre>
<h3 id="supporting-efficient-inheritance"><a class="header" href="#supporting-efficient-inheritance">Supporting efficient inheritance</a></h3>
<p>Finally, specialization can be seen as a form of inheritance, since methods defined within a blanket impl can be overridden in a fine-grained way by a more specialized impl. As we will see, this analogy is a useful guide to the design of specialization. But it is more than that: the specialization design proposed here is specifically tailored to support “efficient inheritance” schemes (like those discussed <a href="https://internals.rust-lang.org/t/summary-of-efficient-inheritance-rfcs/494">here</a>) without adding an entirely separate inheritance mechanism.</p>
<p>The key insight supporting this design is that virtual method definitions in languages like C++ and Java actually encompass two distinct mechanisms: virtual dispatch (also known as “late binding”) and implementation inheritance. These two mechanisms can be separated and addressed independently; this RFC encompasses an “implementation inheritance” mechanism distinct from virtual dispatch, and useful in a number of other circumstances. But it can be combined nicely with an orthogonal mechanism for virtual dispatch to give a complete story for the “efficient inheritance” goal that many previous RFCs targeted.</p>
<p>The author is preparing a companion RFC showing how this can be done with a relatively small further extension to the language. But it should be said that the design in <em>this</em> RFC is fully motivated independently of its companion RFC.</p>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed design</a></h2>
<p>There’s a fair amount of material to cover, so we’ll start with a basic overview of the design in intuitive terms, and then look more formally at a specification.</p>
<p>At the simplest level, specialization is about allowing overlap between impl blocks, so long as there is always an unambiguous “winner” for any type falling into the overlap. For example:</p>
<pre><code class="language-rust">impl&lt;T&gt; Debug for T where T: Display {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        &lt;Self as Display&gt;::fmt(self, f)
    }
}

impl Debug for String {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result {
        try!(write!(f, "\""));
        for c in self.chars().flat_map(|c| c.escape_default()) {
            try!(write!(f, "{}", c));
        }
        write!(f, "\"")
    }
}</code></pre>
<p>The idea for this pair of impls is that you can rest assured that <em>any</em> type implementing <code>Display</code> will also implement <code>Debug</code> via a reasonable default, but go on to provide more specific <code>Debug</code> implementations when warranted. In particular, the intuition is that a <code>Self</code> type of <code>String</code> is somehow “more specific” or “more concrete” than <code>T where T: Display</code>.</p>
<p>The bulk of the detailed design is aimed at making this intuition more precise. But first, we need to explore some problems that arise when you introduce specialization in any form.</p>
<h3 id="hazard-interactions-with-type-checking"><a class="header" href="#hazard-interactions-with-type-checking">Hazard: interactions with type checking</a></h3>
<p>Consider the following, somewhat odd example of overlapping impls:</p>
<pre><code class="language-rust">trait Example {
    type Output;
    fn generate(self) -&gt; Self::Output;
}

impl&lt;T&gt; Example for T {
    type Output = Box&lt;T&gt;;
    fn generate(self) -&gt; Box&lt;T&gt; { Box::new(self) }
}

impl Example for bool {
    type Output = bool;
    fn generate(self) -&gt; bool { self }
}</code></pre>
<p>The key point to pay attention to here is the difference in associated types: the blanket impl uses <code>Box&lt;T&gt;</code>, while the impl for <code>bool</code> just uses <code>bool</code>. If we write some code that uses the above impls, we can get into trouble:</p>
<pre><code class="language-rust">fn trouble&lt;T&gt;(t: T) -&gt; Box&lt;T&gt; {
    Example::generate(t)
}

fn weaponize() -&gt; bool {
    let b: Box&lt;bool&gt; = trouble(true);
    *b
}</code></pre>
<p>What’s going on? When type checking <code>trouble</code>, the compiler has a type <code>T</code> about which it knows nothing, and sees an attempt to employ the <code>Example</code> trait via <code>Example::generate(t)</code>. Because of the blanket impl, this use of <code>Example</code> is allowed – but furthermore, the associated type found in the blanket impl is now directly usable, so that <code>&lt;T as Example&gt;::Output</code> is known within <code>trouble</code> to be <code>Box&lt;T&gt;</code>, allowing <code>trouble</code> to type check. But during <em>monomorphization</em>, <code>weaponize</code> will actually produce a version of the code that returns a boolean instead, and then attempt to dereference that boolean. In other words, things look different to the typechecker than they do to codegen. Oops.</p>
<p>So what went wrong? It should be fine for the compiler to assume that <code>T: Example</code> for all <code>T</code>, given the blanket impl. But it’s clearly problematic to <em>also</em> assume that the associated types will be the ones given by that blanket impl. Thus, the “obvious” solution is just to generate a type error in <code>trouble</code> by preventing it from assuming <code>&lt;T as Example&gt;::Output</code> is <code>Box&lt;T&gt;</code>.</p>
<p>Unfortunately, this solution doesn’t work. For one thing, it would be a breaking change, since the following code <em>does</em> compile today:</p>
<pre><code class="language-rust">trait Example {
    type Output;
    fn generate(self) -&gt; Self::Output;
}

impl&lt;T&gt; Example for T {
    type Output = Box&lt;T&gt;;
    fn generate(self) -&gt; Box&lt;T&gt; { Box::new(self) }
}

fn trouble&lt;T&gt;(t: T) -&gt; Box&lt;T&gt; {
    Example::generate(t)
}</code></pre>
<p>And there are definitely cases where this pattern is important. To pick just one example, consider the following impl for the slice iterator:</p>
<pre><code class="language-rust">impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;
    // ...
}</code></pre>
<p>It’s essential that downstream code be able to assume that <code>&lt;Iter&lt;'a, T&gt; as Iterator&gt;::Item</code> is just <code>&amp;'a T</code>, no matter what <code>'a</code> and <code>T</code> happen to be.</p>
<p>Furthermore, it doesn’t work to say that the compiler can make this kind of assumption <em>unless</em> specialization is being used, since we want to allow downstream crates to add specialized impls. We need to know up front.</p>
<p>Another possibility would be to simply disallow specialization of associated types. But the trouble described above isn’t limited to associated types. Every function/method in a trait has an implicit associated type that implements the closure types, and similar bad assumptions about blanket impls can crop up there. It’s not entirely clear whether they can be weaponized, however. (That said, it may be reasonable to stabilize only specialization of functions/methods to begin with, and wait for strong use cases of associated type specialization to emerge before stabilizing that.)</p>
<p>The solution proposed in this RFC is instead to treat specialization of items in a trait as a per-item <em>opt in</em>, described in the next section.</p>
<h3 id="the-default-keyword"><a class="header" href="#the-default-keyword">The <code>default</code> keyword</a></h3>
<p>Many statically-typed languages that allow refinement of behavior in some hierarchy also come with ways to signal whether or not this is allowed:</p>
<ul>
<li>
<p>C++ requires the <code>virtual</code> keyword to permit a method to be overridden in subclasses. Modern C++ also supports <code>final</code> and <code>override</code> qualifiers.</p>
</li>
<li>
<p>C# requires the <code>virtual</code> keyword at definition and <code>override</code> at point of overriding an existing method.</p>
</li>
<li>
<p>Java makes things silently virtual, but supports <code>final</code> as an opt out.</p>
</li>
</ul>
<p>Why have these qualifiers? Overriding implementations is, in a way, “action at a distance”. It means that the code that’s actually being run isn’t obvious when e.g. a class is defined; it can change in subclasses defined elsewhere. Requiring qualifiers is a way of signaling that this non-local change is happening, so that you know you need to look more globally to understand the actual behavior of the class.</p>
<p>While impl specialization does not directly involve virtual dispatch, it’s closely-related to inheritance, and it allows some amount of “action at a distance” (modulo, as we’ll see, coherence rules). We can thus borrow directly from these previous designs.</p>
<p>This RFC proposes a “final-by-default” semantics akin to C++ that is backwards-compatible with today’s Rust, which means that the following overlapping impls are prohibited:</p>
<pre><code class="language-rust">impl&lt;T&gt; Example for T {
    type Output = Box&lt;T&gt;;
    fn generate(self) -&gt; Box&lt;T&gt; { Box::new(self) }
}

impl Example for bool {
    type Output = bool;
    fn generate(self) -&gt; bool { self }
}</code></pre>
<p>The error in these impls is that the first impl is implicitly defining “final” versions of its items, which are thus not allowed to be refined in further specializations.</p>
<p>If you want to allow specialization of an item, you do so via the <code>default</code> qualifier <em>within the impl block</em>:</p>
<pre><code class="language-rust">impl&lt;T&gt; Example for T {
    default type Output = Box&lt;T&gt;;
    default fn generate(self) -&gt; Box&lt;T&gt; { Box::new(self) }
}

impl Example for bool {
    type Output = bool;
    fn generate(self) -&gt; bool { self }
}</code></pre>
<p>Thus, when you’re trying to understand what code is going to be executed, if you see an impl that applies to a type and the relevant item is <em>not</em> marked <code>default</code>, you know that the definition you’re looking at is the one that will apply. If, on the other hand, the item is marked <code>default</code>, you need to scan for other impls that could apply to your type. The coherence rules, described below, help limit the scope of this search in practice.</p>
<p>This design optimizes for fine-grained control over when specialization is permitted. It’s worth pausing for a moment and considering some alternatives and questions about the design:</p>
<ul>
<li>
<p><strong>Why mark <code>default</code> on impls rather than the trait?</strong> There are a few reasons to have <code>default</code> apply at the impl level. First of all, traits are fundamentally <em>interfaces</em>, while <code>default</code> is really about <em>implementations</em>. Second, as we’ll see, it’s useful to be able to “seal off” a certain avenue of specialization while leaving others open; doing it at the trait level is an all-or-nothing choice.</p>
</li>
<li>
<p><strong>Why mark <code>default</code> on items rather than the entire impl?</strong> Again, this is largely about granularity; it’s useful to be able to pin down part of an impl while leaving others open for specialization. Furthermore, while this RFC doesn’t propose to do it, we could easily add a shorthand later on in which <code>default impl Trait for Type</code> is sugar for adding <code>default</code> to all items in the impl.</p>
</li>
<li>
<p><strong>Won’t <code>default</code> be confused with default methods?</strong> Yes! But usefully so: as we’ll see, in this RFC’s design today’s default methods become sugar for tomorrow’s specialization.</p>
</li>
</ul>
<p>Finally, how does <code>default</code> help with the hazards described above? Easy: an associated type from a blanket impl must be treated “opaquely” if it’s marked <code>default</code>. That is, if you write these impls:</p>
<pre><code class="language-rust">impl&lt;T&gt; Example for T {
    default type Output = Box&lt;T&gt;;
    default fn generate(self) -&gt; Box&lt;T&gt; { Box::new(self) }
}

impl Example for bool {
    type Output = bool;
    fn generate(self) -&gt; bool { self }
}</code></pre>
<p>then the function <code>trouble</code> will fail to typecheck:</p>
<pre><code class="language-rust">fn trouble&lt;T&gt;(t: T) -&gt; Box&lt;T&gt; {
    Example::generate(t)
}</code></pre>
<p>The error is that <code>&lt;T as Example&gt;::Output</code> no longer normalizes to <code>Box&lt;T&gt;</code>, because the applicable blanket impl marks the type as <code>default</code>. The fact that <code>default</code> is an opt in makes this behavior backwards-compatible.</p>
<p>The main drawbacks of this solution are:</p>
<ul>
<li>
<p><strong>API evolution</strong>. Adding <code>default</code> to an associated type <em>takes away</em> some abilities, which makes it a breaking change to a public API. (In principle, this is probably true for functions/methods as well, but the breakage there is theoretical at most.) However, given the design constraints discussed so far, this seems like an inevitable aspect of any simple, backwards-compatible design.</p>
</li>
<li>
<p><strong>Verbosity</strong>. It’s possible that certain uses of the trait system will result in typing <code>default</code> quite a bit. This RFC takes a conservative approach of introducing the keyword at a fine-grained level, but leaving the door open to adding shorthands (like writing <code>default impl ...</code>) in the future, if need be.</p>
</li>
</ul>
<h3 id="overlapping-impls-and-specialization"><a class="header" href="#overlapping-impls-and-specialization">Overlapping impls and specialization</a></h3>
<h4 id="what-is-overlap"><a class="header" href="#what-is-overlap">What is overlap?</a></h4>
<p>Rust today does not allow any “overlap” between impls. Intuitively, this means that you cannot write two trait impls that could apply to the same “input” types. (An input type is either <code>Self</code> or a type parameter of the trait). For overlap to occur, the input types must be able to “unify”, which means that there’s some way of instantiating any type parameters involved so that the input types are the same. Here are some examples:</p>
<pre><code class="language-rust">trait Foo {}

// No overlap: String and Vec&lt;u8&gt; cannot unify.
impl Foo for String {}
impl Foo for Vec&lt;u8&gt; {}

// No overlap: Vec&lt;u16&gt; and Vec&lt;u8&gt; cannot unify because u16 and u8 cannot unify.
impl Foo for Vec&lt;u16&gt; {}
impl Foo for Vec&lt;u8&gt; {}

// Overlap: T can be instantiated to String.
impl&lt;T&gt; Foo for T {}
impl Foo for String {}

// Overlap: Vec&lt;T&gt; and Vec&lt;u8&gt; can unify because T can be instantiated to u8.
impl&lt;T&gt; Foo for Vec&lt;T&gt; {}
impl Foo for Vec&lt;u8&gt;

// No overlap: String and Vec&lt;T&gt; cannot unify, no matter what T is.
impl Foo for String {}
impl&lt;T&gt; Foo for Vec&lt;T&gt; {}

// Overlap: for any T that is Clone, both impls apply.
impl&lt;T&gt; Foo for Vec&lt;T&gt; where T: Clone {}
impl&lt;T&gt; Foo for Vec&lt;T&gt; {}

// No overlap: implicitly, T: Sized, and since !Foo: Sized, you cannot instantiate T with it.
impl&lt;T&gt; Foo for Box&lt;T&gt; {}
impl Foo for Box&lt;Foo&gt; {}

trait Trait1 {}
trait Trait2 {}

// Overlap: nothing prevents a T such that T: Trait1 + Trait2.
impl&lt;T: Trait1&gt; Foo for T {}
impl&lt;T: Trait2&gt; Foo for T {}

trait Trait3 {}
trait Trait4: Trait3 {}

// Overlap: any T: Trait4 is covered by both impls.
impl&lt;T: Trait3&gt; Foo for T {}
impl&lt;T: Trait4&gt; Foo for T {}

trait Bar&lt;T&gt; {}

// No overlap: *all* input types must unify for overlap to happen.
impl Bar&lt;u8&gt; for u8 {}
impl Bar&lt;u16&gt; for u8 {}

// No overlap: *all* input types must unify for overlap to happen.
impl&lt;T&gt; Bar&lt;u8&gt; for T {}
impl&lt;T&gt; Bar&lt;u16&gt; for T {}

// No overlap: no way to instantiate T such that T == u8 and T == u16.
impl&lt;T&gt; Bar&lt;T&gt; for T {}
impl Bar&lt;u16&gt; for u8 {}

// Overlap: instantiate U as T.
impl&lt;T&gt; Bar&lt;T&gt; for T {}
impl&lt;T, U&gt; Bar&lt;T&gt; for U {}

// No overlap: no way to instantiate T such that T == &amp;'a T.
impl&lt;T&gt; Bar&lt;T&gt; for T {}
impl&lt;'a, T&gt; Bar&lt;&amp;'a T&gt; for T {}

// Overlap: instantiate T = &amp;'a U.
impl&lt;T&gt; Bar&lt;T&gt; for T {}
impl&lt;'a, T, U&gt; Bar&lt;T&gt; for &amp;'a U where U: Bar&lt;T&gt; {}</code></pre>
<h4 id="permitting-overlap"><a class="header" href="#permitting-overlap">Permitting overlap</a></h4>
<p>The goal of specialization is to allow overlapping impls, but it’s not as simple as permitting <em>all</em> overlap. There has to be a way to decide which of two overlapping impls to actually use for a given set of input types. The simpler and more intuitive the rule for deciding, the easier it is to write and reason about code – and since dispatch is already quite complicated, simplicity here is a high priority. On the other hand, the design should support as many of the motivating use cases as possible.</p>
<p>The basic intuition we’ve been using for specialization is the idea that one impl is “more specific” than another it overlaps with. Before turning this intuition into a rule, let’s go through the previous examples of overlap and decide which, if any, of the impls is intuitively more specific. <strong>Note that since we’re leaving out the body of the impls, you won’t see the <code>default</code> keyword that would be required in practice for the less specialized impls.</strong></p>
<pre><code class="language-rust">trait Foo {}

// Overlap: T can be instantiated to String.
impl&lt;T&gt; Foo for T {}
impl Foo for String {}          // String is more specific than T

// Overlap: Vec&lt;T&gt; and Vec&lt;u8&gt; can unify because T can be instantiated to u8.
impl&lt;T&gt; Foo for Vec&lt;T&gt; {}
impl Foo for Vec&lt;u8&gt;            // Vec&lt;u8&gt; is more specific than Vec&lt;T&gt;

// Overlap: for any T that is Clone, both impls apply.
impl&lt;T&gt; Foo for Vec&lt;T&gt;          // "Vec&lt;T&gt; where T: Clone" is more specific than "Vec&lt;T&gt; for any T"
    where T: Clone {}
impl&lt;T&gt; Foo for Vec&lt;T&gt; {}

trait Trait1 {}
trait Trait2 {}

// Overlap: nothing prevents a T such that T: Trait1 + Trait2
impl&lt;T: Trait1&gt; Foo for T {}    // Neither is more specific;
impl&lt;T: Trait2&gt; Foo for T {}    // there's no relationship between the traits here

trait Trait3 {}
trait Trait4: Trait3 {}

// Overlap: any T: Trait4 is covered by both impls.
impl&lt;T: Trait3&gt; Foo for T {}
impl&lt;T: Trait4&gt; Foo for T {}    // T: Trait4 is more specific than T: Trait3

trait Bar&lt;T&gt; {}

// Overlap: instantiate U as T.
impl&lt;T&gt; Bar&lt;T&gt; for T {}         // More specific since both input types are identical
impl&lt;T, U&gt; Bar&lt;T&gt; for U {}

// Overlap: instantiate T = &amp;'a U.
impl&lt;T&gt; Bar&lt;T&gt; for T {}         // Neither is more specific
impl&lt;'a, T, U&gt; Bar&lt;T&gt; for &amp;'a U
    where U: Bar&lt;T&gt; {}</code></pre>
<p>What are the patterns here?</p>
<ul>
<li>Concrete types are more specific than type variables, e.g.:
<ul>
<li><code>String</code> is more specific than <code>T</code></li>
<li><code>Vec&lt;u8&gt;</code> is more specific than <code>Vec&lt;T&gt;</code></li>
</ul>
</li>
<li>More constraints lead to more specific impls, e.g.:
<ul>
<li><code>T: Clone</code> is more specific than <code>T</code></li>
<li><code>Bar&lt;T&gt; for T</code> is more specific than <code>Bar&lt;T&gt; for U</code></li>
</ul>
</li>
<li>Unrelated constraints don’t contribute, e.g.:
<ul>
<li>Neither <code>T: Trait1</code> nor <code>T: Trait2</code> is more specific than the other.</li>
</ul>
</li>
</ul>
<p>For many purposes, the above simple patterns are sufficient for working with specialization. But to provide a spec, we need a more general, formal way of deciding precedence; we’ll give one next.</p>
<h4 id="defining-the-precedence-rules"><a class="header" href="#defining-the-precedence-rules">Defining the precedence rules</a></h4>
<p>An impl block <code>I</code> contains basically two pieces of information relevant to specialization:</p>
<ul>
<li>A set of type variables, like <code>T, U</code> in <code>impl&lt;T, U&gt; Bar&lt;T&gt; for U</code>.
<ul>
<li>We’ll call this <code>I.vars</code>.</li>
</ul>
</li>
<li>A set of where clauses, like <code>T: Clone</code> in <code>impl&lt;T: Clone&gt; Foo for Vec&lt;T&gt;</code>.
<ul>
<li>We’ll call this <code>I.wc</code>.</li>
</ul>
</li>
</ul>
<p>We’re going to define a <em>specialization relation</em> <code>&lt;=</code> between impl blocks, so that <code>I &lt;= J</code> means that impl block <code>I</code> is “at least as specific as” impl block <code>J</code>. (If you want to think of this in terms of “size”, you can imagine that the set of types <code>I</code> applies to is no bigger than those <code>J</code> applies to.)</p>
<p>We’ll say that <code>I &lt; J</code> if <code>I &lt;= J</code> and <code>!(J &lt;= I)</code>. In this case, <code>I</code> is <em>more specialized</em> than <code>J</code>.</p>
<p>To ensure specialization is coherent, we will ensure that for any two impls <code>I</code> and <code>J</code> that overlap, we have either <code>I &lt; J</code> or <code>J &lt; I</code>.  That is, one must be truly more specific than the other. Specialization chooses the “smallest” impl in this order – and the new overlap rule ensures there is a unique smallest impl among those that apply to a given set of input types.</p>
<p>More broadly, while <code>&lt;=</code> is not a total order on <em>all</em> impls of a given trait, it will be a total order on any set of impls that all mutually overlap, which is all we need to determine which impl to use.</p>
<p>One nice thing about this approach is that, if there is an overlap without there being an intersecting impl, the compiler can tell the programmer <em>precisely which impl needs to be written</em> to disambiguate the overlapping portion.</p>
<p>We’ll start with an abstract/high-level formulation, and then build up toward an algorithm for deciding specialization by introducing a number of building blocks.</p>
<h5 id="abstract-formulation"><a class="header" href="#abstract-formulation">Abstract formulation</a></h5>
<p>Recall that the <a href="https://github.com/aturon/rfcs/blob/associated-items/active/0000-associated-items.md">input types</a> of a trait are the <code>Self</code> type and all trait type parameters. So the following impl has input types <code>bool</code>, <code>u8</code> and <code>String</code>:</p>
<pre><code class="language-rust">trait Baz&lt;X, Y&gt; { .. }
// impl I
impl Baz&lt;bool, u8&gt; for String { .. }</code></pre>
<p>If you think of these input types as a tuple, <code>(bool, u8, String</code>) you can think of each trait impl <code>I</code> as determining a set <code>apply(I)</code> of input type tuples that obeys <code>I</code>’s where clauses. The impl above is just the singleton set <code>apply(I) = { (bool, u8, String) }</code>.  Here’s a more interesting case:</p>
<pre><code class="language-rust">// impl J
impl&lt;T, U&gt; Baz&lt;T, u8&gt; for U where T: Clone { .. }</code></pre>
<p>which gives the set <code>apply(J) = { (T, u8, U) | T: Clone }</code>.</p>
<p>Two impls <code>I</code> and <code>J</code> overlap if <code>apply(I)</code> and <code>apply(J)</code> intersect.</p>
<p><strong>We can now define the specialization order abstractly</strong>: <code>I &lt;= J</code> if <code>apply(I)</code> is a subset of <code>apply(J)</code>.</p>
<p>This is true of the two sets above:</p>
<pre><code>apply(I) = { (bool, u8, String) }
  is a strict subset of
apply(J) = { (T, u8, U) | T: Clone }
</code></pre>
<p>Here are a few more examples.</p>
<p><strong>Via where clauses</strong>:</p>
<pre><code class="language-rust">// impl I
// apply(I) = { T | T a type }
impl&lt;T&gt; Foo for T {}

// impl J
// apply(J) = { T | T: Clone }
impl&lt;T&gt; Foo for T where T: Clone {}

// J &lt; I</code></pre>
<p><strong>Via type structure</strong>:</p>
<pre><code class="language-rust">// impl I
// apply(I) = { (T, U) | T, U types }
impl&lt;T, U&gt; Bar&lt;T&gt; for U {}

// impl J
// apply(J) = { (T, T) | T a type }
impl&lt;T&gt; Bar&lt;T&gt; for T {}

// J &lt; I</code></pre>
<p>The same reasoning can be applied to all of the examples we saw earlier, and the reader is encouraged to do so. We’ll look at one of the more subtle cases here:</p>
<pre><code class="language-rust">// impl I
// apply(I) = { (T, T) | T any type }
impl&lt;T&gt; Bar&lt;T&gt; for T {}

// impl J
// apply(J) = { (T, &amp;'a U) | U: Bar&lt;T&gt;, 'a any lifetime }
impl&lt;'a, T, U&gt; Bar&lt;T&gt; for &amp;'a U where U: Bar&lt;T&gt; {}</code></pre>
<p>The claim is that <code>apply(I)</code> and <code>apply(J)</code> intersect, but neither contains the other. Thus, these two impls are not permitted to coexist according to this RFC’s design. (We’ll revisit this limitation toward the end of the RFC.)</p>
<h5 id="algorithmic-formulation"><a class="header" href="#algorithmic-formulation">Algorithmic formulation</a></h5>
<p>The goal in the remainder of this section is to turn the above abstract definition of <code>&lt;=</code> into something closer to an algorithm, connected to existing mechanisms in the Rust compiler. We’ll start by reformulating <code>&lt;=</code> in a way that effectively “inlines” <code>apply</code>:</p>
<p><code>I &lt;= J</code> if:</p>
<ul>
<li>
<p>For any way of instantiating <code>I.vars</code>, there is some way of instantiating <code>J.vars</code> such that the <code>Self</code> type and trait type parameters match up.</p>
</li>
<li>
<p>For this instantiation of <code>I.vars</code>, if you assume <code>I.wc</code> holds, you can prove <code>J.wc</code>.</p>
</li>
</ul>
<p>It turns out that the compiler is already quite capable of answering these questions, via “unification” and “skolemization”, which we’ll see next.</p>
<h6 id="unification-solving-equations-on-types"><a class="header" href="#unification-solving-equations-on-types">Unification: solving equations on types</a></h6>
<p>Unification is the workhorse of type inference and many other mechanisms in the Rust compiler. You can think of it as a way of solving equations on types that contain variables. For example, consider the following situation:</p>
<pre><code class="language-rust">fn use_vec&lt;T&gt;(v: Vec&lt;T&gt;) { .. }

fn caller() {
    let v = vec![0u8, 1u8];
    use_vec(v);
}</code></pre>
<p>The compiler ultimately needs to infer what type to use for the <code>T</code> in <code>use_vec</code> within the call in <code>caller</code>, given that the actual argument has type <code>Vec&lt;u8&gt;</code>. You can frame this as a unification problem: solve the equation <code>Vec&lt;T&gt; = Vec&lt;u8&gt;</code>. Easy enough: <code>T = u8</code>!</p>
<p>Some equations can’t be solved. For example, if we wrote instead:</p>
<pre><code class="language-rust">fn caller() {
    let s = "hello";
    use_vec(s);
}</code></pre>
<p>we would end up equating <code>Vec&lt;T&gt; = &amp;str</code>. There’s no choice of <code>T</code> that makes that equation work out. Type error!</p>
<p>Unification often involves solving a series of equations between types simultaneously, but it’s not like high school algebra; the equations involved all have the limited form of <code>type1 = type2</code>.</p>
<p>One immediate way in which unification is relevant to this RFC is in determining when two impls “overlap”: roughly speaking, they overlap if each pair of input types can be unified simultaneously. For example:</p>
<pre><code class="language-rust">// No overlap: String and bool do not unify
impl Foo for String { .. }
impl Foo for bool { .. }

// Overlap: String and T unify
impl Foo for String { .. }
impl&lt;T&gt; Foo for T { .. }

// Overlap: T = U, T = V is trivially solvable
impl&lt;T&gt; Bar&lt;T&gt; for T { .. }
impl&lt;U, V&gt; Bar&lt;U&gt; for V { .. }

// No overlap: T = u8, T = bool not solvable
impl&lt;T&gt; Bar&lt;T&gt; for T { .. }
impl Bar&lt;u8&gt; for bool { .. }</code></pre>
<p>Note the difference in how <em>concrete types</em> and <em>type variables</em> work for unification. When <code>T</code>, <code>U</code> and <code>V</code> are variables, it’s fine to say that <code>T = U</code>, <code>T = V</code> is solvable: we can make the impls overlap by instantiating all three variables with the same type. But asking for e.g. <code>String = bool</code> fails, because these are concrete types, not variables. (The same happens in algebra; consider that <code>2 = 3</code> cannot be solved, but <code>x = y</code> and <code>y = z</code> can be.)  This distinction may seem obvious, but we’ll next see how to leverage it in a somewhat subtle way.</p>
<h6 id="skolemization-asking-forallthere-exists-questions"><a class="header" href="#skolemization-asking-forallthere-exists-questions">Skolemization: asking forall/there exists questions</a></h6>
<p>We’ve already rephrased <code>&lt;=</code> to start with a “for all, there exists” problem:</p>
<ul>
<li>For any way of instantiating <code>I.vars</code>, there is some way of instantiating <code>J.vars</code> such that the <code>Self</code> type and trait type parameters match up.</li>
</ul>
<p>For example:</p>
<pre><code class="language-rust">// impl I
impl&lt;T&gt; Bar&lt;T&gt; for T {}

// impl J
impl&lt;U,V&gt; Bar&lt;U&gt; for V {}</code></pre>
<p>For any choice of <code>T</code>, it’s possible to choose a <code>U</code> and <code>V</code> such that the two impls match – just choose <code>U = T</code> and <code>V = T</code>. But the opposite isn’t possible: if <code>U</code> and <code>V</code> are different (say, <code>String</code> and <code>bool</code>), then no choice of <code>T</code> will make the two impls match up.</p>
<p>This feels similar to a unification problem, and it turns out we can solve it with unification using a scary-sounding trick known as “skolemization”.</p>
<p>Basically, to “skolemize” a type variable is to treat it <em>as if it were a concrete type</em>. So if <code>U</code> and <code>V</code> are skolemized, then <code>U = V</code> is unsolvable, in the same way that <code>String = bool</code> is unsolvable. That’s perfect for capturing the “for any instantiation of I.vars” part of what we want to formalize.</p>
<p>With this tool in hand, we can further rephrase the “for all, there exists” part of <code>&lt;=</code> in the following way:</p>
<ul>
<li>After skolemizing <code>I.vars</code>, it’s possible to unify <code>I</code> and <code>J</code>.</li>
</ul>
<p>Note that a successful unification through skolemization gives you the same answer as you’d get if you unified without skolemizing.</p>
<h6 id="the-algorithmic-version"><a class="header" href="#the-algorithmic-version">The algorithmic version</a></h6>
<p>One outcome of running unification on two impls as above is that we can understand both impl headers in terms of a single set of type variables. For example:</p>
<pre><code class="language-rust">// Before unification:
impl&lt;T&gt; Bar&lt;T&gt; for T where T: Clone { .. }
impl&lt;U, V&gt; Bar&lt;U&gt; for Vec&lt;V&gt; where V: Debug { .. }

// After unification:
// T = Vec&lt;W&gt;
// U = Vec&lt;W&gt;
// V = W
impl&lt;W&gt; Bar&lt;Vec&lt;W&gt;&gt; for Vec&lt;W&gt; where Vec&lt;W&gt;: Clone { .. }
impl&lt;W&gt; Bar&lt;Vec&lt;W&gt;&gt; for Vec&lt;W&gt; where W: Debug { .. }</code></pre>
<p>By putting everything in terms of a single set of type params, it becomes possible to do things like compare the <code>where</code> clauses, which is the last piece we need for a final rephrasing of <code>&lt;=</code> that we can implement directly.</p>
<p>Putting it all together, we’ll say <code>I &lt;= J</code> if:</p>
<ul>
<li>After skolemizing <code>I.vars</code>, it’s possible to unify <code>I</code> and <code>J</code>.</li>
<li>Under the resulting unification, <code>I.wc</code> implies <code>J.wc</code></li>
</ul>
<p>Let’s look at a couple more examples to see how this works:</p>
<pre><code class="language-rust">trait Trait1 {}
trait Trait2 {}

// Overlap: nothing prevents a T such that T: Trait1 + Trait2
impl&lt;T: Trait1&gt; Foo for T {}    // Neither is more specific;
impl&lt;T: Trait2&gt; Foo for T {}    // there's no relationship between the traits here</code></pre>
<p>In comparing these two impls in either direction, we make it past unification and must try to prove that one where clause implies another. But <code>T: Trait1</code> does not imply <code>T: Trait2</code>, nor vice versa, so neither impl is more specific than the other. Since the impls do overlap, an ambiguity error is reported.</p>
<p>On the other hand:</p>
<pre><code class="language-rust">trait Trait3 {}
trait Trait4: Trait3 {}

// Overlap: any T: Trait4 is covered by both impls.
impl&lt;T: Trait3&gt; Foo for T {}
impl&lt;T: Trait4&gt; Foo for T {}    // T: Trait4 is more specific than T: Trait3</code></pre>
<p>Here, since <code>T: Trait4</code> implies <code>T: Trait3</code> but not vice versa, we get</p>
<pre><code class="language-rust">impl&lt;T: Trait4&gt; Foo for T    &lt;    impl&lt;T: Trait3&gt; Foo for T</code></pre>
<h6 id="key-properties"><a class="header" href="#key-properties">Key properties</a></h6>
<p>Remember that for each pair of impls <code>I</code>, <code>J</code>, the compiler will check that exactly one of the following holds:</p>
<ul>
<li><code>I</code> and <code>J</code> do not overlap (a unification check), or else</li>
<li><code>I &lt; J</code>, or else</li>
<li><code>J &lt; I</code></li>
</ul>
<p>Recall also that if there is an overlap without there being an intersecting impl, the compiler can tell the programmer <em>precisely which impl needs to be written</em> to disambiguate the overlapping portion.</p>
<p>Since <code>I &lt;= J</code> ultimately boils down to a subset relationship, we get a lot of nice properties for free (e.g., transitivity: if <code>I &lt;= J &lt;= K</code> then <code>I &lt;= K</code>). Together with the compiler check above, we know that at monomorphization time, after filtering to the impls that apply to some concrete input types, there will always be a unique, smallest impl in specialization order. (In particular, if multiple impls apply to concrete input types, those impls must overlap.)</p>
<p>There are various implementation strategies that avoid having to recalculate the ordering during monomorphization, but we won’t delve into those details in this RFC.</p>
<h4 id="implications-for-coherence"><a class="header" href="#implications-for-coherence">Implications for coherence</a></h4>
<p>The coherence rules ensure that there is never an ambiguity about which impl to use when monomorphizing code. Today, the rules consist of the simple overlap check described earlier, and the “orphan” check which limits the crates in which impls are allowed to appear (“orphan” refers to an impl in a crate that defines neither the trait nor the types it applies to). The orphan check is needed, in particular, so that overlap cannot be created accidentally when linking crates together.</p>
<p>The design in this RFC heavily revises the overlap check, as described above, but does not propose any changes to the orphan check (which is described in <a href="http://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/">a blog post</a>). Basically, the change to the overlap check does not appear to change the cases in which orphan impls can cause trouble. And a moment’s thought reveals why: if two sibling crates are unaware of each other, there’s no way that they could each provide an impl overlapping with the other, yet be sure that one of those impls is more specific than the other in the overlapping region.</p>
<h4 id="interaction-with-lifetimes"><a class="header" href="#interaction-with-lifetimes">Interaction with lifetimes</a></h4>
<p>A hard constraint in the design of the trait system is that <em>dispatch cannot depend on lifetime information</em>. In particular, we both cannot, and should not allow specialization based on lifetimes:</p>
<ul>
<li>
<p>We can’t, because when the compiler goes to actually generate code (“trans”), lifetime information has been erased – so we’d have no idea what specializations would soundly apply.</p>
</li>
<li>
<p>We shouldn’t, because lifetime inference is subtle and would often lead to counterintuitive results. For example, you could easily fail to get <code>'static</code> even if it applies, because inference is choosing the smallest lifetime that matches the other constraints.</p>
</li>
</ul>
<p>To be more concrete, here are some scenarios which should not be allowed:</p>
<pre><code class="language-rust">// Not allowed: trans doesn't know if T: 'static:
trait Bad1 {}
impl&lt;T&gt; Bad1 for T {}
impl&lt;T: 'static&gt; Bad1 for T {}

// Not allowed: trans doesn't know if two refs have equal lifetimes:
trait Bad2&lt;U&gt; {}
impl&lt;T, U&gt; Bad2&lt;U&gt; for T {}
impl&lt;'a, T, U&gt; Bad2&lt;&amp;'b U&gt; for &amp;'a T {}</code></pre>
<p>But simply <em>naming</em> a lifetime that must exist, without <em>constraining</em> it, is fine:</p>
<pre><code class="language-rust">// Allowed: specializes based on being *any* reference, regardless of lifetime
trait Good {}
impl&lt;T&gt; Good for T {}
impl&lt;'a, T&gt; Good for &amp;'a T {}</code></pre>
<p>In addition, it’s okay for lifetime constraints to show up as long as they aren’t part of specialization:</p>
<pre><code class="language-rust">// Allowed: *all* impls impose the 'static requirement; the dispatch is happening
// purely based on `Clone`
trait MustBeStatic {}
impl&lt;T: 'static&gt; MustBeStatic for T {}
impl&lt;T: 'static + Clone&gt; MustBeStatic for T {}</code></pre>
<h5 id="going-down-the-rabbit-hole"><a class="header" href="#going-down-the-rabbit-hole">Going down the rabbit hole</a></h5>
<p>Unfortunately, we cannot easily rule out the undesirable lifetime-dependent specializations, because they can be “hidden” behind innocent-looking trait bounds that can even cross crates:</p>
<pre><code class="language-rust">////////////////////////////////////////////////////////////////////////////////
// Crate marker
////////////////////////////////////////////////////////////////////////////////

trait Marker {}
impl Marker for u32 {}

////////////////////////////////////////////////////////////////////////////////
// Crate foo
////////////////////////////////////////////////////////////////////////////////

extern crate marker;

trait Foo {
    fn foo(&amp;self);
}

impl&lt;T&gt; Foo for T {
    default fn foo(&amp;self) {
        println!("Default impl");
    }
}

impl&lt;T: marker::Marker&gt; Foo for T {
    fn foo(&amp;self) {
        println!("Marker impl");
    }
}

////////////////////////////////////////////////////////////////////////////////
// Crate bar
////////////////////////////////////////////////////////////////////////////////

extern crate marker;

pub struct Bar&lt;T&gt;(T);
impl&lt;T: 'static&gt; marker::Marker for Bar&lt;T&gt; {}

////////////////////////////////////////////////////////////////////////////////
// Crate client
////////////////////////////////////////////////////////////////////////////////

extern crate foo;
extern crate bar;

fn main() {
    // prints: Marker impl
    0u32.foo();

    // prints: ???
    // the relevant specialization depends on the 'static lifetime
    bar::Bar("Activate the marker!").foo();
}</code></pre>
<p>The problem here is that all of the crates in isolation look perfectly innocent. The code in <code>marker</code>, <code>bar</code> and <code>client</code> is accepted today. It’s only when these crates are plugged together that a problem arises – you end up with a specialization based on a <code>'static</code> lifetime. And the <code>client</code> crate may not even be aware of the existence of the <code>marker</code> crate.</p>
<p>If we make this kind of situation a hard error, we could easily end up with a scenario in which plugging together otherwise-unrelated crates is <em>impossible</em>.</p>
<h5 id="proposal-ask-forgiveness-rather-than-permission"><a class="header" href="#proposal-ask-forgiveness-rather-than-permission">Proposal: ask forgiveness, rather than permission</a></h5>
<p>So what do we do? There seem to be essentially two avenues:</p>
<ol>
<li>
<p>Be maximally permissive in the impls you can write, and then just ignore lifetime information in dispatch. We can generate a warning when this is happening, though in cases like the above, it may be talking about traits that the client is not even aware of. The assumption here is that these “missed specializations” will be extremely rare, so better not to impose a burden on everyone to rule them out.</p>
</li>
<li>
<p>Try, somehow, to prevent you from writing impls that appear to dispatch based on lifetimes. The most likely way of doing that is to somehow flag a trait as “lifetime-dependent”. If a trait is lifetime-dependent, it can have lifetime-sensitive impls (like ones that apply only to <code>'static</code> data), but it cannot be used when writing specialized impls of another trait.</p>
</li>
</ol>
<p>The downside of (2) is that it’s an additional knob that all trait authors have to think about. That approach is sketched in more detail in the Alternatives section.</p>
<p>What this RFC proposes is to follow approach (1), at least during the initial experimentation phase. That’s the easiest way to gain experience with specialization and see to what extent lifetime-dependent specializations accidentally arise in practice. If they are indeed rare, it seems much better to catch them via a lint then to force the entire world of traits to be explicitly split in half.</p>
<p>To begin with, this lint should be an error by default; we want to get feedback as to how often this is happening before any stabilization.</p>
<h6 id="what-this-means-for-the-programmer"><a class="header" href="#what-this-means-for-the-programmer">What this means for the programmer</a></h6>
<p>Ultimately, the goal of the “just ignore lifetimes for specialization” approach is to reduce the number of knobs in play. The programmer gets to use both lifetime bounds and specialization freely.</p>
<p>The problem, of course, is that when using the two together you can get surprising dispatch results:</p>
<pre><code class="language-rust">trait Foo {
    fn foo(&amp;self);
}

impl&lt;T&gt; Foo for T {
    default fn foo(&amp;self) {
        println!("Default impl");
    }
}

impl Foo for &amp;'static str {
    fn foo(&amp;self) {
        println!("Static string slice: {}", self);
    }
}

fn main() {
    // prints "Default impl", but generates a lint saying that
    // a specialization was missed due to lifetime dependence.
    "Hello, world!".foo();
}</code></pre>
<p>Specialization is refusing to consider the second impl because it imposes lifetime constraints not present in the more general impl. We don’t know whether these constraints hold when we need to generate the code, and we don’t want to depend on them because of the subtleties of region inference. But we alert the programmer that this is happening via a lint.</p>
<p>Sidenote: for such simple intracrate cases, we could consider treating the impls themselves more aggressively, catching that the <code>&amp;'static str</code> impl will never be used and refusing to compile it.</p>
<p>In the more complicated multi-crate example we saw above, the line</p>
<pre><code class="language-rust">bar::Bar("Activate the marker!").foo();</code></pre>
<p>would likewise print <code>Default impl</code> and generate a warning. In this case, the warning may be hard for the <code>client</code> crate author to understand, since the trait relevant for specialization – <code>marker::Marker</code> – belongs to a crate that hasn’t even been imported in <code>client</code>. Nevertheless, this approach seems friendlier than the alternative (discussed in Alternatives).</p>
<h5 id="an-algorithm-for-ignoring-lifetimes-in-dispatch"><a class="header" href="#an-algorithm-for-ignoring-lifetimes-in-dispatch">An algorithm for ignoring lifetimes in dispatch</a></h5>
<p>Although approach (1) may seem simple, there are some subtleties in handling cases like the following:</p>
<pre><code class="language-rust">trait Foo { ... }
impl&lt;T: 'static&gt; Foo for T { ... }
impl&lt;T: 'static + Clone&gt; Foo for T { ... }</code></pre>
<p>In this “ignore lifetimes for specialization” approach, we still want the above specialization to work, because <em>all</em> impls in the specialization family impose the same lifetime constraints. The dispatch here purely comes down to <code>T: Clone</code> or not. That’s in contrast to something like this:</p>
<pre><code class="language-rust">trait Foo { ... }
impl&lt;T&gt; Foo for T { ... }
impl&lt;T: 'static + Clone&gt; Foo for T { ... }</code></pre>
<p>where the difference between the impls includes a nontrivial lifetime constraint (the <code>'static</code> bound on <code>T</code>). The second impl should effectively be dead code: we should never dispatch to it in favor of the first impl, because that depends on lifetime information that we don’t have available in trans (and don’t want to rely on in general, due to the way region inference works). We would instead lint against it (probably error by default).</p>
<p>So, how do we tell these two scenarios apart?</p>
<ul>
<li>
<p>First, we evaluate the impls normally, winnowing to a list of applicable impls.</p>
</li>
<li>
<p>Then, we attempt to determine specialization. For any pair of applicable impls <code>Parent</code> and <code>Child</code> (where <code>Child</code> specializes <code>Parent</code>), we do the following:</p>
<ul>
<li>
<p>Introduce as assumptions all of the where clauses of <code>Parent</code></p>
</li>
<li>
<p>Attempt to prove that <code>Child</code> definitely applies, using these assumptions. <strong>Crucially</strong>, we do this test in a special mode: lifetime bounds are only considered to hold if they (1) follow from general well-formedness or (2) are directly assumed from <code>Parent</code>. That is, a constraint in <code>Child</code> that <code>T: 'static</code> has to follow either from some basic type assumption (like the type <code>&amp;'static T</code>) or from a similar clause in <code>Parent</code>.</p>
</li>
<li>
<p>If the <code>Child</code> impl cannot be shown to hold under these more stringent conditions, then we have discovered a lifetime-sensitive specialization, and can trigger the lint.</p>
</li>
<li>
<p>Otherwise, the specialization is valid.</p>
</li>
</ul>
</li>
</ul>
<p>Let’s do this for the two examples above.</p>
<p><strong>Example 1</strong></p>
<pre><code class="language-rust">trait Foo { ... }
impl&lt;T: 'static&gt; Foo for T { ... }
impl&lt;T: 'static + Clone&gt; Foo for T { ... }</code></pre>
<p>Here, if we think both impls apply, we’ll start by assuming that <code>T: 'static</code> holds, and then we’ll evaluate whether <code>T: 'static</code> and <code>T: Clone</code> hold. The first evaluation succeeds trivially from our assumption. The second depends on <code>T</code>, as you’d expect.</p>
<p><strong>Example 2</strong></p>
<pre><code class="language-rust">trait Foo { ... }
impl&lt;T&gt; Foo for T { ... }
impl&lt;T: 'static + Clone&gt; Foo for T { ... }</code></pre>
<p>Here, if we think both impls apply, we start with no assumption, and then evaluate <code>T: 'static</code> and <code>T: Clone</code>. We’ll fail to show the former, because it’s a lifetime-dependent predicate, and we don’t have any assumption that immediately yields it.</p>
<p>This should scale to less obvious cases, e.g. using <code>T: Any</code> rather than <code>T: 'static</code> – because when trying to prove <code>T: Any</code>, we’ll find we need to prove <code>T: 'static</code>, and then we’ll end up using the same logic as above. It also works for cases like the following:</p>
<pre><code class="language-rust">trait SometimesDep {}

impl SometimesDep for i32 {}
impl&lt;T: 'static&gt; SometimesDep for T {}

trait Spec {}
impl&lt;T&gt; Spec for T {}
impl&lt;T: SometimesDep&gt; Spec for T {}</code></pre>
<p>Using <code>Spec</code> on <code>i32</code> will not trigger the lint, because the specialization is justified without any lifetime constraints.</p>
<h3 id="default-impls"><a class="header" href="#default-impls">Default impls</a></h3>
<p>An interesting consequence of specialization is that impls need not (and in fact sometimes <em>cannot</em>) provide all of the items that a trait specifies. Of course, this is already the case with defaulted items in a trait – but as we’ll see, that mechanism can be seen as just a way of using specialization.</p>
<p>Let’s start with a simple example:</p>
<pre><code class="language-rust">trait MyTrait {
    fn foo(&amp;self);
    fn bar(&amp;self);
}

impl&lt;T: Clone&gt; MyTrait for T {
    default fn foo(&amp;self) { ... }
    default fn bar(&amp;self) { ... }
}

impl MyTrait for String {
    fn bar(&amp;self) { ... }
}</code></pre>
<p>Here, we’re acknowledging that the blanket impl has already provided definitions for both methods, so the impl for <code>String</code> can opt to just re-use the earlier definition of <code>foo</code>. This is one reason for the choice of the keyword <code>default</code>. Viewed this way, items defined in a specialized impl are optional overrides of those in overlapping blanket impls.</p>
<p>And, in fact, if we’d written the blanket impl differently, we could <em>force</em> the <code>String</code> impl to leave off <code>foo</code>:</p>
<pre><code class="language-rust">impl&lt;T: Clone&gt; MyTrait for T {
    // now `foo` is "final"
    fn foo(&amp;self) { ... }

    default fn bar(&amp;self) { ... }
}</code></pre>
<p>Being able to leave off items that are covered by blanket impls means that specialization is close to providing a finer-grained version of defaulted items in traits – one in which the defaults can become ever more refined as more is known about the input types to the traits (as described in the Motivation section). But to fully realize this goal, we need one other ingredient: the ability for the <em>blanket</em> impl itself to leave off some items. We do this by using the <code>default</code> keyword at the <code>impl</code> level:</p>
<pre><code class="language-rust">trait Add&lt;Rhs=Self&gt; {
    type Output;
    fn add(self, rhs: Rhs) -&gt; Self::Output;
    fn add_assign(&amp;mut self, rhs: Rhs);
}

default impl&lt;T: Clone, Rhs&gt; Add&lt;Rhs&gt; for T {
    fn add_assign(&amp;mut self, rhs: Rhs) {
        let tmp = self.clone() + rhs;
        *self = tmp;
    }
}</code></pre>
<p>A subsequent overlapping impl of <code>Add</code> where <code>Self: Clone</code> can choose to leave off <code>add_assign</code>, “inheriting” it from the partial impl above.</p>
<p>A key point here is that, as the keyword suggests, a <code>partial</code> impl may be incomplete: from the above code, you <em>cannot</em> assume that <code>T: Add&lt;T&gt;</code> for any <code>T: Clone</code>, because no such complete impl has been provided.</p>
<p>Defaulted items in traits are just sugar for a default blanket impl:</p>
<pre><code class="language-rust">trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (0, None)
    }
    // ...
}

// desugars to:

trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
    // ...
}

default impl&lt;T&gt; Iterator for T {
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (0, None)
    }
    // ...
}</code></pre>
<p>Default impls are somewhat akin to abstract base classes in object-oriented languages; they provide some, but not all, of the materials needed for a fully concrete implementation, and thus enable code reuse but cannot be used concretely.</p>
<p>Note that the semantics of <code>default impls</code> and defaulted items in traits is that both are implicitly marked <code>default</code> – that is, both are considered specializable. This choice gives a coherent mental model: when you choose <em>not</em> to employ a default, and instead provide your own definition, you are in effect overriding/specializing that code. (Put differently, you can think of default impls as abstract base classes).</p>
<p>There are a few important details to nail down with the design. This RFC proposes starting with the conservative approach of applying the general overlap rule to default impls, same as with complete ones. That ensures that there is always a clear definition to use when providing subsequent complete impls.  It would be possible, though, to relax this constraint and allow <em>arbitrary</em> overlap between default impls, requiring then whenever a complete impl overlaps with them, <em>for each item</em>, there is either a unique “most specific” default impl that applies, or else the complete impl provides its own definition for that item. Such a relaxed approach is much more flexible, probably easier to work with, and can enable more code reuse – but it’s also more complicated, and backwards-compatible to add on top of the proposed conservative approach.</p>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p>One frequent motivation for specialization is broader “expressiveness”, in particular providing a larger set of trait implementations than is possible today.</p>
<p>For example, the standard library currently includes an <code>AsRef</code> trait for “as-style” conversions:</p>
<pre><code class="language-rust">pub trait AsRef&lt;T&gt; where T: ?Sized {
    fn as_ref(&amp;self) -&gt; &amp;T;
}</code></pre>
<p>Currently, there is also a blanket implementation as follows:</p>
<pre><code class="language-rust">impl&lt;'a, T: ?Sized, U: ?Sized&gt; AsRef&lt;U&gt; for &amp;'a T where T: AsRef&lt;U&gt; {
    fn as_ref(&amp;self) -&gt; &amp;U {
        &lt;T as AsRef&lt;U&gt;&gt;::as_ref(*self)
    }
}</code></pre>
<p>which allows these conversions to “lift” over references, which is in turn important for making a number of standard library APIs ergonomic.</p>
<p>On the other hand, we’d also like to provide the following very simple blanket implementation:</p>
<pre><code class="language-rust">impl&lt;'a, T: ?Sized&gt; AsRef&lt;T&gt; for T {
    fn as_ref(&amp;self) -&gt; &amp;T {
        self
    }
}</code></pre>
<p>The current coherence rules prevent having both impls, however, because they can in principle overlap:</p>
<pre><code class="language-rust">AsRef&lt;&amp;'a T&gt; for &amp;'a T where T: AsRef&lt;&amp;'a T&gt;</code></pre>
<p>Another examples comes from the <code>Option</code> type, which currently provides two methods for unwrapping while providing a default value for the <code>None</code> case:</p>
<pre><code class="language-rust">impl&lt;T&gt; Option&lt;T&gt; {
    fn unwrap_or(self, def: T) -&gt; T { ... }
    fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T where F: FnOnce() -&gt; T { .. }
}</code></pre>
<p>The <code>unwrap_or</code> method is more ergonomic but <code>unwrap_or_else</code> is more efficient in the case that the default is expensive to compute. The original <a href="https://github.com/rust-lang/rfcs/pull/235">collections reform RFC</a> proposed a <code>ByNeed</code> trait that was rendered unworkable after unboxed closures landed:</p>
<pre><code class="language-rust">trait ByNeed&lt;T&gt; {
    fn compute(self) -&gt; T;
}

impl&lt;T&gt; ByNeed&lt;T&gt; for T {
    fn compute(self) -&gt; T {
        self
    }
}

impl&lt;F, T&gt; ByNeed&lt;T&gt; for F where F: FnOnce() -&gt; T {
    fn compute(self) -&gt; T {
        self()
    }
}

impl&lt;T&gt; Option&lt;T&gt; {
    fn unwrap_or&lt;U&gt;(self, def: U) where U: ByNeed&lt;T&gt; { ... }
    ...
}</code></pre>
<p>The trait represents any value that can produce a <code>T</code> on demand. But the above impls fail to compile in today’s Rust, because they overlap: consider <code>ByNeed&lt;F&gt; for F</code> where <code>F: FnOnce() -&gt; F</code>.</p>
<p>There are also some trait hierarchies where a subtrait completely subsumes the functionality of a supertrait. For example, consider <code>PartialOrd</code> and <code>Ord</code>:</p>
<pre><code class="language-rust">trait PartialOrd&lt;Rhs: ?Sized = Self&gt;: PartialEq&lt;Rhs&gt; {
    fn partial_cmp(&amp;self, other: &amp;Rhs) -&gt; Option&lt;Ordering&gt;;
}

trait Ord: Eq + PartialOrd&lt;Self&gt; {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
}</code></pre>
<p>In cases like this, it’s somewhat annoying to have to provide an impl for <em>both</em> <code>Ord</code> and <code>PartialOrd</code>, since the latter can be trivially derived from the former. So you might want an impl like this:</p>
<pre><code class="language-rust">impl&lt;T&gt; PartialOrd&lt;T&gt; for T where T: Ord {
    fn partial_cmp(&amp;self, other: &amp;T) -&gt; Option&lt;Ordering&gt; {
        Some(self.cmp(other))
    }
}</code></pre>
<p>But this blanket impl would conflict with a number of others that work to “lift” <code>PartialOrd</code> and <code>Ord</code> impls over various type constructors like references and tuples, e.g.:</p>
<pre><code class="language-rust">impl&lt;'a, A: ?Sized&gt; Ord for &amp;'a A where A: Ord {
    fn cmp(&amp;self, other: &amp; &amp;'a A) -&gt; Ordering { Ord::cmp(*self, *other) }
}

impl&lt;'a, 'b, A: ?Sized, B: ?Sized&gt; PartialOrd&lt;&amp;'b B&gt; for &amp;'a A where A: PartialOrd&lt;B&gt; {
    fn partial_cmp(&amp;self, other: &amp;&amp;'b B) -&gt; Option&lt;Ordering&gt; {
        PartialOrd::partial_cmp(*self, *other)
    }</code></pre>
<p>The case where they overlap boils down to:</p>
<pre><code class="language-rust">PartialOrd&lt;&amp;'a T&gt; for &amp;'a T where &amp;'a T: Ord
PartialOrd&lt;&amp;'a T&gt; for &amp;'a T where T: PartialOrd</code></pre>
<p>and there is no implication between either of the where clauses.</p>
<p>There are many other examples along these lines.</p>
<p>Unfortunately, <em>none</em> of these examples are permitted by the revised overlap rule in this RFC, because in none of these cases is one of the impls fully a “subset” of the other; the overlap is always partial.</p>
<p>It’s a shame to not be able to address these cases, but the benefit is a specialization rule that is very intuitive and accepts only very clear-cut cases. The Alternatives section sketches some different rules that are less intuitive but do manage to handle cases like those above.</p>
<p>If we allowed “relaxed” partial impls as described above, one could at least use that mechanism to avoid having to give a definition directly in most cases. (So if you had <code>T: Ord</code> you could write <code>impl PartialOrd for T {}</code>.)</p>
<h3 id="possible-extensions"><a class="header" href="#possible-extensions">Possible extensions</a></h3>
<p>It’s worth briefly mentioning a couple of mechanisms that one could consider adding on top of specialization.</p>
<h4 id="inherent-impls"><a class="header" href="#inherent-impls">Inherent impls</a></h4>
<p>It has long been folklore that inherent impls can be thought of as special, anonymous traits that are:</p>
<ul>
<li>Automatically in scope;</li>
<li>Given higher dispatch priority than normal traits.</li>
</ul>
<p>It is easiest to make this idea work out if you think of each inherent item as implicitly defining and implementing its own trait, so that you can account for examples like the following:</p>
<pre><code class="language-rust">struct Foo&lt;T&gt; { .. }

impl&lt;T&gt; Foo&lt;T&gt; {
    fn foo(&amp;self) { .. }
}

impl&lt;T: Clone&gt; Foo&lt;T&gt; {
    fn bar(&amp;self) { .. }
}</code></pre>
<p>In this example, the availability of each inherent item is dependent on a distinct <code>where</code> clause. A reasonable “desugaring” would be:</p>
<pre><code class="language-rust">#[inherent] // an imaginary attribute turning on the "special" treatment of inherent impls
trait Foo_foo&lt;T&gt; {
    fn foo(&amp;self);
}

#[inherent]
trait Foo_bar&lt;T&gt; {
    fn bar(&amp;self);
}

impl&lt;T&gt; Foo_foo&lt;T&gt; for Foo&lt;T&gt; {
    fn foo(&amp;self) { .. }
}

impl&lt;T: Clone&gt; Foo_bar&lt;T&gt; for Foo&lt;T&gt; {
    fn bar(&amp;self) { .. }
}</code></pre>
<p>With this idea in mind, it is natural to expect specialization to work for inherent impls, e.g.:</p>
<pre><code class="language-rust">impl&lt;T, I&gt; Vec&lt;T&gt; where I: IntoIterator&lt;Item = T&gt; {
    default fn extend(iter: I) { .. }
}

impl&lt;T&gt; Vec&lt;T&gt; {
    fn extend(slice: &amp;[T]) { .. }
}</code></pre>
<p>We could permit such specialization at the inherent impl level. The semantics would be defined in terms of the folklore desugaring above.</p>
<p>(Note: this example was chosen purposefully: it’s possible to use specialization at the inherent impl level to avoid refactoring the <code>Extend</code> trait as described in the Motivation section.)</p>
<p>There are more details about this idea in the appendix.</p>
<h4 id="super"><a class="header" href="#super">Super</a></h4>
<p>Continuing the analogy between specialization and inheritance, one could imagine a mechanism like <code>super</code> to access and reuse less specialized implementations when defining more specialized ones. While there’s not a strong need for this mechanism as part of this RFC, it’s worth checking that the specialization approach is at least compatible with <code>super</code>.</p>
<p>Fortunately, it is. If we take <code>super</code> to mean “the most specific impl overlapping with this one”, there is always a unique answer to that question, because all overlapping impls are totally ordered with respect to each other via specialization.</p>
<h4 id="extending-hrtbs"><a class="header" href="#extending-hrtbs">Extending HRTBs</a></h4>
<p>In the Motivation we mentioned the need to refactor the <code>Extend</code> trait to take advantage of specialization. It’s possible to work around that need by using specialization on inherent impls (and having the trait impl defer to the inherent one), but of course that’s a bit awkward.</p>
<p>For reference, here’s the refactoring:</p>
<pre><code class="language-rust">// Current definition
pub trait Extend&lt;A&gt; {
    fn extend&lt;T&gt;(&amp;mut self, iterable: T) where T: IntoIterator&lt;Item=A&gt;;
}

// Refactored definition
pub trait Extend&lt;A, T: IntoIterator&lt;Item=A&gt;&gt; {
    fn extend(&amp;mut self, iterable: T);
}</code></pre>
<p>One problem with this kind of refactoring is that you <em>lose</em> the ability to say that a type <code>T</code> is extendable <em>by an arbitrary iterator</em>, because every use of the <code>Extend</code> trait has to say precisely what iterator is supported. But the whole point of this exercise is to have a blanket impl of <code>Extend</code> for any iterator that is then specialized later.</p>
<p>This points to a longstanding limitation: the trait system makes it possible to ask for any number of specific impls to exist, but not to ask for a blanket impl to exist – <em>except</em> in the limited case of lifetimes, where higher-ranked trait bounds allow you to do this:</p>
<pre><code class="language-rust">trait Trait { .. }
impl&lt;'a&gt; Trait for &amp;'a MyType { .. }

fn use_all&lt;T&gt;(t: T) where for&lt;'a&gt; &amp;'a T: Trait { .. }</code></pre>
<p>We could extend this mechanism to cover type parameters as well, so that you could write:</p>
<pre><code class="language-rust">fn needs_extend_all&lt;T&gt;(t: T) where for&lt;I: IntoIterator&lt;Item=u8&gt;&gt; T: Extend&lt;u8, I&gt; { .. }</code></pre>
<p>Such a mechanism is out of scope for this RFC.</p>
<h4 id="refining-bounds-on-associated-types"><a class="header" href="#refining-bounds-on-associated-types">Refining bounds on associated types</a></h4>
<p>The design with <code>default</code> makes specialization of associated types an all-or-nothing affair, but it would occasionally be useful to say that all further specializations will at least guarantee some additional trait bound on the associated type. This is particularly relevant for the “efficient inheritance” use case. Such a mechanism can likely be added, if needed, later on.</p>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>Many of the more minor tradeoffs have been discussed in detail throughout. We’ll focus here on the big picture.</p>
<p>As with many new language features, the most obvious drawback of this proposal is the increased complexity of the language – especially given the existing complexity of the trait system. Partly for that reason, the RFC errs on the side of simplicity in the design wherever possible.</p>
<p>One aspect of the design that mitigates its complexity somewhat is the fact that it is entirely opt in: you have to write <code>default</code> in an impl in order for specialization of that item to be possible. That means that all the ways we have of reasoning about existing code still hold good. When you do opt in to specialization, the “obviousness” of the specialization rule should mean that it’s easy to tell at a glance which of two impls will be preferred.</p>
<p>On the other hand, the simplicity of this design has its own drawbacks:</p>
<ul>
<li>
<p>You have to lift out trait parameters to enable specialization, as in the <code>Extend</code> example above. Of course, this lifting can be hidden behind an additional trait, so that the end-user interface remains idiomatic.  The RFC mentions a few other extensions for dealing with this limitation – either by employing inherent item specialization, or by eventually generalizing HRTBs.</p>
</li>
<li>
<p>You can’t use specialization to handle some of the more “exotic” cases of overlap, as described in the Limitations section above. This is a deliberate trade, favoring simple rules over maximal expressiveness.</p>
</li>
</ul>
<p>Finally, if we take it as a given that we want to support some form of “efficient inheritance” as at least a programming pattern in Rust, the ability to use specialization to do so, while also getting all of its benefits, is a net simplifier. The full story there, of course, depends on the forthcoming companion RFC.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<h3 id="alternatives-to-specialization"><a class="header" href="#alternatives-to-specialization">Alternatives to specialization</a></h3>
<p>The main alternative to specialization in general is an approach based on negative bounds, such as the one outlined in an <a href="https://github.com/rust-lang/rfcs/pull/586">earlier RFC</a>. Negative bounds make it possible to handle many of the examples this proposal can’t (the ones in the Limitations section). But negative bounds are also fundamentally <em>closed</em>: they make it possible to perform a certain amount of specialization up front when defining a trait, but don’t easily support downstream crates further specializing the trait impls.</p>
<h3 id="alternative-specialization-designs"><a class="header" href="#alternative-specialization-designs">Alternative specialization designs</a></h3>
<h4 id="the-lattice-rule"><a class="header" href="#the-lattice-rule">The “lattice” rule</a></h4>
<p>The rule proposed in this RFC essentially says that overlapping impls must form <em>chains</em>, in which each one is strictly more specific than the last.</p>
<p>This approach can be generalized to <em>lattices</em>, in which partial overlap between impls is allowed, so long as there is an additional impl that covers precisely the area of overlap (the intersection). Such a generalization can support all of the examples mentioned in the Limitations section. Moving to the lattice rule is backwards compatible.</p>
<p>Unfortunately, the lattice rule (or really, any generalization beyond the proposed chain rule) runs into a nasty problem with our lifetime strategy. Consider the following:</p>
<pre><code class="language-rust">trait Foo {}
impl&lt;T, U&gt; Foo for (T, U) where T: 'static {}
impl&lt;T, U&gt; Foo for (T, U) where U: 'static {}
impl&lt;T, U&gt; Foo for (T, U) where T: 'static, U: 'static {}</code></pre>
<p>The problem is, if we allow this situation to go through typeck, by the time we actually generate code in trans, <em>there is no possible impl to choose</em>. That is, we do not have enough information to specialize, but we also don’t know which of the (overlapping) unspecialized impls actually applies. We can address this problem by making the “lifetime dependent specialization” lint issue a hard error for such intersection impls, but that means that certain compositions will simply not be allowed (and, as mentioned before, these compositions might involve traits, types, and impls that the programmer is not even aware of).</p>
<p>The limitations that the lattice rule addresses are fairly secondary to the main goals of specialization (as laid out in the Motivation), and so, since the lattice rule can be added later, the RFC sticks with the simple chain rule for now.</p>
<h4 id="explicit-ordering"><a class="header" href="#explicit-ordering">Explicit ordering</a></h4>
<p>Another, perhaps more palatable alternative would be to take the specialization rule proposed in this RFC, but have some other way of specifying precedence when that rule can’t resolve it – perhaps by explicit priority numbering. That kind of mechanism is usually noncompositional, but due to the orphan rule, it’s a least a crate-local concern. Like the alternative rule above, it could be added backwards compatibly if needed, since it only enables new cases.</p>
<h4 id="singleton-non-default-wins"><a class="header" href="#singleton-non-default-wins">Singleton non-default wins</a></h4>
<p>@pnkfelix suggested the following rule, which allows overlap so long as there is a unique non-default item.</p>
<blockquote>
<p>For any given type-based lookup, either:</p>
<ol start="0">
<li>
<p>There are no results (error)</p>
</li>
<li>
<p>There is only one lookup result, in which case we’re done (regardless of whether it is tagged as default or not),</p>
</li>
<li>
<p>There is a non-empty set of results with defaults, where exactly one result is non-default – and then that non-default result is the answer, <em>or</em></p>
</li>
<li>
<p>There is a non-empty set of results with defaults, where 0 or &gt;1 results are non-default (and that is an error).</p>
</li>
</ol>
</blockquote>
<p>This rule is arguably simpler than the one proposed in this RFC, and can accommodate the examples we’ve presented throughout. It would also support some of the cases this RFC cannot, because the default/non-default distinction can be used to specify an ordering between impls when the subset ordering fails to do so. For that reason, it is not forward-compatible with the main proposal in this RFC.</p>
<p>The downsides are:</p>
<ul>
<li>
<p>Because actual dispatch occurs at monomorphization, errors are generated quite late, and only at use sites, not impl sites. That moves traits much more in the direction of C++ templates.</p>
</li>
<li>
<p>It’s less scalable/compositional: this alternative design forces the “specialization hierarchy” to be flat, in particular ruling out multiple levels of increasingly-specialized blanket impls.</p>
</li>
</ul>
<h3 id="alternative-handling-of-lifetimes"><a class="header" href="#alternative-handling-of-lifetimes">Alternative handling of lifetimes</a></h3>
<p>This RFC proposes a <em>laissez faire</em> approach to lifetimes: we let you write whatever impls you like, then warn you if some of them are being ignored because the specialization is based purely on lifetimes.</p>
<p>The main alternative approach is to make a more “principled” distinction between two kinds of traits: those that can be used as constraints in specialization, and those whose impls can be lifetime dependent. Concretely:</p>
<pre><code class="language-rust">#[lifetime_dependent]
trait Foo {}

// Only allowed to use 'static here because of the lifetime_dependent attribute
impl Foo for &amp;'static str {}

trait Bar { fn bar(&amp;self); }
impl&lt;T&gt; Bar for T {
    // Have to use `default` here to allow specialization
    default fn bar(&amp;self) {}
}

// CANNOT write the following impl, because `Foo` is lifetime_dependent
// and Bar is not.
//
// NOTE: this is what I mean by *using* a trait in specialization;
// we are trying to say a specialization applies when T: Foo holds
impl&lt;T: Foo&gt; Bar for T {
    fn bar(&amp;self) { ... }
}

// CANNOT write the following impl, because `Bar` is not lifetime_dependent
impl Bar for &amp;'static str {
    fn bar(&amp;self) { ... }
}</code></pre>
<p>There are several downsides to this approach:</p>
<ul>
<li>
<p>It forces trait authors to consider a rather subtle knob for every trait they write, choosing between two forms of expressiveness and dividing the world accordingly. The last thing the trait system needs is another knob.</p>
</li>
<li>
<p>Worse still, changing the knob in either direction is a breaking change:</p>
<ul>
<li>
<p>If a trait gains a <code>lifetime_dependent</code> attribute, any impl of a different trait that used it to specialize would become illegal.</p>
</li>
<li>
<p>If a trait loses its <code>lifetime_dependent</code> attribute, any impl of that trait that was lifetime dependent would become illegal.</p>
</li>
</ul>
</li>
<li>
<p>It hobbles specialization for some existing traits in <code>std</code>.</p>
</li>
</ul>
<p>For the last point, consider <code>From</code> (which is tied to <code>Into</code>). In <code>std</code>, we have the following important “boxing” impl:</p>
<pre><code class="language-rust">impl&lt;'a, E: Error + 'a&gt; From&lt;E&gt; for Box&lt;Error + 'a&gt;</code></pre>
<p>This impl would necessitate <code>From</code> (and therefore, <code>Into</code>) being marked <code>lifetime_dependent</code>. But these traits are very likely to be used to describe specializations (e.g., an impl that applies when <code>T: Into&lt;MyType&gt;</code>).</p>
<p>There does not seem to be any way to consider such impls as lifetime-independent, either, because of examples like the following:</p>
<pre><code class="language-rust">// If we consider this innocent...
trait Tie {}
impl&lt;'a, T: 'a&gt; Tie for (T, &amp;'a u8)

// ... we get into trouble here
trait Foo {}
impl&lt;'a, T&gt; Foo for (T, &amp;'a u8)
impl&lt;'a, T&gt; Foo for (T, &amp;'a u8) where (T, &amp;'a u8): Tie</code></pre>
<p>All told, the proposed <em>laissez faire</em> seems a much better bet in practice, but only experience with the feature can tell us for sure.</p>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<p>All questions from the RFC discussion and prototype have been resolved.</p>
<h2 id="appendix"><a class="header" href="#appendix">Appendix</a></h2>
<h3 id="more-details-on-inherent-impls"><a class="header" href="#more-details-on-inherent-impls">More details on inherent impls</a></h3>
<p>One tricky aspect for specializing inherent impls is that, since there is no explicit trait definition, there is no general signature that each definition of an inherent item must match. Thinking about <code>Vec</code> above, for example, notice that the two signatures for <code>extend</code> look superficially different, although it’s clear that the first impl is the more general of the two.</p>
<p>It’s workable to use a very simple-minded conceptual desugaring: each item desugars into a distinct trait, with type parameters for e.g. each argument and the return type. All concrete type information then emerges from desugaring into impl blocks. Thus, for example:</p>
<pre><code>impl&lt;T, I&gt; Vec&lt;T&gt; where I: IntoIterator&lt;Item = T&gt; {
    default fn extend(iter: I) { .. }
}

impl&lt;T&gt; Vec&lt;T&gt; {
    fn extend(slice: &amp;[T]) { .. }
}

// Desugars to:

trait Vec_extend&lt;Arg, Result&gt; {
    fn extend(Arg) -&gt; Result;
}

impl&lt;T, I&gt; Vec_extend&lt;I, ()&gt; for Vec&lt;T&gt; where I: IntoIterator&lt;Item = T&gt; {
    default fn extend(iter: I) { .. }
}

impl&lt;T&gt; Vec_extend&lt;&amp;[T], ()&gt; for Vec&lt;T&gt; {
    fn extend(slice: &amp;[T]) { .. }
}
</code></pre>
<p>All items of a given name must desugar to the same trait, which means that the number of arguments must be consistent across all impl blocks for a given <code>Self</code> type. In addition, we’d require that <em>all of the impl blocks overlap</em> (meaning that there is a single, most general impl). Without these constraints, we would implicitly be permitting full-blown overloading on both arity and type signatures. For the time being at least, we want to restrict overloading to explicit uses of the trait system, as it is today.</p>
<p>This “desugaring” semantics has the benefits of allowing inherent item specialization, and also making it <em>actually</em> be the case that inherent impls are really just implicit traits – unifying the two forms of dispatch. Note that this is a breaking change, since examples like the following are (surprisingly!) allowed today:</p>
<pre><code class="language-rust">struct Foo&lt;A, B&gt;(A, B);

impl&lt;A&gt; Foo&lt;A,A&gt; {
    fn foo(&amp;self, _: u32) {}
}

impl&lt;A,B&gt; Foo&lt;A,B&gt; {
    fn foo(&amp;self, _: bool) {}
}

fn use_foo&lt;A, B&gt;(f: Foo&lt;A,B&gt;) {
    f.foo(true)
}</code></pre>
<p>As has been proposed <a href="https://internals.rust-lang.org/t/pre-rfc-adjust-default-object-bounds/2199/">elsewhere</a>, this “breaking change” could be made available through a feature flag that must be used even after stabilization (to opt in to specialization of inherent impls); the full details will depend on pending revisions to <a href="https://github.com/rust-lang/rfcs/pull/1122">RFC 1122</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="1201-naked-fns.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="1211-mir.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="1201-naked-fns.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="1211-mir.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
