<!DOCTYPE HTML>
<html lang="zh_CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>3467-unsafe-pinned - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-b61d75f0.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h2 id="unsafe_pinned"><a class="header" href="#unsafe_pinned"><code>unsafe_pinned</code></a></h2>
<ul>
<li>Feature Name: <code>unsafe_pinned</code></li>
<li>Start Date: 2022-11-05</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/3467">rust-lang/rfcs#3467</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/125735">rust-lang/rust#125735</a></li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Add a type <code>UnsafePinned</code> that indicates to the compiler that this field is “pinned” and there might be pointers elsewhere that point to the same memory. This means, in particular, that <code>&amp;mut UnsafePinned</code> is not necessarily a unique pointer, and thus the compiler cannot just make aliasing assumptions. However, <code>&amp;mut UnsafePinned</code> can still be <code>mem::swap</code>ed, so this is not a free ticket for arbitrary aliasing of mutable references. You need to use mechanisms such as <code>Pin</code> to ensure that mutable references cannot be used in incorrect ways by clients.</p>
<p>This type is then used in generator lowering, finally fixing <a href="https://github.com/rust-lang/rust/issues/63818">#63818</a>.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Let’s say you want to write a type with a self-referential pointer:</p>
<pre><code class="language-rust">#![feature(negative_impls)]
use std::ptr;
use std::pin::{pin, Pin};

pub struct S {
    data: i32,
    ptr_to_data: *mut i32,
}

impl !Unpin for S {}

impl S {
    pub fn new() -&gt; Self {
        S { data: 42, ptr_to_data: ptr::null_mut() }
    }

    pub fn get_data(self: Pin&lt;&amp;mut Self&gt;) -&gt; i32 {
        // SAFETY: We're not moving anything.
        let this = unsafe { Pin::get_unchecked_mut(self) };
        if this.ptr_to_data.is_null() {
            this.ptr_to_data = ptr::addr_of_mut!(this.data);
        }
        // SAFETY: if the pointer is non-null, then we are pinned and it points to the `data` field.
        unsafe { this.ptr_to_data.read() }
    }

    pub fn set_data(self: Pin&lt;&amp;mut Self&gt;, data: i32) {
        // SAFETY: We're not moving anything.
        let this = unsafe { Pin::get_unchecked_mut(self) };
        if this.ptr_to_data.is_null() {
            this.ptr_to_data = ptr::addr_of_mut!(this.data);
        }
        // SAFETY: if the pointer is non-null, then we are pinned and it points to the `data` field.
        unsafe { this.ptr_to_data.write(data) }
    }
}

fn main() {
    let mut s = pin!(S::new());
    s.as_mut().set_data(42);
    println!("{}", s.as_mut().get_data());
}</code></pre>
<p>This kind of code is implicitly generated by rustc all the time when an <code>async fn</code> has a local variable of reference type that is live across a yield point. The problem is that this code has UB under our aliasing rules: the <code>&amp;mut S</code> inside the <code>self</code> argument of <code>get_data</code> aliases with <code>ptr_to_data</code>! (If you run this code in Miri, remove the <code>impl !Unpin</code> to see the UB. Miri treats <code>Unpin</code> as magic as otherwise the entire async ecosystem would cause errors. But that is not how <code>Unpin</code> was actually designed.)</p>
<p>This simple code only has UB under Stacked Borrows but not under the LLVM aliasing rules; more complex variants of this – still in the realm of what <code>async fn</code> generates – also have UB under the LLVM aliasing rules.</p>
<details>
<summary>A more complex variant</summary>
<p>The following roughly corresponds to a generator with this code:</p>
<pre><code class="language-rust">let mut data = 0;
let ptr_to_data = &amp;mut data;
yield;
*ptr_to_data = 42;
println!("{}", data);
return;</code></pre>
<p>When implemented by hand, it looks as follows, and causes aliasing issues:</p>
<pre><code class="language-rust">#![feature(negative_impls)]
use std::ptr;
use std::pin::{pin, Pin};
use std::task::Poll;

pub struct S {
    state: i32,
    data: i32,
    ptr_to_data: *mut i32,
}

impl !Unpin for S {}

impl S {
    pub fn new() -&gt; Self {
        S { state: 0, data: 0, ptr_to_data: ptr::null_mut() }
    }

    fn poll(self: Pin&lt;&amp;mut Self&gt;) -&gt; Poll&lt;()&gt; {
        // SAFETY: We're not moving anything.
        let this = unsafe { Pin::get_unchecked_mut(self) };
        match this.state {
            0 =&gt; {
                // The first time, set up the pointer.
                this.ptr_to_data = ptr::addr_of_mut!(this.data);
                // Now yield.
                this.state += 1;
                Poll::Pending
            }
            1 =&gt; {
                // After coming back from the yield, write to the pointer.
                unsafe { this.ptr_to_data.write(42) };
                // And read our local variable `data`.
                // THIS IS UB! `this` is derived from the `noalias` pointer
                // `self` but we did a write to `this.data` in the previous
                // line when writing to `ptr_to_data`. The compiler is allowed
                // to reorder this and the previous line and then the output
                // would change.
                println!("{}", this.data);
                // Now yield and be done.
                this.state += 1;
                Poll::Ready(())
            }
            _ =&gt; unreachable!(),
        }
    }
}

fn main() {
    let mut s = pin!(S::new());
    while let Poll::Pending = s.as_mut().poll() {}
}</code></pre>
</details>
<br>
<p>Beyond self-referential types, a similar problem also comes up with intrusive linked lists: the nodes of such a list often live on the stack frames of the functions participating in the list, but also have incoming pointers from other list elements. When a function takes a mutable reference to its stack-allocated node, that will alias the pointers from the neighboring elements. <a href="https://github.com/rust-lang/rust/issues/114581">This</a> is an example of an intrusive list in the standard library that is breaking Rust’s aliasing rules. <code>Pin</code> is sometimes used to ensure that the list elements don’t just move elsewhere (which would invalidate those incoming pointers) and provide a safe API, but there still is the problem that an <code>&amp;mut Node</code> is actually not a unique pointer due to these aliases – so we need a way for the to opt-out of the aliasing rules.</p>
<br>
<p>The goal of this RFC is to offer a way of writing such self-referential types and intrusive collections without UB. We don’t want to change the rules for mutable references in general (that would also affect all the code that doesn’t do anything self-referential), instad we want to be able to tell the compiler that this code is doing funky aliasing and that should be taken into account for optimizations.</p>
<h2 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h2>
<p>To write this code in a UB-free way, wrap the fields that are <em>targets</em> of self-referential pointers in an <code>UnsafePinned</code>:</p>
<pre><code class="language-rust">pub struct S {
    data: UnsafePinned&lt;i32&gt;, // &lt;!---- here
    ptr_to_data: *mut i32,
}

impl S {
    pub fn new() -&gt; Self {
        S { data: UnsafePinned::new(42), ptr_to_data: ptr::null_mut() }
    }

    pub fn get_data(self: Pin&lt;&amp;mut Self&gt;) -&gt; i32 {
        // SAFETY: We're not moving anything.
        let this = unsafe { Pin::get_unchecked_mut(self) };
        if this.ptr_to_data.is_null() {
            this.ptr_to_data = UnsafePinned::raw_get_mut(ptr::addr_of_mut!(this.data));
        }
        // SAFETY: if the pointer is non-null, then we are pinned and it points to the `data` field.
        unsafe { this.ptr_to_data.read() }
    }

    pub fn set_data(self: Pin&lt;&amp;mut Self&gt;, data: i32) {
        // SAFETY: We're not moving anything.
        let this = unsafe { Pin::get_unchecked_mut(self) };
        if this.ptr_to_data.is_null() {
            this.ptr_to_data = UnsafePinned::raw_get_mut(ptr::addr_of_mut!(this.data));
        }
        // SAFETY: if the pointer is non-null, then we are pinned and it points to the `data` field.
        unsafe { this.ptr_to_data.write(data) }
    }
}</code></pre>
<p>This lets the compiler know that mutable references to <code>data</code> might still have aliases, and so optimizations cannot assume that no aliases exist. That’s entirely analogous to how <code>UnsafeCell</code> lets the compiler know that <em>shared</em> references to this field might undergo mutation.</p>
<p>However, what is <em>not</em> analogous is that <code>&amp;mut S</code>, when handed to safe code <em>you do not control</em>, must still be unique pointers! This is because of methods like <code>mem::swap</code> that can still assume that their two arguments are non-overlapping. (<code>mem::swap</code> on two <code>&amp;mut UnsafePinned&lt;i32&gt;</code> may soundly assume that they do not alias.) In other words, the safety invariant of <code>&amp;mut S</code> still requires full ownership of the entire memory range <code>S</code> is stored at; for the duration that a function holds on to the borrow, nobody else may read and write this memory. But again, this is a <em>safety invariant</em>; it only applies to safe code you do not control. You can write your own code handling <code>&amp;mut S</code> and as long as that code is careful not to make use of this memory in the wrong way, potential aliasing is fine.</p>
<p>To hand such references to safe code, use <code>Pin</code>: the type <code>Pin&lt;&amp;mut S&gt;</code> can be safely given to external code, since the <code>Pin</code> wrapper blocks access to operations like <code>mem::swap</code>.</p>
<p>Similarly, the intrusive linked list from the motivation can be fixed by wrapping the entire <code>UnsafeListEntry</code> in <code>UnsafePinned</code>.</p>
<h2 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h2>
<p><strong>API sketch:</strong></p>
<pre><code class="language-rust">/// The type `UnsafePinned&lt;T&gt;` lets unsafe code violate
/// the rule that `&amp;mut UnsafePinned&lt;T&gt;` may never alias anything else.
///
/// However, even if you define your type like `pub struct Wrapper(UnsafePinned&lt;...&gt;)`,
/// it is still very risky to have an `&amp;mut Wrapper` that aliases
/// anything else. Many functions that work generically on `&amp;mut T` assume that the
/// memory that stores `T` is uniquely owned (such as `mem::swap`). In other words,
/// while having aliasing with `&amp;mut Wrapper` is not immediate Undefined
/// Behavior, it is still unsound to expose such a mutable reference to code you do
/// not control! Techniques such as pinning via `Pin` are needed to ensure soundness.
///
/// Similar to `UnsafeCell`, `UnsafePinned` will not usually show up in the public
/// API of a library. It is an internal implementation detail of libraries that
/// need to support aliasing mutable references.
///
/// Further note that this does *not* lift the requirement that shared references
/// must be read-only! Use `UnsafeCell` for that.
///
/// This type blocks niches the same way `UnsafeCell` does.
#[lang = "unsafe_aliased"]
#[repr(transparent)]
struct UnsafePinned&lt;T: ?Sized&gt; {
    value: T,
}

/// When this type is used, that almost certainly means safe APIs need to use pinning
/// to avoid the aliases from becoming invalidated. Therefore let's mark this as `!Unpin`.
impl&lt;T&gt; !Unpin for UnsafePinned&lt;T&gt; {}

/// The type is `Copy` when `T` is to avoid people assuming that `Copy` implies there
/// is no `UnsafePinned` anywhere. (This is an issue with `UnsafeCell`: people use `Copy` bounds
/// to mean `Freeze`.) Given that there is no `unsafe impl Copy for ...`, this is also
/// the option that leaves the user more choices (as they can always wrap this in a `!Copy` type).
impl&lt;T: Copy&gt; Copy for UnsafePinned&lt;T&gt; {}
impl&lt;T: Copy&gt; Clone for UnsafePinned&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self { *self }
}

// `Send` and `Sync` are inherited from `T`. This is similar to `SyncUnsafeCell`, since
// we eventually concluded that `UnsafeCell` implicitly making things `!Sync` is sometimes
// unergonomic. A type that needs to be `!Send`/`!Sync` should really have an explicit
// opt-out itself, e.g. via an `PhantomData&lt;*mut T&gt;` or (one day) via `impl !Send`/`impl !Sync`.

impl&lt;T: ?Sized&gt; UnsafePinned&lt;T&gt; {
    /// Constructs a new instance of `UnsafePinned` which will wrap the specified
    /// value.
    pub fn new(value: T) -&gt; UnsafePinned&lt;T&gt; where T: Sized {
        UnsafePinned { value }
    }

    pub fn into_inner(self) -&gt; T where T: Sized {
        self.value
    }

    /// Get read-write access to the contents of an `UnsafePinned`.
    ///
    /// You should usually be using `get_mut_pinned` instead to explicitly track
    /// the fact that this memory is "pinned" due to there being aliases.
    pub fn get_mut_unchecked(&amp;mut self) -&gt; *mut T {
        ptr::addr_of_mut!(self.value)
    }

    /// Get read-write access to the contents of a pinned `UnsafePinned`.
    pub fn get_mut_pinned(self: Pin&lt;&amp;mut Self&gt;) -&gt; *mut T {
        // SAFETY: we're not using `get_unchecked_mut` to unpin anything
        unsafe { ptr::addr_of_mut!(self.get_unchecked_mut().value) }
    }

    /// Get read-only access to the contents of a shared `UnsafePinned`.
    /// Note that `&amp;UnsafePinned&lt;T&gt;` is read-only if `&amp;T` is read-only.
    /// This means that if there is mutation of the `T`, future reads from the
    /// `*const T` returned here are UB!
    ///
    /// ```rust
    /// unsafe {
    ///     let mut x = UnsafePinned::new(0);
    ///     let ref1 = &amp;mut *addr_of_mut!(x);
    ///     let ref2 = &amp;mut *addr_of_mut!(x);
    ///     let ptr = ref1.get(); // read-only pointer, assumes immutability
    ///     ref2.get_mut().write(1);
    ///     ptr.read(); // UB!
    /// }
    /// ```
    pub fn get(&amp;self) -&gt; *const T {
        self as *const _ as *const T
    }

    pub fn raw_get_mut(this: *mut Self) -&gt; *mut T {
        this as *mut T
    }

    pub fn raw_get(this: *const Self) -&gt; *const T {
        this as *const T
    }
}</code></pre>
<p>The comment about aliasing <code>&amp;mut</code> being “risky” refers to the fact that their safety invariant still asserts exclusive ownership. This implies that <code>duplicate</code> in the following example, while not causing immediate UB, is still unsound:</p>
<pre><code class="language-rust">pub struct S {
    data: UnsafePinned&lt;i32&gt;,
}

impl S {
    fn new(x: i32) -&gt; Self {
        S { data: UnsafePinned::new(x) }
    }

    fn duplicate&lt;'a&gt;(s: &amp;'a mut S) -&gt; (&amp;'a mut S, &amp;'a mut S) {
        let s1 = unsafe { (&amp;s).transmute_copy() };
        let s2 = s;
        (s1, s2)
    }
}</code></pre>
<p>The unsoundness is easily demonstrated by using safe code to cause UB:</p>
<pre><code class="language-rust">let mut s = S::new(42);
let (s1, s2) = s.duplicate(); // no UB
mem::swap(s1, s2); // UB</code></pre>
<p>We could even soundly make <code>get_mut_unchecked</code> return an <code>&amp;mut T</code>, given that the safety invariant is not affected by <code>UnsafePinned</code>. But that would probably not be useful and only cause confusion.</p>
<p>Here is a <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=e686152296347467f9c9b173ebd1e2d0">polyfill on current Rust</a> that uses the <code>Unpin</code> hack to achieve mostly the same effect as this API. (“Mostly” because a safe <code>impl Unpin for ...</code> can un-do the effect of this, which would not be the case with the real <code>UnsafePinned</code>.)</p>
<p><strong>Reference diff:</strong></p>
<pre><code class="language-diff">  * Breaking the [pointer aliasing rules]. `&amp;mut T` and `&amp;T` follow LLVM’s scoped
-   [noalias] model, except if the `&amp;T` contains an [`UnsafeCell&lt;U&gt;`].
+   [noalias] model, except if the `&amp;T` contains an [`UnsafeCell&lt;U&gt;`] or
+   the `&amp;mut T` contains an [`UnsafePinned&lt;U&gt;`].
</code></pre>
<p><strong>Async generator lowering changes:</strong></p>
<ul>
<li>Fields that represent local variables whose address is taken across a yield point must be wrapped in <code>UnsafePinned</code>.</li>
</ul>
<p><strong>rustc and Miri changes:</strong></p>
<ul>
<li>We have a <code>UnsafeUnpin</code> auto trait similar to <code>Freeze</code> that is implemented if the type does not contain any by-val <code>UnsafePinned</code>. This trait is an internal implementation detail and (for now) not exposed to users.</li>
<li><code>noalias</code> on mutable references is only emitted for <code>UnsafeUnpin</code> types. (This replaces the current hack where it is only emitted for <code>Unpin</code> types.)</li>
<li>Niches are blocked on <code>UnsafePinned</code>.</li>
<li>Miri will do <code>SharedReadWrite</code> retagging inside <code>UnsafePinned</code> similar to what it does inside <code>UnsafeCell</code> already. (This replaces the current <code>Unpin</code>-based hack.)</li>
</ul>
<h3 id="comparison-with-some-other-types-that-affect-aliasing"><a class="header" href="#comparison-with-some-other-types-that-affect-aliasing">Comparison with some other types that affect aliasing</a></h3>
<ul>
<li><code>UnsafeCell</code>: disables aliasing (and affects but does not fully disable dereferenceable) behind shared refs, i.e. <code>&amp;UnsafeCell&lt;T&gt;</code> is special. <code>UnsafeCell&lt;&amp;T&gt;</code> (by-val, fully owned) is not special at all and basically like <code>&amp;T</code>; <code>&amp;mut UnsafeCell&lt;T&gt;</code> is also not special. Safe wrappers around this type can expose mutability behind shared references, such as <code>&amp;RefCell&lt;T&gt;</code>.</li>
<li><code>UnsafePinned</code>: disables aliasing (and affects but does not fully disable dereferenceable) behind mutable refs, i.e. <code>&amp;mut UnsafePinned&lt;T&gt;</code> is special. <code>UnsafePinned&lt;&amp;mut T&gt;</code> (by-val, fully owned) is not special at all and basically like <code>&amp;mut T</code>; <code>&amp;UnsafePinned&lt;T&gt;</code> is also not special. Safe wrappers around this type can expose sharing that involves <em>pinned</em> mutable references, such as <code>Pin&lt;&amp;mut MyFuture&gt;</code>.</li>
<li><a href="https://github.com/rust-lang/rfcs/pull/3336"><code>MaybeDangling</code></a>: disables aliasing and dereferencable <em>of all references (and boxes) directly inside it</em>, i.e. <code>MaybeDangling&lt;&amp;[mut] T&gt;</code> is special. <code>&amp;[mut] MaybeDangling&lt;T&gt;</code> is not special at all and basically like <code>&amp;[mut] T</code>.</li>
</ul>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<ul>
<li>
<p>It’s yet another wrapper type adjusting our aliasing rules and very easy to mix up with <code>UnsafeCell</code> or <a href="https://github.com/rust-lang/rfcs/pull/3336"><code>MaybeDangling</code></a>. Furthermore, it is an extremely subtle wrapper type, as the <code>duplicate</code> example shows.</p>
</li>
<li>
<p><code>UnsafeUnpin</code> is a somewhat unfortunate twin to <code>Unpin</code>. The purpose of <code>UnsafeUnpin</code> really is only to search for <code>UnsafePinned</code> fields, so that we can use the trait solver to determine whether an <code>&amp;mut</code> reference gets <code>noalias</code> or not. The actual safety promise of <code>UnsafeUnpin</code> is likely going to be exactly the same as <code>Unpin</code>, but we can’t use a stable and safe trait to determine <code>noalias</code>: <code>impl UnsafeUnpin for T</code> would add the <code>noalias</code> back to <code>&amp;mut T</code>, and that can lead to very surprising aliasing issues as <a href="https://internals.rust-lang.org/t/surprising-soundness-trouble-around-pollfn/17484">the <code>poll_fn</code> debacle</a> showed. (Note that <code>PollFn</code> has already been fixed, but that doesn’t mean nobody will make similar mistakes in the future so it is worth discussing how the original, problematic <code>PollFn</code> would fare under this RFC.) Splitting up the traits partially mitigates such issues: after <code>impl&lt;T&gt; Unpin for PollFn&lt;T&gt;</code>, <code>PollFn&lt;T&gt;</code> is (in general) <code>Unpin + !UnsafeUnpin</code>. The known examples of UB that Miri found all were caused by bad aliasing assumptions, which no longer occur when the aliasing assumptions are tied to <code>UnsafeUnpin</code> rather than <code>Unpin</code>. Actually moving the <code>PollFn</code> would still cause problems (and that can be done in safe code since it implements <code>Unpin</code>), but now the chances of code causing UB are much reduced since one must <em>both</em> pin data that’s moved into a closure, and move that closure – even though the Rust compiler will not help prevent such moves, programmers thinking carefully about pinning are hopefully less likely to then try to move that closure. In conclusion, <code>Unpin + !UnsafeUnpin</code> types are somewhat foot-gunny but less foot-gunny than the status quo. Maybe in a future edition <code>Unpin</code> can be transitioned to an unsafe trait and then this situation can be re-evaluated; for now, <code>UnsafeUnpin</code> remains an unstable implementation detail similar to <code>Freeze</code>. (<code>UnsafeUnpin + !Unpin</code> types are harmless, one just loses the ability to call <code>Pin::deref_mut</code> for no good reason.)</p>
</li>
<li>
<p>It is unfortunate that <code>&amp;mut UnsafePinned</code> and <code>&amp;mut TypeThatContainsUnsafePinned</code> lose their no-alias assumptions even when they are not currently pinned. However, since pinning was implemented as a library concept, there’s not really any way the compiler can know whether an <code>&amp;mut UnsafePinned</code> is pinned or not – working with <code>Pin&lt;&amp;mut TypeThatContainsUnsafePinned&gt;</code> generally requires using <code>Pin::get_unchecked_mut</code> and <code>Pin::map_unchecked_mut</code>, which exposes <code>&amp;mut TypeThatContainsUnsafePinned</code> and <code>&amp;mut UnsafePinned</code> that still need to be considered aliased.</p>
</li>
</ul>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<p>The proposal in this RFC matches <a href="https://github.com/rust-lang/rust/issues/63818#issuecomment-526579977">what was discussed with the lang team a long time ago</a>.</p>
<p>However, of course one could imagine alternatives:</p>
<ul>
<li>
<p>Keep the status quo. The current sitaution is that we only make aliasing requirements on mutable references if the type they point to is <code>Unpin</code>. This is unsatisfying: <code>Unpin</code> was never meant to have this job. A consequence is that a stray <code>impl Unpin</code> on a <code>Wrapper&lt;T&gt;</code>-style type can <a href="https://internals.rust-lang.org/t/surprising-soundness-trouble-around-pollfn/17484/15">lead to subtle miscompilations</a> since it re-adds aliasing requirements for the inner <code>T</code>. Contrast this with the <code>UnsafeCell</code> situation, where it is not possible for (stable) code to just <code>impl Freeze for T</code> in the wrong way – <code>UnsafeCell</code> is <em>always</em> recognized by the compiler.</p>
<p>On the other hand, <code>UnsafePinned</code> is rather quirky in its behavior and having two marker traits (<code>UnsafeUnpin</code> and <code>Unpin</code>) might be too confusing, so sticking with <code>Unpin</code> might not be too bad in comparison.</p>
<p>If we do that, however, it seems preferrable to transition <code>Unpin</code> to an unsafe trait. There <em>is</em> a clear statement about the types’ invariants associated with <code>Unpin</code>, so an <code>impl Unpin</code> already comes with a proof obligation. It just happens to be the case that in a module without unsafe, one can always arrange all the pieces such that the proof obligation is satisifed. This is mostly a coincidence  and related to the fact that we don’t have safe field projections on <code>Pin</code>. That said, solving this also requires solving the trouble around <code>Drop</code> and <code>Pin</code>, where effectively an <code>impl Drop</code> does an implicit <code>get_mut_unchecked</code>, i.e., implicitly assumes the type is <code>Unpin</code>.</p>
</li>
<li>
<p><code>UnsafePinned</code> could affect aliasing guarantees <em>both</em> on mutable and shared references. This would avoid the currently rather subtle situation that arises when one of many aliasing <code>&amp;mut UnsafePinned&lt;T&gt;</code> is cast or coerced to <code>&amp;UnsafePinned&lt;T&gt;</code>: that is a read-only shared reference and all aliases must stop writing! It would make this type strictly more ‘powerful’ than <code>UnsafeCell</code> in the sense that replacing <code>UnsafeCell</code> by <code>UnsafePinned</code> would always be correct. (Under the RFC as written, <code>UnsafeCell</code> and <code>UnsafePinned</code> can be nested to remove aliasing requirements from both shared and mutable references.)</p>
<p>If we don’t do this, we could consider removing <code>get</code> since it seems too much like a foot-gun. But that makes shared references to <code>UnsafePinned</code> fairly pointless. Shared references to generators/futures are basically useless so it is unclear what the potential use-cases here are.</p>
</li>
<li>
<p>Instead of introducing a new type, we could say that <code>UnsafeCell</code> affects <em>both</em> shared and mutable references. That would lose some optimization potential on types like <code>&amp;mut Cell&lt;T&gt;</code>, but would avoid the footgun of coercing an <code>&amp;mut UnsafePinned&lt;T&gt;</code> to <code>&amp;UnsafePinned&lt;T&gt;</code>. That said, so far the author is not aware of Miri detecting code that would run into this footgun (and Miri is <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=aab417b535f7dbd266fbfe470ea208c7">able to detect such issues</a>).</p>
</li>
<li>
<p>We could entirely avoid all these problems by not having aliasing restrictions on mutable references. But that is completely against the direction Rust has had for 8 years now, and it would mean removing LLVM <code>noalias</code> annotations for mutable references (and likely boxes) entirely. That is sacrificing optimization potential for the common case in favor of simplifying niche cases such as self-referential structs – which is against the usual design philosophy of Rust.</p>
</li>
<li>
<p>Instead of adding a new type that needs to be used as <code>Pin&lt;&amp;mut UnsafePinned&lt;T&gt;&gt;</code>, can’t we just make <code>Pin&lt;&amp;mut T&gt;</code> special? The answer is no, because working with <code>Pin&lt;&amp;mut T&gt;</code> in unsafe code usually involves getting direct access to the <code>&amp;mut</code> and then using it “carefully”. But being careful is not enough when the compiler makes non-aliasing assumptions! We need to preserve the fact that the <code>&amp;mut T</code> may have aliases even after <code>Pin::get_unchecked_mut</code> was used and inside <code>Pin::map_unchecked_mut</code>. In a different universe where pinning is a first-class concept with native support for projections and no need for <code>get_unchecked_mut</code>, this might not have been required, but with pinning being introduced as a library type, there is no (currently known) alternative to <code>UnsafePinned</code>.</p>
</li>
</ul>
<p>In terms of rationale, the question that comes to mind first is <strong>why is this so different from <code>UnsafeCell</code>.</strong> <code>UnsafeCell</code> opts-out of read-only guarantees for shared references, can’t we just have a type that opts-out of uniqueness guarantees for mutable references? The answer is no, because mutable references have some universal operations that exploit their uniqueness – in particular, <code>mem::swap</code>. In contrast, there exists no operation available on all shared references that exploits their immutability. This is why we need pinning to make APIs around <code>UnsafePinned</code> actually sound.</p>
<h3 id="naming"><a class="header" href="#naming">Naming</a></h3>
<p>An earlier proposal suggested to call the type <code>UnsafeAliased</code>, since the type is not inherently tied to pinning. However, it is not possible to write sound wrappers around <code>UnsafeAliased</code> such that we can have aliasing <code>&amp;mut MyType</code>. One has to use pinning for that: <code>Pin&lt;&amp;mut MyType&gt;</code>. Because of that, the RFC proposes that we suggestively put pinning into the name of the type, so that people don’t confuse it with a general mechanism for aliasing mutable references. It is more like the core primitive behind pinning, where whenever a type is pinned that is caused by an <code>UnsafePinned</code> field somewhere inside it.</p>
<p>For instance, it may be tempting to use an <code>UnsafeAliased</code> type to mark a single field in some struct as “separately aliased”, and then a <code>Mutex&lt;Struct&gt;</code> would acquire ownership of the entire struct except for that field. However, due to <code>mem::swap</code>, that would not be sound. One cannot hand out an <code>&amp;mut</code> to such aliased memory as part of a safe-to-use abstraction – except by using pinning.</p>
<h2 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h2>
<p>This is somewhat like <code>UnsafeCell</code>, but for mutable instead of shared references.</p>
<p>Adding something like this to Rust has been discussed many times throughout the years. Here are some links for recent discussions:</p>
<ul>
<li><a href="https://rust-lang.zulipchat.com/#narrow/stream/136281-t-opsem/topic/UnsafeCellMut/near/308124014">Zulip, Nov 2022</a></li>
<li><a href="https://internals.rust-lang.org/t/an-alternative-to-the-current-unpin-hack-unsafealias/18810">IRLO, May 2023</a></li>
</ul>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<ul>
<li>Is there a better name than <code>UnsafePinned</code> for the type? What about the trait – <code>UnsafeUnpin</code> is awkward. Maybe <code>Unique</code> is better?</li>
<li>How do we transition code that relies on <code>Unpin</code> opting-out of aliasing guarantees to the new type? Here’s a plan: define the <code>PhantomPinned</code> type as <code>UnsafePinned&lt;()&gt;</code>. Places in the standard library that use <code>impl !Unpin for</code> and the generator lowering are adjusted to use <code>UnsafePinned</code> instead. Then as long as nobody outside the standard library used the unstable <code>impl !Unpin for</code>, switching the <code>noalias</code>-opt-out to the <code>UnsafeUnpin</code> trait is actually backwards compatible with the (never explicitly supported) <code>Unpin</code> hack! However, if we ever make <code>UnsafePinned</code> location-relevant (i.e., only data inside the <code>UnsafePinned</code> is allowed to have aliases), then unsafe code in the ecosystem needs to be adjusted. The justification for this is that currently this code relies on undocumented unstable behavior (using <code>!Unpin</code> to opt-out of aliasing guarantees), so we are in our right to declare it unsound. Of course we should give the ecosystem time to migrate to the new approach before we actually start doing optimizations that exploit this UB.</li>
<li>Relatedly, in which module should this type live?</li>
<li><code>Unpin</code> <a href="https://github.com/rust-lang/rust/pull/106180">also affects the <code>dereferenceable</code> attribute</a>, so the same would happen for this type. Is that something we want to guarantee, or do we hope to get back <code>dereferenceable</code> when better semantics for it materialize on the LLVM side?</li>
</ul>
<h2 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h2>
<ul>
<li>Similar to how we might want the ability to project from <code>&amp;UnsafeCell&lt;Struct&gt;</code> to <code>&amp;UnsafeCell&lt;Field&gt;</code>, the same kind of projection could also be interesting for <code>UnsafePinned</code>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="3463-crates-io-policy-update.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="3477-cargo-check-lang-policy.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="3463-crates-io-policy-update.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="3477-cargo-check-lang-policy.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
