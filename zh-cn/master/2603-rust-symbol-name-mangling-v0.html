<!DOCTYPE HTML>
<html lang="zh_CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2603-rust-symbol-name-mangling-v0 - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-b61d75f0.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Feature Name: N/A</li>
<li>Start Date: 2018-11-27</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2603">rust-lang/rfcs#2603</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/60705">rust-lang/rust#60705</a></li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This RFC proposes a new mangling scheme that describes what the symbol names generated by the Rust compiler look like. This new scheme has a number of advantages over the existing one which has grown over time without a clear direction. The new scheme is consistent, depends less on compiler internals, and the information it stores in symbol names can be decoded again which provides an improved experience for users of external tools that work with Rust symbol names.</p>
<p>Note that, at this point, the new mangling scheme would not be part of the language specification or the specification of a stable Rust ABI. In the future it <em>could</em> be part of both and it is designed to be stable and extensible; but for the time being it would still be an implementation detail of the Rust compiler.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Due to its ad-hoc nature, the compiler’s current name mangling scheme has a number of drawbacks:</p>
<ul>
<li>
<p>Information about generic parameters and other things is lost in the mangling process. One cannot extract the type arguments of a monomorphized function from its symbol name.</p>
</li>
<li>
<p>The current scheme is inconsistent: most paths use <a href="http://refspecs.linuxbase.org/cxxabi-1.86.html#mangling">Itanium ABI</a> style encoding, but some don’t.</p>
</li>
<li>
<p>The symbol names it generates can contain <code>.</code> characters which is not generally supported on all platforms. [<a href="https://sourceware.org/binutils/docs/as/Symbol-Names.html#Symbol-Names">1</a>] [<a href="https://github.com/rust-lang/rust/issues/54190">2</a>] [<a href="https://github.com/rust-lang/rust/issues/53912">3</a>]</p>
</li>
<li>
<p>It depends on compiler internals and its results cannot be replicated by another compiler implementation or external tool.</p>
</li>
</ul>
<p>The proposed scheme solves these problems:</p>
<ul>
<li>It encodes information about generic parameters in a reversible way.</li>
<li>It has a consistent definition that does not rely on pretty-printing certain language constructs.</li>
<li>It generates symbols that only consist of the characters <code>A-Z</code>, <code>a-z</code>, <code>0-9</code>, and <code>_</code>.</li>
<li>While the proposed scheme still contains things that are implementation defined it has a clearer path towards full name predictability in future.</li>
</ul>
<p>These properties should make it easier for third party tools to work with Rust binaries.</p>
<h2 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h2>
<p>The following section will lay out the requirements for a name mangling scheme and then introduce the actual scheme through a series of ever more complex examples.</p>
<h3 id="requirements-for-a-symbol-mangling-scheme"><a class="header" href="#requirements-for-a-symbol-mangling-scheme">Requirements for a Symbol Mangling Scheme</a></h3>
<p>A symbol mangling scheme has a few goals, one of them essential, the rest of them desirable. The essential one is:</p>
<ul>
<li>The scheme must provide an unambiguous string encoding for everything that can end up in a binary’s symbol table.</li>
</ul>
<p>“Unambiguous” means that no two distinct compiler-generated entities (that is, mostly object code for functions) must be mapped to the same symbol name. This disambiguation is the main purpose of the hash-suffix in the current, legacy mangling scheme. The scheme proposed here, on the other hand, achieves it in a way that allows to also satisfy a number of additional desirable properties of a mangling scheme:</p>
<ul>
<li>
<p>A mangled symbol should be <em>decodable</em> to some degree. That is, it is desirable to be able to tell which exact concrete instance of e.g. a polymorphic function a given symbol identifies. This is true for external tools, backtraces, or just people only having the binary representation of some piece of code available to them. With the current scheme, this kind of information gets lost in the magical hash-suffix.</p>
</li>
<li>
<p>A mangling scheme should be platform-independent. This is mainly achieved by restricting the character set to <code>A-Z</code>, <code>a-z</code>, <code>0-9</code>, <code>_</code>. All other characters might have special meaning in some context (e.g. <code>.</code> for MSVC <code>DEF</code> files) or are simply not supported (e.g. Unicode).</p>
</li>
<li>
<p>The scheme should be efficient, meaning that the symbols it produces are not unnecessarily long (because that takes up space in object files and means more work for the compiler and the linker). In addition, generating or demangling a symbol name should not be too computationally expensive.</p>
</li>
<li>
<p>When used as part of a stable ABI, it should be possible to predict the symbol name for a given source-level construct. For example, given the definition <code>fn foo&lt;T&gt;() { ... }</code>, the scheme should allow to construct, by hand, the symbol names for e.g. <code>foo&lt;u32&gt;</code> or <code>foo&lt;extern fn(i32, &amp;mut SomeStruct&lt;(char, &amp;str)&gt;, ...) -&gt; !&gt;()</code>. Since the current scheme generates its hash from the values of various compiler internal data structures, an alternative compiler implementation could not predict the symbol name, even for simple cases. Note that the scheme proposed here does not fulfill this requirement either (yet) as some things are still left to the compiler implementation.</p>
</li>
</ul>
<p>The RFC also has a couple of non-goals:</p>
<ul>
<li>
<p>The mangling scheme does not try to be compatible with an existing (e.g. C++) mangling scheme. While it might sound tempting to encode Rust symbols with an existing scheme, it is the author’s opinion that the actual benefits are small (C++ tools would not demangle to Rust syntax, demanglings would be hard to read) and at the same time supporting a Rust-specific scheme in existing tools seems quite feasible (many tools like GDB, LLDB, binutils, and valgrind already have specialized code paths for Rust symbols).</p>
</li>
<li>
<p>The RFC does not try to define a standardized <em>demangled</em> form for symbol names. It defines the mangled form and makes sure it can be demangled in an efficient manner but different demanglers still have some degree of freedom regarding how symbol names are presented to the user.</p>
</li>
</ul>
<h3 id="the-mangling-scheme-by-example"><a class="header" href="#the-mangling-scheme-by-example">The Mangling Scheme by Example</a></h3>
<p>This section will develop an overview of the mangling scheme by walking through a number of examples. We’ll start with the simplest case – and will see how that already involves things that might be surprising.</p>
<h4 id="free-standing-functions-and-statics"><a class="header" href="#free-standing-functions-and-statics">Free-standing Functions and Statics</a></h4>
<p>A free-standing function is fully identified via its absolute path. For example, the following function</p>
<pre><code class="language-rust">mod foo {
  fn bar() {}
}</code></pre>
<p>has the path <code>foo::bar</code> and <code>NN3foo3bar</code> is a possible mangling of that path that complies to the character set we are restricted to. Why this format with numbers embedded in it? It is a run-length encoding, similar to what the <a href="http://refspecs.linuxbase.org/cxxabi-1.86.html#mangling">Itanium C++ ABI</a> name mangling scheme uses for identifiers. The scheme proposed here will also use this format because it does not need termination tokens for identifiers (which are hard to come by with our limited character set).</p>
<p>Note that each component in the path (i.e. <code>foo</code> and <code>bar</code>) also has an accompanying <em>start-tag</em> (here <code>N</code>) at the beginning. This start-tag is needed in order for the syntax to be able to represent complex, nested structures as we will see later.</p>
<p>The symbol name above, unfortunately, does not unambiguously identify the function in every context. It is perfectly valid for another crate to also define <code>mod foo { fn bar() {} }</code> somewhere. So in order to avoid conflicts in such cases, the absolute path must always include the crate-id, as in <code>NNC7mycrate3foo3bar</code>. The crate-id has a <code>C</code> start-tag.</p>
<p>There is another possible ambiguity that we have to take care of. Rust has two distinct namespaces: the type and the value namespace. This leads to a path of the form <code>crate_id::foo::bar</code> not uniquely identifying the item <code>bar</code> because the following snippet is legal Rust code:</p>
<pre><code class="language-rust">fn foo() {
    fn bar() {}
}

mod foo {
    fn bar() {}
}</code></pre>
<p>The function <code>foo</code> lives in the value namespace while the module <code>foo</code> lives in the type namespace. They don’t interfere. In order to make the symbol names for the two distinct <code>bar</code> functions unique, we thus add a namespace identifier to the start-tag of components where necessary, as in <code>NvNvC7mycrate3foo3bar</code> for the first case and <code>NvNtC7mycrate3foo3bar</code> second case (notice the difference: <code>NvNv...</code> vs <code>NvNt...</code>).</p>
<p>There is one final case of name ambiguity that we have to take care of. Because of macro hygiene, multiple items with the same name can appear in the same context. The compiler internally disambiguates such names by augmenting them with a numeric index. For example, the first occurrence of the name <code>foo</code> within its parent is actually treated as <code>foo'0</code>, the second occurrence would be <code>foo'1</code>, the next <code>foo'2</code>, and so one. The mangling scheme will adopt this setup by prepending a disambiguation prefix to each identifier with a non-zero index. So if macro expansion would result in the following code:</p>
<pre><code class="language-rust">mod foo {
    fn bar'0() {}
    // The second `bar` function was introduced by macro expansion.
    fn bar'1() {}
}</code></pre>
<p>then we would encode the two functions symbols as <code>NvNtC7mycrate3foo3bar</code> and <code>NvNtC7mycrate3foos_3bar</code> respectively (note the <code>s_</code> prefix in the second case). A very similar disambiguation is needed for avoiding conflicts between crates of the same name but different versions. The same syntactic prefix is thus used for crate-id where we encode the crate disambiguator as in <code>NtNvCs1234_7mycrate3foo3bar</code>. Details on the shape of this prefix are provided in the reference-level description.</p>
<p>As opposed to C++ and other languages that support function overloading, we don’t need to include function parameter types in the symbol name. Rust does not allow two functions of the same name but different arguments.</p>
<p>The final symbol name for the function would also include the prefix <code>_R</code> that is common to all symbol names generated by this scheme:</p>
<pre><code>  _RNvNtCs1234_7mycrate3foo3bar
  &lt;&gt;^^^^^&lt;----&gt;&lt;------&gt;&lt;--&gt;&lt;--&gt;
   ||||||   |      |     |   |
   ||||||   |      |     |   +--- "bar" identifier
   ||||||   |      |     +------- "foo" identifier
   ||||||   |      +------------- "mycrate" identifier
   ||||||   +-------------------- disambiguator for "mycrate"
   |||||+------------------------ start-tag for "mycrate"
   ||||+------------------------- namespace tag for "foo"
   |||+-------------------------- start-tag for "foo"
   ||+--------------------------- namespace tag for "bar"
   |+---------------------------- start-tag for "bar"
   +----------------------------- common Rust symbol prefix
</code></pre>
<h4 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h4>
<p>Each monomorphization of a generic function has its own symbol name. The monomorphizations are disambiguated by the list of concrete generic arguments. These arguments are added to the symbol name by a pair of <code>I</code> start-tag at the beginning and a list of the actual arguments at the end. So the instance</p>
<pre><code class="language-rust">std::mem::align_of::&lt;f64&gt;</code></pre>
<p>would be mangled to</p>
<pre><code>_RINvNtC3std3mem8align_ofdE
  ^                      ^^
  |                      ||
  |                      |+--- end of argument list
  |                      +--- f64
  +--- start-tag
</code></pre>
<p>where <code>I</code> precedes the thing the arguments belong to, <code>d</code> designates <code>f64</code> and <code>E</code> ends the argument list. As we can see, we need to be able to represent all kinds of types that can be part of such an argument list. (In the future, when const generics get added to the language, we will also need to represent <em>values</em>) These kinds of types are:</p>
<ul>
<li>basic types (<code>char</code>, <code>()</code>, <code>str</code>, <code>!</code>, <code>i8</code>, <code>i16</code>, …)</li>
<li>reference and pointers types, shared, <code>mut</code> and <code>const</code></li>
<li>tuples</li>
<li>arrays, with and without fixed size (e.g. <code>[u8]</code>, <code>[u8; 17]</code>)</li>
<li>structs, enums, closures, and other named types, possibly with their own set of type arguments</li>
<li>function types such as <code>fn(&amp;i32) -&gt; u16</code></li>
<li><code>dyn</code> traits</li>
</ul>
<p>Basic types are all encoded via a single lower-case letter, like in the Itanium scheme. Named types are encoded as their absolute path (including arguments) like is done for function symbols. Composites like references, tuples, and function types all follow a simple grammar given in the reference-level explanation below. Here are some example manglings to get a general feel of what they look like:</p>
<ul>
<li><code>std::mem::align_of::&lt;usize&gt;</code>: <code>_RINvNtC3std3mem8align_ofjE</code></li>
<li><code>std::mem::align_of::&lt;&amp;char&gt;</code>: <code>_RINvNtC3std3mem8align_ofRcE</code></li>
<li><code>std::mem::align_of::&lt;std::mem::Discriminant&gt;</code>: <code>_RINvNtC3std3mem8align_ofNtNtC3std3mem12DiscriminantE</code></li>
<li><code>std::mem::align_of::&lt;&amp;mut (&amp;str,())&gt;</code>: <code>_RINvNtC3std3mem8align_ofQTReuEE</code></li>
</ul>
<p>There’s one more thing we have to take into account for generic functions: The compiler may produce “crate-local” copies of a monomorphization. That is, if there is a function <code>foo&lt;T&gt;</code> which gets used as <code>foo&lt;u32&gt;</code> in two different crates, the compiler (depending on the optimization level) might generate two distinct functions at the LLVM IR level, each with it’s own symbol. In order to support this without running into conflicts, symbol names for monomorphizations must include the id of the crate they are instantiated for. This scheme does this by appending an <code>&lt;crate-id&gt;</code> suffix to the symbol. So for example the mangling for <code>std::mem::align_of::&lt;usize&gt;</code> would actually look like this:</p>
<pre><code>_RINvNtC3std3mem8align_ofjEC3foo (for crate "foo")
_RINvNtC3std3mem8align_ofjEC3bar (for crate "bar")
</code></pre>
<h4 id="closures-and-closure-environments"><a class="header" href="#closures-and-closure-environments">Closures and Closure Environments</a></h4>
<p>The scheme needs to be able to generate symbol names for the function containing the code of a closure and it needs to be able to refer to the type of a closure if it occurs as a type argument. As closures don’t have a name, we need to generate one. The scheme proposes to use the namespace and disambiguation mechanisms already introduced above for this purpose. Closures get their own “namespace” (i.e. they are neither in the type nor the value namespace), and each closure has an empty name with a disambiguation index (like for macro hygiene) identifying them within their parent. The full name of a closure is then constructed like for any other named item:</p>
<pre><code class="language-rust">mod foo {
  fn bar(x: u32) {
    let a = |x| { x + 1 }; // local name: NC&lt;...&gt;0
    let b = |x| { x + 2 }; // local name: NC&lt;...&gt;s_0

    a(b(x))
  }
}
</code></pre>
<p>In the above example we have two closures, the one assigned to <code>a</code> and the one assigned to <code>b</code>. The first one would get the local name <code>NC&lt;...&gt;0</code> and the second one the name <code>NC&lt;...&gt;s_0</code>. The <code>0</code> signifies the length of their (empty) name. The <code>&lt;...&gt;</code> part is the path of the parent. The <code>C</code> is the namespace tag, analogous to the <code>v</code> tag for the value namespace. The <code>s_</code> for the second closure is the disambiguation index (index <code>0</code> is, again, encoded by not prepending a prefix). Their full names would then be <code>NCNvNtC7mycrate3foo3bar0</code> and <code>NCNvNtC7mycrate3foo3bars_0</code> respectively.</p>
<h4 id="methods"><a class="header" href="#methods">Methods</a></h4>
<p>Methods are nested within <code>impl</code> or <code>trait</code> items. As such it would be possible to construct their symbol names as paths like <code>my_crate::foo::{{impl}}::some_method</code> where <code>{{impl}}</code> somehow identifies the <code>impl</code> in question. Since <code>impl</code>s don’t have names, we’d have to use an indexing scheme like the one used for closures (and indeed, this is what the compiler does internally). Adding in generic arguments to, this would lead to symbol names looking like <code>my_crate::foo::impl'17::&lt;u32, char&gt;::some_method</code>.</p>
<p>However, in the opinion of the author these symbols are very hard to map back to the method they represent. Consider a module containing dozens of types, each with multiple <code>impl</code> blocks generated via <code>#[derive(...)]</code>. In order to find out which method a symbol maps to, one would have to count the number of handwritten <em>and</em> macro generated <code>impl</code> blocks in the module, and hope that one correctly guessed the number of <code>impl</code> blocks introduced by the given derive-macro (each macro invocation can introduce <code>0..n</code> such blocks). The name of the method might give a hint, but there are still likely to be dozens of methods named <code>clone</code>, <code>hash</code>, <code>eq</code>, et cetera.</p>
<p>The RFC therefore proposes to keep symbol names close to how methods are represented in error messages, that is:</p>
<ul>
<li><code>&lt;Foo&lt;u32, char&gt;&gt;::some_method</code> for inherent methods, and</li>
<li><code>&lt;Foo&lt;u32, char&gt; as SomeTrait&lt;Quux&gt;&gt;::some_method</code> for trait methods.</li>
</ul>
<p>This can be achieved by extending the definition of paths that we have used so far. Instead of the path root always being a crate-id, we now also allow a path to start with an <code>impl</code> production that contains the self-type and (for trait methods) the name of the trait being implemented.</p>
<p>Thus, this extended form of paths would have the following syntax:</p>
<pre><code>&lt;path&gt; = C &lt;identifier&gt;                      // crate-id root
       | M &lt;type&gt;                            // inherent impl root
       | X &lt;type&gt; &lt;path&gt;                     // trait impl root
       | N &lt;namespace&gt; &lt;path&gt; &lt;identifier&gt;   // nested path
       | I &lt;path&gt; {&lt;generic-arg&gt;} E          // generic arguments
</code></pre>
<p>Here are some examples for complete symbol names:</p>
<pre><code>&lt;mycrate::Foo&lt;u32&gt;&gt;::foo =&gt; _RNvMINtC7mycrate3FoomE3foo
&lt;u32 as mycrate::Foo&gt;::foo =&gt; _RNvXmNtC7mycrate3Foo3foo
&lt;mycrate::Foo&lt;u32&gt; as mycrate::Bar&lt;u64&gt;&gt;::foo =&gt; _RNvXINtC7mycrate3FoomEINtC7mycrate3BaryE3foo
</code></pre>
<h4 id="items-within-generic-impls"><a class="header" href="#items-within-generic-impls">Items Within Generic Impls</a></h4>
<p>In Rust one can define items within generic items, e.g. functions or impls, like in the following example:</p>
<pre><code class="language-rust">struct Foo&lt;T&gt;(T);

impl&lt;T&gt; From&lt;T&gt; for Foo&lt;T&gt; {
  fn from(x: T) -&gt; Self {
    static MSG: &amp;str = "...";
    panic!("{}", MSG)
  }
}</code></pre>
<p>The <code>MSG</code> here (or any other such nested definition) does not inherit the generic context from the <code>impl</code>. <code>MSG</code> is non-generic, and a function defined in its place would be too. The fully qualified name of <code>MSG</code>, according to our examples so far, is thus <code>&lt;mycrate::Foo&lt;_&gt; as std::convert::From&lt;_&gt;&gt;::from::MSG</code> and its symbol name:</p>
<pre><code>_RNvNvXINtC7mycrate3FoopEINtNtC3std7convert4FrompE4from3MSG
</code></pre>
<p>However, with trait specialization, this symbol can be ambiguous. Consider the following piece of code:</p>
<pre><code class="language-rust">struct Foo&lt;T&gt;(T);

impl&lt;T&gt; From&lt;T&gt; for Foo&lt;T&gt; {
  default fn from(x: T) -&gt; Self {
    static MSG: &amp;str = "...";
    panic!("{}", MSG)
  }
}

impl&lt;T: Default&gt; From&lt;T&gt; for Foo&lt;T&gt; {
  fn from(x: T) -&gt; Self {
    static MSG: &amp;str = "123";
    panic!("{}", MSG)
  }
}</code></pre>
<p>Notice that both <code>MSG</code> statics have the path <code>&lt;Foo&lt;_&gt; as From&lt;_&gt;&gt;::foo::MSG</code>. We somehow have to disambiguate the <code>impls</code>. We do so by adding the path of the <code>impl</code> to the symbol name.</p>
<pre><code>&lt;path&gt; = C &lt;identifier&gt;                      // crate-id root
       | M &lt;impl-path&gt; &lt;type&gt;                // inherent impl root
       | X &lt;impl-path&gt; &lt;type&gt; &lt;path&gt;         // trait impl root
       | N &lt;namespace&gt; &lt;path&gt; &lt;identifier&gt;   // nested path
       | I &lt;path&gt; {&lt;generic-arg&gt;} E          // generic arguments

&lt;impl-path&gt; = [&lt;disambiguator&gt;] &lt;path&gt;
</code></pre>
<p>The two symbol names would then look something like:</p>
<pre><code>_RNvNvXs2_C7mycrateINtC7mycrate3FoopEINtNtC3std7convert4FrompE4from3MSG
_RNvNvXs3_C7mycrateINtC7mycrate3FoopEINtNtC3std7convert4FrompE4from3MSG
       &lt;----------&gt;&lt;----------------&gt;&lt;-----------------------&gt;
        impl-path      self-type            trait-name
</code></pre>
<p>Like other disambiguation information, this path would usually not actually be shown by demanglers.</p>
<h4 id="unicode-identifiers"><a class="header" href="#unicode-identifiers">Unicode Identifiers</a></h4>
<p>Rust allows Unicode identifiers but our character set is restricted to ASCII alphanumerics, and <code>_</code>. In order to transcode the former to the latter, we use the same approach as Swift, which is: encode all non-ASCII identifiers via <a href="https://tools.ietf.org/html/rfc3492">Punycode</a>, a standardized and efficient encoding that keeps encoded strings in a rather human-readable format. So for example, the string</p>
<pre><code>"Gödel, Escher, Bach"
</code></pre>
<p>is encoded as</p>
<pre><code>"Gdel, Escher, Bach-d3b"
</code></pre>
<p>which, as opposed to something like <em>Base64</em>, still gives a pretty good idea of what the original string looked like.</p>
<p>Each component of a name, i.e. anything that starts with the number of bytes to read in the examples above, is encoded individually. Components encoded this way are augmented with a <code>u</code> prefix so that demanglers know that the identifier needs further decoding. As an example, the function:</p>
<pre><code class="language-rust">mod gödel {
  mod escher {
    fn bach() {}
  }
}</code></pre>
<p>would be mangled as:</p>
<pre><code>_RNvNtNtC7mycrateu8gdel_5qa6escher4bach
                 &lt;--------&gt;
              Unicode component
</code></pre>
<h4 id="compressionsubstitution"><a class="header" href="#compressionsubstitution">Compression/Substitution</a></h4>
<p>The length of symbol names has an influence on how much work the compiler, linker, and loader have to perform. The shorter the names, the better. At the same time, Rust’s generics can lead to rather long names (which are often not visible in the code because of type inference and <code>impl Trait</code>). For example, the return type of the following function:</p>
<pre><code class="language-rust">fn quux(s: Vec&lt;u32&gt;) -&gt; impl Iterator&lt;Item = (u32, usize)&gt; {
    s.into_iter()
     .map(|x| x + 1)
     .filter(|&amp;x| x &gt; 10)
     .zip(0..)
     .chain(iter::once((0, 0)))
}</code></pre>
<p>is</p>
<pre><code class="language-rust">std::iter::Chain&lt;
  std::iter::Zip&lt;
    std::iter::Filter&lt;
      std::iter::Map&lt;
        std::vec::IntoIter&lt;u32&gt;,
        [closure@src/main.rs:16:11: 16:18]&gt;,
      [closure@src/main.rs:17:14: 17:25]&gt;,
    std::ops::RangeFrom&lt;usize&gt;&gt;,
  std::iter::Once&lt;(u32, usize)&gt;&gt;</code></pre>
<p>It would make for a long symbol name if this type is used (maybe repeatedly) as a generic argument somewhere. C++ has the same problem with its templates; which is why the Itanium mangling introduces the concept of compression. If a component of a definition occurs more than once, it will not be repeated and instead be emitted as a substitution marker that allows to reconstruct which component it refers to. The scheme proposed here will use the same approach (but with a simpler definition).</p>
<p>The exact scheme will be described in detail in the reference level explanation below but it roughly works as follows: As a mangled symbol name is being built, we remember the position of every substitutable item in the output string, that is, we keep track of things a subsequent occurrence of which could be replaced by a back reference.</p>
<p>The things that are eligible for substitution are (1) all prefixes of paths (including the entire path itself), (2) all types except for basic types, and (3) type-level constants (array lengths and values passed to const generic params).</p>
<p>Here’s an example in order to illustrate the concept. The name</p>
<pre><code>std::iter::Chain&lt;std::iter::Zip&lt;std::vec::IntoIter&lt;u32&gt;, std::vec::IntoIter&lt;u32&gt;&gt;&gt;
</code></pre>
<p>is mangled to the following uncompressed string. The lines below show parts of the mangled string that already occurred before and can thus be replaced by a back reference. The number of at the beginning of each span given the 0-based byte position of where it occurred the first time.</p>
<pre><code>  0         10        20        30        40        50        60        70        80        90
_RINtNtC3std4iter5ChainINtNtC3std4iter3ZipINtNtC3std3vec8IntoItermEINtNtC3std3vec8IntoItermEEE
                            5----              5----                    5----
                          3-----------                                43---------
                                                                    41--------------------
                                                                   40-----------------------
</code></pre>
<p>The compiler is always supposed to use the longest replacement possible in order to achieve the best compression. The compressed symbol looks as follows:</p>
<pre><code>_RINtNtC3std4iter5ChainINtB2_3ZipINtNtB4_3vec8IntoItermEBt_EE
                          ^^^         ^^^               ^^^     back references
</code></pre>
<p>Back references have the form <code>B&lt;base-62-number&gt;_</code>.</p>
<h2 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h2>
<p>The reference-level explanation consists of three parts:</p>
<ol>
<li>A specification of the syntax mangled names conform to.</li>
<li>A specification of the compression scheme.</li>
<li>A mapping of Rust entities to the mangling syntax.</li>
</ol>
<p>For implementing a demangler, only the first two sections are of interest, that is, a demangler only needs to understand syntax and compression of names, but it does not have to care about how the compiler generates mangled names.</p>
<h3 id="syntax-of-mangled-names"><a class="header" href="#syntax-of-mangled-names">Syntax Of Mangled Names</a></h3>
<p>The syntax of mangled names is given in extended Backus-Naur form:</p>
<ul>
<li>Non-terminals are within angle brackets (as in <code>&lt;path&gt;</code>)</li>
<li>Terminals are within quotes (as in <code>"_R"</code>),</li>
<li>Optional parts are in brackets (as in <code>[&lt;disambiguator&gt;]</code>),</li>
<li>Repetition (zero or more times) is signified by curly braces (as in <code>{&lt;type&gt;}</code>)</li>
<li>Comments are marked with <code>//</code>.</li>
</ul>
<p>Mangled names conform to the following grammar:</p>
<pre><code>// The &lt;decimal-number&gt; specifies the encoding version.
&lt;symbol-name&gt; =
    "_R" [&lt;decimal-number&gt;] &lt;path&gt; [&lt;instantiating-crate&gt;] [&lt;vendor-specific-suffix&gt;]

&lt;path&gt; = "C" &lt;identifier&gt;                    // crate root
       | "M" &lt;impl-path&gt; &lt;type&gt;              // &lt;T&gt; (inherent impl)
       | "X" &lt;impl-path&gt; &lt;type&gt; &lt;path&gt;       // &lt;T as Trait&gt; (trait impl)
       | "Y" &lt;type&gt; &lt;path&gt;                   // &lt;T as Trait&gt; (trait definition)
       | "N" &lt;namespace&gt; &lt;path&gt; &lt;identifier&gt; // ...::ident (nested path)
       | "I" &lt;path&gt; {&lt;generic-arg&gt;} "E"      // ...&lt;T, U&gt; (generic args)
       | &lt;backref&gt;

// Path to an impl (without the Self type or the trait).
// The &lt;path&gt; is the parent, while the &lt;disambiguator&gt; distinguishes
// between impls in that same parent (e.g. multiple impls in a mod).
// This exists as a simple way of ensure uniqueness, and demanglers
// don't need to show it (unless the location of the impl is desired).
&lt;impl-path&gt; = [&lt;disambiguator&gt;] &lt;path&gt;

// The &lt;decimal-number&gt; is the length of the identifier in bytes.
// &lt;bytes&gt; is the identifier itself, and it's optionally preceded by "_",
// to separate it from its length - this "_" is mandatory if the &lt;bytes&gt;
// starts with a decimal digit, or "_", in order to keep it unambiguous.
// If the "u" is present then &lt;bytes&gt; is Punycode-encoded.
&lt;identifier&gt; = [&lt;disambiguator&gt;] &lt;undisambiguated-identifier&gt;
&lt;disambiguator&gt; = "s" &lt;base-62-number&gt;
&lt;undisambiguated-identifier&gt; = ["u"] &lt;decimal-number&gt; ["_"] &lt;bytes&gt;

// Namespace of the identifier in a (nested) path.
// It's an a-zA-Z character, with a-z reserved for implementation-internal
// disambiguation categories (and demanglers should never show them), while
// A-Z are used for special namespaces (e.g. closures), which the demangler
// can show in a special way (e.g. `NC...` as `...::{closure}`), or just
// default to showing the uppercase character.
&lt;namespace&gt; = "C"      // closure
            | "S"      // shim
            | &lt;A-Z&gt;    // other special namespaces
            | &lt;a-z&gt;    // internal namespaces

&lt;generic-arg&gt; = &lt;lifetime&gt;
              | &lt;type&gt;
              | "K" &lt;const&gt; // forward-compat for const generics

// An anonymous (numbered) lifetime, either erased or higher-ranked.
// Index 0 is always erased (can show as '_, if at all), while indices
// starting from 1 refer (as de Bruijn indices) to a higher-ranked
// lifetime bound by one of the enclosing &lt;binder&gt;s.
&lt;lifetime&gt; = "L" &lt;base-62-number&gt;

// Specify the number of higher-ranked (for&lt;...&gt;) lifetimes to bound.
// &lt;lifetime&gt; can then later refer to them, with lowest indices for
// innermost lifetimes, e.g. in `for&lt;'a, 'b&gt; fn(for&lt;'c&gt; fn(...))`,
// any &lt;lifetime&gt;s in ... (but not inside more binders) will observe
// the indices 1, 2, and 3 refer to 'c, 'b, and 'a, respectively.
// The number of bound lifetimes is value of &lt;base-62-number&gt; + 1.
&lt;binder&gt; = "G" &lt;base-62-number&gt;

&lt;type&gt; = &lt;basic-type&gt;
       | &lt;path&gt;                      // named type
       | "A" &lt;type&gt; &lt;const&gt;          // [T; N]
       | "S" &lt;type&gt;                  // [T]
       | "T" {&lt;type&gt;} "E"            // (T1, T2, T3, ...)
       | "R" [&lt;lifetime&gt;] &lt;type&gt;     // &amp;T
       | "Q" [&lt;lifetime&gt;] &lt;type&gt;     // &amp;mut T
       | "P" &lt;type&gt;                  // *const T
       | "O" &lt;type&gt;                  // *mut T
       | "F" &lt;fn-sig&gt;                // fn(...) -&gt; ...
       | "D" &lt;dyn-bounds&gt; &lt;lifetime&gt; // dyn Trait&lt;Assoc = X&gt; + Send + 'a
       | &lt;backref&gt;

&lt;basic-type&gt; = "a"      // i8
             | "b"      // bool
             | "c"      // char
             | "d"      // f64
             | "e"      // str
             | "f"      // f32
             | "h"      // u8
             | "i"      // isize
             | "j"      // usize
             | "l"      // i32
             | "m"      // u32
             | "n"      // i128
             | "o"      // u128
             | "s"      // i16
             | "t"      // u16
             | "u"      // ()
             | "v"      // ...
             | "x"      // i64
             | "y"      // u64
             | "z"      // !
             | "p"      // placeholder (e.g. for generic params), shown as _

// If the "U" is present then the function is `unsafe`.
// The return type is always present, but demanglers can
// choose to omit the ` -&gt; ()` by special-casing "u".
&lt;fn-sig&gt; = [&lt;binder&gt;] ["U"] ["K" &lt;abi&gt;] {&lt;type&gt;} "E" &lt;type&gt;

&lt;abi&gt; = "C"
      | &lt;undisambiguated-identifier&gt;

&lt;dyn-bounds&gt; = [&lt;binder&gt;] {&lt;dyn-trait&gt;} "E"
&lt;dyn-trait&gt; = &lt;path&gt; {&lt;dyn-trait-assoc-binding&gt;}
&lt;dyn-trait-assoc-binding&gt; = "p" &lt;undisambiguated-identifier&gt; &lt;type&gt;
&lt;const&gt; = &lt;type&gt; &lt;const-data&gt;
        | "p" // placeholder, shown as _
        | &lt;backref&gt;

// The encoding of a constant depends on its type. Integers use their value,
// in base 16 (0-9a-f), not their memory representation. Negative integer
// values are preceded with "n". The bool value false is encoded as `0_`, true
// value as `1_`. The char constants are encoded using their Unicode scalar
// value.
&lt;const-data&gt; = ["n"] {&lt;hex-digit&gt;} "_"

// &lt;base-62-number&gt; uses 0-9-a-z-A-Z as digits, i.e. 'a' is decimal 10 and
// 'Z' is decimal 61.
// "_" with no digits indicates the value 0, while any other value is offset
// by 1, e.g. "0_" is 1, "Z_" is 62, "10_" is 63, etc.
&lt;base-62-number&gt; = {&lt;0-9a-zA-Z&gt;} "_"

&lt;backref&gt; = "B" &lt;base-62-number&gt;

// We use &lt;path&gt; here, so that we don't have to add a special rule for
// compression. In practice, only a crate root is expected.
&lt;instantiating-crate&gt; = &lt;path&gt;

// There are no restrictions on the characters that may be used
// in the suffix following the `.` or `$`.
&lt;vendor-specific-suffix&gt; = ("." | "$") &lt;suffix&gt;
</code></pre>
<h4 id="namespace-tags"><a class="header" href="#namespace-tags">Namespace Tags</a></h4>
<p>Namespaces are identified by an implementation defined single character tag (the <code>&lt;namespace&gt;</code> production). Only closures (<code>C</code>) and shims (<code>S</code>) have a specific character assigned to them so that demanglers can reliable adjust their output accordingly. Other namespace tags have to be omitted or shown verbatim during demangling.</p>
<p>This is a concession to the compiler’s current implementation. While the language only knows two namespaces (the type and the value namespace), the compiler uses many more in some important data structures and disambiguation indices are assigned according to these internal data structures. So, in order not to force the compiler to waste processing time on re-constructing different disambiguation indices, the internal unspecified “namespaces” are used. This may change in the future.</p>
<h4 id="type-level-constants"><a class="header" href="#type-level-constants">Type-Level Constants</a></h4>
<p>As described above, the grammar encodes constant values via the <code>&lt;const-data&gt; = {&lt;hex-digit&gt;} "_"</code> production, where <code>{&lt;hex-digit&gt;}</code> is the numeric value of the constant, not its representation as bytes. Using the numeric value is platform independent but does not easily scale to non-integer data types.</p>
<p>In the future it is likely that Rust will support complex type-level constants (i.e. not just integers). This RFC suggests to develop a proper mangling for these as part of the future const-generics work, and, for now, only define a mangling for integer values.</p>
<h4 id="punycode-identifiers"><a class="header" href="#punycode-identifiers">Punycode Identifiers</a></h4>
<p>Punycode generates strings of the form <code>([[:ascii:]]+-)?[[:alnum:]]+</code>. This is problematic because of the <code>-</code> character, which is not in the supported character set; Punycode uses it to separate the ASCII part (if it exists), from the base-36 encoding of the non-ASCII characters.</p>
<p>For this reasons, we deviate from vanilla Punycode, by replacing the <code>-</code> character with a <code>_</code> character.</p>
<p>Here are some examples:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Original</th><th>Punycode</th><th>Punycode + Encoding</th></tr>
</thead>
<tbody>
<tr><td>føø</td><td>f-5gaa</td><td>f_5gaa</td></tr>
<tr><td>α_ω</td><td>_-ylb7e</td><td>__ylb7e</td></tr>
<tr><td>铁锈</td><td>n84amf</td><td>n84amf</td></tr>
<tr><td>🤦</td><td>fq9h</td><td>fq9h</td></tr>
<tr><td>ρυστ</td><td>2xaedc</td><td>2xaedc</td></tr>
</tbody>
</table>
</div>
<p>With this post-processing in place the Punycode strings can be treated like regular identifiers and need no further special handling.</p>
<h4 id="vendor-specific-suffix"><a class="header" href="#vendor-specific-suffix">Vendor-specific suffix</a></h4>
<p>Similarly to the <a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling-structure">Itanium C++ ABI mangling scheme</a>, a symbol name containing a period (<code>.</code>) or a dollar sign (<code>$</code>) represents a vendor-specific version of the symbol. There are no restrictions on the characters following the period or dollar sign.</p>
<p>This can happen in practice when locally unique names needed to become globally unique. For example, LLVM can append a <code>.llvm.&lt;numbers&gt;</code> suffix during LTO to ensure a unique name, and <code>$</code> can be used for thread-local data on Mach-O. In these situations it’s generally fine to ignore the suffix: the suffixed name has the same semantics as the original.</p>
<h3 id="compression"><a class="header" href="#compression">Compression</a></h3>
<p>Symbol name compression works by substituting parts of the mangled name that have already been seen for a back reference. Compression is directly built into the mangling algorithm, as shown by the following piece of pseudocode:</p>
<pre><code class="language-rust">fn mangle(node, output_string, substitution_dictionary) {
    if let Some(backref) = substitution_dictionary.get(node) {
        // Emit the backref instead of the node's contents
        mangle(backref, output_string)
    } else {
        // Remember where the current node starts in the output
        let start_position = output_string.len()

        // Do the actual mangling, including recursive mangling of child nodes

        // Add the current node to the substitution dictionary
        if node.is_substitutable() {
            substitution_dictionary.insert(node, start_position)
        }
    }
}</code></pre>
<p>This algorithm automatically chooses the best compression because parent nodes (which are always larger) are visited before child nodes.</p>
<p>Note that this kind of compression relies on the fact that all substitutable AST nodes have a self-terminating mangled form, that is, given the start position of the encoded node, the grammar guarantees that it is always unambiguous where the node ends. This is ensured by not allowing optional or repeating elements at the end of substitutable productions.</p>
<h4 id="decompression"><a class="header" href="#decompression">Decompression</a></h4>
<p>Decompression too is built directly into demangling/parsing. When a back reference is encountered, we decode the referenced position and use a temporary demangler/parser to do the decoding of the node’s actual content:</p>
<pre><code class="language-rust">fn demangle_at(&amp;mut pos, mangled, output_string) {
  if is_backref(*pos, mangled) {
    // Read the byte offset of the referenced node and
    // advance `pos` past the backref.
    let mut referenced_pos = decode(pos, mangled);
    demangle_at(&amp;mut referenced_pos, mangled, output_string)
  } else {
    // do regular demangling
  }
}</code></pre>
<p>Using byte offsets as backref keys (as this RFC does) instead of post-order traversal indices (as Itanium mangling does) has the advantage that the demangler does not need to duplicate the mangler’s substitution indexing logic, something that can become quite complex (as demonstrated by the compression scheme proposed in the initial version of this RFC).</p>
<h4 id="a-note-on-implementing-efficient-demanglers"><a class="header" href="#a-note-on-implementing-efficient-demanglers">A Note On Implementing Efficient Demanglers</a></h4>
<p>The mangling syntax is constructed in a way that allows for implementing efficient demanglers:</p>
<ul>
<li>
<p>Mangled names contain information in the same order as unmangled names are expected to contain it. Therefore, a demangler can directly generate its output while parsing the mangled form. There is no need to explicitly instantiate the AST in memory.</p>
</li>
<li>
<p>The same is true for decompression. Decompression can be done without allocating memory outside of the stack. Alternatively the demangler can keep a simple array that maps back-ref indices to ranges in the already generated output. When it encounters a <code>&lt;backref&gt;</code> in need of expansion, it can just look up corresponding range and do a simple <code>memcpy</code>.</p>
</li>
</ul>
<p>Parsing, decompression, and demangling can thus be done in a single pass over the mangled name without the need for complex data structures, which is useful when having to implement <code>#[no_std]</code> or C demanglers. (Note that Punycode can complicate decoding slightly because it needs dynamic memory allocation in the general case but it can be implemented with an on-stack buffer for a reasonable maximum supported length).</p>
<h3 id="mapping-rust-language-entities-to-symbol-names"><a class="header" href="#mapping-rust-language-entities-to-symbol-names">Mapping Rust Language Entities to Symbol Names</a></h3>
<p>This RFC suggests the following mapping of Rust entities to mangled names:</p>
<ul>
<li>
<p>Named functions, methods, and statics shall be represented by a <code>&lt;path&gt;</code> production.</p>
</li>
<li>
<p>Paths should be rooted at the inner-most entity that can act as a path root. Roots can be crate-ids, inherent impls, trait impls, and (for items within default methods) trait definitions.</p>
</li>
<li>
<p>The compiler is free to choose disambiguation indices and namespace tags from the reserved ranges as long as it ascertains identifier unambiguity.</p>
</li>
<li>
<p>Generic arguments that are equal to the default should not be encoded in order to save space.</p>
</li>
</ul>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>Why should we <em>not</em> do this?</p>
<ul>
<li>The current/legacy scheme based on symbol-hashes is flexible in that hashes can be changed at will. That is, the unstable part of the current mangling scheme is nicely contained and does not keep breaking external tools. The danger of breakage is greater with the scheme proposed here because it exposes more information.</li>
</ul>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<p>The alternatives considered are:</p>
<ol>
<li>
<p>Keeping the current scheme. It does meet the minimum requirements after all. However, the general consensus seems to be that this leads to situations where people are unpleasantly surprised when they come across (demangled) symbol names in backtraces or profilers.</p>
</li>
<li>
<p>Keeping the current scheme but cleaning it up by making the non-hash part more consistent and more expressive. Keep the hash part as a safeguard against symbol conflicts and the rest as something just for demangling. The downside of this is that the hash would still not be predictable, and symbols would get rather long if they should contain more human-readable information about generic arguments.</p>
</li>
<li>
<p>Define a standardized pretty-printing format for things that end up as symbols, and then encode that via Punycode in order to meet the character set restrictions. This would be rather simple. Symbol names would remain somewhat human-readable (but not very, because all separators would be stripped out). But without some kind of additional compression, symbol names would become rather long.</p>
</li>
<li>
<p>Use the scheme from the previous bullet point but apply the compression scheme described above. We could do this but it wouldn’t really be less complex than the scheme proposed by the RFC.</p>
</li>
<li>
<p>Define a standardized pretty-printing format for things that end up as symbols, compress with <code>zstd</code> (specially trained for Rust symbols) and encode the result as <code>base63</code>. This is rather simple but loses all human-readability. It’s unclear how well this would compress. It would pull the <code>zstd</code> specification into the mangling scheme specification, as well as the pre-trained dictionary.</p>
</li>
</ol>
<h2 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h2>
<p>One of the major modern mangling schemes with a public specification is the <a href="http://refspecs.linuxbase.org/cxxabi-1.86.html#mangling">Itanium C++ ABI</a> scheme for C++ which is used by the GCC toolchain. An initial version of this RFC sticked closely to Itanium mangling, however, the latest version only retains the run-length encoding for identifiers and some literals for tagging things like basic types. The Itanium scheme has been criticized for being overly complex, due to its extensive grammar and two separate compression schemes.</p>
<p>The idea of using <a href="https://tools.ietf.org/html/rfc3492">Punycode</a> for handling of unicode identifiers is taken from the <a href="https://github.com/apple/swift">Swift</a> programming language’s <a href="https://github.com/apple/swift/blob/master/docs/ABI/Mangling.rst#identifiers">mangling scheme</a>.</p>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<h3 id="punycode-vs-utf-8"><a class="header" href="#punycode-vs-utf-8">Punycode vs UTF-8</a></h3>
<p>During the pre-RFC phase, it has been suggested that Unicode identifiers should be encoded as UTF-8 instead of Punycode on platforms that allow it. GCC, Clang, and MSVC seem to do this. The author of the RFC has a hard time making up their mind about this issue. Here are some interesting points that might influence the final decision:</p>
<ul>
<li>
<p>Using UTF-8 instead of Punycode would make mangled strings containing non-ASCII identifiers a bit more human-readable. For demangled strings, there would be no difference.</p>
</li>
<li>
<p>Punycode support is non-optional since some platforms only allow a very limited character set for symbol names. Thus, we would be using UTF-8 on some platforms and Punycode on others, making it harder to predict what a symbol name for a given item looks like.</p>
</li>
<li>
<p>Punycode encoding and decoding is more runtime effort for the mangler and demangler.</p>
</li>
<li>
<p>Once a demangler supports Punycode, it is not much effort to support both encodings. The <code>u</code> identifier prefix tells the demangler whether it is Punycode. Otherwise it can just assume UTF-8 which already subsumes ASCII.</p>
</li>
</ul>
<p><strong>UPDATE</strong>: This RFC recommends that Punycode encoded identifiers must be supported by demanglers but that it is up to the compiler implementation (for now) to decide whether to use it for a given platform. This question will have to be revisited if Rust ever wants to define a stable ABI.</p>
<h3 id="encoding-parameter-types-for-function-symbols"><a class="header" href="#encoding-parameter-types-for-function-symbols">Encoding parameter types for function symbols</a></h3>
<p>It has been suggested that parameter types for functions and methods should be encoded in mangled form too. This is not necessary for symbol name uniqueness but it would provide an additional safeguard against silent ABI-related errors where definition and callers of some function make different assumptions about what parameters a function takes. The RFC does not propose to do this because:</p>
<ul>
<li>Rust makes sure this cannot happen via crate metadata,</li>
<li>it would make symbol names longer, and</li>
<li>only some but not all ABI related errors are caught by the safeguard.</li>
</ul>
<p>However, a final decision on the topic has not been made yet.</p>
<p><strong>UPDATE</strong>: This RFC suggests that parameter types are <em>not</em> encoded into function and method symbols. Symbol names will already get significantly longer due to encoding additional information and the additional safeguard provided against ABI mismatches is less relevant for Rust than it is for other languages that don’t have a concept of library/crate metadata.</p>
<h2 id="appendix-a---suggested-demangling"><a class="header" href="#appendix-a---suggested-demangling">Appendix A - Suggested Demangling</a></h2>
<p>This RFC suggests that names are demangled to a form that matches Rust syntax as it is used in source code, compiler error messages and <code>rustdoc</code>:</p>
<ul>
<li>
<p>Path components should be separated by <code>::</code>.</p>
</li>
<li>
<p>If the path root is a <code>&lt;crate-id&gt;</code> it should be printed as the crate name. If the context requires it for correctness, the crate disambiguator can be printed too, as in, for example, <code>std[a0b1c2d3]::collections::HashMap</code>. In this case <code>a0b1c2d3</code> would be the disambiguator. Usually, the disambiguator can be omitted for better readability.</p>
</li>
<li>
<p>If the path root is an impl, it should be printed as <code>&lt;SelfType&gt;</code> (for inherent impls) or <code>&lt;SelfType as Trait&gt;</code> (for trait impls), like the compiler does in error messages. The <code>&lt;impl-path&gt;</code> also contained in the AST node should usually be omitted.</p>
</li>
<li>
<p>The list of generic arguments should be demangled as <code>&lt;T1, T2, T3&gt;</code>.</p>
</li>
<li>
<p>Identifiers can have a numeric disambiguator (the <code>&lt;disambiguator&gt;</code> production). The syntactic version of the numeric disambiguator maps to a numeric index. If the disambiguator is not present, this index is 0. If it is of the form <code>s_</code> then the index is 1. If it is of the form <code>s&lt;base-62-digit&gt;_</code> then the index is <code>&lt;base-62-digit&gt; + 2</code>. The suggested demangling of a disambiguator is <code>[&lt;index&gt;]</code>. However, for better readability, these disambiguators should usually be omitted in the demangling altogether. Disambiguators with index zero can <em>always</em> be omitted.</p>
<p>The exception here are closures. Since these do not have a name, the disambiguator is the only thing identifying them. The suggested demangling for closures is thus <code>{closure}[&lt;index&gt;]</code>.</p>
</li>
</ul>
<h2 id="appendix-b---examples"><a class="header" href="#appendix-b---examples">Appendix B - Examples</a></h2>
<p>We assume that all examples are defined in a crate named <code>mycrate[1234]</code>.</p>
<h3 id="free-standing-item"><a class="header" href="#free-standing-item">Free-standing Item</a></h3>
<pre><code class="language-rust">mod foo {
  mod bar {
    fn baz() {}
  }
}</code></pre>
<ul>
<li>unmangled: <code>mycrate::foo::bar::baz</code></li>
<li>mangled: <code>_RNvNtNtCs1234_7mycrate3foo3bar3baz</code></li>
</ul>
<h3 id="item-defined-in-inherent-method"><a class="header" href="#item-defined-in-inherent-method">Item Defined In Inherent Method</a></h3>
<pre><code class="language-rust">struct Foo&lt;T&gt;(T);

impl&lt;T&gt; Foo&lt;T&gt; {
  pub fn bar&lt;U&gt;(_: U) {
    static QUUX: u32 = 0;
    // ...
  }
}</code></pre>
<ul>
<li>unmangled: <code>&lt;mycrate::Foo&lt;_&gt;&gt;::bar::QUUX</code></li>
<li>mangled: <code>_RNvNvMCs1234_7mycrateINtCs1234_7mycrate3FoopE3bar4QUUX</code></li>
</ul>
<h3 id="item-defined-in-trait-method"><a class="header" href="#item-defined-in-trait-method">Item Defined In Trait Method</a></h3>
<pre><code class="language-rust">struct Foo&lt;T&gt;(T);

impl&lt;T&gt; Clone for Foo&lt;T&gt; {
  fn clone(&amp;self) -&gt; Self {
    static QUUX: u32 = 0;
    // ...
  }
}</code></pre>
<ul>
<li>unmangled: <code>&lt;mycrate::Foo&lt;_&gt; as std::clone::Clone&gt;::clone::QUUX</code></li>
<li>mangled: <code>_RNvNvXCs1234_7mycrateINtCs1234_7mycrate3FoopENtNtC3std5clone5Clone5clone4QUUX</code></li>
</ul>
<h3 id="item-defined-in-initializer-of-a-static"><a class="header" href="#item-defined-in-initializer-of-a-static">Item Defined In Initializer Of A Static</a></h3>
<pre><code class="language-rust">pub static QUUX: u32 = {
  static FOO: u32 = 1;
  FOO + FOO
};</code></pre>
<ul>
<li>unmangled: <code>mycrate::QUUX::FOO</code></li>
<li>mangled: <code>_RNvNvCs1234_7mycrate4QUUX3FOO</code></li>
</ul>
<h3 id="compressed-prefix-constructed-from-prefix-that-contains-a-substitution-itself---todo"><a class="header" href="#compressed-prefix-constructed-from-prefix-that-contains-a-substitution-itself---todo">Compressed Prefix Constructed From Prefix That Contains A Substitution Itself - TODO</a></h3>
<ul>
<li>unmangled: <code>mycrate::foo&lt;mycrate::bar,mycrate::bar::baz&gt;</code></li>
<li>mangled: <code>_RINvCs1234_7mycrate3fooNvB4_3barNvBn_3bazE</code></li>
</ul>
<h3 id="progressive-type-compression"><a class="header" href="#progressive-type-compression">Progressive type compression</a></h3>
<ul>
<li>unmangled: <code>std::foo&lt;(std::Bar,std::Bar),(std::Bar,std::Bar)&gt;</code></li>
<li>mangled: <code>_RINxC3std3fooTNyB4_3BarBe_EBd_E</code></li>
</ul>
<h2 id="appendix-c---change-log"><a class="header" href="#appendix-c---change-log">Appendix C - Change LOG</a></h2>
<ul>
<li>Removed mention of Itanium mangling in introduction.</li>
<li>Weakened “predictability” goal.</li>
<li>Removed non-goal of not providing a mangling for lifetimes.</li>
<li>Added non-goal for not trying to standardize the demangled form.</li>
<li>Updated specification and examples to new grammar as proposed by eddyb.</li>
<li><code>impl</code> disambiguation strategy changed to using the impl path instead of param bounds.</li>
<li>Updated prior art section to not say this RFC is an adaptation of Itanium mangling.</li>
<li>Updated compiler’s expected assignment of disambiguation indices and namespace tags.</li>
<li>Removed “complexity” drawback since the scheme is not very complex anymore.</li>
<li>Removed unresolved question “Re-use <code>&lt;disambiguator&gt;</code> for crate disambiguator”.</li>
<li>Added note about default generic arguments to reference-level-explanation.</li>
<li>Added note about Punycode making decoding more complicated.</li>
<li>Resolve question of complex constant data.</li>
<li>Add a recommended resolution for open question around Punycode identifiers.</li>
<li>Add a recommended resolution for open question around encoding function parameter types.</li>
<li>Allow identifiers to start with a digit.</li>
<li>Make <code>&lt;binder&gt;</code> optional in <code>&lt;fn-sig&gt;</code> and <code>&lt;dyn-bounds&gt;</code> productions.</li>
<li>Extend <code>&lt;const-data&gt;</code> to include <code>bool</code> values, <code>char</code> values, and negative integer values.</li>
<li>Remove type from constant placeholders.</li>
<li>Allow vendor-specific suffixes.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="2592-futures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="2627-raw-dylib-kind.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="2592-futures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="2627-raw-dylib-kind.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
