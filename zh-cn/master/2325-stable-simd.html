<!DOCTYPE HTML>
<html lang="zh_CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2325-stable-simd - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-b61d75f0.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Feature Name: <code>vendor_intrinsics</code></li>
<li>Start Date: 2018-02-04</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2325">rust-lang/rfcs#2325</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/48556">rust-lang/rust#48556</a></li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The purpose of this RFC is to provide a framework for SIMD to be used on stable Rust. It proposes stabilizing x86-specific vendor intrinsics, but includes the scaffolding for other platforms as well as a future portable SIMD design (to be fleshed out in another RFC).</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Stable Rust today does not typically expose all of the capabilities of the platform that you’re running on. A notable gap in Rust’s support includes SIMD (single instruction multiple data) support. For example on x86 you don’t currently have explicit access to the 128, 256, and 512 bit registers on the CPU. LLVM is in general an excellent optimizing compiler and often attempts to make use of these registers (auto vectorizing code), but it unfortunately is still somewhat limited and doesn’t express the full power of the various SIMD intrinsics.</p>
<p>The goal of this RFC is to enable using SIMD intrinsics on stable Rust, and in general provide a means to access the architecture-specific functionality of each vendor. For example the AES intrinsics on x86 would also be made available through this RFC, not only the SIMD-related AVX intrinsics.</p>
<p>Note that this is certainly not the first discussion to broach the topic of SIMD in Rust, but rather this has been an ongoing discussion for quite some time now! For example the <a href="https://github.com/rust-lang-nursery/simd">simd crate</a> started <a href="http://huonw.github.io/blog/2015/08/simd-in-rust/">long ago</a>, we’ve had <a href="https://github.com/rust-lang/rfcs/pull/1199">rfcs</a>, we’ve had a <a href="https://internals.rust-lang.org/t/getting-explicit-simd-on-stable-rust/4380">lot</a> of <a href="https://internals.rust-lang.org/t/whats-the-next-step-towards-the-stabilization-of-simd/5867">discussions</a> on internals, and the <a href="https://github.com/rust-lang-nursery/stdsimd">stdsimd</a> crate has been implemented.</p>
<p>This RFC draws from much of the historical feedback and design that we’ve done around SIMD in Rust and is targeted at providing path forward for using SIMD on stable Rust while allowing the compiler to change in the future and retain a stable interface.</p>
<h2 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h2>
<p>Let’s say you’ve just heard about this fancy feature called “auto vectorization” in LLVM and you want to take advantage of it. For example you’ve got a function like this you’d like to make faster:</p>
<pre><code class="language-rust">pub fn foo(a: &amp;[u8], b: &amp;[u8], c: &amp;mut [u8]) {
    for ((a, b), c) in a.iter().zip(b).zip(c) {
        *c = *a + *b;
    }
}</code></pre>
<p>When <a href="https://play.rust-lang.org/?gist=36b253cd70840ea2ce6aad90418ec58b&amp;version=nightly&amp;mode=release">inspecting the assembly</a> you notice that rustc is making use of the <code>%xmmN</code> registers which you’ve read is related to SSE on your CPU. You know, however, that your CPU supports up to AVX2 which has bigger registers, so you’d like to get access to them!</p>
<p>Your first solution to this problem is to compile with <code>-C target-feature=+avx2</code>, and after that you see the <code>%ymmN</code> registers being used, yay! Unfortunately though you’re publishing this binary on CPUs which may not actually have AVX2 as a feature, so you don’t want to enable AVX2 for the entire program. Instead what you can do is enable it for just this function:</p>
<pre><code class="language-rust">#[target_feature(enable = "avx2")]
pub unsafe fn foo(a: &amp;[u8], b: &amp;[u8], c: &amp;mut [u8]) {
    for ((a, b), c) in a.iter().zip(b).zip(c) {
        *c = *a + *b;
    }
}</code></pre>
<p>And <a href="https://play.rust-lang.org/?gist=a31bdd3ce2b9a60e3317ccafb0133490&amp;version=nightly&amp;mode=release">sure enough</a> you see the <code>%ymmN</code> registers getting used in this function! Note, however, that because you’ve explicitly enabled a feature you’re required to declare the function as <code>unsafe</code>, as specified in <a href="https://github.com/rust-lang/rfcs/blob/master/text/2045-target-feature.md">RFC 2045</a> (although this requirement is likely to be relaxed in <a href="https://github.com/rust-lang/rfcs/pull/2212">RFC 2212</a>). This worked as a proof of concept but what you still need to do is dispatch at runtime whether the local CPU that you’re running on supports AVX2 or not. Thankfully, though, libstd has a handy macro for this!</p>
<pre><code class="language-rust">pub fn foo(a: &amp;[u8], b: &amp;[u8], c: &amp;mut [u8]) {
    // Note that this `unsafe` block is safe because we're testing
    // that the `avx2` feature is indeed available on our CPU.
    if is_target_feature_detected!("avx2") {
        unsafe { foo_avx2(a, b, c) }
    } else {
        foo_fallback(a, b, c)
    }
}

#[target_feature(enable = "avx2")]
unsafe fn foo_avx2(a: &amp;[u8], b: &amp;[u8], c: &amp;mut [u8]) {
    foo_fallback(a, b, c) // the function below is inlined here
}

fn foo_fallback(a: &amp;[u8], b: &amp;[u8], c: &amp;mut [u8]) {
    for ((a, b), c) in a.iter().zip(b).zip(c) {
        *c = *a + *b;
    }
}</code></pre>
<p>And <a href="https://play.rust-lang.org/?gist=cfce0743910291517aae3b15f70a7cbd&amp;version=nightly&amp;mode=release">sure enough once again</a> we see that <code>foo</code> is dispatching at runtime to the appropriate function, and only <code>foo_avx2</code> is using our <code>%ymmN</code> registers!</p>
<p>Ok great! At this point we’ve seen how to enable CPU features for functions-at-a-time as well as how they could be used in a larger context to do runtime dispatch to the most appropriate implementation. As we saw in the motivation, however, we’re just relying on LLVM to auto-vectorize here which often isn’t good enough or otherwise doesn’t expose the functionality we want.</p>
<p>For <strong>explicit and guaranteed simd</strong> on stable Rust you’ll be using a new module in the standard library, <code>std::arch</code>. The <code>std::arch</code> module is defined by vendors/architectures, not us actually! For example Intel <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#">publishes a list of intrinsics</a> as does <a href="https://developer.arm.com/technologies/neon/intrinsics">ARM</a>. These exact functions and their signatures will be available in <code>std::arch</code> with types translated to Rust (e.g. <code>int32_t</code> becomes <code>i32</code>). Vendor specific types like <code>__m128i</code> on Intel will also live in <code>std::arch</code>.</p>
<p>For example let’s say that we’re writing a function that encodes a <code>&amp;[u8]</code> in ascii hex and we want to convert <code>&amp;[1, 2]</code> to <code>"0102"</code>. The <a href="https://github.com/rust-lang-nursery/stdsimd">stdsimd</a> crate currently has this <a href="https://github.com/rust-lang-nursery/stdsimd/blob/ee046e0419e4d5e8f742b138313eeefd603326b5/examples/hex.rs">as an example</a>, and let’s take a look at a few snippets from that.</p>
<p>First up you’ll see the dispatch routine like we wrote above:</p>
<pre><code class="language-rust">fn hex_encode&lt;'a&gt;(src: &amp;[u8], dst: &amp;'a mut [u8]) -&gt; Result&lt;&amp;'a str, usize&gt; {
    let len = src.len().checked_mul(2).unwrap();
    if dst.len() &lt; len {
        return Err(len);
    }

    #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
    {
        if is_target_feature_detected!("avx2") {
            return unsafe { hex_encode_avx2(src, dst) };
        }
        if is_target_feature_detected!("sse4.1") {
            return unsafe { hex_encode_sse41(src, dst) };
        }
    }

    hex_encode_fallback(src, dst)
}</code></pre>
<p>Here we have some routine business about hex encoding in general, and then for x86/x86_64 platforms we have optimized versions specifically for avx2 and sse41. Using the <code>is_target_feature_detected!</code> macro in libstd we saw above we’ll dispatch to the correct one at runtime.</p>
<p>Taking a closer look at <a href="https://github.com/rust-lang-nursery/stdsimd/blob/ee046e0419e4d5e8f742b138313eeefd603326b5/examples/hex.rs#L114-L160"><code>hex_encode_sse41</code></a> we see that it starts out with a bunch of weird looking function calls:</p>
<pre><code class="language-rust">let ascii_zero = _mm_set1_epi8(b'0' as i8);
let nines = _mm_set1_epi8(9);
let ascii_a = _mm_set1_epi8((b'a' - 9 - 1) as i8);
let and4bits = _mm_set1_epi8(0xf);</code></pre>
<p>As it turns out though, these are all Intel SIMD intrinsics! For example <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set1_epi8&amp;expand=4669"><code>_mm_set1_epi8</code></a> is defined as creating an instance of <code>__m128i</code>, a 128-bit integer register. The intrinsic specifically sets all bytes to the first argument.</p>
<p>These functions are all imported through <code>std::arch::*</code> at the top of the example (in this case <code>stdsimd::vendor::*</code>). We go on to use a bunch of these intrinsics throughout the <code>hex_encode_sse41</code> function to actually do the hex encoding.</p>
<p>The example listed currently has some tests/benchmarks as well, and if we run the benchmarks we’ll see:</p>
<pre><code>test benches::large_default    ... bench:      73,432 ns/iter (+/- 12,526) = 14279 MB/s
test benches::large_fallback   ... bench:   1,711,030 ns/iter (+/- 286,642) = 612 MB/s
test benches::small_default    ... bench:          30 ns/iter (+/- 18) = 3900 MB/s
test benches::small_fallback   ... bench:         204 ns/iter (+/- 74) = 573 MB/s
test benches::x86::large_avx2  ... bench:      69,742 ns/iter (+/- 9,157) = 15035 MB/s
test benches::x86::large_sse41 ... bench:     108,463 ns/iter (+/- 70,250) = 9667 MB/s
test benches::x86::small_avx2  ... bench:          25 ns/iter (+/- 8) = 4680 MB/s
test benches::x86::small_sse41 ... bench:          25 ns/iter (+/- 14) = 4680 MB/s
</code></pre>
<p>Or in other words, our runtime dispatch implementation (“default”) is <strong>20 times faster</strong> than the fallback implementation (no explicit SIMD). Furthermore the AVX2 implementation is nearly 2x faster than the SSE4.1 implementation for large inputs, and the SSE4.1 implementation is over 10x faster than the default fallback as well.</p>
<p>With <code>std::arch</code> and <code>is_target_feature_detected!</code> we’ve now written a program that’s 20x faster on supported hardware, yet it also continues to run on older hardware as well! Not bad for a few dozen lines on each function!</p>
<hr>
<p>Note that this RFC is explicitly not attempting to stabilize/design a set of “portable simd operations”. The contents of <code>std::arch</code> are platform specific and provide no guarantees about portability. Efforts in the past, however, such as with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SIMD">simd.js</a> and the <a href="https://github.com/rust-lang-nursery/simd">simd crate</a> show that it’s desirable and useful to have a set of types which are usable across platforms.</p>
<p>Furthermore LLVM does quite a good job with a portable <code>u32x4</code> type, for example, in terms of platform support and speed on platforms that support it. This RFC is not going to go too much into the details about these types, but rather these guidelines will still hold:</p>
<ul>
<li>The intrinsics <strong>will not</strong> take portable types as arguments. For example <code>u32x4</code> and <code>__m128i</code> will be different types on x86. The two types, however, will be convertible between one another (either via transmutes or via explicit functions). This conversion will have zero run-time cost.</li>
<li>The portable simd types will likely live in a module like <code>std::simd</code> rather than <code>std::arch</code>.</li>
</ul>
<p>The design around these portable types are ongoing, however, and stay tuned for an RFC for the <code>std::simd</code> module!</p>
<h2 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h2>
<p>Stable SIMD in Rust ends up requiring a surprising number of both language and library features to be productive. Thankfully, though, there’s has been quite a bit of experimentation over time with SIMD in Rust and we’ve gotten a lot of good experience along the way! In this section, though, we’ll be going into the various features in detail.</p>
<h3 id="the-target_feature-attribute"><a class="header" href="#the-target_feature-attribute">The <code>#[target_feature]</code> Attribute</a></h3>
<p>The <code>#[target_feature]</code> attribute was specified in <a href="https://github.com/rust-lang/rfcs/blob/master/text/2045-target-feature.md">RFC 2045</a> and remains unchanged from that specification. As a quick recap it allows you to add this attribute to functions:</p>
<pre><code class="language-rust">#[target_feature(enable = "avx2")]</code></pre>
<p>The only currently allowed key is <code>enable</code> (one day we may allow <code>disable</code>). The string values accepted by <code>enable</code> will be separately stabilized but are likely to be guided by vendor definitions. For example in Intel’s <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#">intrinsic guide</a> it lists functions under “AVX2”, so we’re likely to stabilize the name <code>avx2</code> for Rust.</p>
<p>There’s a good number of these features supported by the compiler today. It’s expected that when stabilizing other pieces of this RFC the names of the following existing features for x86 will be stabilized:</p>
<ul>
<li><code>aes</code></li>
<li><code>avx2</code></li>
<li><code>avx</code></li>
<li><code>bmi2</code></li>
<li><code>bmi</code> - to be renamed to <code>bmi1</code>, the name Intel gives it</li>
<li><code>fma</code></li>
<li><code>fxsr</code></li>
<li><code>lzcnt</code></li>
<li><code>popcnt</code></li>
<li><code>rdrnd</code></li>
<li><code>rdseed</code></li>
<li><code>sse2</code></li>
<li><code>sse3</code></li>
<li><code>sse4.1</code></li>
<li><code>sse4.2</code></li>
<li><code>sse</code></li>
<li><code>ssse3</code></li>
<li><code>xsave</code></li>
<li><code>xsavec</code></li>
<li><code>xsaveopt</code></li>
<li><code>xsaves</code></li>
</ul>
<p>Note that AVX-512 names are missing from this list, but that’s because we haven’t implemented any AVX-512 intrinsics yet. Those’ll get stabilized on their own once implemented. Additionally note that <code>mmx</code> is missing from this list. For reasons discussed later, it’s proposed that MMX types are omitted from the first pass of stabilization. AMD also has some specific features supported (<code>sse4a</code>, <code>tbm</code>), and so do ARM, MIPS, and PowerPC, but none of these feature names a proposed for becoming stable in the first pass.</p>
<h3 id="the-target_feature-value-in-cfg"><a class="header" href="#the-target_feature-value-in-cfg">The <code>target_feature</code> value in <code>#[cfg]</code></a></h3>
<p>In addition to enabling target features for a function the compiler will also allow statically testing whether a particular target feature is enabled. This corresponds to the <code>cfg_target_feature</code> feature today in rustc, and can be seen via:</p>
<pre><code class="language-rust">#[cfg(target_feature = "avx")]
fn foo() {
    // implementation that can use `avx`
}

#[cfg(not(target_feature = "avx"))]
fn foo() {
    // a fallback implementation
}</code></pre>
<p>Additionally this is also made available to <code>cfg!</code>:</p>
<pre><code class="language-rust">if cfg!(target_feature = "avx") {
    println!("this program was compiled with AVX support");
}</code></pre>
<p>The <code>#[cfg]</code> attribute and <code>cfg!</code> macro statically resolve and <strong>do not do runtime dispatch</strong>. Tweaking these functions is currently done via the <code>-C target-feature</code> flag to the compiler. This flag to the compiler accepts a similar set of strings to the ones specified above and is already “stable”.</p>
<h3 id="the-is_target_feature_detected-macro"><a class="header" href="#the-is_target_feature_detected-macro">The <code>is_target_feature_detected!</code> Macro</a></h3>
<p>One mode of operation with intrinsics is to compile <em>part</em> of a program with certain CPU features enabled but not the entire program. This way a portable program can be compiled which runs across a broad range of hardware which can still benefit from optimized implementations for particular hardware at runtime.</p>
<p>The crux of this support in libstd is this macro provided by libstd, <code>is_target_feature_detected!</code>. The macro will accept one argument, a string literal.  The string can be any feature passed to <code>#[target_feature(enable = ...)]</code> for the platform you’re compiling for. Finally, the macro will resolve to a <code>bool</code> result.</p>
<p>For example on x86 you could write:</p>
<pre><code class="language-rust">if is_target_feature_detected!("sse4.1") {
    println!("this cpu has sse4.1 features enabled!");
}</code></pre>
<p>It would, however, be an error to write this on x86 cpus:</p>
<pre><code class="language-rust">is_target_feature_detected!("neon"); //~ COMPILE ERROR: neon is an ARM feature, not x86
is_target_feature_detected!("foo"); //~ COMPILE ERROR: unknown target feature for x86</code></pre>
<p>The macro is intended to be implemented in the <code>std</code> crate (<strong>not</strong> <code>core</code>) and made available via the normal macro preludes. The implementation of this macro is expected to be what <a href="https://github.com/rust-lang-nursery/stdsimd"><code>stdsimd</code></a> does today, notably:</p>
<ul>
<li>The first time the macro is invoked all the local CPU features will be detected.</li>
<li>The detected features will then be cached globally (when possible and currently in a bitset) for the rest of the execution of the program.</li>
<li>Further invocations of <code>is_target_feature_detected!</code> are expected to be cheap runtime dispatches. (aka load a value and check whether a bit is set)</li>
<li>Exception: in some cases the result of the macro is statically known: for example, <code>is_target_feature_detected!("sse2")</code> when the binary is being compiled with “sse42” globally. In these cases, none of the steps above are performed and the macro just expands to <code>true</code>.</li>
</ul>
<p>The exact method of CPU feature detection various by platform, OS, and architecture. For example on x86 we make heavy use of the <code>cpuid</code> instruction whereas on ARM the implementation currently uses getauxval/<code>/proc</code> mounted information on Linux. It’s expected that the detection will vary for each particular target, as necessary.</p>
<p>Note that the implementation details of the macro today prevent it from being located in libcore. If getauxval or <code>/proc</code> is used that requires libc to be available or <code>File</code> in one form or another. These concerns are currently std-only (not available in libcore). This is also a conservative route for x86 where it is possible to do CPU feature detection in libcore (as it’s just the <code>cpuid</code> instruction), but for consistency across platforms the macro will only be available in libstd for now. This placement can of course be relaxed in the future if necessary.</p>
<h3 id="the-stdarch-module"><a class="header" href="#the-stdarch-module">The <code>std::arch</code> Module</a></h3>
<p>This is where the real meat is. A new module will be added to the standard library, <code>std::arch</code>. This module will also be available in <code>core::arch</code> (and <code>std</code> will simply reexport it). The contents of this module provide no portability guarantees (like <code>std::os</code> and unlike the rest of <code>std</code>). APIs present on one platform may not be present on another.</p>
<p>The contents of the <code>arch</code> modules are defined by, well, architectures! For example Intel has an <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#">intrinsics guide</a> which will serve as a guideline for all contents in the <code>arch</code> module itself. The standard library will not deviate in naming or type signature of any intrinsic defined by an architecture.</p>
<p>For example most Intel intrinsics start with <code>_mm_</code> or <code>_mm256_</code> for 128 and 256-bit registers. While perhaps unergonomic, we’ll be sticking to what Intel says. Note that all intrinsics will also be <code>unsafe</code>, according to <a href="https://github.com/rust-lang/rfcs/blob/master/text/2045-target-feature.md">RFC 2045</a>.</p>
<p>Function signatures defined by architectures are typically defined in terms of C types. In Rust, however, those aren’t always available! Instead the intrinsics will be defined in terms of Rust-specific types. Some types are easily translated such as <code>int32_t</code>, but otherwise a different mapping may be applied per-architecture.</p>
<p>The current proposed mapping for x86 intrinsics is:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>What Intel says</th><th>Rust Type</th></tr>
</thead>
<tbody>
<tr><td><code>void*</code></td><td><code>*mut u8</code></td></tr>
<tr><td><code>char</code></td><td><code>i8</code></td></tr>
<tr><td><code>short</code></td><td><code>i16</code></td></tr>
<tr><td><code>int</code></td><td><code>i32</code></td></tr>
<tr><td><code>long long</code></td><td><code>i64</code></td></tr>
<tr><td><code>const int</code></td><td><code>i32</code> [0]</td></tr>
</tbody>
</table>
</div>
<p>[0] required to be compile-time constants.</p>
<p>Other than these exceptions the x86 intrinsics will be defined exactly as Intel defines them. This will necessitate new types in the <code>std::arch</code> modules for SIMD registers! For example these new types will all be present in <code>std::arch</code> on x86 platforms:</p>
<ul>
<li><code>__m128</code></li>
<li><code>__m128d</code></li>
<li><code>__m128i</code></li>
<li><code>__m256</code></li>
<li><code>__m256d</code></li>
<li><code>__m256i</code></li>
</ul>
<p>(note that AVX-512 types will come in the future!)</p>
<p>Infrastructure-wise the contents of <code>std::arch</code> are expected to continue to be defined in the <a href="https://github.com/rust-lang-nursery/stdsimd"><code>stdsimd</code> crate/repository</a>. Intrinsics defined here go through a rigorous test suite involving automatic verification against the upstream architecture definition, verification that the correct instruction is generated by LLVM, and at least one runtime test for each intrinsic to ensure it not only compiles but also produces correct results. It’s expected that stabilized intrinsics will meet these criteria to the best of their ability.</p>
<p>Currently today on x86 and ARM platforms the stdsimd crate performs all these checks, but these checks are not yet implemented for PowerPC/MIPS/etc, but that’s always just some more work to do!</p>
<p>It’s not expected that the contents of <code>std::arch</code> will remain static for all time. Rather intrinsics will continue to be implemented in <code>stdsimd</code> and make their way into the main Rust repository. For example there are not currently any implemented AVX-512 intrinsics, but that doesn’t mean we won’t implement them! Rather once implemented they’ll be stabilized and included in libstd following the Rust release model.</p>
<h3 id="the-types-in-stdarch"><a class="header" href="#the-types-in-stdarch">The types in <code>std::arch</code></a></h3>
<p>It’s worth paying close attention to the types in <code>std::arch</code>. Types like <code>__m128i</code> are intended to represent a 128-bit packed SIMD register on x86, but there’s nothing stopping you from using types like <code>Option&lt;__m128i&gt;</code> in your program!  Most generic containers and such probably aren’t written with packed SIMD types in mind, and it’d be a bummer if everything stopped working once you used a packed SIMD type in one of them.</p>
<p>Instead it will be required that the types defined in <code>std::arch</code> do indeed work when used in “nonstandard” contexts. For example <code>Option&lt;__m128i&gt;</code> should never produce a compiler error or a codegen error when used (it may just be slower than you expect). This requires special care to be taken both in representation of these arguments as well as their ABI.</p>
<p>Implementation-wise these packed SIMD types are implemented in terms of a “portable” vector in LLVM. LLVM as a results gets most of this logic correct for us in terms of having these compile without errors in many contexts. The ABI, however, had to be special cased as it was a location where LLVM didn’t always help us.</p>
<p>The Rust ABI will currently be implemented such that all related packed-SIMD types are passed via <em>memory</em> instead of by-value. This means that regardless of the target features enabled for a function everything should agree on how packed SIMD arguments are passed across boundaries and whatnot.</p>
<p>Again though, note that this section is largely an implementation detail of SIMD in Rust today, though it’s enabling usage without a lot of codegen errors popping up all over the place.</p>
<h3 id="intrinsics-in-stdarch-and-constant-arguments"><a class="header" href="#intrinsics-in-stdarch-and-constant-arguments">Intrinsics in <code>std::arch</code> and constant arguments</a></h3>
<p>There are a number of intrinsics on x86 (and other) platforms that require their arguments to be constants rather than decided at runtime. For example <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=insert_pi&amp;expand=2973"><code>_mm_insert_pi16</code></a> requires its third argument to be a constant value where only the lowest two bits are used. The Rust type system, however, does not currently have a stable way of expressing this information.</p>
<p>Eventually we will likely have some form of <code>const</code> arguments or <code>const</code> machinery to guarantee that these functions are called and monomorphized with constant arguments, but for now this RFC proposes taking a more conservative route forward. Instead we’ll, for the time being, forbid the functions from being invoked with non-constant arguments. Prototyped in <a href="https://github.com/rust-lang/rust/pull/48018">#48018</a> the <code>stdsimd</code> crate will have an unstable attribute where the compiler can help provide this guarantee. As an extra precaution as well <a href="https://github.com/rust-lang/rust/pull/48078">#48078</a> also implements disallowing taking a function pointer to these intrinsics, requiring a direct invocation.</p>
<p>It’s hoped that this restriction will allow <code>stdsimd</code> to be forward compatible with a future const-powered world of Rust but in the meantime not otherwise block stabilization of these intrinsics.</p>
<h3 id="portable-packed-simd"><a class="header" href="#portable-packed-simd">Portable packed SIMD</a></h3>
<p>So-called “portable” packed SIMD types are currently implemented in both the <a href="https://github.com/rust-lang-nursery/stdsimd">stdsimd</a> and <a href="https://github.com/rust-lang-nursery/simd">simd</a> crates. These types look like <code>u8x16</code> and explicitly specify how many lanes they have (16 in this case) and what type each line is (<code>u8</code> in this case). These types are intended to unconditionally available (like the rest of libstd) and simply optimized much more aggressively on platforms that have native support for the various operations.</p>
<p>For example <code>u8x16::add</code> may be implemented differently on i586 vs i686, and also entirely differently implemented on ARM. The idea with portable packed SIMD types is that they represent a broad intersection of fast behavior across a broad range of platforms.</p>
<p>It’s intended that this RFC neither includes nor rules out the addition of portable packed-SIMD types in Rust. It’s expected that an upcoming RFC will propose the addition of these types in a <code>std::simd</code> module. These types will be orthogonal to scalable-vector types which are expected to be proposed in another, also different, RFC.  What this RFC does do, however, is explicitly specify that:</p>
<ul>
<li>The portable SIMD types (both packed and scalable) will not be used in intrinsics.</li>
<li>The per-architecture SIMD types will be distinct types from the portable SIMD types.</li>
</ul>
<p>Or, in other words, it’s intended that portable SIMD types are entirely decoupled from intrinsics. If they both end up being implemented then there will be jkro-cost interoperation between them, but neither will necessarily depend on the other.</p>
<h3 id="not-stabilizing-mmx-in-this-rfc"><a class="header" href="#not-stabilizing-mmx-in-this-rfc">Not stabilizing MMX in this RFC</a></h3>
<p>This RFC proposed notably omitting the MMX intrinsics, or those related to <code>__m64</code> in other words. The MMX type <code>__m64</code> and the intrinsics have been somewhat problematic in a number of ways. Known cases include:</p>
<ul>
<li><a href="https://github.com/rust-lang/rust/pull/45367#issuecomment-337883136">MMX intrinsics aren’t always desirable</a></li>
<li><a href="https://github.com/rust-lang-nursery/stdsimd/issues/246">LLVM codegen errors happen with debuginfo enabled and MMX</a></li>
<li><a href="https://github.com/rust-lang-nursery/stdsimd/issues/300">LLVM codegen errors with MMX types and i586</a></li>
</ul>
<p>Due to these issues having an unclear conclusion as well as a seeming lack of desire to stabilize MMX intrinsics, the <code>__m64</code> and all related intrinsics <strong>will not be stabilized</strong> via this RFC.</p>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>This RFC represents a <em>significant</em> addition to the standard library, maybe one of the largest we’ve ever done! As a result alternate implementations of Rust will likely have a difficult time catching up to rustc/LLVM with all the SIMD intrinsics. Additionally the semantics of “packed SIMD types should work everywhere” may be overly difficult to implement in alternate implementations. It is worth noting that both <a href="https://github.com/CraneStation/cranelift/">Cranelift</a> and GCC support packed SIMD types.</p>
<p>Due to the enormity of what’s being added to the standard library it’s also infeasible to carefully review each addition in isolation. While there are a number of automatic verifications in place we’re likely to inevitably make a mistake when stabilizing something. <em>Fixing</em> a stabilization can often be quite difficult and costly.</p>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<p>Over the years quite a few iterations have happened for SIMD in Rust. This RFC draws from as many of those as it can and attempts to strike a balance between exposing functionality while still allowing us to implement everything in a stable fashion for years to come (and without blocking us from updating LLVM, for example). Despite this there’s a few alternatives we could do as well.</p>
<h3 id="portable-types-in-architecture-interfaces"><a class="header" href="#portable-types-in-architecture-interfaces">Portable types in architecture interfaces</a></h3>
<p>It was initially attempted in the <a href="https://github.com/rust-lang-nursery/stdsimd">stdsimd</a> crate that we would use the portable types on all of the intrinsics. For example instead of:</p>
<pre><code class="language-rust">pub unsafe fn _mm_set1_epi8(val: i8) -&gt; __m128i;</code></pre>
<p>we would instead define</p>
<pre><code class="language-rust">pub unsafe fn _mm_set1_epi8(val: i8) -&gt; i8x16;</code></pre>
<p>The latter definition here is much easier for a beginner to SIMD to read (or at least I gawked when I first saw <code>__m128i</code>).</p>
<p>The downside of this approach, however, is that Intel isn’t telling us what to do. While that may sound simple, this RFC is proposing an addition of <strong>thousands</strong> of functions to the standard library in a stable manner. It’s infeasible for any one person (or even the entire libs team) to scrutinize all functions and assess whether the correct signature is applied (aka was it <code>i8x16</code> or <code>i16x8</code>?)</p>
<p>Furthermore not all intrinsics from Intel actually have an interpretation with one of the portable types. For example some intrinsics take an integer constant which when 0 interprets the input as <code>u8x16</code> and when 1 interprets it as <code>u16x8</code> (as an example). This effectively means that there <em>isn’t</em> a correct choice in all situations for what portable type should be used.</p>
<p>Consequently it’s proposed that instead of portable types the exact architecture types are used in all intrinsics. This provides us a much easier route to stabilization (“make sure it’s what Intel says”) along with no need to interpret what Intel does and attempt to find the most appropriate type.</p>
<p>There is interest by both current <code>stdsimd</code> maintainers and users to expose a “better-typed” SIMD API in crates.io that builds on top of the intrinsics proposed for stabilization here.</p>
<h3 id="stabilizing-simd-implementation-details"><a class="header" href="#stabilizing-simd-implementation-details">Stabilizing SIMD implementation details</a></h3>
<p>Another alternative to the bulk of this RFC is allowing more raw access to the internals of LLVM. For example stabilizing <code>#[repr(simd)]</code> or the ability to write <code>extern "platform-intrinsics" { ... }</code> or <code>#[link_llvm_intrinsic...]</code>. This is certainly a <em>much</em> smaller surface area to stabilize (aka not thousands of intrinsics).</p>
<p>This avenue was decided against, however, for a few reasons:</p>
<ul>
<li>Such raw interfaces may change over time as they simply represent LLVM as a current point in time rather than what LLVM wants to do in the future.</li>
<li>Alternate implementations of rustc or alternate rustc backends like <a href="https://github.com/CraneStation/cranelift/">Cranelift</a> may not expose the same sort of functionality that LLVM provides, or implementing the interfaces may be much more difficult in alternate backends than in LLVM’s.</li>
</ul>
<p>As a result, it’s intended that instead of exposing raw building blocks (and allowing <code>stdsimd</code> to live on crates.io) we’ll instead pull in <code>stdsimd</code> to the standard library and expose it as the stable interface to SIMD in Rust.</p>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<p>There’s a number of unresolved questions around stabilizing SIMD today which don’t pose serious blockers and may also wish to be considered open bugs rather than blocking stabilization:</p>
<h3 id="relying-on-unexported-llvm-apis"><a class="header" href="#relying-on-unexported-llvm-apis">Relying on unexported LLVM APIs</a></h3>
<p>The static detection performed by <code>cfg!</code> and <code>#[cfg]</code> currently relies on a <a href="https://github.com/rust-lang/llvm/commit/68e1e29618b2bd094d82faac16cf8e89959bbd68">Rust-specific patch to LLVM</a>. LLVM internal knows all about hierarchies of features and such. For example if you compile with <code>-C target-feature=+avx2</code> then <code>cfg!(target_feature = "sse2")</code> also needs to resolve to <code>true</code>. Rustc, however, does not know about these features and relies on learning this information through LLVM.</p>
<p>Unfortunately though LLVM does not actually export this information for us to consume (as far as we know). As a result we have a <a href="https://github.com/rust-lang/llvm/commit/68e1e29618b2bd094d82faac16cf8e89959bbd68">local patch</a> which exposed this information for us to read. The consequence of this implementation detail is that when compiled against the system LLVM the <code>cfg!</code> macro may not work correctly when used in conjunction with <code>-C target-feature</code> or <code>-C target-cpu</code> flags.</p>
<p>It appears that clang <a href="https://github.com/llvm-mirror/clang/blob/679d846fcc73bd213347785185006d591698a132/lib/Basic/Targets/X86.cpp">vendors and/or duplicates</a> LLVM’s functionality in this regard. It’s an option for rustc to do the same but it may also be an option to expose the information in upstream LLVM. So far there appears to have been no attempts to upstream this patch into LLVM itself.</p>
<h3 id="packed-simd-types-in-extern-functions-are-not-sound"><a class="header" href="#packed-simd-types-in-extern-functions-are-not-sound">Packed SIMD types in <code>extern</code> functions are not sound</a></h3>
<p>The packed SIMD types have particular care paid to them with respect to their ABI in Rust and how they’re passed between functions, notably to ensure that they work properly throughout Rust programs. The “fix” to pass them in memory over function calls, however, was only applied to the “Rust” ABI and not any other function ABIs.</p>
<p>A consequence of this change is that if you instead label all your functions <code>extern</code> then the <a href="https://github.com/rust-lang/rust/issues/44367">same bug</a> will arise. It may be possible to implement a “lint” or a compiler error of sorts to forbid this situation in the short term. We could also possibly accept this as a known bug for the time being.</p>
<h3 id="what-if-were-wrong"><a class="header" href="#what-if-were-wrong">What if we’re wrong?</a></h3>
<p>Despite the CI infrastructure of the <code>stdsimd</code> crate it seems inevitable that we’ll get an intrinsic wrong at some point. What do we do in a situation like that? This situation is somewhat analogous to the <code>libc</code> crate but there you can fix the problem downstream (just have a corrected type/definition) for vendor intrinsics it’s not so easy.</p>
<p>Currently it seems that our only recourse would be to add a <code>2</code> suffix to the function name or otherwise indicate there’s a corrected version, but that’s not always the best…</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="2318-custom-test-frameworks.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="2333-prior-art.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="2318-custom-test-frameworks.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="2333-prior-art.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
