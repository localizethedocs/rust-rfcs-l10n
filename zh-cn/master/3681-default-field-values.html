<!DOCTYPE HTML>
<html lang="zh_CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>3681-default-field-values - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-b61d75f0.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Feature Name: <code>default_field_values</code></li>
<li>Start Date: 2024-08-22</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/3681">rust-lang/rfcs#3681</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/132162">rust-lang/rust#132162</a></li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Allow <code>struct</code> definitions to provide default values for individual fields and thereby allowing those to be omitted from initializers. When deriving <code>Default</code>, the provided values will then be used. For example:</p>
<pre><code class="language-rust">#[derive(Default)]
struct Pet {
    name: Option&lt;String&gt;, // impl Default for Pet will use Default::default() for name
    age: i128 = 42, // impl Default for Pet will use the literal 42 for age
}</code></pre>
<p>These can then be used in the following way with the existing <a href="https://doc.rust-lang.org/reference/expressions/struct-expr.html#functional-update-syntax">functional update syntax</a>, but without a “base expression” after the <code>..</code>:</p>
<pre><code class="language-rust">// Pet { name: Some(""), age: 42 }
let _ = Pet { name: Some(String::new()), .. }
// Compilation error: `name` needs to be specified
let _ = Pet { .. }</code></pre>
<p>Derived <code>Default</code> <code>impl</code> also uses struct field defaults if present:</p>
<pre><code class="language-rust">// Pet { name: None, age: 42 }
let _ = Pet::default();</code></pre>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<h3 id="boilerplate-reduction"><a class="header" href="#boilerplate-reduction">Boilerplate reduction</a></h3>
<h4 id="for-structs"><a class="header" href="#for-structs">For <code>struct</code>s</a></h4>
<p>Rust allows you to create an instance of a <code>struct</code> using the struct literal syntax <code>Foo { bar: expr, baz: expr }</code>. To do so, all fields in the <code>struct</code> must be assigned a value. This makes it inconvenient to create large <code>struct</code>s whose fields usually receive the same values. It also allows you construct <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">a new instance of the same <code>struct</code> by consuming some (or all) of the fields of an existing value</a>, which can reduce noise when a <code>struct</code> derives <code>Default</code>, but are also invalid when the <code>struct</code> has inaccessible fields and do not allow the creation of an <code>impl</code> where <em>some</em> fields are mandatory.</p>
<p>To work around these shortcomings, you can create constructor functions:</p>
<pre><code class="language-rust">struct Foo {
    alpha: &amp;'static str,
    beta: bool,
    gamma: i32,
}

impl Foo {
    /// Constructs a `Foo`.
    fn new(alpha: &amp;'static str, gamma: i32) -&gt; Self {
        Self {
            alpha,
            beta: true,
            gamma
        }
    }
}

let foo = Foo::new("Hello", 42);</code></pre>
<p>The problem with a constructor is that you need one for each combination of fields a caller can supply. To work around this, you can use builders, such as <a href="https://doc.rust-lang.org/stable/std/process/struct.Command.html"><code>process::Command</code></a> in the standard library. Builders enable more advanced initialization, but require additional boilerplate. To represent the difference, we can see the dramatic syntactical increase for semantically small changes:</p>
<pre><code class="language-rust">// All fields are mandatory
struct Foo {
    alpha: &amp;'static str,
    beta: bool,
    gamma: i32,
}</code></pre>
<pre><code class="language-rust">impl Foo {
    /// Constructs a `Foo`.
    fn new(alpha: &amp;'static str, gamma: i32) -&gt; Self {
        Self {
            alpha,
            beta: true,
            gamma
        }
    }
}</code></pre>
<pre><code class="language-rust">// A builder type that is able to construct a `Foo`, but that will fail at runtime if a field is
// missing.
#[derive(Default)]
struct FooBuilder {
    pub alpha: Option&lt;&amp;'static str&gt;,
    pub beta: Option&lt;bool&gt;,
    pub gamma: Option&lt;i32&gt;,
}

impl FooBuilder {
    fn new() -&gt; Self {
        FooBuilder::default()
    }
    fn set_alpha(&amp;mut self, alpha: &amp;'static str) -&gt; &amp;mut Self {
        self.alpha = Some(alpha);
        self
    }
    fn set_beta(&amp;mut self, beta: &amp;'static str) -&gt; &amp;mut Self {
        self.beta = Some(beta);
        self
    }
    fn set_gamma(&amp;mut self, gamma: &amp;'static str) -&gt; &amp;mut Self {
        self.gamma = Some(gamma);
        self
    }

    fn build(self) -&gt; Foo {
        Foo {
            alpha: self.alpha.unwrap(),
            beta: self.beta.unwrap(),
            gamma: self.gamma.unwrap_or(0),
        }
    }
}</code></pre>
<pre><code class="language-rust">pub struct Foo {
    pub alpha: &amp;'static str,
    pub beta: bool,
    pub gamma: i32,
}

// A builder type that is able to construct a `Foo`, but that will fail at compile time if a field
// is missing.
#[derive(Default)]
pub struct FooBuilder&lt;const A: bool, const B: bool, const G: bool&gt; {
    alpha: Option&lt;&amp;'static str&gt;,
    beta: Option&lt;bool&gt;,
    gamma: Option&lt;i32&gt;,
}

// We provide this `impl` on its own so that `FooBuilder::new()` will work without specifying the
// const parameters.
impl FooBuilder&lt;false, false, false&gt; {
    fn new() -&gt; FooBuilder&lt;false, false, false&gt; {
        FooBuilder::default()
    }
}

// The fields can only be set once. Calling `set_alpha` twice will result in a compilation error.
impl&lt;const B: bool, const G: bool&gt; FooBuilder&lt;false, B, G&gt; {
    fn set_alpha(mut self, alpha: &amp;'static str) -&gt; FooBuilder&lt;true, B, G&gt; {
        self.alpha = Some(alpha);
        unsafe { std::mem::transmute(self) }
    }
}
impl&lt;const A: bool, const G: bool&gt; FooBuilder&lt;A, false, G&gt; {
    fn set_beta(mut self, beta: bool) -&gt; FooBuilder&lt;A, true, G&gt; {
        self.beta = Some(beta);
        unsafe { std::mem::transmute(self) }
    }
}
impl&lt;const A: bool, const B: bool&gt; FooBuilder&lt;A, B, false&gt; {
    fn set_gamma(mut self, gamma: i32) -&gt; FooBuilder&lt;A, B, true&gt; {
        self.gamma = Some(gamma);
        unsafe { std::mem::transmute(self) }
    }
}
// If any field is optional,
impl&lt;const G: bool&gt; FooBuilder&lt;true, true, G&gt; {
    fn build(self) -&gt; Foo { // can only be called if all fields have been set
        Foo {
            alpha: self.alpha.unwrap(),
            beta: self.beta.unwrap(),
            gamma: self.gamma.unwrap_or(0), // This is an optional field with a default.
        }
    }
}

fn main() {
    let _ = FooBuilder::new()
        .set_alpha("")
        .set_beta(false) // If we comment this out, it will no longer compile.
        .set_gamma(42) // If we comment this out, it will still compile.
        .build();
}</code></pre>
<p>All of the above can be represented with the exact same results with struct field default values, but with much less boilerplate:</p>
<pre><code class="language-rust">pub struct Foo {
    pub alpha: &amp;'static str,
    pub beta: bool,
    pub gamma: i32 = 0,
}

fn main() {
    let _ = Foo {
        alpha: "",
        beta: false,
        ..
    };
}</code></pre>
<p>The builder pattern is quite common in the Rust ecosystem, but as shown above its need is greatly reduced with <code>struct</code> field defaults.</p>
<h3 id="derivedefault-in-more-cases"><a class="header" href="#derivedefault-in-more-cases"><code>#[derive(Default)]</code> in more cases</a></h3>
<p>The <code>#[derive(..)]</code> (“custom derive”) mechanism works by defining procedural <em>macros</em>. Because they are macros, these operate on abstract <em>syntax</em> and don’t have more information available. Therefore, when you <code>#[derive(Default)]</code> on a data type definition as with:</p>
<pre><code class="language-rust">#[derive(Default)]
struct Foo {
    bar: u8,
    baz: String,
}</code></pre>
<p>it only has the immediate “textual” definition available to it.</p>
<p>Because Rust currently does not have an in-language way to define default values, you cannot <code>#[derive(Default)]</code> in the cases where you are not happy with the natural default values that each field’s type provides. By extending the syntax of Rust such that default values can be provided, <code>#[derive(Default)]</code> can be used in many more circumstances and thus boilerplate is further reduced.  The addition of a single field, expands the code written by the <code>struct</code> author from a single <code>derive</code> line to a whole <code>Default</code> <code>impl</code>, which becomes more verbose linearly with the number of fields.</p>
<h4 id="imperfect-derives"><a class="header" href="#imperfect-derives">Imperfect derives</a></h4>
<p>One thing to notice, is that taking default values into consideration during the desugaring of <code>#[derive(Default)]</code> would allow to side-step the issue of our lack of <a href="https://smallcultfollowing.com/babysteps/blog/2022/04/12/implied-bounds-and-perfect-derive/">perfect derives</a>, by making the desugaring syntactically check which type parameters correspond to fields that don’t have a default field, as in the expansion they will use the default value instead of <code>Default::default()</code>. By doing this a user can side-step the introduction of unnecessary bounds by specifying a default value of the same return value of <code>Default::default()</code>:</p>
<pre><code class="language-rust">#[derive(Default)]
struct Foo&lt;T&gt; {
    bar: Option&lt;T&gt;,
}</code></pre>
<p>previously expands to:</p>
<pre><code class="language-rust">struct Foo&lt;T&gt; {
    bar: Option&lt;T&gt;,
}
impl&lt;T: Default&gt; Default for Foo&lt;T&gt; {
    fn default() -&gt; Foo&lt;T&gt; {
        Foo {
            bar: Default::default(),
        }
    }
}</code></pre>
<p>but we can make the following:</p>
<pre><code class="language-rust">#[derive(Default)]
struct Foo&lt;T&gt; {
    bar: Option&lt;T&gt; = None,
}</code></pre>
<p>expand to:</p>
<pre><code class="language-rust">struct Foo&lt;T&gt; {
    bar: Option&lt;T&gt;,
}
impl&lt;T&gt; Default for Foo&lt;T&gt; {
    fn default() -&gt; Foo&lt;T&gt; {
        Foo {
            bar: None,
        }
    }
}</code></pre>
<h3 id="usage-by-other-derive-macros"><a class="header" href="#usage-by-other-derive-macros">Usage by other <code>#[derive(..)]</code> macros</a></h3>
<p>Custom derive macros exist that have a notion of or use default values.</p>
<h4 id="serde"><a class="header" href="#serde"><code>serde</code></a></h4>
<p>For example, the <a href="https://serde.rs/attributes.html"><code>serde</code></a> crate provides a <code>#[serde(default)]</code> attribute that can be used on <code>struct</code>s, and fields. This will use the field’s or type’s <code>Default</code> implementations. This works well with field defaults; <code>serde</code> can either continue to rely on <code>Default</code> implementations in which case this RFC facilitates specification of field defaults; or it can directly use the default values provided in the type definition.</p>
<h4 id="structopt"><a class="header" href="#structopt"><code>structopt</code></a></h4>
<p>Another example is the <code>structopt</code> crate with which you can write:</p>
<pre><code class="language-rust">#[derive(Debug, StructOpt)]
#[structopt(name = "example", about = "An example of StructOpt usage.")]
struct Opt {
    /// Set speed
    #[structopt(short = "s", long = "speed", default_value_t = 42)]
    speed: f64,
    ...
}</code></pre>
<p>By having default field values in the language, <code>structopt</code> could let you write:</p>
<pre><code class="language-rust">#[derive(Debug, StructOpt)]
#[structopt(name = "example", about = "An example of StructOpt usage.")]
struct Opt {
    /// Set speed
    #[structopt(short = "s", long = "speed")]
    speed: f64 = 42,
    ...
}</code></pre>
<h4 id="derive_builder"><a class="header" href="#derive_builder"><code>derive_builder</code></a></h4>
<p>A third example comes from the crate <a href="https://docs.rs/derive_builder/0.7.0/derive_builder/#default-values"><code>derive_builder</code></a>. As the name implies, you can use it to <code>#[derive(Builder)]</code>s for your types. An example is:</p>
<pre><code class="language-rust">#[derive(Builder, Debug, PartialEq)]
struct Lorem {
    #[builder(default = "42")]
    pub ipsum: u32,
}</code></pre>
<h4 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h4>
<p>As seen in the previous sections, rather than make deriving <code>Default</code> more magical, by allowing default field values in the language, user-space custom derive macros can make use of them.</p>
<h2 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h2>
<h3 id="providing-field-defaults"><a class="header" href="#providing-field-defaults">Providing field defaults</a></h3>
<p>Consider a data-type such as (1):</p>
<pre><code class="language-rust">pub struct Probability {
    value: f32,
}</code></pre>
<p>You’d like encode the default probability value to be <code>0.5</code>; With this RFC now you can provide such a default directly where <code>Probability</code> is defined like so (2):</p>
<pre><code class="language-rust">pub struct Probability {
    value: f32 = 0.5,
}</code></pre>
<p>Having done this, you can now construct a <code>Probability</code> with a struct initializer and leave <code>value</code> out to use the default (3):</p>
<pre><code class="language-rust">let prob = Probability { .. };</code></pre>
<h3 id="deriving-default"><a class="header" href="#deriving-default">Deriving <code>Default</code></a></h3>
<p>Previously, you might have instead implemented the <code>Default</code> trait like so (4):</p>
<pre><code class="language-rust">impl Default for Probability {
    fn default() -&gt; Self {
        Self { value: 0.5 }
    }
}</code></pre>
<p>You can now shorten this to (5):</p>
<pre><code class="language-rust">impl Default for Probability {
    fn default() -&gt; Self {
        Self { .. }
    }
}</code></pre>
<p>However, since you had specified <code>value: f32 = 0.5</code> in the definition of <code>Probability</code>, you can take advantage of that to write the more simpler and more idiomatic (6):</p>
<pre><code class="language-rust">#[derive(Default)]
pub struct Probability {
    value: f32 = 0.5,
}</code></pre>
<p>Having done this, a <code>Default</code> implementation equivalent to the one in (5) will be generated for you.</p>
<h3 id="more-fields"><a class="header" href="#more-fields">More fields</a></h3>
<p>As you saw in the <a href="#summary">summary</a>, you are not limited to a single field and all fields need not have any defaults associated with them. Instead, you can freely mix and match. Given the definition of <code>LaunchCommand</code> from the <a href="#motivation">motivation</a> (7):</p>
<pre><code class="language-rust">struct LaunchCommand {
    cmd: String,
    args: Vec&lt;String&gt; = Vec::new(),
    some_special_setting: Option&lt;FancyConfig&gt; = None,
    setting_most_people_will_ignore: Option&lt;FlyMeToTheMoon&gt; = None,
}</code></pre>
<p>you can omit all fields but <code>cmd</code> (8):</p>
<pre><code class="language-rust">let ls_cmd = LaunchCommand {
    cmd: "ls".to_string(),
    ..
};</code></pre>
<p>You can also elect to override the provided defaults (9):</p>
<pre><code class="language-rust">let ls_cmd2 = LaunchCommand {
    cmd: "ls".to_string(),
    args: vec!["-lah".to_string()],
    some_special_setting: make_special_setting(),
    // setting_most_people_will_ignore is still defaulted.
    ..
};</code></pre>
<h3 id="default-fields-values-are-const-contexts"><a class="header" href="#default-fields-values-are-const-contexts">Default fields values are <a href="https://github.com/rust-lang-nursery/reference/blob/66ef5396eccca909536b91cad853f727789c8ebe/src/const_eval.md#const-context"><code>const</code> context</a>s</a></h3>
<p>As you saw in (7), <code>Vec::new()</code>, a function call, was used. However, this assumes that <code>Vec::new</code> is a <em><code>const fn</code></em>. That is, when you provide a default value <code>field: Type = value</code>, the given <code>value</code> must be a <em>constant expression</em> such that it is valid in a <a href="https://github.com/rust-lang-nursery/reference/blob/66ef5396eccca909536b91cad853f727789c8ebe/src/const_eval.md#const-context"><code>const</code> context</a>. Therefore, you cannot write something like (10):</p>
<pre><code class="language-rust">fn launch_missiles() -&gt; Result&lt;(), LaunchFailure&gt; {
    authenticate()?;
    begin_launch_sequence()?;
    ignite()?;
    Ok(())
}

struct BadFoo {
    bad_field: u8 = {
        launch_missiles().unwrap();
        42
    },
}</code></pre>
<p>Since launching missiles interacts with the real world and has <em>side-effects</em> in it, it is not possible to do that in a <code>const</code> context since it may violate deterministic compilation.</p>
<h3 id="privacy-interactions"><a class="header" href="#privacy-interactions">Privacy interactions</a></h3>
<p>The same privacy interactions that the struct update syntax has when a base is present are still at place under this RFC: if a type can’t be constructed from another base expression due to private fields, then it can’t be constructed from field defaults either. See <a href="#future-privacy">Future Possibilities</a> for additional context.</p>
<h3 id="non_exhaustive-interactions"><a class="header" href="#non_exhaustive-interactions"><code>#[non_exhaustive]</code> interactions</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/2008-non-exhaustive.md#structs-1">RFC 2008</a> introduced the attribute <code>#[non_exhaustive]</code> that can be placed on <code>struct</code>, <code>enum</code>, and <code>enum</code> variants. The RFC notes that upon defining a <code>struct</code> in <em>crate A</em> such as (12):</p>
<pre><code class="language-rust">#[non_exhaustive]
pub struct Config {
    pub width: u16,
    pub height: u16,
}</code></pre>
<p>it is <strong><em>not</em></strong> possible to initialize a <code>Config</code> in a different <em>crate B</em> (13):</p>
<pre><code class="language-rust">let config = Config { width: 640, height: 480 };</code></pre>
<p>This is forbidden when <code>#[non_exhaustive]</code> is attached because the purpose of the attribute is to permit adding fields to <code>Config</code> without causing a breaking change. However, the RFC goes on to note that you can pattern match if you allow for the possibility of having fields be ignored with <code>..</code> (14):</p>
<pre><code class="language-rust">let Config { width, height, .. } = config;</code></pre>
<p>This RFC restricts the use of default field values only to types that are <em>not</em> annotated with <code>#[non_exhaustive]</code>, leaving it and the specifics of their interaction if allowed as an open question of future concern. Supporting this without additional compiler support could mean that the following</p>
<pre><code class="language-rust">#[non_exhaustive]
pub struct Foo;

// another crate
let _ = Foo { .. }; // Currently forbidden</code></pre>
<p>Would be <em>allowed</em>, changing the meaning of this code in a way that goes against user intention.</p>
<p>Some alternatives present for the case mentioned above can be:</p>
<ul>
<li>
<p>Add a private non-defaulted field:</p>
<pre><code class="language-rust">#[non_exhaustive]
pub struct Config {
    pub width: u16 = 640,
    pub height: u16 = 480,
    __priv: PhantomData&lt;()&gt;
}</code></pre>
<p>which disallows the following</p>
<pre><code class="language-rust">let _ = Config { .. };
let _ = Config { width: 800, height: 600, .. };</code></pre>
<p>at the cost of forcing the API-internal construction of <code>Config</code> to specify <code>__priv</code> everywhere.</p>
</li>
<li>
<p>If defaulting private fields is allowed outside of the current crate, or that behavior can be explicitly set by the user, then the following:</p>
<pre><code class="language-rust">#[non_exhaustive]
pub struct Config {
    pub width: u16 = 640,
    pub height: u16 = 480,
    __priv: PhantomData&lt;()&gt; = PhantomData,
}</code></pre>
<p>still disallows the following</p>
<pre><code class="language-rust">let _ = Config { .. };
let _ = Config { width: 800, height: 600, .. };</code></pre>
<p>while also allowing precisely that syntax within the API-internal constructions of <code>Config</code>.</p>
</li>
</ul>
<h3 id="defaults-for-enums"><a class="header" href="#defaults-for-enums">Defaults for <code>enum</code>s</a></h3>
<p>The ability to give fields default values is not limited to <code>struct</code>s. Fields of <code>enum</code> variants can also be given defaults (16):</p>
<pre><code class="language-rust">enum Ingredient {
    Tomato {
        color: Color = Color::Red,
        taste: TasteQuality,
    },
    Onion {
        color: Color = Color::Yellow,
    }
}</code></pre>
<p>Given these defaults, you can then proceed to initialize <code>Ingredient</code>s as you did with <code>struct</code>s (17):</p>
<pre><code class="language-rust">let sallad_parts = vec![
    Ingredient::Tomato { taste: Yummy, .. },
    Ingredient::Tomato { taste: Delicious, color: Color::Green, },
    Ingredient::Onion { .. },
];</code></pre>
<p>Note that <code>enum</code> variants have public fields and in today’s Rust, this cannot be controlled with visibility modifiers on variants.</p>
<p>Furthermore, when <code>#[non_exhaustive]</code> is specified directly on an <code>enum</code>, it has no interaction with the defaults values and the ability to construct variants of said enum. However, as specified by <a href="https://github.com/rust-lang/rfcs/blob/master/text/2008-non-exhaustive.md#structs-1">RFC 2008</a>, <code>#[non_exhaustive]</code> is permitted on variants. When that occurs, the behaviour is the same as if it had been attached to a <code>struct</code> with the same fields and field visibility.</p>
<h4 id="interaction-with-default"><a class="header" href="#interaction-with-default">Interaction with <code>#[default]</code></a></h4>
<p>It is possible today to specify a <a href="https://github.com/rust-lang/rfcs/pull/3107"><code>#[default]</code> variant</a> in an enum so that it can be <code>#[derive(Default)]</code>. A variant marked with <code>#[default]</code> will use defaulted fields when present.</p>
<pre><code class="language-rust">#[derive(Default)]
enum Ingredient {
    Tomato {
        color: Color = Color::Red,
        taste: TasteQuality,
    },
    Onion {
        color: Color = Color::Yellow,
    },
    #[default]
    Lettuce {
        color: Color = Color::Green,
    },
}</code></pre>
<p>Now the compiler does know that <code>Ingredient::Lettuce</code> should be considered the default and will accordingly generate an appropriate implementation of <code>Default for Ingredient</code> (19):</p>
<pre><code class="language-rust">impl Default for Ingredient {
    fn default() -&gt; Self {
        Ingredient::Lettuce {
            color: Color::Green,
        }
    }
}</code></pre>
<h3 id="defaults-on-tuple-structs-and-tuple-enum-variants"><a class="header" href="#defaults-on-tuple-structs-and-tuple-enum-variants">Defaults on tuple <code>struct</code>s and tuple <code>enum</code> variants</a></h3>
<p>Default values are only allowed on named fields. There is no syntax provided for tuple types like <code>struct S(i32)</code> or <code>enum E { V(i32), }</code>.</p>
<h2 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h2>
<h3 id="field-default-values"><a class="header" href="#field-default-values">Field default values</a></h3>
<h4 id="grammar"><a class="header" href="#grammar">Grammar</a></h4>
<p>Let the grammar of record fields in <code>struct</code>s and <code>enum</code> variants be defined like so (in the <code>.lyg</code> notation):</p>
<pre><code class="language-rust">RecordField = attrs:OuterAttr* vis:Vis? name:IDENT ":" ty:Type;</code></pre>
<p>Then, <code>RecordField</code> is changed into:</p>
<pre><code class="language-rust">RecordField = attrs:OuterAttr* vis:Vis? name:IDENT ":" ty:Type { "=" def:Expr }?;</code></pre>
<p>Further, given the following partial definition for the expression grammar:</p>
<pre><code class="language-rust">Expr = attrs:OuterAttr* kind:ExprKind;
ExprKind =
  | ...
  | Struct:{ path:Path "{" attrs:InnerAttr* fields:StructExprFieldsAndBase "}" }
  ;

StructExprFieldsAndBase =
  | Fields:{ fields:StructExprField* % "," ","? }
  | Base:{ ".." base:Expr }
  | FieldsAndBase:{ fields:StructExprField+ % "," "," ".." base:Expr }
  ;
StructExprField = attrs:OuterAttr* kind:StructExprFieldKind;
StructExprFieldKind =
  | Shorthand:IDENT
  | Explicit:{ field:FieldName ":" expr:Expr }
  ;</code></pre>
<p>the rule <code>StructExprFieldsAndBase</code> is extended with:</p>
<pre><code class="language-rust">StructExprFieldsAndBase =| FieldsAndDefault:{ fields:StructExprField+ % "," "," ".." };
StructExprFieldsAndBase =| Default:{ ".." }</code></pre>
<h4 id="static-semantics"><a class="header" href="#static-semantics">Static semantics</a></h4>
<h5 id="defining-defaults"><a class="header" href="#defining-defaults">Defining defaults</a></h5>
<p>Given a <code>RecordField</code> where the default is specified, i.e.:</p>
<pre><code class="language-rust">RecordField = attrs:OuterAttr* vis:Vis? name:IDENT ":" ty:Type "=" def:Expr;</code></pre>
<p>all the following rules apply when type-checking:</p>
<ol>
<li>
<p>The expression <code>def</code> must be a constant expression.</p>
</li>
<li>
<p>The expression <code>def</code> must coerce to the type <code>ty</code>.</p>
</li>
<li>
<p>Generic parameters of the current items are accessible</p>
<pre><code class="language-rust">struct Bar&lt;const A: usize&gt; {
    field: usize = A,
}</code></pre>
</li>
<li>
<p>Default const expressions are <em>not</em> evaluated at definition time, only during instantiation. This means that the following will not fail to compile:</p>
<pre><code class="language-rust">struct Bar {
    field1: usize = panic!(),
    field2: usize = 42,
}

let _ = Bar { field1: 0, .. };</code></pre>
<p>Having said that, it can be possible to proactivelly attempt to evaluate the default values and emit a lint in a case where the expression is assured to always fail (which would only be possible for expressions that do not reference <code>const</code> parameters).</p>
</li>
<li>
<p>The <code>struct</code>’s parameters are properly propagated, meaning the following is possible:</p>
<pre><code class="language-rust">struct Bar&lt;T&gt; {
    field: Vec&lt;T&gt; = Vec::new(),
}

let _ = Bar::&lt;i32&gt; { .. };</code></pre>
</li>
</ol>
<p>When lints check attributes such as <code>#[allow(lint_name)]</code> are placed on a <code>RecordField</code>, it also applies to <code>def</code> if it exists.</p>
<h5 id="initialization-expressions"><a class="header" href="#initialization-expressions">Initialization expressions</a></h5>
<p><code>Path { fields, .. }</code> is <code>const</code> since the defaulted fields are initialized from constants.</p>
<h3 id="derivedefault"><a class="header" href="#derivedefault"><code>#[derive(Default)]</code></a></h3>
<p>When generating an implementation of <code>Default</code> for a <code>struct</code> named <code>$s</code> on which <code>#[derive(Default)]</code> has been attached, the compiler will omit all fields which have default values provided in the <code>struct</code>. The the associated function <code>default</code> shall then be defined as (where <code>$f_i</code> denotes the <code>i</code>-th field of <code>$s</code>):</p>
<pre><code class="language-rust">fn default() -&gt; Self {
    $s { $f_i: Default::default(), .. }
}</code></pre>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>The usual drawback of increasing the complexity of the language applies. However, the degree to which complexity is increased is not substantial.</p>
<p>In particular, the syntax <code>Foo { .. }</code> mirrors the identical and already existing pattern syntax. This makes the addition of <code>Foo { .. }</code> at worst low-cost and potentially cost-free.</p>
<p>It is true that there are cases where <code>Foo { ..Default::default() }</code> will be allowed where <code>Foo { .. }</code> won’t be, and vice-versa.</p>
<p>This new syntax is more ergonomic to use, but it requires specifying a default value for every field which can be much less ergonomic than using <code>#[derive(Default)]</code> on your type. The following two are almost equivalent, and the more fields there are, the more the verbosity is increased:</p>
<pre><code class="language-rust">#[derive(Default)]
struct S {
    foo: Option&lt;String&gt;,
    bar: Option&lt;String&gt;,
}</code></pre>
<pre><code class="language-rust">struct S {
    foo: Option&lt;String&gt; = None,
    bar: Option&lt;String&gt; = None,
}</code></pre>
<p>This can become relevant when an API author wants to push users towards the new syntax because <code>..</code> is shorter than <code>..Default::default()</code>, or when some fields with types that <code>impl Default</code> are optional, but <code>#[derive(Default)]</code> can’t be used because some fields are mandatory.</p>
<p>The main complexity comes instead from introducing <code>field: Type = expr</code>. However, as seen in the <a href="#prior-art">prior-art</a>, there are several widely-used languages that have a notion of field / property / instance-variable defaults. Therefore, the addition is intuitive and thus the cost is seen as limited. As an implementation detail, <code>rustc</code> <em>already</em> parses <code>field: Type = expr</code> purely to provide an appropriate diagnostic error:</p>
<pre><code>error: default values on `struct` fields aren't supported
 --&gt; src/lib.rs:2:28
  |
2 |     pub alpha: &amp;'static str = "",
  |                            ^^^^^ help: remove this unsupported default value
</code></pre>
<p>An issue arises when considering <code>const</code> patterns. A pattern <code>Foo { .. }</code> can match more things than just the expression <code>Foo { .. }</code>, because the pattern matches any value of the unmentioned fields, but the expression sets them to a particular value. This means that, with the unstable <code>inline_const_pat</code>, the arm <code>const { Foo { .. } } =&gt;</code> matches less than the arm <code>Foo { .. } =&gt;</code> (assuming a type like <code>struct Foo { a: i32 = 1 }</code>). A way to mitigate this might be to use an alternative syntax, like <code>...</code> or <code>..kw#default</code>.</p>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<p>Besides the given <a href="#motivation">motivation</a>, there are some specific design choices worthy of more in-depth discussion, which is the aim of this section.</p>
<h3 id="provided-associated-items-as-precedent"><a class="header" href="#provided-associated-items-as-precedent">Provided associated items as precedent</a></h3>
<p>While Rust does not have any support for default values for fields or for formal parameters of functions, the notion of defaults are not foreign to Rust.</p>
<p>Indeed, it is possible to provide default function bodies for <code>fn</code> items in <code>trait</code> definitions. For example:</p>
<pre><code class="language-rust">pub trait PartialEq&lt;Rhs: ?Sized = Self&gt; {
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;

    fn ne(&amp;self, other: &amp;Rhs) -&gt; bool { // A default body.
        !self.eq(other)
    }
}</code></pre>
<p>In traits, <code>const</code> items can also be assigned a default value. For example:</p>
<pre><code class="language-rust">trait Foo {
    const BAR: usize = 42; // A default value.
}</code></pre>
<p>Thus, to extend Rust with a notion of field defaults is not an entirely alien concept.</p>
<h3 id="pattern-matching-follows-construction"><a class="header" href="#pattern-matching-follows-construction">Pattern matching follows construction</a></h3>
<p>In mathematics there is a notion of one thing being the <em><a href="https://en.wikipedia.org/wiki/Duality_(mathematics)">dual</a></em> of another. Loosely speaking, duals are often about inverting something. In Rust, one example of such an inversion is expressions and patterns.</p>
<p>Expressions are used to <em>build up</em> and patterns <em>break apart</em>; While it doesn’t hold generally, a principle of language design both in Rust and other languages with with pattern matching has been that the syntax for patterns should, to the extent possible, follow that of expressions.</p>
<p>For example:</p>
<ul>
<li>
<p>You can match on or build up a struct with <code>Foo { field }</code>. For patterns this will make <code>field</code> available as a binding while for expressions the binding <code>field</code> will be used to build a <code>Foo</code>.</p>
<p>For a tuple struct, <code>Foo(x)</code> will work both for construction and matching.</p>
</li>
<li>
<p>If you want to be more flexible, both patterns and expressions permit <code>Foo { field: bar }</code>.</p>
</li>
<li>
<p>You can use both <code>&amp;x</code> to dereference and bind to <code>x</code> or construct a reference to <code>x</code>.</p>
</li>
<li>
<p>An array can be constructed with <code>[a, b, c, d]</code> and the same is a valid pattern for destructuring an array.</p>
</li>
</ul>
<p>The reason why matching should follow construction is that it makes languages easier to understand; you simply learn the expression syntax and then reuse it to run the process in reverse.</p>
<p>In some places, Rust could do a better job than it currently does of adhering to this principle. In this particular case, the pattern syntax <code>Foo { a, b: c, .. }</code> has no counterpart in the expression syntax. This RFC rectifies this by permitting <code>Foo { a, b: c, .. }</code> as an expression syntax; this is identical to the expression syntax and thus consistency has been gained.</p>
<p>However, it is not merely sufficient to use the same syntax for expressions; the semantics also have to be similar in kind for things to work out well. This RFC argues that this is the case because in both contexts, <code>..</code> indicates something partially ignorable is going on: “I am <em>destructuring</em>/<em>constructing</em> this struct, and by the way there are some more fields I don’t care about <em>and let’s</em> drop those* / <em>and let’s fill in with default values</em>”. In a way, the use of <code>_</code> to mean both a catch-all pattern and type / value placeholder is similar to <code>..</code>; in the case of <code>_</code> both cases indicate something unimportant going on. For patterns, <code>_</code> matches everything and doesn’t give access to the value; for types, the placeholder is just an unbounded inference variable.</p>
<h3 id="on-const-contexts"><a class="header" href="#on-const-contexts">On <code>const</code> contexts</a></h3>
<p>To recap, the expression a default value is computed with must be constant one. There are many reasons for this restriction:</p>
<ul>
<li>
<p>If <em>determinism</em> is not enforced, then just by writing the following snippet, the condition <code>x == y</code> may fail:</p>
<pre><code class="language-rust">let x = Foo { .. };
let y = Foo { .. };</code></pre>
<p>This contributes to surprising behaviour overall.</p>
<p>Now you may object with an observation that if you replace <code>Foo { .. }</code> with <code>make_foo()</code> then a reader no longer know just from the syntactic form whether <code>x == y</code> is still upheld. This is indeed true. However, there is a general expectation in Rust that a function call may not behave deterministically. Meanwhile, for the syntactic form <code>Foo { .. }</code> and with default values, the whole idea is that they are something that doesn’t require close attention.</p>
</li>
<li>
<p>The broader class of problem that non-determinism highlights is that of <em>side</em>-effects. These effects wrt. program behaviour are prefixed with <em>“side”</em> because they happen without being communicated in the type system or more specifically in the inputs and outputs of a function.</p>
<p>In general, it is easier to do formal verification of programs that lack side-effects. While programming with Rust, requirements are usually not that demanding and robust. However, the same properties that make pure logic easier to formally verify also make for more <em>local reasoning</em>.</p>
<p><em>By requring default field values to be <code>const</code> contexts, global reasoning can be avoided. Thus, the <a href="https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html#implicit-vs-explicit">reasoning footprint</a> for <code>Foo { .. }</code> is reduced.</em></p>
</li>
<li>
<p>By restricting ourselves to <code>const</code> contexts, you can be sure that default literals have a degree of <em>cheapness</em>.</p>
<p>While <code>const</code> expressions form a turing complete language and therefore have no limits to their complexity other than being computable, these expressions are evaluated at <em>compile time</em>. Thus, <em><code>const</code> expressions cannot have unbounded complexity at run-time</em>. At most, <code>const</code> expressions can create huge arrays and similar cases;</p>
<p>Ensuring that <code>Foo { .. }</code> remains relatively cheap is therefore important because there is a general expectation that literal expressions have a small and predictable run-time cost and are trivially predictable. This is particularly important for Rust since this is a language that aims to give a high degree of control over space and time as well as predictable performance characteristics.</p>
</li>
<li>
<p>Keeping default values limited to <code>const</code> expressions ensures that if the following situation develops:</p>
<pre><code class="language-rust">// Crate A:
pub struct Foo {
    bar: u8 = const_expr,
}

// Crate B:
const fn baz() -&gt; Foo {
    Foo { .. }
}</code></pre>
<p>then crate A cannot suddenly, and unawares, cause a semver breakage for crate B by replacing <code>const_expr</code> with <code>non_const_expr</code> since the compiler would reject such a change (see lemmas 1-2). Thus, enforcing constness gives a helping hand in respecting semantic version.</p>
<p>Note that if Rust would ever gain a mechanism to state that a function will not diverge, e.g.:</p>
<pre><code class="language-rust">nopanic fn foo() -&gt; u8 { 42 } // The weaker variant; more easily attainable.
total fn bar() -&gt; u8 { 24 } // No divergence, period.</code></pre>
<p>then the same semver problem would manifest itself for those types of functions. However, Rust does not have any such enforcement mechanism right now and if it did, it is generally harder to ensure that a function is total than it is to ensure that it is deterministic; thus, while it is regrettable, this is an acceptable trade-off.</p>
</li>
<li>
<p>Finally, note that <code>const fn</code>s, can become quite expressive. For example, it is possible to use <code>loop</code>s, <code>match</code>es, <code>let</code> statements, and <code>panic!(..)</code>s. Another feasible extension in the future is allocation.</p>
<p>Therefore, constant expressions should be enough to satisfy most expressive needs.</p>
</li>
</ul>
<h3 id="instead-of-foo--defaultdefault-"><a class="header" href="#instead-of-foo--defaultdefault-">Instead of <code>Foo { ..Default::default() }</code></a></h3>
<p>As an alternative to the proposed design is either explicitly writing out <code>..Default::default()</code> or extending the language such that <code>Foo { .. }</code> becomes sugar for <code>Foo { ..Default::default() }</code>. While the former idea does not satisfy any of the <a href="#motivation">motivation</a> set out, the latter does to a small extent.</p>
<p>In particular, <code>Foo { .. }</code> as sugar slightly improves ergonomics. However, it has some notable problems:</p>
<ul>
<li>
<p>Because it desugars to <code>Foo { ..Default::default() }</code>, it cannot be required that the expression is a constant one. This carries all the problems noted in the previous section on why default field values should be a <code>const</code> context.</p>
</li>
<li>
<p>There is no way of implementing a <code>Default</code> implementation that has mandatory fields for users to specify during value construction.</p>
</li>
<li>
<p>It provides zero improvements to the ergonomics of <em>specifying</em> defaults, only for using them. Arguably, the most important aspect of this RFC is not the syntax <code>Foo { .. }</code> but rather the ability to provide default values for fields.</p>
</li>
<li>
<p>By extension, the improvement to documentation clarity is lost.</p>
</li>
<li>
<p>The trait <code>Default</code> must now become a <code>#[lang_item]</code>. This is a sign of increasing the overall magic in the system; meanwhile, this proposal makes the default values provided usable by other custom derive macros.</p>
</li>
</ul>
<p>Thus in conclusion, while desugaring <code>..</code> to <code>Default::default()</code> has lower cost, it also provides significantly less value to the point of not being worth it.</p>
<h3 id="-is-useful-as-a-marker"><a class="header" href="#-is-useful-as-a-marker"><code>..</code> is useful as a marker</a></h3>
<p>One possible change to the current design is to permit filling in defaults by simply writing <code>Foo {}</code>; in other words, <code>..</code> is simply dropped from the expression.</p>
<p>Among the benefits are:</p>
<ul>
<li>
<p>To enhance ergonomics of initialization further.</p>
</li>
<li>
<p>To introduce less syntax.</p>
</li>
<li>
<p>To be more in line with how other languages treat default values.</p>
</li>
</ul>
<p>Among the drawbacks are:</p>
<ul>
<li>
<p>The syntax <code>Foo { .. }</code> is no longer introduced to complement the identical pattern syntax. As aforementioned, destruction (and pattern matching) generally attempts to follow construction in Rust. Because of that, introducing <code>Foo { .. }</code> is essentially cost-free in terms of the complexity budget. It is arguably even cost-negative.</p>
</li>
<li>
<p>By writing <code>Foo { .. }</code>, there is explicit indication that default values are being used; this enhances local reasoning further.</p>
</li>
</ul>
<p>This RFC requires the <code>..</code> to get defaulted fields because it wants to continue to allow the workflow of intentionally <em>not</em> including <code>..</code> in the struct literal expression so that when a user adds a field they get compilation errors on every use – just like is currently possible in patterns by not including <code>..</code> in the struct pattern.</p>
<h3 id="named-function-arguments-with-default-values"><a class="header" href="#named-function-arguments-with-default-values">Named function arguments with default values</a></h3>
<p>A frequently requested feature is named function arguments. Today, the way to design around the lack of these in the language are:</p>
<ul>
<li>Builder pattern</li>
<li>Defining a <code>struct</code> “bag-object” where optional fields are set, making users call functions in the following way: <code>foo(mandatory, Optionals { bar: 42, ..Default::default() })</code></li>
<li>Provide multiple methods: <code>fn foo(mandatory)</code> <em>and</em> <code>fn foo_with_bar(mandatory, bar)</code></li>
</ul>
<h2 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h2>
<p>A prior version of this RFC, from which part of the contents in this version were sourced, exists at https://github.com/Centril/rfcs/pull/19.</p>
<p>This RFC was informed by a <a href="https://internals.rust-lang.org/t/pre-pre-rfc-syntactic-sugar-for-default-default/13234/75">lengthy discussion in internals.rust-lang.org</a> from a few years prior.</p>
<p>Another prior RFC for the same feature is at https://github.com/rust-lang/rfcs/pull/1806.</p>
<h3 id="other-languages"><a class="header" href="#other-languages">Other languages</a></h3>
<p>This selection of languages are not exhaustive; rather, a few notable or canonical examples are used instead.</p>
<h4 id="java"><a class="header" href="#java">Java</a></h4>
<p>In Java it is possible to assign default values, computed by any expression, to an instance variable; for example, you may write:</p>
<pre><code class="language-java">class Main {
    public static void main(String[] args) {
        new Foo();
    }

    public static int make_int() {
        System.out.println("I am making an int!");
        return 42;
    }

    static class Foo {
        private int bar = Main.make_int();
    }
}
</code></pre>
<p>When executing this program, the JVM will print the following to <code>stdout</code>:</p>
<pre><code>I am making an int!
</code></pre>
<p>Two things are worth noting here:</p>
<ol>
<li>
<p>It is possible to cause arbitrary side effects in the expression that computes the default value of <code>bar</code>. This behaviour is unlike that which this RFC proposes.</p>
</li>
<li>
<p>It is possible to construct a <code>Foo</code> which uses the default value of <code>bar</code> even though <code>bar</code> has <code>private</code> visibility. This is because default values act as syntactic sugar for how the default constructor <code>Foo()</code> should act. There is no such thing as constructors in Rust. However, the behaviour that Java has is morally equivalent to this RFC since literals are constructor-like and because this RFC also permits the usage of defaults for private fields where the fields are not visible.</p>
</li>
</ol>
<h4 id="scala"><a class="header" href="#scala">Scala</a></h4>
<p>Being a JVM language, Scala builds upon Java and retains the notion of default field values. For example, you may write:</p>
<pre><code class="language-scala">case class Person(name: String = make_string(), age: Int = 42)

def make_string(): String = {
    System.out.println("foo");
    "bar"
}

var p = new Person(age = 24);
System.out.println(p.name);
</code></pre>
<p>As expected, this prints <code>foo</code> and then <code>bar</code> to the terminal.</p>
<h4 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h4>
<p>Kotlin is similar to both Java and Scala; here too can you use defaults:</p>
<pre><code class="language-kotlin">fun make_int(): Int {
    println("foo");
    return 42;
}

class Person(val age: Int = make_int());

fun main() {
    Person();
}
</code></pre>
<p>Similar to Java and Scala, Kotlin does also permit side-effects in the default values because both languages have no means of preventing the effects.</p>
<h4 id="c"><a class="header" href="#c">C#</a></h4>
<p>Another language with defaults of the object-oriented variety is C#. The is behaviour similar to Java:</p>
<pre><code class="language-csharp">class Foo {
    int bar = 42;
}
</code></pre>
<h4 id="c-1"><a class="header" href="#c-1">C++</a></h4>
<p>Another language in the object-oriented family is C++. It also affords default values like so:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int make_int() {
    std::cout &lt;&lt; "hello" &lt;&lt; std::endl; // As in Java.
    return 42;
}

class Foo {
    private:
        int bar = make_int();
    public:
        int get_bar() {
          return this-&gt;bar;
        }
};

int main() {
    Foo x;
    std::cout &lt;&lt; x.get_bar() &lt;&lt; std::endl;
}
</code></pre>
<p>In C++ it is still the case that the defaults are usable due to constructors. And while the language has <code>constexpr</code> to enforce the ability to evaluate something at compile time, as can be seen in the snippet above, no such requirement is placed on default field values.</p>
<h4 id="swift"><a class="header" href="#swift">Swift</a></h4>
<p>A language which is closer to Rust is <a href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html">Swift</a>, and it allows for default values:</p>
<pre><code class="language-swift">struct Person {
    var age = 42
}
</code></pre>
<p>This is equivalent to writing:</p>
<pre><code class="language-swift">struct Person {
    var age: Int
    init() {
        age = 42
    }
}
</code></pre>
<h4 id="agda"><a class="header" href="#agda">Agda</a></h4>
<p>Having defaults for record fields is not the sole preserve of OO languages. The pure, total, and dependently typed functional programming language Agda also affords default values. For example, you may write:</p>
<pre><code class="language-agda">-- | Define the natural numbers inductively:
-- This corresponds to an `enum` in Rust.
data Nat : Set where
    zero : Nat
    suc  : Nat → Nat

-- | Define a record type `Foo` with a field named `bar` typed at `Nat`.
record Foo : Set where
    bar : Nat
    bar = zero -- An optionally provided default value.

myFoo : Foo
myFoo = record {} -- Construct a `Foo`.
</code></pre>
<p>In contrast to languages such as Java, Agda does not have have a notion of constructors. Rather, <code>record {}</code> fills in the default value.</p>
<p>Furthermore, Agda is a pure and <a href="https://en.wikipedia.org/wiki/Normalization_property_(abstract_rewriting)">strongly normalizing</a> language and as such, <code>record {}</code> may not cause any side-effects or even divergence. However, as Agda employs monadic IO in the vein of Haskell, it is possible to store a <code>IO Nat</code> value in the record:</p>
<pre><code class="language-agda">record Foo : Set where
    bar : IO Nat
    bar = do
        putStrLn "hello!"
        pure zero
</code></pre>
<p>Note that this is explicitly typed as <code>bar : IO Nat</code> and that <code>record {}</code> won’t actually run the action. To do that, you will need take the <code>bar</code> value and run it in an <code>IO</code> context.</p>
<h3 id="procedural-macros"><a class="header" href="#procedural-macros">Procedural macros</a></h3>
<p>There are a number of crates which to varying degrees afford macros for default field values and associated facilities.</p>
<h4 id="derivebuilder"><a class="header" href="#derivebuilder"><code>#[derive(Builder)]</code></a></h4>
<p>A third example comes from the crate <a href="https://docs.rs/derive_builder/0.7.0/derive_builder/#default-values"><code>derive_builder</code></a>. As the name implies, you can use it to <code>#[derive(Builder)]</code>s for your types. An example is:</p>
<pre><code class="language-rust">#[derive(Builder, Debug, PartialEq)]
struct Lorem {
    #[builder(default = "42")]
    pub ipsum: u32,
}</code></pre>
<p>Under this RFC, the code would be</p>
<pre><code class="language-rust">#[derive(Default, Debug, PartialEq)]
struct Lorem {
    pub ipsum: u32 = 42,
}</code></pre>
<h4 id="derivederivative"><a class="header" href="#derivederivative"><code>#[derive(Derivative)]</code></a></h4>
<p>The crate <a href="https://crates.io/crates/derivative"><code>derivative</code></a> provides the <code>#[derivative(Default)]</code> attribute. With it, you may write:</p>
<pre><code class="language-rust">#[derive(Derivative)]
#[derivative(Default)]
struct RegexOptions {
    #[derivative(Default(value="10 * (1 &lt;&lt; 20)"))]
    size_limit: usize,
    #[derivative(Default(value="2 * (1 &lt;&lt; 20)"))]
    dfa_size_limit: usize,
    #[derivative(Default(value="true"))]
    unicode: bool,
}

#[derive(Derivative)]
#[derivative(Default)]
enum Foo {
    #[derivative(Default)]
    Bar,
    Baz,
}</code></pre>
<p>Contrast this with the equivalent in the style of this RFC:</p>
<pre><code class="language-rust">#[derive(Default)]
struct RegexOptions {
    size_limit: usize = 10 * (1 &lt;&lt; 20),
    dfa_size_limit: usize = 2 * (1 &lt;&lt; 20),
    unicode: bool = true,
}

#[derive(Default)]
enum Foo {
    #[default]
    Bar,
    Baz,
}</code></pre>
<p>There a few aspects to note:</p>
<ol>
<li>
<p>The signal to noise ratio is low as compared to the notation in this RFC. Substantial of syntactic overhead is accumulated to specify defaults.</p>
</li>
<li>
<p>Expressions need to be wrapped in strings, i.e. <code>value="2 * (1 &lt;&lt; 20)"</code>. While this is flexible and allows most logic to be embedded, the mechanism works poorly with IDEs and other tooling. Syntax highlighting also goes out of the window because the highlighter has no idea that the string included in the quotes is Rust code. It could just as well be a poem due to Shakespeare. At best, a highlighter could use some heuristic.</p>
</li>
<li>
<p>The macro has no way to enforce that the code embedded in the strings are constant expressions. It might be possible to fix that but that might increase the logic of the macro considerably.</p>
</li>
<li>
<p>Because the macro merely customizes how deriving <code>Default</code> works, it cannot provide the syntax <code>Foo { .. }</code>, interact with privacy, and it cannot provide defaults for <code>enum</code> variants.</p>
</li>
<li>
<p>Like in this RFC, <code>derivative</code> allows you to derive <code>Default</code> for <code>enum</code>s. The syntax used in the macro is <code>#[derivative(Default)]</code> whereas the RFC provides the more ergonomic and direct notation <code>#[default]</code> in this RFC.</p>
</li>
<li>
<p>To its credit, the macro provides <code>#[derivative(Default(bound=""))]</code> with which you can remove unnecessary bounds as well as add needed ones. This addresses a <a href="https://smallcultfollowing.com/babysteps/blog/2022/04/12/implied-bounds-and-perfect-derive/">deficiency in the current deriving system</a> for built-in derive macros. However, the attribute solves an orthogonal problem.  The ability to specify default values would mean that <code>derivative</code> can piggyback on the default value syntax due to this RFC. The mechanism for removing or adding bounds can remain the same. Similar mechanisms could also be added to the language itself.</p>
</li>
</ol>
<h4 id="derivesmartdefault"><a class="header" href="#derivesmartdefault"><code>#[derive(SmartDefault)]</code></a></h4>
<p>The <a href="https://crates.io/crates/smart-default"><code>smart-default</code></a> provides <code>#[derive(SmartDefault)]</code> custom derive macro. It functions similarly to <code>derivative</code> but is specialized for the <code>Default</code> trait. With it, you can write:</p>
<pre><code class="language-rust">#[derive(SmartDefault)]
struct RegexOptions {
    #[default = "10 * (1 &lt;&lt; 20)"]
    size_limit: usize,
    #[default = "2 * (1 &lt;&lt; 20)"]
    dfa_size_limit: usize,
    #[default = true]
    unicode: bool,
}

#[derive(SmartDefault)]
enum Foo {
    #[default]
    Bar,
    Baz,
}</code></pre>
<ul>
<li>
<p>The signal to noise ratio is still higher as compared to the notation in due to this RFC. The problems aforementioned from the <code>derivative</code> crate with respect to embedding Rust code in strings also persists.</p>
</li>
<li>
<p>Points 2-4 regarding <code>derivative</code> apply to <code>smart-default</code> as well.</p>
</li>
<li>
<p>The same syntax <code>#[default]</code> is used both by <code>smart-default</code> and by this RFC. While it may seem that this RFC was inspired by <code>smart-default</code>, this is not the case. Rather, this RFC’s author came up with the notation independently. That suggests that the notation is intuitive since and a solid design choice.</p>
</li>
<li>
<p>There is no trait <code>SmartDefault</code> even though it is being derived. This works because <code>#[proc_macro_derive(SmartDefault)]</code> is in fact not tied to any trait. That <code>#[derive(Serialize)]</code> refers to the same trait as the name of the macro is from the perspective of the language’s static semantics entirely coincidental.</p>
<p>However, for users who aren’t aware of this, it may seem strange that <code>SmartDefault</code> should derive for the <code>Default</code> trait.</p>
</li>
</ul>
<h4 id="derivenew"><a class="header" href="#derivenew"><code>#[derive(new)]</code></a></h4>
<p>The <a href="https://crates.io/crates/derive-new"><code>derive-new</code></a> crate provides the <code>#[derive(new)]</code> custom derive macro. Unlike the two previous procedural macro crates, <code>derive-new</code> does not provide implementations of <code>Default</code>. Rather, the macro facilitates the generation of <code>MyType::new</code> constructors.</p>
<p>For example, you may write:</p>
<pre><code class="language-rust">#[derive(new)]
struct Foo {
    x: bool,
    #[new(value = "42")]
    y: i32,
    #[new(default)]
    z: Vec&lt;String&gt;,
}

Foo::new(true);

#[derive(new)]
enum Enum {
    FirstVariant,
    SecondVariant(bool, #[new(default)] u8),
    ThirdVariant { x: i32, #[new(value = "vec![1]")] y: Vec&lt;u8&gt; }
}

Enum::new_first_variant();
Enum::new_second_variant(true);
Enum::new_third_variant(42);</code></pre>
<p>Notice how <code>#[new(value = "vec![1]")</code>, <code>#[new(value = "42")]</code>, and <code>#[new(default)]</code> are used to provide values that are then omitted from the respective constructor functions that are generated.</p>
<p>If you transcribe the above snippet as much as possible to the system proposed in this RFC, you would get:</p>
<pre><code class="language-rust">struct Foo {
    x: bool,
    y: i32 = 42,
    z: Vec&lt;String&gt; = &lt;_&gt;::default(),
    //               --------------
    //               note: assuming some `impl const Default { .. }` mechanism.
}

Foo { x: true };

enum Enum {
    FirstVariant,
    SecondVariant(bool, u8), // See future possibilities.
    ThirdVariant { x: i32, y: Vec&lt;u8&gt; = vec![1] }
}

Enum::FirstVariant;
Enum::SecondVariant(true, 0);
Enum::ThirdVariant { x: 42 };</code></pre>
<p>Relative to <code>#[derive(new)]</code>, the main benefits are:</p>
<ul>
<li>No wrapping code in strings, as noted in previous sections.</li>
<li>The defaults used can be mixed and matches; it works to request all defaults or just some of them.</li>
</ul>
<p>The constructor functions <code>new_first_variant(..)</code> are not provided for you. However, it should be possible to tweak <code>#[derive(new)]</code> to interact with this RFC so that constructor functions are regained if so desired.</p>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<h3 id="non_exhaustive"><a class="header" href="#non_exhaustive"><code>#[non_exhaustive]</code></a></h3>
<ol>
<li>
<p>What is the right interaction wrt. <code>#[non_exhaustive]</code>?</p>
<p>In particular, if given the following definition:</p>
<pre><code class="language-rust">#[non_exhaustive]
pub struct Config {
    pub height: u32,
    pub width: u32,
}</code></pre>
<p>it could be possible to construct a <code>Config</code> like so, if the construction of types without default field values is allowed (to support semver changes):</p>
<pre><code class="language-rust">let config = Config { width: 640, height: 480, .. };</code></pre>
<p>then adding a field to <code>Config</code> can only happen if and only if that field is provided a default value.</p>
<p>This arrangement, while diminishing the usefulness of <code>#[non_exhaustive]</code>, makes the ruleset of the language simpler, more consistent, and also simplifies type checking as <code>#[non_exhaustive]</code> is entirely ignored when checking <code>Foo { fields, .. }</code> expressions.</p>
<p>As an alternative, users who desire the semantics described above can omit <code>#[non_exhaustive]</code> from their type and instead add a private defaulted field that has a ZST, if the construction of structs with private fields is allowed. If they are not, then the attribute is still relevant and needed to control the accepted code to force <code>..</code>.</p>
</li>
</ol>
<h3 id="enum-variants"><a class="header" href="#enum-variants"><code>enum</code> variants</a></h3>
<p>Currently <code>#[derive(Default)]</code> only supports unit <code>enum</code> variants. In this RFC we propose supporting <code>..</code> on struct <code>enum</code> variants. It would be nice to keep the symmetry with <code>struct</code>s and support <code>#[derive(Default)]</code> on them, but it is not absolutely necessary. <a href="https://github.com/rust-lang/rfcs/pull/3683">RFC-3683</a> proposes that support. These two features are technically orthogonal, but work well together.</p>
<h2 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h2>
<h3 id="non_exhaustive-interactions-1"><a class="header" href="#non_exhaustive-interactions-1"><code>#[non_exhaustive]</code> interactions</a></h3>
<p>This RFC doesn’t allow mixing default field values and <code>#[non_exhaustive]</code> because of the interaction with the allowance to build struct literals that have private fields:</p>
<pre><code class="language-rust">#[non_exhaustive]
pub struct Foo {
    bar: i32 = 42,
}

// another crate
let _ = Foo { .. }; // Currently forbidden, but would be allowed by this RFC without the attribute</code></pre>
<p>There are several options:</p>
<ul>
<li>Allow <code>#[non_exhaustive]</code> but deny the ability to build a struct literal when there are non-accessible fields with defaults</li>
<li>Disallow both <code>#[non_exhaustive]</code> and building struct literals with private fields in order to resolve the interaction some-time in the future, as <em>enabling</em> either ability is a backwards compatible change that strictly allows more code to work</li>
<li>Have additional rules on what the interactions are, like for example allow building struct literals with private fields <em>as long as</em> the type isn’t annotated with <code>#[non_exhaustive]</code></li>
<li>Extend <code>#[non_exhaustive]</code> with arguments in order to specify the desired behavior</li>
<li>Change the defaults of <code>#[non_exhaustive]</code> and allow for the change in meaning of it being set</li>
</ul>
<p>I propose to go for the maximally restrictive version of the default field values feature, and allow for future experimentation of which of these options best fits the language.</p>
<p>The following also needs to be specified:</p>
<pre><code class="language-rust">#[non_exhaustive]
pub struct Foo;

// another crate
let _ = Foo { .. }; // Currently forbidden</code></pre>
<h3 id="privacy-building-structs-with-private-defaulted-fields"><a class="header" href="#privacy-building-structs-with-private-defaulted-fields">Privacy: building <code>struct</code>s with private defaulted fields</a></h3>
<p>In this RFC we do not propose any changes to the normal visibility rules: constructing a <code>struct</code> with default fields requires those fields to be visible in that scope.</p>
<p>Let’s consider a scenario where this comes into play:</p>
<pre><code class="language-rust">pub mod foo {
    pub struct Alpha {
        beta: u8 = 42,
        gamma: bool = true,
    }
}

mod bar {
    fn baz() {
        let x = Alpha { .. };
    }
}</code></pre>
<p>Despite <code>foo::bar</code> being in a different module than <code>foo::Alpha</code> and despite <code>beta</code> and <code>gamma</code> being private to <code>foo::bar</code>, a Rust compiler could accept the above snippet. It would be legal because when <code>Alpha { .. }</code> expands to <code>Alpha { beta: 42, gamma: true }</code>, the fields <code>beta</code> and <code>gamma</code> can be considered in the context of <code>foo::Alpha</code>’s <em>definition site</em> rather than <code>bar::baz</code>’s definition site.</p>
<p>By permitting the above snippet, you are able to construct a default value for a type more ergonomically with <code>Foo { .. }</code>. Since it isn’t possible for functions in <code>beta</code> to access <code>field</code>’s value, the value <code>42</code> or any other remains at all times private to <code>alpha</code>. Therefore, privacy, and by extension soundness, is preserved.</p>
<p>This used to be the behavior the [Functional Record Update syntax had <em>before</em> <a href="https://github.com/rust-lang/rfcs/blob/master/text/0736-privacy-respecting-fru.md">RFC-0736</a>, where we previously allowed for the construction of a value with private fields with values from a base expression.</p>
<p>If a user wishes to keep other modules from constructing a <code>Foo</code> with <code>Foo { .. }</code> they can add, or keep, one private field without a default, or add (for now) <code>#[non_exhaustive]</code>, as mixing these two features is not allowed under this RFC. Situations where this can be important include those where <code>Foo</code> is some token for some resource and where fabricating a <code>Foo</code> may prove dangerous or worse unsound. This is however no different than carelessly adding <code>#[derive(Default)]</code>.</p>
<p>Changing this behavior after stabilization of this RFC does present a potential foot-gun: if an API author relies on the privacy of a defaulted field to make a type unconstructable outside of its defining crate, then this change would cause the API to no longer be correct, needing the addition of a non-defaulted private field to keep its prior behavior. If we were to make this change, we could lint about the situation when all default values are private, which would be silenced by adding another non-defaulted private field.</p>
<p>Another alternative would be to allow this new behavior in an opt in manner, such as an attribute or item modifier:</p>
<pre><code class="language-rust">pub mod foo {
    #[allow_private_defaults(gamma)]
    pub struct Alpha {
        beta: u8 = 42,
        gamma: bool = true,
    }
}</code></pre>
<pre><code class="language-rust">pub mod foo {
    struct Alpha {
        pub(default) beta: u8 = 42,
        pub(default) gamma: bool = true,
    }
}</code></pre>
<p>Additionally, the interaction between this privacy behavior and <code>#[non_exhaustive]</code> is fraught and requires additional discussion.</p>
<h3 id="empty-types-and-types-without-default-field-values"><a class="header" href="#empty-types-and-types-without-default-field-values">“Empty” types and types without default field values</a></h3>
<p>Under this RFC, the following code isn’t specified one way or the other:</p>
<pre><code class="language-rust">pub struct Foo;

let _ = Foo { .. }; // should be denied</code></pre>
<p>I propose we disallow this at least initially. <code>..</code> can then <em>only</em> be used if there is at least one default field. We might want to change this rule in the future, but careful with how it would interact with <code>#[non_exhaustive]</code>, as it could accidentally allow for types that are not meant to be constructed outside of a given crate to all of a sudden be constructable.</p>
<p>One alternative can be to provide an explicit opt-in attribute to allow for the use of default field values even if the type doesn’t currently have any:</p>
<pre><code class="language-rust">#[allow(default_field_construction)]
pub struct Foo;

let _ = Foo { .. }; // ok</code></pre>
<h3 id="use-of-_-on-struct-literals"><a class="header" href="#use-of-_-on-struct-literals">Use of <code>_</code> on struct literals</a></h3>
<p>On patterns, one can currently use <code>field: _</code> to explicitly ignore a single named field, in order to force a compilation error at the pattern use place if a field is explicitly added to the type. One could envision a desire to allow for the use of the same syntax during construction, as an explicit expression to set a given default, but still fail to compile if a field has been added to the type:</p>
<pre><code class="language-rust">struct Foo {
    bar: i32 = 42,
}

let _ = Foo {
    bar: _,
};</code></pre>
<h3 id="tuple-structs-and-tuple-variants"><a class="header" href="#tuple-structs-and-tuple-variants">Tuple structs and tuple variants</a></h3>
<p>Although it could, this proposal does not offer a way to specify default values for tuple struct / variant fields. For example, you may not write:</p>
<pre><code class="language-rust">#[derive(Default)]
struct Alpha(u8 = 42, bool = true);

#[derive(Default)]
enum Ingredient {
    Tomato(TasteQuality, Color = Color::Red),
    Lettuce,
}</code></pre>
<p>While well-defined semantics could be given for these positional fields, there are some tricky design choices; in particular:</p>
<ul>
<li>
<p>It’s unclear whether the following should be permitted:</p>
<pre><code class="language-rust">#[derive(Default)]
struct Beta(&amp;'static str = "hello", bool);</code></pre>
<p>In particular, the fields with defaults are not at the end of the struct. A restriction could imposed to enforce that. However, it would also be useful to admit the above definition of <code>Beta</code> so that <code>#[derive(Default)]</code> can make use of <code>"hello"</code>.</p>
</li>
<li>
<p>The syntax <code>Alpha(..)</code> as an expression already has a meaning. Namely, it is sugar for <code>Alpha(RangeFull)</code>. Thus unfortunately, this syntax cannot be used to mean <code>Alpha(42, true)</code>. In newer editions, the syntax <code>Alpha(...)</code> (three dots) can be used for filling in defaults. This would ostensibly entail adding the pattern syntax <code>Alpha(...)</code> as well.</p>
</li>
<li>
<p>As mentioned in the previous section, <code>_</code> could also be allowed in <code>struct</code> literals. If so, then they would also be allowed in tuple literals, allowing us to use the <code>struct</code> in the prior snippet with <code>Beta(_, true)</code>.</p>
</li>
</ul>
<p>For these reasons, default values for positional fields are not included in this RFC and are instead left as a possible future extension.</p>
<h3 id="integration-with-structural-records"><a class="header" href="#integration-with-structural-records">Integration with structural records</a></h3>
<p>In <a href="https://github.com/rust-lang/rfcs/pull/2584">RFC 2584</a> structural records are proposed. These records are structural like tuples but have named fields. As an example, you can write:</p>
<pre><code class="language-rust">let color = { red: 255u8, green: 100u8, blue: 70u8 };</code></pre>
<p>which then has the type:</p>
<pre><code class="language-rust">{ red: u8, green: u8, blue: u8 }</code></pre>
<p>These can then be used to further emulate named arguments. For example:</p>
<pre><code class="language-rust">fn open_window(config: { height: u32, width: u32 }) {
    // logic...
}

open_window({ height: 720, width: 1280 });</code></pre>
<p>Since this proposal introduces field defaults, the natural combination with structural records would be to permit them to have defaults. For example:</p>
<pre><code class="language-rust">fn open_window(config: { height: u32 = 1080, width: u32 = 1920 }) {
    // logic...
}</code></pre>
<p>A coercion could then allow you to write:</p>
<pre><code class="language-rust">open_window({ .. });</code></pre>
<p>This could be interpreted as <code>open_window({ RangeFull })</code>, see the previous section for a discussion… alternatively <code>open_window(_)</code> could be permitted instead for general value inference where <code>_</code> is a placeholder expression similar to <code>_</code> as a type expression placeholder (i.e. a fresh and unconstrained unification variable).</p>
<p>If you wanted to override a default, you would write:</p>
<pre><code class="language-rust">open_window({ height: 720, });</code></pre>
<p>Note that the syntax used to give fields in structural records defaults belongs to the type grammar; in other words, the following would be legal:</p>
<pre><code class="language-rust">type RGB = { red: u8 = 0, green: u8 = 0, blue: u8 = 0 };

let color: RGB = { red: 255, };</code></pre>
<p>As structural records are not yet in the language, figuring out designs for how to extend this RFC to them is left as possible work for the future.</p>
<h3 id="integration-with-struct-literal-type-inference"><a class="header" href="#integration-with-struct-literal-type-inference">Integration with struct literal type inference</a></h3>
<p>Yet another common requested feature is the introduction of struct literal type inference in the form of elision of the name of an ADT literal when it can be gleaned from context. This has sometimes been proposed as an alternative or complementary to structural records. This would allow people to write <code>foo(_ { bar: 42 })</code> where the function argument type is inferred from the <code>foo</code> definition. struct literal type inference with default struct fields would also allow people to write APIs that “feel” like named function arguments when calling them, although not when defining them.</p>
<pre><code class="language-rust">struct Config {
    height: u32 = 1080,
    width: u32 = 1920,
}
fn open_window(config: Config) {
    // logic...
}

open_window(_ { width: 800, .. });</code></pre>
<h3 id="accessing-default-values-from-the-type"><a class="header" href="#accessing-default-values-from-the-type">Accessing default values from the type</a></h3>
<p>If one were to conceptualize default field values in the following way:</p>
<pre><code class="language-rust">struct Config {
    height: u32 = Self::HEIGHT,
    width: u32 = Self::WIDTH,
}

impl Config {
    const HEIGHT: u32 = 1080,
    const WIDTH: u32 = 1920,
}</code></pre>
<p>It would follow that one should be able to access the value of these defaults <em>without</em> constructing <code>Config</code>, by writing <code>Config::HEIGHT</code>. I do not believe this should be done or advanced, but there’s nothing in this RFC that precludes <em>some</em> mechanism to access these values in the future. With the RFC as written, these values can be accessed by instantiating <code>Config { .. }.height</code>, as long as <code>height</code> is visible in the current scope.</p>
<p>Note that the <em>opposite</em> is supported, writing that code will compile, so any API author that wants to make these <code>const</code> values on the type can:</p>
<pre><code class="language-rust">struct Config {
    height: u32 = Config::HEIGHT,
    width: u32 = Config::WIDTH,
}

impl Config {
    const HEIGHT: u32 = 1080,
    const WIDTH: u32 = 1920,
}</code></pre>
<h3 id="non-const-values"><a class="header" href="#non-const-values">Non-const values</a></h3>
<p>Although there are <a href="#on-const-contexts">strong reasons</a> to restrict default values only to const values, it would be possible to allow non-const values as well, potentially allowed but linted against. Expanding the kind of values that can be accepted can be expanded in the future.</p>
<p>Of note, <code>Default</code> implementations are not currently <code>~const</code>, but that is something to be addressed by making them <code>~const</code> when suitable instead.</p>
<h3 id="lint-against-explicit-impl-default-when-derivedefault-would-be-ok"><a class="header" href="#lint-against-explicit-impl-default-when-derivedefault-would-be-ok">Lint against explicit <code>impl Default</code> when <code>#[derive(Default)]</code> would be ok</a></h3>
<p>As a future improvement, we could nudge implementors towards leveraging the feature for less verbosity, but care will have to be taken in not being overly annoying, particularly for crates that have an MSRV that would preclude them from using this feature. This could be an edition lint, which would simplify implementation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="3673-rustdoc-types-maintainers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="3691-trusted-publishing-cratesio.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="3673-rustdoc-types-maintainers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="3691-trusted-publishing-cratesio.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
