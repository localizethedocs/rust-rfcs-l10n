<!DOCTYPE HTML>
<html lang="en_US" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>3058-try-trait-v2 - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-0060737d.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Feature Name: try_trait_v2</li>
<li>Start Date: 2020-12-12</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/3058">rust-lang/rfcs#3058</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/84277">rust-lang/rust#84277</a></li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Replace <a href="https://rust-lang.github.io/rfcs/1859-try-trait.html">RFC #1859, <code>try_trait</code></a>,
with a new design for the currently-unstable <a href="https://doc.rust-lang.org/nightly/std/ops/trait.Try.html"><code>Try</code> trait</a>
and corresponding desugaring for the <code>?</code> operator.</p>
<p>The new design includes support for all <em>intentional</em> interconversions.
It proposes removing the <em>accidental</em> interconversions, as a crater run
demonstrated that would be feasible, however includes an alternative system
that can support them as a low-support-cost edition mechanism if needed.</p>
<p><em>This is <a href="#future-possibilities">forward-looking</a> to be compatible with other features,
like <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/try-blocks.html"><code>try {}</code></a> blocks
or <a href="https://twitter.com/josh_triplett/status/1248658754976927750"><code>yeet e</code></a> expressions
or <a href="https://github.com/rust-lang/rust/issues/63178"><code>Iterator::try_find</code></a>,
but the statuses of those features are <strong>not</strong> themselves impacted by this RFC.</em></p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>The motivations from the previous RFC still apply (supporting more types, and restricted interconversion).
However, new information has come in since the previous RFC, making people wish for a different approach.</p>
<ul>
<li>Using the ‚Äúerror‚Äù terminology is a poor fit for other potential implementations of the trait.</li>
<li>The previous RFC‚Äôs mechanism for controlling interconversions proved ineffective, with inference meaning that people did it unintentionally.</li>
<li>It‚Äôs no longer clear that <code>From</code> should be part of the <code>?</code> desugaring for <em>all</em> types.  It‚Äôs both more flexible ‚Äì making inference difficult ‚Äì and more restrictive ‚Äì especially without specialization ‚Äì than is always desired.</li>
<li>An <a href="https://github.com/rust-lang/rust/issues/42327#issuecomment-366840247">experience report</a> in the tracking issue mentioned that it‚Äôs annoying to need to make a residual type in common cases.</li>
</ul>
<p>This RFC proposes a solution that <em>mixes</em> the two major options considered last time.</p>
<ul>
<li>Like the <em>reductionist</em> approach, this RFC proposes an unparameterized trait with an <em>associated</em> type for the ‚Äúok‚Äù part, so that the type produced from the <code>?</code> operator on a value is always the same.</li>
<li>Like the <a href="https://github.com/rust-lang/rfcs/blob/master/text/1859-try-trait.md#the-essentialist-approach"><em>essentialist</em> approach</a>, this RFC proposes a trait with a <em>generic</em> parameter for ‚Äúerror‚Äù part, so that different types can be consumed.</li>
</ul>
<!--
Why are we doing this? What use cases does it support? What is the expected outcome?
-->
<h2 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h2>
<h3 id="the-opscontrolflow-type"><a class="header" href="#the-opscontrolflow-type">The <code>ops::ControlFlow</code> type</a></h3>
<p>This is a simple enum:</p>
<pre><code class="language-rust">enum ControlFlow&lt;B, C = ()&gt; {
    /// Exit the operation without running subsequent phases.
    Break(B),
    /// Move on to the next phase of the operation as normal.
    Continue(C),
}</code></pre>
<p>It‚Äôs intended for exposing things (like graph traversals or visitor) where you want the user to be able to choose whether to exit early.  Using an enum is clearer than just using a bool ‚Äì what did <code>false</code> mean again? ‚Äì as well as <a href="https://github.com/rust-lang/rust/pull/78779#pullrequestreview-524885131">allows it to carry a value</a>, if desired.</p>
<p>For example, you could use it to expose a simple tree traversal in a way that lets the caller exit early if they want:</p>
<pre><code class="language-rust">impl&lt;T&gt; TreeNode&lt;T&gt; {
    fn traverse_inorder&lt;B&gt;(&amp;self, mut f: impl FnMut(&amp;T) -&gt; ControlFlow&lt;B&gt;) -&gt; ControlFlow&lt;B&gt; {
        if let Some(left) = &amp;self.left {
            left.traverse_inorder(&amp;mut f)?;
        }
        f(&amp;self.value)?;
        if let Some(right) = &amp;self.right {
            right.traverse_inorder(&amp;mut f)?;
        }
        ControlFlow::Continue(())
    }
}</code></pre>
<!-- https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=286ac85c43e5bf242b5431b4f6f63386 -->
<p>Now, you <em>could</em> write the same thing with <code>Result&lt;(), B&gt;</code> instead.  But that would require that the passed-in closure use <code>Err(value)</code> to early-exit the traversal, which can cause mental dissonance when that exit is because it successfully found the value for which it was looking.  Using <code>ControlFlow::Break(value)</code> instead avoids that prejudice, the same way that <code>break val</code> in a <code>loop</code> doesn‚Äôt inherently mean success nor failure.</p>
<h3 id="the-try-trait"><a class="header" href="#the-try-trait">The <code>Try</code> trait</a></h3>
<p>The <code>ops::Try</code> trait describes a type‚Äôs behavior when used with the <code>?</code> operator, like how the <code>ops::Add</code> trait describes its behavior when used with the <code>+</code> operator.</p>
<p>At its core, the <code>?</code> operator is about splitting a type into its two parts:</p>
<ul>
<li>The <em>output</em> that will be returned from the <code>?</code> expression, with which the program will continue, and</li>
<li>The <em>residual</em> that will be returned to the calling code, as an early exit from the normal flow.</li>
</ul>
<p>(Oxford‚Äôs definition for a residual is ‚Äúa quantity remaining after other things have been subtracted or allowed for‚Äù, thus the use here.)</p>
<p>The <code>Try</code> trait also has facilities for rebuilding a type from either of its parts.  This is needed to build the final return value from a function, both in <code>?</code> and in methods generic over multiple types implementing <code>Try</code>.</p>
<p>Here‚Äôs a quick overview of a few standard types which implement <code>Try</code>, their corresponding output and residual types, and the functions which convert between them.
(Full details will come later; the goal for now is just to get the general idea.)</p>
<pre><code class="language-text">+-------------+                             +-------------------+                          +-------------------+
| Try::Output |                             |      Try Type     |                          |   Try::Residual   |
+-------------+   Try::branch is Continue   +-------------------+   Try::branch is Break   +-------------------+
|      T      |  &lt;------------------------  |   Result&lt;T, E&gt;    |  ---------------------&gt;  |   Result&lt;!, E&gt;    |
|      T      |                             |     Option&lt;T&gt;     |                          |     Option&lt;!&gt;     |
|      C      |  ------------------------&gt;  | ControlFlow&lt;B, C&gt; |  &lt;---------------------  | ControlFlow&lt;B, !&gt; |
+-------------+      Try::from_output       +-------------------+    Try::from_residual    +-------------------+
</code></pre>
<p>If you‚Äôve used <code>?</code>-on-<code>Result</code> before, that output type is likely unsurprising.  Since it‚Äôs given out directly from the operator, there‚Äôs not much of a choice.</p>
<p>The residual types, however, are somewhat more interesting.  Code using <code>?</code> doesn‚Äôt see them directly ‚Äì their usage is hidden inside the desugaring ‚Äì so there are more possibilities available.  So why are we using these ones specifically?</p>
<p>Most importantly, this gives each family of types (<code>Result</code>s, <code>Option</code>s, <code>ControlFlow</code>s) their own <em>distinct</em> residual type.  That avoids unrestricted <em>interconversion</em> between the different types, the ability to arbitrarily mix them in the same method.  For example, like in the traversal example earlier, just because a <code>ControlFlow::Break</code> is also an early exit, that doesn‚Äôt mean that it should be allowed to consider it a <code>Result::Err</code> ‚Äì it might be a success, conceptually.  So by giving <code>ControlFlow&lt;X, _&gt;</code> and <code>Result&lt;_, X&gt;</code> different residual types, it becomes a compilation error to use the <code>?</code> operator on a <code>ControlFlow</code> in a method which returns a <code>Result</code>, and vice versa.  (There are also ways to allow interconversion where it‚Äôs desirable between a particular pair of types.)</p>
<blockquote>
<p>üèóÔ∏è Note for those familiar with the previous RFC üèóÔ∏è</p>
<p>This is the most critical semantic difference.  Structurally this definition of the trait is very similar to the previous ‚Äì there‚Äôs still a method splitting the type into a discriminated union between two associated types, and constructors to rebuild it from them.  But by keeping the ‚Äúresult-ness‚Äù or ‚Äúoption-ness‚Äù in the residual type, it gives extra control over interconversion that wasn‚Äôt possible before.  The changes other than this are comparatively minor, typically either rearrangements to work with that or renamings to change the vocabulary used in the trait.</p>
</blockquote>
<p>Using <code>!</code> is then just a convenient yet efficient way to create those residual types.  It‚Äôs nice as a user, too, not to need to understand an additional type.  Just the same ‚Äúit can‚Äôt be that one‚Äù pattern that‚Äôs also used in <code>TryFrom</code>, where for example <code>i32::try_from(10_u8)</code> gives a <code>Result&lt;i32, !&gt;</code>, since it‚Äôs a widening conversion which cannot fail.  Note that there‚Äôs nothing special going on with <code>!</code> here ‚Äì any uninhabited <code>enum</code> would work fine.</p>
<h3 id="how-error-conversion-works"><a class="header" href="#how-error-conversion-works">How error conversion works</a></h3>
<p>One thing <a href="https://doc.rust-lang.org/stable/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">The Book mentions</a>,
if you recall, is that error values in <code>?</code> have <code>From::from</code> called on them, to convert from one error type to another.</p>
<p>The previous section actually lied to you slightly: there are <em>two</em> traits involved, not just one.  The <code>from_residual</code> method is on <code>FromResidual</code>, which is generic so that the implementation on <code>Result</code> can add that extra conversion.  Specifically, the trait looks like this:</p>
<pre><code class="language-rust">trait FromResidual&lt;Residual = &lt;Self as Try&gt;::Residual&gt; {
    fn from_residual(r: Residual) -&gt; Self;
}</code></pre>
<p>And while we‚Äôre showing code, here‚Äôs the exact definition of the <code>Try</code> trait:</p>
<pre><code class="language-rust">trait Try: FromResidual {
    type Output;
    type Residual;
    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, Self::Output&gt;;
    fn from_output(o: Self::Output) -&gt; Self;
}</code></pre>
<p>The fact that it‚Äôs a super-trait like that is why I don‚Äôt feel bad about the slight lie: Every <code>T: Try</code> <em>always</em> has a <code>from_residual</code> function from <code>T::Residual</code> to <code>T</code>.  It‚Äôs just that some types might offer more.</p>
<p>Here‚Äôs how <code>Result</code> implements <code>FromResidual</code> to do error-conversions:</p>
<pre><code class="language-rust">impl&lt;T, E, F: From&lt;E&gt;&gt; FromResidual&lt;Result&lt;!, E&gt;&gt; for Result&lt;T, F&gt; {
    fn from_residual(x: Result&lt;!, E&gt;) -&gt; Self {
        match x {
            Err(e) =&gt; Err(From::from(e)),
        }
    }
}</code></pre>
<p>But <code>Option</code> doesn‚Äôt need to do anything exciting, so just has a simple implementation, taking advantage of the default parameter:</p>
<pre><code class="language-rust">impl&lt;T&gt; FromResidual for Option&lt;T&gt; {
    fn from_residual(x: Self::Residual) -&gt; Self {
        match x {
            None =&gt; None,
        }
    }
}</code></pre>
<p>In your own types, it‚Äôs up to you to decide how much freedom is appropriate.  You can even enable interconversion by defining implementations from the residual types of other families if you‚Äôd like.  But just supporting your one residual type is ok too.</p>
<blockquote>
<p>üèóÔ∏è Note for those familiar with the previous RFC üèóÔ∏è</p>
<p>This is another notable difference: The <code>From::from</code> is up to the trait implementation, not part of the desugaring.</p>
</blockquote>
<h3 id="implementing-try-for-a-non-generic-type"><a class="header" href="#implementing-try-for-a-non-generic-type">Implementing <code>Try</code> for a non-generic type</a></h3>
<p>The examples in the standard library are all generic, so serve as good examples of that, but non-generic implementations are also possible.</p>
<p>Suppose we‚Äôre working on migrating some C code to Rust, and it‚Äôs still using the common ‚Äúzero is success; non-zero is an error‚Äù pattern.  Maybe we‚Äôre using a simple type like this to stay ABI-compatible:</p>
<pre><code class="language-rust">#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[repr(transparent)]
pub struct ResultCode(pub i32);
impl ResultCode {
    const SUCCESS: Self = ResultCode(0);
}</code></pre>
<p>We can implement <code>Try</code> for that type to simplify the code without changing the error model.</p>
<p>First, we‚Äôll need a residual type.  We can make this a simple newtype, and conveniently there‚Äôs a type with a niche for exactly the value that this can‚Äôt hold.  This is only used inside the desugaring, so we can leave it opaque ‚Äì nobody but us will need to create or inspect it.</p>
<pre><code class="language-rust">use std::num::NonZeroI32;
pub struct ResultCodeResidual(NonZeroI32);</code></pre>
<p>With that, it‚Äôs straight-forward to implement the traits.  <code>NonZeroI32</code>‚Äôs constructor even does exactly the check we need in <code>Try::branch</code>:</p>
<pre><code class="language-rust">impl Try for ResultCode {
    type Output = ();
    type Residual = ResultCodeResidual;
    fn branch(self) -&gt; ControlFlow&lt;Self::Residual&gt; {
        match NonZeroI32::new(self.0) {
            Some(r) =&gt; ControlFlow::Break(ResultCodeResidual(r)),
            None =&gt; ControlFlow::Continue(()),
        }
    }
    fn from_output((): ()) -&gt; Self {
        ResultCode::SUCCESS
    }
}

impl FromResidual for ResultCode {
    fn from_residual(r: ResultCodeResidual) -&gt; Self {
        ResultCode(r.0.into())
    }
}</code></pre>
<p>Aside: As a nice bonus, the use of a <code>NonZero</code> type in the residual means that <code>&lt;ResultCode as Try&gt;::branch</code> <a href="https://rust.godbolt.org/z/GxeYax">compiles down to a nop</a> on the current nightly.  Thanks, enum layout optimizations!</p>
<p>Now, this is all great for keeping the interface that the other unmigrated C code expects, and can even work in <code>no_std</code> if we want.  But it might also be nice to give other <em>Rust</em> code that uses it the option to convert things into a <code>Result</code> with a more detailed error.</p>
<p>For expository purposes, we‚Äôll use this error type:</p>
<pre><code class="language-rust">#[derive(Debug, Clone)]
pub struct FancyError(String);</code></pre>
<p>(A real one would probably be more complicated and have a better name, but this will work for what we need here ‚Äì it‚Äôs bigger and needs non-core things to work.)</p>
<p>We can allow <code>?</code> on a <code>ResultCode</code> in a method returning <code>Result</code> with an implementation like this:</p>
<pre><code class="language-rust">impl&lt;T, E: From&lt;FancyError&gt;&gt; FromResidual&lt;ResultCodeResidual&gt; for Result&lt;T, E&gt; {
    fn from_residual(r: ResultCodeResidual) -&gt; Self {
        Err(FancyError(format!("Something fancy about {} at {:?}", r.0, std::time::SystemTime::now())).into())
    }
}</code></pre>
<p><em>The split between different error strategies in this section is inspired by <a href="https://github.com/microsoft/windows-rs"><code>windows-rs</code></a>, which has both <a href="https://microsoft.github.io/windows-docs-rs/doc/bindings/windows/struct.ErrorCode.html"><code>ErrorCode</code></a> ‚Äì a simple newtype over <code>u32</code> ‚Äì and <a href="https://microsoft.github.io/windows-docs-rs/doc/bindings/windows/struct.Error.html"><code>Error</code></a> ‚Äì a richer type that can capture a stack trace, has an <code>Error</code> trait implementation, and can carry additional debugging information ‚Äì where the former can be converted into the latter.</em></p>
<h3 id="using-these-traits-in-generic-code"><a class="header" href="#using-these-traits-in-generic-code">Using these traits in generic code</a></h3>
<p><code>Iterator::try_fold</code> has been stable to call (but not to implement) for a while now.  To illustrate the flow through the traits in this RFC, let‚Äôs implement our own version.</p>
<p>As a reminder, an infallible version of a fold looks something like this:</p>
<pre><code class="language-rust">fn simple_fold&lt;A, T&gt;(
    iter: impl Iterator&lt;Item = T&gt;,
    mut accum: A,
    mut f: impl FnMut(A, T) -&gt; A,
) -&gt; A {
    for x in iter {
        accum = f(accum, x);
    }
    accum
}</code></pre>
<p>So instead of <code>f</code> returning just an <code>A</code>, we‚Äôll need it to return some other type that produces an <code>A</code> in the ‚Äúdon‚Äôt short circuit‚Äù path.  Conveniently, that‚Äôs also the type we need to return from the function.</p>
<p>Let‚Äôs add a new generic parameter <code>R</code> for that type, and bound it to the output type that we want:</p>
<pre><code class="language-rust">fn simple_try_fold_1&lt;A, T, R: Try&lt;Output = A&gt;&gt;(
    iter: impl Iterator&lt;Item = T&gt;,
    mut accum: A,
    mut f: impl FnMut(A, T) -&gt; R,
) -&gt; R {
    todo!()
}</code></pre>
<p><code>Try</code> is also the trait we need to get the updated accumulator from <code>f</code>‚Äôs return value and return the result if we manage to get through the entire iterator:</p>
<pre><code class="language-rust">fn simple_try_fold_2&lt;A, T, R: Try&lt;Output = A&gt;&gt;(
    iter: impl Iterator&lt;Item = T&gt;,
    mut accum: A,
    mut f: impl FnMut(A, T) -&gt; R,
) -&gt; R {
    for x in iter {
        let cf = f(accum, x).branch();
        match cf {
            ControlFlow::Continue(a) =&gt; accum = a,
            ControlFlow::Break(_) =&gt; todo!(),
        }
    }
    R::from_output(accum)
}</code></pre>
<p>We‚Äôll also need <code>FromResidual::from_residual</code> to turn the residual back into the original type.  But because it‚Äôs a supertrait of <code>Try</code>, we don‚Äôt need to mention it in the bounds.  All types which implement <code>Try</code> can always be recreated from their corresponding residual, so we‚Äôll just call it:</p>
<pre><code class="language-rust">pub fn simple_try_fold_3&lt;A, T, R: Try&lt;Output = A&gt;&gt;(
    iter: impl Iterator&lt;Item = T&gt;,
    mut accum: A,
    mut f: impl FnMut(A, T) -&gt; R,
) -&gt; R {
    for x in iter {
        let cf = f(accum, x).branch();
        match cf {
            ControlFlow::Continue(a) =&gt; accum = a,
            ControlFlow::Break(r) =&gt; return R::from_residual(r),
        }
    }
    R::from_output(accum)
}</code></pre>
<p>But this ‚Äúcall <code>branch</code>, then <code>match</code> on it, and <code>return</code> if it was a <code>Break</code>‚Äù is exactly what happens inside the <code>?</code> operator.  So rather than do all this manually, we can just use <code>?</code> instead:</p>
<pre><code class="language-rust">fn simple_try_fold&lt;A, T, R: Try&lt;Output = A&gt;&gt;(
    iter: impl Iterator&lt;Item = T&gt;,
    mut accum: A,
    mut f: impl FnMut(A, T) -&gt; R,
) -&gt; R {
    for x in iter {
        accum = f(accum, x)?;
    }
    R::from_output(accum)
}</code></pre>
<!--
Explain the proposal as if it was already included in the language and you were teaching it to another Rust programmer. That generally means:

- Introducing new named concepts.
- Explaining the feature largely in terms of examples.
- Explaining how Rust programmers should *think* about the feature, and how it should impact the way they use Rust. It should explain the impact as concretely as possible.
- If applicable, provide sample error messages, deprecation warnings, or migration guidance.
- If applicable, describe the differences between teaching this to existing Rust programmers and new Rust programmers.

For implementation-oriented RFCs (e.g. for compiler internals), this section should focus on how compiler contributors should think about the change, and give examples of its concrete impact. For policy RFCs, this section should provide an example-driven introduction to the policy, and explain its impact in concrete terms.
-->
<h2 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h2>
<h3 id="opscontrolflow"><a class="header" href="#opscontrolflow"><code>ops::ControlFlow</code></a></h3>
<pre><code class="language-rust">#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ControlFlow&lt;B, C = ()&gt; {
    /// Exit the operation without running subsequent phases.
    Break(B),
    /// Move on to the next phase of the operation as normal.
    Continue(C),
}</code></pre>
<h3 id="the-traits"><a class="header" href="#the-traits">The traits</a></h3>
<pre><code class="language-rust">pub trait Try: FromResidual {
    /// The type of the value consumed or produced when not short-circuiting.
    type Output;

    /// A type that "colours" the short-circuit value so it can stay associated
    /// with the type constructor from which it came.
    type Residual;

    /// Used in `try{}` blocks to wrap the result of the block.
    fn from_output(x: Self::Output) -&gt; Self;

    /// Determine whether to short-circuit (by returning `ControlFlow::Break`)
    /// or continue executing (by returning `ControlFlow::Continue`).
    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, Self::Output&gt;;
}

pub trait FromResidual&lt;Residual = &lt;Self as Try&gt;::Residual&gt; {
    /// Recreate the type implementing `Try` from a related residual
    fn from_residual(x: Residual) -&gt; Self;
}</code></pre>
<h3 id="expected-laws"><a class="header" href="#expected-laws">Expected laws</a></h3>
<p>What comes out is what you put in:</p>
<ul>
<li><code>&lt;T as Try&gt;::from_output(x).branch()</code> ‚áí <code>ControlFlow::Continue(x)</code> (aka <code>try { x }?</code> ‚áí <code>x</code>)</li>
<li><code>&lt;T as Try&gt;::from_residual(x).branch()</code> ‚áí <code>ControlFlow::Break(x)</code> (maybe aka something like <code>try { yeet e }</code> ‚áí <code>Err(e)</code>, see the future possibilities)</li>
</ul>
<p>You can recreate what you split up:</p>
<ul>
<li><code>match x.branch() { ControlFlow::Break(r) =&gt; Try::from_residual(r), ControlFlow::Continue(v) =&gt; Try::from_output(v) }</code> ‚áí <code>x</code> (aka <code>try { x? }</code> ‚áí <code>x</code>)</li>
</ul>
<h3 id="desugaring-"><a class="header" href="#desugaring-">Desugaring <code>?</code></a></h3>
<p>The previous desugaring of <code>x?</code> was</p>
<pre><code class="language-rust">match Try::into_result(x) {
    Ok(v) =&gt; v,
    Err(e) =&gt; return Try::from_error(From::from(e)),
}</code></pre>
<p>The new one is very similar:</p>
<pre><code class="language-rust">match Try::branch(x) {
    ControlFlow::Continue(v) =&gt; v,
    ControlFlow::Break(r) =&gt; return FromResidual::from_residual(r),
}</code></pre>
<p>The critical difference is that conversion (such as <code>From::from</code>) is left up to the implementation instead of forcing it in the desugar.</p>
<h3 id="standard-implementations"><a class="header" href="#standard-implementations">Standard implementations</a></h3>
<h4 id="result"><a class="header" href="#result"><code>Result</code></a></h4>
<pre><code class="language-rust">impl&lt;T, E&gt; ops::Try for Result&lt;T, E&gt; {
    type Output = T;
    type Residual = Result&lt;!, E&gt;;

    #[inline]
    fn from_output(c: T) -&gt; Self {
        Ok(c)
    }

    #[inline]
    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, T&gt; {
        match self {
            Ok(c) =&gt; ControlFlow::Continue(c),
            Err(e) =&gt; ControlFlow::Break(Err(e)),
        }
    }
}

impl&lt;T, E, F: From&lt;E&gt;&gt; ops::FromResidual&lt;Result&lt;!, E&gt;&gt; for Result&lt;T, F&gt; {
    fn from_residual(x: Result&lt;!, E&gt;) -&gt; Self {
        match x {
            Err(e) =&gt; Err(From::from(e)),
        }
    }
}</code></pre>
<h4 id="option"><a class="header" href="#option"><code>Option</code></a></h4>
<pre><code class="language-rust">impl&lt;T&gt; ops::Try for Option&lt;T&gt; {
    type Output = T;
    type Residual = Option&lt;!&gt;;

    #[inline]
    fn from_output(c: T) -&gt; Self {
        Some(c)
    }

    #[inline]
    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, T&gt; {
        match self {
            Some(c) =&gt; ControlFlow::Continue(c),
            None =&gt; ControlFlow::Break(None),
        }
    }
}

impl&lt;T&gt; ops::FromResidual for Option&lt;T&gt; {
    fn from_residual(x: &lt;Self as ops::Try&gt;::Residual) -&gt; Self {
        match x {
            None =&gt; None,
        }
    }
}</code></pre>
<h4 id="poll"><a class="header" href="#poll"><code>Poll</code></a></h4>
<p>These reuse <code>Result</code>‚Äôs residual type, and thus interconversion between <code>Poll</code> and <code>Result</code> is allowed without needing additional <code>FromResidual</code> implementations on <code>Result</code>.</p>
<pre><code class="language-rust">impl&lt;T, E&gt; ops::Try for Poll&lt;Result&lt;T, E&gt;&gt; {
    type Output = Poll&lt;T&gt;;
    type Residual = &lt;Result&lt;T, E&gt; as ops::Try&gt;::Residual;

    fn from_output(c: Self::Output) -&gt; Self {
        c.map(Ok)
    }

    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, Self::Output&gt; {
        match self {
            Poll::Ready(Ok(x)) =&gt; ControlFlow::Continue(Poll::Ready(x)),
            Poll::Ready(Err(e)) =&gt; ControlFlow::Break(Err(e)),
            Poll::Pending =&gt; ControlFlow::Continue(Poll::Pending),
        }
    }
}

impl&lt;T, E, F: From&lt;E&gt;&gt; ops::FromResidual&lt;Result&lt;!, E&gt;&gt; for Poll&lt;Result&lt;T, F&gt;&gt; {
    fn from_residual(x: Result&lt;!, E&gt;) -&gt; Self {
        match x {
            Err(e) =&gt; Poll::Ready(Err(From::from(e))),
        }
    }
}</code></pre>
<pre><code class="language-rust">impl&lt;T, E&gt; ops::Try for Poll&lt;Option&lt;Result&lt;T, E&gt;&gt;&gt; {
    type Output = Poll&lt;Option&lt;T&gt;&gt;;
    type Residual = &lt;Result&lt;T, E&gt; as ops::Try&gt;::Residual;

    fn from_output(c: Self::Output) -&gt; Self {
        c.map(|x| x.map(Ok))
    }

    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, Self::Output&gt; {
        match self {
            Poll::Ready(Some(Ok(x))) =&gt; ControlFlow::Continue(Poll::Ready(Some(x))),
            Poll::Ready(Some(Err(e))) =&gt; ControlFlow::Break(Err(e)),
            Poll::Ready(None) =&gt; ControlFlow::Continue(Poll::Ready(None)),
            Poll::Pending =&gt; ControlFlow::Continue(Poll::Pending),
        }
    }
}

impl&lt;T, E, F: From&lt;E&gt;&gt; ops::FromResidual&lt;Result&lt;!, E&gt;&gt; for Poll&lt;Option&lt;Result&lt;T, F&gt;&gt;&gt; {
    fn from_residual(x: Result&lt;!, E&gt;) -&gt; Self {
        match x {
            Err(e) =&gt; Poll::Ready(Some(Err(From::from(e)))),
        }
    }
}</code></pre>
<h4 id="controlflow"><a class="header" href="#controlflow"><code>ControlFlow</code></a></h4>
<pre><code class="language-rust">impl&lt;B, C&gt; ops::Try for ControlFlow&lt;B, C&gt; {
    type Output = C;
    type Residual = ControlFlow&lt;B, !&gt;;

    fn from_output(c: C) -&gt; Self {
        ControlFlow::Continue(c)
    }

    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, C&gt; {
        match self {
            ControlFlow::Continue(c) =&gt; ControlFlow::Continue(c),
            ControlFlow::Break(b) =&gt; ControlFlow::Break(ControlFlow::Break(b)),
        }
    }
}

impl&lt;B, C&gt; ops::FromResidual for ControlFlow&lt;B, C&gt; {
    fn from_residual(x: &lt;Self as ops::Try&gt;::Residual) -&gt; Self {
        match x {
            ControlFlow::Break(r) =&gt; ControlFlow::Break(r),
        }
    }
}</code></pre>
<h3 id="use-in-iterator"><a class="header" href="#use-in-iterator">Use in <code>Iterator</code></a></h3>
<p>The provided implementation of <code>try_fold</code> is already just using <code>?</code> and <code>try{}</code>, so doesn‚Äôt change.  The only difference is the name of the associated type in the bound:</p>
<pre><code class="language-rust">fn try_fold&lt;B, F, R&gt;(&amp;mut self, init: B, mut f: F) -&gt; R
where
    Self: Sized,
    F: FnMut(B, Self::Item) -&gt; R,
    R: Try&lt;Output = B&gt;,
{
    let mut accum = init;
    while let Some(x) = self.next() {
        accum = f(accum, x)?;
    }
    try { accum }
}</code></pre>
<!--
This is the technical portion of the RFC. Explain the design in sufficient detail that:

- Its interaction with other features is clear.
- It is reasonably clear how the feature would be implemented.
- Corner cases are dissected by example.

The section should return to the examples given in the previous section, and explain more fully how the detailed proposal makes those examples work.
-->
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<ul>
<li>While this handles a known accidental stabilization, it‚Äôs possible that there‚Äôs something else unknown that will keep this from being doable while meeting Rust‚Äôs stringent stability guarantees.</li>
<li>The extra complexity of this approach, compared to either of the alternatives considered the last time around, might not be worth it.</li>
<li>This is the fourth attempt at a design in this space, so it might not be the right one either.</li>
<li>As with all overloadable operators, users might implement this to do something weird.</li>
<li>In situations where extensive interconversion is desired, this requires more implementations.</li>
<li>Moving <code>From::from</code> from the desugaring to the implementations means that implementations which do want it are more complicated.</li>
</ul>
<!--
Why should we *not* do this?
-->
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<h3 id="why-controlflow-pulls-its-weight"><a class="header" href="#why-controlflow-pulls-its-weight">Why <code>ControlFlow</code> pulls its weight</a></h3>
<p>The previous RFC discussed having such a type, but ended up deciding that defining a new type for the desugar wasn‚Äôt worth it, and just used <code>Result</code>.</p>
<p>This RFC does use a new type because one already <a href="https://doc.rust-lang.org/nightly/std/ops/enum.ControlFlow.html">exists in nightly</a> under <a href="https://github.com/rust-lang/rust/issues/75744">the <code>control_flow_enum</code> feature gate</a>.
It‚Äôs being used in <a href="https://github.com/rust-lang/rust/blob/fd34606ddf02d1e9364e459b373a6ad665c3d8a4/library/core/src/iter/traits/iterator.rs#L2239-L2252">the library</a> and <a href="https://github.com/rust-lang/rust/blob/c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9/compiler/rustc_middle/src/ty/fold.rs#L184-L206">the compiler</a>, demonstrating that it‚Äôs useful beyond just this desugaring, so the desugar might as well use it too for extra clarity.
There are also <a href="https://github.com/rust-itertools/itertools/issues/469#issuecomment-677729589">ecosystem changes waiting on something like it</a>, so it‚Äôs not just a compiler-internal need.</p>
<h3 id="methods-on-controlflow"><a class="header" href="#methods-on-controlflow">Methods on <code>ControlFlow</code></a></h3>
<p>On nightly there are a <a href="https://doc.rust-lang.org/nightly/std/ops/enum.ControlFlow.html#implementations">variety of methods</a> available on <code>ControlFlow</code>.  However, none of them are needed for the stabilization of the traits, so they left out of this RFC.  They can be considered by libs at a later point.</p>
<p>There‚Äôs a basic set of simple ones that could be included if desired, though:</p>
<pre><code class="language-rust">impl&lt;B, C&gt; ControlFlow&lt;B, C&gt; {
    fn is_break(&amp;self) -&gt; bool;
    fn is_continue(&amp;self) -&gt; bool;
    fn break_value(self) -&gt; Option&lt;B&gt;;
    fn continue_value(self) -&gt; Option&lt;C&gt;;
}</code></pre>
<h3 id="traits-for-controlflow"><a class="header" href="#traits-for-controlflow">Traits for <code>ControlFlow</code></a></h3>
<p><code>ControlFlow</code> derives a variety of traits where they have obvious behaviour.  It does not, however, derive <code>PartialOrd</code>/<code>Ord</code>.  They‚Äôre left out as it‚Äôs unclear which order, if any, makes sense between the variants.</p>
<p>For <code>Option</code>s, <code>None &lt; Some(_)</code>, but for <code>Result</code>s, <code>Ok(_) &lt; Err(_)</code>.  So there‚Äôs no definition for <code>ControlFlow</code> that‚Äôs consistent with the isomorphism to both types.</p>
<p>Leaving it out also leaves us free to change the ordering of the variants in the definition in case doing so can allow us to optimize the <code>?</code> operator.  (For a similar previous experiment, see <a href="https://github.com/rust-lang/rust/pull/49499">PR #49499</a>.)</p>
<h3 id="naming-the-variants-on-controlflow"><a class="header" href="#naming-the-variants-on-controlflow">Naming the variants on <code>ControlFlow</code></a></h3>
<p>The variants are given those names as they serve the same purpose as the corresponding keywords when used in <code>Iterator::try_fold</code> or <code>Iterator::try_for_each</code>.</p>
<!-- https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=f10bc2eab9db91273601c9e806989f7e -->
<p>For example, this (admittedly contrived) loop</p>
<pre><code class="language-rust">let mut sum = 0;
for x in iter {
    if x % 2 == 0 { continue }
    sum += x;
    if sum &gt; 100 { break }
    continue
}</code></pre>
<p>can be written as</p>
<pre><code class="language-rust">let mut sum = 0;
iter.try_for_each(|x| {
    if x % 2 == 0 { return ControlFlow::Continue(()) }
    sum += x;
    if sum &gt; 100 { return ControlFlow::Break(()) }
    ControlFlow::Continue(())
});</code></pre>
<p>(Of course, one wouldn‚Äôt normally use the <code>continue</code> keyword at the end of a <code>for</code> loop like that, but I‚Äôve included it here to emphasize that even the <code>ControlFlow::Continue(())</code> as the final expression of the block it ends up working like the keyword would.)</p>
<h3 id="why-controlflow-has-c--"><a class="header" href="#why-controlflow-has-c--">Why <code>ControlFlow</code> has <code>C = ()</code></a></h3>
<p>The type that eventually became <code>ControlFlow</code> was originally added way back in 2017 as <a href="https://github.com/rust-lang/rust/commit/b32267f2c1344d37c4aa30eccd5a9ab77642b3e6#diff-6f95fa6b66f447d11bb7507f832027237ee240310c159c74495a2363c82e76d7R357-R376">the internal-only type <code>LoopState</code></a> used to make some default implementations in <code>Iterator</code> easier to read.  It had no type parameter defaults.</p>
<p><a href="https://github.com/rust-lang/rust/issues/75744">Issue #75744</a> in 2020 started the process of exposing it, coming out of the <a href="https://github.com/rust-itertools/itertools/issues/469">observation</a> that <code>Iterator::try_fold</code> isn‚Äôt a great replacement for the deprecated-at-the-time <code>Itertools::fold_while</code> since using <code>Err</code> for a conceptual success makes code hard to read.</p>
<p>The compiler actually had <a href="https://github.com/rust-lang/rust/blob/515c9fa505e18a65d7f61bc3e9eb833b79a68618/src/librustc_data_structures/graph/iterate/mod.rs#L91-L94">its own version of the type</a> in <code>librustc_data_structures</code> at the time:</p>
<pre><code class="language-rust">pub enum ControlFlow&lt;T&gt; {
    Break(T),
    Continue,
}</code></pre>
<p>The compiler was moved over to the newly-exposed type, and that inspired the creation of <a href="https://github.com/rust-lang/compiler-team/issues/374">MCP#374</a>, TypeVisitor: use ops::ControlFlow instead of bool.  Experience from that lead to flipping the type arguments in <a href="https://github.com/rust-lang/rust/pull/76614">PR#76614</a> ‚Äì which also helped the original use cases in <code>Iterator</code>, where things like default implementation of <code>find</code> also want <code>C = ()</code>.  And these were so successful that it lead to <a href="https://github.com/rust-lang/compiler-team/issues/383">MCP#383</a>, TypeVisitor: do not hard-code a <code>ControlFlow&lt;()&gt;</code> result, having the visitors use <code>ControlFlow&lt;Self::BreakTy&gt;</code>.</p>
<p>As an additional anecdote that <code>C = ()</code> is particularly common, <a href="https://discord.com/channels/530598289813536771/530603542138847242/807920021728264193">Hytak mentioned the following</a> on Discord in response to seeing a draft of this RFC:</p>
<blockquote>
<p>i didn‚Äôt read your proposal in depth, but this reminds me of a recursive search function i experimented with a few days ago. It used a Result type as output, where Err(value) meant that it found the value and Ok(()) meant that it didn‚Äôt find the value. That way i could use the <code>?</code> to exit early</p>
</blockquote>
<p>So when thinking about <code>ControlFlow</code>, it‚Äôs often best to think of it not like <code>Result</code>, but like an <code>Option</code> which short-circuits the other variant.  While it <em>can</em> flow a <code>Continue</code> value, that seems to be a fairly uncommon use in practice.</p>
<h3 id="was-this-considered-last-time"><a class="header" href="#was-this-considered-last-time">Was this considered last time?</a></h3>
<p>Interestingly, a <a href="https://github.com/rust-lang/rfcs/blob/f89568b1fe5db4d01c4668e0d334d4a5abb023d8/text/0000-try-trait.md#using-an-associated-type-for-the-success-value">previous version</a> of RFC #1859 <em>did</em> actually mention a two-trait solution, splitting the ‚Äúassociated type for ok‚Äù and ‚Äúgeneric type for error‚Äù like is done here.  It‚Äôs no longer  mentioned in the version that was merged.  To speculate, it may have been unpopular due to a thought that an extra traits just for the associated type wasn‚Äôt worth it.</p>
<p>Current desires for the solution, however, have more requirements than were included in the RFC at the time of that version.  Notably, the stabilized <code>Iterator::try_fold</code> method depends on being able to create a <code>Try</code> type from the accumulator.  Including such a constructor on the trait with the associated type helps that separate trait provide value.</p>
<p>Also, ok-wrapping was decided <a href="https://github.com/rust-lang/rust/issues/70941">in #70941</a>, which needs such a constructor, making this <a href="https://github.com/rust-lang/rust/issues/42327#issuecomment-379882998">‚Äúmuch more appealing‚Äù</a>.</p>
<h3 id="why-not-make-the-output-a-generic-type"><a class="header" href="#why-not-make-the-output-a-generic-type">Why not make the output a generic type?</a></h3>
<p>It‚Äôs helpful that type information can flow both ways through <code>?</code>.</p>
<ul>
<li>In the forward direction, not needing a contextual type means that <code>println!("{}", x?)</code> works instead of needing a type annotation.  (It‚Äôs also just less confusing to have <code>?</code> on the same type always produce the same type.)</li>
<li>In the reverse direction, it allows things like <code>let x: i32 = s.parse()?;</code> to infer the requested type from that annotation, rather than requiring it be specified again.</li>
</ul>
<p>Similar scenarios exist for <code>try</code>, though of course they‚Äôre not yet stable:</p>
<ul>
<li><code>let y: anyhow::Result&lt;_&gt; = try { x };</code> doesn‚Äôt need to repeat the type of <code>x</code>.</li>
<li><code>let x: i16 = { 4 };</code> works for infallible code, so for consistency it‚Äôs good for <code>let x: anyhow::Result&lt;i16&gt; = try { 4 };</code> to also work (rather than default the literal to <code>i32</code> and fail).</li>
</ul>
<h3 id="why-does-fromresidual-take-a-generic-type"><a class="header" href="#why-does-fromresidual-take-a-generic-type">Why does <code>FromResidual</code> take a generic type?</a></h3>
<p>The simplest case is that the already-stable error conversions require a generic <em>somewhere</em> in the error path in the desugaring.  In the RFC #1859 implementation, that generic comes from using <code>From::from</code> in the desugaring.</p>
<p>However, more experience with trying to use <code>Try</code> for scenarios other than ‚Äúthe early exit is an error‚Äù have shown that <em>forcing</em> this on everything is inappropriate.  <code>ControlFlow</code>, for example, would rather not have it, for the same kinds of reasons that <code>return</code> and <code>break</code>-from-<code>loop</code> don‚Äôt implicitly call it.  <code>Option</code> may not care, as it only ever gets applied for <code>None</code>‚áí<code>None</code>, but that‚Äôs not really a glowing endorsement.</p>
<p>But even for the error path, forcing <code>From</code> causes problems, notably because of its identity impl.  <a href="https://lib.rs/crates/anyhow"><code>anyhow</code></a>‚Äôs <code>Error</code> type, for example, doesn‚Äôt implement <code>std::error::Error</code> because that would prevent it from being <code>From</code>-convertible from any <code>E: std::error::Error</code> type.  The <a href="https://blog.rust-lang.org/inside-rust/2020/09/18/error-handling-wg-announcement.html">error handling project group</a> under libs has experimented with a prototype toolchain with this RFC implemented, and is <a href="https://rust-lang.zulipchat.com/#narrow/stream/257204-project-error-handling/topic/separating.20From.3CE.3A.20Error.3E.20from.20Box.3Cdyn.20Error.3E">excited</a> at the possibilities that could come from being free of this restriction:</p>
<blockquote>
<p>my mind is exploding, the possibility of all error types implementing error the way they actually should has such massive implications for the rest of the error reporting stuff we‚Äôve been working on</p>
</blockquote>
<p>As a bonus, moving conversion (if any) into the <code>FromResidual</code> implementation may actually speed up the compiler ‚Äì the simpler desugar means generating less HIR, and thus less work for everything thereafter (up to LLVM optimizations, at least).  The <code>serde</code> crate has <a href="https://github.com/serde-rs/serde/blob/b0c99ed761d638f2ca2f0437522e6c35ad254d93/serde_derive/src/try.rs#L3-L6">their own macro</a> for error propagation which omits <code>From</code>-conversion as they see a ‚Äúsignificant improvement‚Äù from doing so.</p>
<h3 id="why-not-merge-try-and-fromresidual"><a class="header" href="#why-not-merge-try-and-fromresidual">Why not merge <code>Try</code> and <code>FromResidual</code>?</a></h3>
<p>This RFC treats them as conceptually the same trait ‚Äì there are no types proposed here to implement <code>FromResidual&lt;_&gt;</code> which don‚Äôt also implement <code>Try</code> ‚Äì so one might wonder why they‚Äôre not merged into one <code>Try&lt;R&gt;</code>.  After all, that would seem to remove the duplication between the associated type and the generic type, as something like</p>
<pre><code class="language-rust">trait Try&lt;Residual&gt; {
    type Output;
    fn branch(self) -&gt; ControlFlow&lt;Residual, Self::Output&gt;;
    fn from_residual(r: Residual) -&gt; Self;
    fn from_output(x: Self::Output) -&gt; Self;
}</code></pre>
<p>This, however, is technically too much freedom.  Looking at the error propagation case, it would end up calling both <code>Try&lt;?R1&gt;::branch</code> and <code>Try&lt;?R2&gt;::from_residual</code>.  With the implementation for <code>Result</code>, where those inference variables go through <code>From</code>, there‚Äôs no way to pick what they should be, similar to how <code>.into().into()</code> doesn‚Äôt compile.  And even outside the desugaring, this would make <code>Try::from_output(x)</code> no longer work, since the compiler would (correctly) insist that the desired residual type be specified.</p>
<p>And even for a human, it‚Äôs not clear that this freedom is helpful.  While any trait can be implemented weirdly, one good part of RFC #1859 that this one hopes to retain is that one doesn‚Äôt need to know contextual information to understand what comes out of <code>?</code>.  Whereas any design that puts <code>branch</code> on a generic trait would mean it‚Äôd be possible for <code>?</code> to return different things depending on that generic type parameter ‚Äì unless the associated type were split out into a separate trait, but that just reopens the ‚Äúwhy are they different traits‚Äù conversation again, without solving the other issues.</p>
<h3 id="naming-the--related-traits-and-associated-types"><a class="header" href="#naming-the--related-traits-and-associated-types">Naming the <code>?</code>-related traits and associated types</a></h3>
<p>This RFC introduces the <em>residual</em> concept as it was helpful to have a name to talk about in the guide section.  (A previous version proved unclear, perhaps in part due to it being difficult to discuss something without naming it.)  But the <code>fn branch(self) -&gt; ControlFlow&lt;Self::Residual, Self::Output&gt;</code> API is not necessarily obvious.</p>
<p>A different scheme might be clearer for people.  For example, there‚Äôs some elegance to matching the variant names by using <code>fn branch(self) -&gt; ControlFlow&lt;Self::Break, Self::Continue&gt;</code>.  Or perhaps there are more descriptive names, like <code>KeepGoing</code>/<code>ShortCircuit</code>.</p>
<p>As a sketch, one of those alternatives might look something like this:</p>
<pre><code class="language-rust">trait Try: FromBreak {
    type Break;
    type Continue;
    fn branch(self) -&gt; ControlFlow&lt;Self::Break, Self::Continue&gt;;
    fn from_continue(c: Self::Continue) -&gt; Self;
}
trait FromBreak&lt;B = &lt;Self as Try&gt;::Break&gt; {
    fn from_break(b: B) -&gt; Self;
}</code></pre>
<p>However the ‚Äúboring‚Äù <code>Output</code> name does have the advantage that one doesn‚Äôt need to remember a special name, as it‚Äôs the same as the other operator traits.  (For precedent, it‚Äôs <code>Add::Output</code> and <code>Div::Output</code> even if one could argue that <code>Add::Sum</code> or <code>Div::Quotient</code> would be more ‚Äúcorrect‚Äù, in a sense.)</p>
<blockquote>
<p>‚Ñπ Per feedback from T-libs, this is left as an unresolved question for the RFC, to be resolved in nightly.</p>
</blockquote>
<h3 id="splitting-up-try-more"><a class="header" href="#splitting-up-try-more">Splitting up <code>Try</code> more</a></h3>
<p>This RFC encourages one to think of a <code>Try</code> type holistically, as something that supports all three of the core operations, with expected rules between them.</p>
<p>That‚Äôs not necessarily the way it should go.  It could be different, like there‚Äôs no guarantee that <code>Add</code> and <code>AddAssign</code> work consistently, nor that <code>Add</code> and <code>Sub</code> are inverses.</p>
<p>Notably, the this proposal has both an <em>introduction</em> rule (<code>Try::from_output</code>) and <em>elimination</em> rule (<code>Try::branch</code>), in the <a href="https://en.wikipedia.org/wiki/Natural_deduction#Introduction_and_elimination">Gentzian sense</a>, on the same trait.  That means that an implementor will need to support both, which could restrict the set of type with which <code>?</code> (and <code>try</code> and <code>yeet</code>) could be used.</p>
<p>One unknown question here is whether this is important for any FFI scenarios.  Often error APIs come in pairs (like Win32‚Äôs <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror"><code>GetLastError</code></a> and <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setlasterror"><code>SetLastError</code></a>), but some libraries may only give them out without allowing updating them to a custom value.  It‚Äôs unclear whether such a thing would want to be exposed as <code>?</code> on some ZST, and thus would need a trait split to work, or whether it would be sufficient to load such things into a <code>?</code>-supporting type where supporting <code>from_residual</code> would be simple.</p>
<p>In pure rust, one could also imagine types where it might be interesting to allow <em>introduction</em> rules but not <em>elimination</em> rules.  With <code>try</code> blocks, one could perhaps have something like</p>
<pre><code class="language-rust">let _: IgnoreAllErrors = try {
    foo()?;
    bar()?;
    qux()?;
};</code></pre>
<p>which works by allowing <code>from_residual</code> from any <code>Result&lt;_, _&gt;::Residual</code>, as well as <code>from_output</code> from <code>()</code>.  On such a type there‚Äôs no real <em>use</em> in allowing <code>?</code> on the result, but at the same time it wouldn‚Äôt be a hardship to offer it.</p>
<p>The split currently in the proposal, though it‚Äôs there for other reasons, would allow a small version of this: it would be possible to add an implementation like <code>impl FromResidual&lt;Result&lt;!, !&gt;&gt; for ()</code>, which would allow code like <code>u64::try_from(123_u16)?</code> even in a method that returns unit.  That has a number of issues, however, like only supporting <code>-&gt; ()</code> and not other things like <code>-&gt; i32</code> where one would probably also expect it to work, and it could not be a generic implementation without some form of specialization, as it would conflict with the desired implementation on <code>Result</code>.  And even if it did work, it‚Äôs not clear that allowing <code>?</code> here is the clearest option ‚Äì other options <a href="https://github.com/rust-lang/rfcs/issues/1723">such as an <code>always_ok</code> method on <code>Result&lt;T, !&gt;</code></a> might be superior anyway.</p>
<p>Another downside of the flexibility is that the structure of the traits would be somewhat more complicated.</p>
<p>The simplest split would just move each method to its own trait,</p>
<pre><code class="language-rust">trait Branch {
    type Output;
    type Residual;
    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, Self::Output&gt;;
}
trait FromOutput {
    type Output;
    fn from_output(x: Self::Output) -&gt; Self;
}
trait FromResidual&lt;R&gt; {
    fn from_residual(x: R) -&gt; Self;
}</code></pre>
<p>but that loses the desired property that the returned-by-<code>?</code> and expected-by-<code>try</code> types match for types which <em>do</em> implement both.</p>
<p>One way to fix that would be to add another trait for that associated type, perhaps something like</p>
<pre><code class="language-rust">trait TryBase {
    type Output;
}
trait Branch: TryBase {
    type Residual;
    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, Self::Output&gt;;
}
trait FromOutput: TryBase {
    fn from_output(x: Self::Output) -&gt; Self;
}
trait FromResidual&lt;R&gt; {
    fn from_residual(x: R) -&gt; Self;
}
</code></pre>
<p>But this has still lost the simplicity of the <code>R: Try</code> bound for use in simple cases like <code>try_fold</code>.  (And, in fact, all designs that allow types to choose them independently have that issue.)  That may mean that it would also be useful to add yet another item, a trait alias to tie everything together in the ‚Äúusual‚Äù way again.  Perhaps it would look something like this:</p>
<pre><code class="language-rust">trait Try = Branch + FromOutput + FromResidual&lt;&lt;Self as Branch&gt;::Residual&gt;;</code></pre>
<p>There are probably also useful intermediary designs here.  Perhaps the <code>IgnoreAllErrors</code> example above suggests that <em>introduction</em> on its own is reasonable, but <em>elimination</em> should require that both be supported.  That‚Äôs also the direction that would make sense for <code>?</code> in infallible functions: it‚Äôs absolutely undesirable for <code>()?????</code> to compile, but it might be fine for all return types to support something like <code>T: FromResidual&lt;!&gt;</code> eventually.</p>
<blockquote>
<p>‚Ñπ Per feedback from T-libs, this is left as an unresolved question for the RFC, to be resolved in nightly.</p>
</blockquote>
<h3 id="why-a-residual-type-is-better-than-an-error-type"><a class="header" href="#why-a-residual-type-is-better-than-an-error-type">Why a ‚Äúresidual‚Äù type is better than an ‚Äúerror‚Äù type</a></h3>
<p>Most importantly, for any type generic in its ‚Äúoutput type‚Äù it‚Äôs easy to produce a residual type using an uninhabited type.  That works for <code>Option</code> ‚Äì no <code>NoneError</code> residual type needed ‚Äì as well as for the <code>StrandFail&lt;T&gt;</code> type from the experience report.  And thanks to enum layout optimizations, there‚Äôs no space overhead to doing this: <code>Option&lt;!&gt;</code> is a ZST, and <code>Result&lt;!, E&gt;</code> is no larger than <code>E</code> itself.  So most of the time one will not need to define anything additional.</p>
<p>In those cases where a separate type <em>is</em> needed, it‚Äôs still easier to make a residual type because they‚Äôre transient and thus can be opaque: there‚Äôs no point at which a user is expected to <em>do</em> anything with a residual type other than convert it back into a known <code>Try</code> type.  This is different from the previous design, where less-restrictive interconversion meant that anything could be exposed via a <code>Result</code>.  That has lead to requests, <a href="https://github.com/rust-lang/rust/issues/46871#issuecomment-618186642">such as for <code>NoneError</code> to implement <code>Error</code></a>, that are perfectly understandable given that the instances are exposed in <code>Result</code>s.  As residual types aren‚Äôt ever exposed like that, it would be fine for them to implement nothing but <code>FromResidual</code> (and probably <code>Debug</code>), making them cheap to define and maintain.</p>
<h3 id="use-of-"><a class="header" href="#use-of-">Use of <code>!</code></a></h3>
<p>This RFC uses <code>!</code> to be concise.  It would work fine with <code>convert::Infallible</code> instead if <code>!</code> has not yet stabilized, though a few more match arms would be needed in the implementations.  (For example, <code>Option::from_residual</code> would need <code>Some(c) =&gt; match c {}</code>.)</p>
<h3 id="why-fromresidual-is-the-supertrait"><a class="header" href="#why-fromresidual-is-the-supertrait">Why <code>FromResidual</code> is the supertrait</a></h3>
<p>It‚Äôs nicer for <code>try_fold</code> implementations to just mention the simpler <code>Try</code> name.  It being the subtrait means that code needing only the basic scenario can just bound on <code>Try</code> and know that both <code>from_output</code> and <code>from_residual</code> are available.</p>
<h3 id="default-residual-on-fromresidual"><a class="header" href="#default-residual-on-fromresidual">Default <code>Residual</code> on <code>FromResidual</code></a></h3>
<p>The default here is provided to make the basic case simple.  It means that when implementing the trait, the simple case (like in <code>Option</code>) doesn‚Äôt need to think about it ‚Äì similar to how you can <code>impl Add for Foo</code> for the homogeneous case even though that trait also has a generic parameter.</p>
<h3 id="fromresidualfrom_residual-vs-residualinto_try"><a class="header" href="#fromresidualfrom_residual-vs-residualinto_try"><code>FromResidual::from_residual</code> vs <code>Residual::into_try</code></a></h3>
<p>Either of these directions could be made to work.  Indeed, an early experiment while drafting this had a method on a required trait for the residual that created the type implementing <code>Try</code> (not just the associated type).  However that method was removed as unnecessary once <code>from_residual</code> was added, and then the whole trait was moved to future work in order to descope the RFC, as it proved unnecessary for the essential <code>?</code>/<code>try_fold</code> functionality.</p>
<p>A major advantage of the <code>FromResidual::from_residual</code> direction is that it‚Äôs more flexible with coherence when it comes to allowing other things to be converted into a new type being defined.  That does come at the cost of higher restriction on allowing the new type to be converted into other things, but reusing a residual can also be used for that scenario.</p>
<p>Converting a known residual into a generic <code>Try</code> type seems impossible (unless it‚Äôs uninhabited), but consuming arbitrary residuals could work ‚Äì imagine something like</p>
<pre><code class="language-rust">impl&lt;R: std::fmt::Debug&gt; FromResidual&lt;R&gt; for LogAndIgnoreErrors {
    fn from_residual(h: H) -&gt; Self {
        dbg!(h);
        Self
    }
}</code></pre>
<p>(Not that that‚Äôs necessarily a good idea ‚Äì it‚Äôs plausibly <em>too</em> generic.  This RFC definitely isn‚Äôt proposing it for the standard library.)</p>
<p>And, ignoring the coherence implications, a major difference between the two sides is that the target type is typically typed out visibly (in a return type) whereas the source type (going into the <code>?</code>) is often the result of some called function.  So it‚Äôs preferable for any behaviour extensions to be on the type that can more easily be seen in the code.</p>
<h3 id="can-we-just-remove-the-accidental-interconversions"><a class="header" href="#can-we-just-remove-the-accidental-interconversions">Can we just remove the accidental interconversions?</a></h3>
<p>This depends on how we choose to read the rules around breaking changes.</p>
<p>A <a href="https://github.com/rust-lang/rust/pull/82322#issuecomment-792299734">crater run on a prototype implementation</a> found that some people are doing this.  PRs have been sent to the places that broke, and generally it was agreed that removing the mixing improved the code:</p>
<blockquote>
<p>Definitely a good change.</p>
</blockquote>
<blockquote>
<p>Thanks for spotting that, that was indeed a confusing mix</p>
</blockquote>
<p>However another instance is in an abandoned project where the repository has been archived, so will not be fixed.  And of course if it happened 3 times, there might be more instances in the wild.</p>
<p>The interesting pattern boils down to this:</p>
<pre><code class="language-rust">.map(|v| Ok(something_returning_option(v)?))</code></pre>
<p>That means it‚Äôs using <code>?</code> on an <code>Option</code>, but the closure ends up returning <code>Result&lt;_, NoneError&gt;</code> without needing to name the type as trait resolution discovers that it‚Äôs the only possibility.  It seems reasonable that this could happen accidentally while refactoring.  That does mean, however, that the breakage could also be considered ‚Äúallowed‚Äù as an inference change, and hypothetically additional implementations could make it ambiguous in the future.  (It‚Äôs like the normal <code>AsRef</code> breakage, and fits the pattern of ‚Äúthere‚Äôs a way it could be written that works before and after‚Äù, though in this case the disambiguated form requires naming an unstable type.)</p>
<p>This RFC thus proposes removing the accidental interconversions.</p>
<h4 id="compatibility-with-accidental-interconversions-if-needed"><a class="header" href="#compatibility-with-accidental-interconversions-if-needed">Compatibility with accidental interconversions (if needed)</a></h4>
<p>If something happens that turns out they need to be supported, the following approach can work.</p>
<p>This would take a multi-step approach:</p>
<ul>
<li>Add a new never-stable <code>FromResidualLegacy</code> trait</li>
<li>Have a blanket implementation so that users interact only with <code>FromResidual</code></li>
<li>Add implementations for the accidental interconversions</li>
<li>Use <code>FromResidualLegacy</code> in the desugaring, <a href="https://github.com/scottmcm/rust/commit/do-or-do-not-edition">perhaps only for old editions</a></li>
</ul>
<p>This keeps them from being visible in the trait system on stable, as <code>FromResidual</code> (the only form that would ever stabilize, or even be mentionable) would not include them.</p>
<pre><code class="language-rust">mod sadness {
    use super::*;

    /// This includes all of the [`ops::FromResidual`] conversions, but
    /// also adds the two interconversions that work in 2015 &amp; 2018.
    /// It will never be stable.
    pub trait FromResidualLegacy&lt;R&gt; {
        fn from_residual_legacy(r: R) -&gt; Self;
    }

    impl&lt;T: ops::FromResidual&lt;R&gt;, R&gt; FromResidualLegacy&lt;R&gt; for T {
        fn from_residual_legacy(r: R) -&gt; Self {
            &lt;Self as ops::FromResidual&lt;R&gt;&gt;::from_residual(r)
        }
    }

    /// This is a remnant of the old `NoneError` which is never going to be stabilized.
    /// It's here as a snapshot of an oversight that allowed this to work in the past,
    /// so we're stuck supporting it even though we'd really rather not.
    /// This will never be stabilized; use [`Option::ok_or`] to mix `Option` and `Result`.
    #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]
    pub struct LegacyNoneError;

    impl&lt;T, E&gt; ops::FromResidual&lt;Option&lt;!&gt;&gt; for Result&lt;T, E&gt;
    where
        E: From&lt;LegacyNoneError&gt;,
    {
        fn from_residual(x: Option&lt;!&gt;) -&gt; Self {
            match x {
                None =&gt; Err(From::from(LegacyNoneError)),
            }
        }
    }


    #[unstable(feature = "try_trait_v2", issue = "42327")]
    impl&lt;T&gt; FromResidualLegacy&lt;Result&lt;!, LegacyNoneError&gt;&gt; for Option&lt;T&gt;
    {
        fn from_residual_legacy(_: Result&lt;!, LegacyNoneError&gt;) -&gt; Self {
            None
        }
    }
}</code></pre>
<!--
- Why is this design the best in the space of possible designs?
- What other designs have been considered and what is the rationale for not choosing them?
- What is the impact of not doing this?
-->
<h2 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h2>
<p>Previous approaches used on nightly</p>
<ul>
<li>The original <a href="https://doc.rust-lang.org/1.16.0/core/ops/trait.Carrier.html"><code>Carrier</code> trait</a></li>
<li>The next design with a <a href="https://doc.rust-lang.org/1.32.0/core/ops/trait.Try.html"><code>Try</code> trait</a> (different from the one here)</li>
</ul>
<p>This is definitely <em>monadic</em>.  One can define the basic monad operations for the <code>Maybe</code> monad as</p>
<pre><code class="language-rust">use std::ops::Try;

fn monad_unit&lt;T: Try&gt;(x: &lt;T as Try&gt;::Ok) -&gt; T {
    T::from_output(x)
}

fn monad_bind&lt;T1: Try&lt;Residual = R&gt;, T2: Try&lt;Residual = R&gt;, R&gt;(mx: T1, f: impl FnOnce(&lt;T1 as Try&gt;::Ok) -&gt; T2) -&gt; T2 {
    let x = mx?;
    f(x)
}

fn main() {
    let mx: Option&lt;i32&gt; = monad_unit(1);
    let my = monad_bind(mx, |x| Some(x + 1));
    let mz = monad_bind(my, |x| Some(-x));
    assert_eq!(mz, Some(-2));
}</code></pre>
<p>However, <a href="https://twitter.com/withoutboats/status/1027702535707090944">like boats described for <code>async.await</code></a>, using monads directly isn‚Äôt a great fit for rust.  <code>?</code> desugaring to a <code>return</code> (rather than closures) mixes better with the other control flow constructs, such as <code>break</code> and <code>continue</code>, that don‚Äôt work through closures.  And while the definitions above work fine for <code>Option</code>, they don‚Äôt allow the error-conversion that‚Äôs already stable with <code>Result</code>, so any monad-based implementation of <code>?</code> wouldn‚Äôt be able to be the normal monad structure regardless.</p>
<!--
Discuss prior art, both the good and the bad, in relation to this proposal.
A few examples of what this can include are:

- For language, library, cargo, tools, and compiler proposals: Does this feature exist in other programming languages and what experience have their community had?
- For community proposals: Is this done by some other community and what were their experiences with it?
- For other teams: What lessons can we learn from what other communities have done here?
- Papers: Are there any published papers or great posts that discuss this? If you have some relevant papers to refer to, this can serve as a more detailed theoretical background.

This section is intended to encourage you as an author to think about the lessons from other languages, provide readers of your RFC with a fuller picture.
If there is no prior art, that is fine - your ideas are interesting to us whether they are brand new or if it is an adaptation from other languages.

Note that while precedent set by other languages is some motivation, it does not on its own motivate an RFC.
Please also take into consideration that rust sometimes intentionally diverges from common language features.
-->
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<p>Questions from T-libs to be resolved in nightly:</p>
<ul>
<li><input disabled="" type="checkbox"> What vocabulary should <code>Try</code> use in the associated types/traits?  Output+residual, continue+break, or something else entirely?</li>
<li><input disabled="" type="checkbox"> Is it ok for the two traits to be tied together closely, as outlined here, or should they be split up further to allow types that can be only-created or only-destructured?</li>
</ul>
<h3 id="implementation-and-stabilization-sequencing"><a class="header" href="#implementation-and-stabilization-sequencing">Implementation and Stabilization Sequencing</a></h3>
<ul>
<li><code>ControlFlow</code> is implemented in nightly already.</li>
<li>The traits and desugaring could go into nightly immediately.</li>
<li>That would allow <code>ControlFlow</code> to be considered for stabilizating, as the new desugaring would keep from stabilizing any unwanted interconversions.</li>
<li>Beta testing might result in reports requiring that the accidental interconversions be added back in old editions, due to crater-invisible code.</li>
<li>Then the unresolved naming &amp; structure questions need to be addressed before <code>Try</code> could stabilize.</li>
</ul>
<!--
- What parts of the design do you expect to resolve through the RFC process before this gets merged?
- What parts of the design do you expect to resolve through the implementation of this feature before stabilization?
- What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?
-->
<h2 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h2>
<p>While it isn‚Äôt directly used in this RFC, a particular residual type can be used to define a ‚Äúfamily‚Äù of types which all share that residual.</p>
<p>For example, one could define a trait like this one:</p>
<pre><code class="language-rust">pub trait GetCorrespondingTryType&lt;TryOutputType&gt;: Sized {
    /// The type from the original type constructor that also has this residual type,
    /// but has the specified Output type.
    type TryType: Try&lt;Output = TryOutputType, Residual = Self&gt;;
}</code></pre>
<p>With corresponding simple implementations like these:</p>
<pre><code class="language-rust">impl&lt;T&gt; GetCorrespondingTryType&lt;T&gt; for Option&lt;!&gt; {
    type TryType = Option&lt;T&gt;;
}

impl&lt;C, B&gt; ops::GetCorrespondingTryType&lt;C&gt; for ControlFlow&lt;B, !&gt; {
    type TryType = ControlFlow&lt;B, C&gt;;
}</code></pre>
<p>And thus allow code to put whatever value they want into the appropriate type from the same family.</p>
<p>This can be thought of as the type-level inverse of <code>Try</code>‚Äôs associated types: It splits them apart, and this puts them back together again.</p>
<p>(Why is this not written using Generic Associated Types (GATs)?  Because it allows implementations to work with only specific types, or with generic-but-bounded types.  Anything using it can bound to just the specific types needed for that method.)</p>
<p>A previous version of this RFC included a trait along these lines, but it wasn‚Äôt needed for the stable-at-time-of-writing scenarios.  Furthermore, some experiments demonstrated that having a bound in <code>Try</code> requiring it (something like <code>where Self::Residual: GetCorrespondingTryType&lt;Self::Output&gt;</code>) wasn‚Äôt actually even helpful for unstable scenarios, so there was no need to include it in normative section of the RFC.</p>
<h3 id="possibilities-for-try_find"><a class="header" href="#possibilities-for-try_find">Possibilities for <code>try_find</code></a></h3>
<p>Various library methods, such as <code>try_map</code> for arrays (<a href="https://github.com/rust-lang/rust/pull/79713#issuecomment-739075171">PR #79713</a>), would like to be able to do HKT-like things to produce their result types.  For example, <code>Iterator::try_find</code> wants to be able to return a <code>Foo&lt;Option&lt;Item&gt;&gt;</code> from a predicate that returned a <code>Foo&lt;bool&gt;</code>.</p>
<p>That could be done with an implementation such as the following:</p>
<pre><code class="language-rust">fn try_find&lt;F, R&gt;(
    &amp;mut self,
    f: F,
) -&gt; &lt;R::Residual as ops::GetCorrespondingTryType&lt;Option&lt;Self::Item&gt;&gt;&gt;::TryType
where
    Self: Sized,
    F: FnMut(&amp;Self::Item) -&gt; R,
    R: ops::Try&lt;Output = bool&gt;,
    R::Residual: ops::GetCorrespondingTryType&lt;Option&lt;Self::Item&gt;&gt;,
{
    #[inline]
    fn check&lt;F, T, R&gt;(mut f: F) -&gt; impl FnMut((), T) -&gt; ControlFlow&lt;Result&lt;T, R::Residual&gt;&gt;
    where
        F: FnMut(&amp;T) -&gt; R,
        R: Try&lt;Output = bool&gt;,
    {
        move |(), x| match f(&amp;x).branch() {
            ControlFlow::Continue(false) =&gt; ControlFlow::Continue(()),
            ControlFlow::Continue(true) =&gt; ControlFlow::Break(Ok(x)),
            ControlFlow::Break(r) =&gt; ControlFlow::Break(Err(r)),
        }
    }

    match self.try_fold((), check(f)) {
        ControlFlow::Continue(()) =&gt; Try::from_output(None),
        ControlFlow::Break(Ok(x)) =&gt; Try::from_output(Some(x)),
        ControlFlow::Break(Err(r)) =&gt; &lt;_&gt;::from_residual(r),
    }
}</code></pre>
<p>Similarly, it could allow <code>Try</code> to automatically provide an appropriate <code>map</code> method:</p>
<pre><code class="language-rust">fn map&lt;T&gt;(self, f: impl FnOnce(Self::Output) -&gt; T) -&gt; &lt;Self::Residual as GetCorrespondingTryType&lt;T&gt;&gt;::TryType
where
    Self::Residual: GetCorrespondingTryType&lt;T&gt;,
{
    match self.branch() {
        ControlFlow::Continue(c) =&gt; Try::from_output(f(c)),
        ControlFlow::Break(r) =&gt; FromResidual::from_residual(r),
    }
}
</code></pre>
<h3 id="possibilities-for-try"><a class="header" href="#possibilities-for-try">Possibilities for <code>try{}</code></a></h3>
<p>A core problem with <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/try-blocks.html">try blocks</a> as implemented in nightly, is that they require their contextual type to be known.</p>
<p>That is, the following never compiles, no matter the types of <code>x</code> and <code>y</code>:</p>
<pre><code class="language-rust">let _ = try {
    foo(x?);
    bar(y?);
    z
};</code></pre>
<p>This usually isn‚Äôt a problem on stable, as the <code>?</code> usually has a contextual type from its function, but can still happen there in closures.</p>
<p>But with something like <code>GetCorrespondingTryType</code>, an alternative desugaring becomes available which takes advantage of how the residual type preserves the ‚Äúresult-ness‚Äù (or whatever-ness) of the original value.  That might turn the block above into something like the following:</p>
<pre><code class="language-rust">fn helper&lt;C, R: GetCorrespondingTryType&lt;C&gt;&gt;(r: R) -&gt; &lt;R as GetCorrespondingTryType&lt;C&gt;&gt;::TryType
{
    FromResidual::from_residual(h)
}

'block: {
    foo(match Try::branch(x) {
        ControlFlow::Continue(c) =&gt; c,
        ControlFlow::Break(r) =&gt; break 'block helper(r),
    });
    bar(match Try::branch(y) {
        ControlFlow::Continue(c) =&gt; c,
        ControlFlow::Break(r) =&gt; break 'block helper(r),
    });
    Try::from_output(z)
}</code></pre>
<p>(It‚Äôs untested whether the inference engine is smart enough to pick the appropriate <code>C</code> with just that ‚Äì the <code>Output</code> associated type is constrained to have a <code>Continue</code> type matching the generic parameter, and that <code>Continue</code> type needs to match that of <code>z</code>, so it‚Äôs possible.  But hopefully this communicates the idea, even if an actual implementation might need to more specifically introduce type variables or something.)</p>
<p>That way it could compile so long as the <code>TryType</code>s of the residuals matched.  For example, <a href="https://github.com/rust-lang/rust/blob/7cf205610e1310897f43b35713a42459e8b40c64/compiler/rustc_codegen_ssa/src/back/linker.rs#L529-L573">these uses in rustc</a> would work without the extra annotation.</p>
<p>Now, of course that wouldn‚Äôt cover anything.  It wouldn‚Äôt work with anything needing error conversion, for example, but annotation is also unavoidable in those cases ‚Äì there‚Äôs no reasonable way for the compiler to pick ‚Äúthe‚Äù type into which all the errors are convertible.</p>
<p>So a future RFC could define a way (syntax, code inspection, heuristics, who knows) to pick which of the desugarings would be best.  (As a strawman, one could say that <code>try { ... }</code> uses the ‚Äúsame family‚Äù desugaring whereas <code>try as anyhow::Result&lt;_&gt; { ... }</code> uses the contextual desugaring.)  This RFC declines to debate those possibilities, however.</p>
<p><em>Note that the <code>?</code> desugaring in nightly is already different depending whether it‚Äôs inside a <code>try {}</code> (since it needs to block-break instead of <code>return</code>), so making it slightly more different shouldn‚Äôt have excessive implementation cost.</em></p>
<h3 id="possibilities-for-yeet"><a class="header" href="#possibilities-for-yeet">Possibilities for <code>yeet</code></a></h3>
<p>As previously mentioned, this RFC neither defines nor proposes a <code>yeet</code> operator.  However, like the previous design could support one with its <code>Try::from_error</code>, it‚Äôs important that this design would be sufficient to support it.</p>
<p><em><code>yeet</code> is a <a href="https://twitter.com/josh_triplett/status/1248658754976927750">bikeshed-avoidance</a> name for <code>throw</code>/<code>fail</code>/<code>raise</code>/etc, used because it definitely won‚Äôt be the final keyword.</em></p>
<p>Because this ‚Äúresidual‚Äù design carries along the ‚Äúresult-ness‚Äù or ‚Äúoption-ness‚Äù or similar, it means there are two possibilities for a desugaring.</p>
<ul>
<li>It could directly take the residual type, so <code>yeet e</code> would desugar directly to <code>FromResidual::from_residual(e)</code>.</li>
<li>It could put the argument into a special residual type, so <code>yeet e</code> would desugar to something like <code>FromResidual::from_residual(Yeeted(e))</code>.</li>
</ul>
<p>These have various implications ‚Äì like <code>yeet None</code>/<code>yeet</code>, <code>yeet Err(ErrorKind::NotFound)</code>/<code>yeet ErrorKind::NotFound.into()</code>, etc ‚Äì but thankfully this RFC doesn‚Äôt need to discuss those.  (And please don‚Äôt do so in the GitHub comments either, to keep things focused, though feel free to start an IRLO or Zulip thread if you‚Äôre so inspired.)</p>
<!--
Think about what the natural extension and evolution of your proposal would
be and how it would affect the language and project as a whole in a holistic
way. Try to use this section as a tool to more fully consider all possible
interactions with the project and language in your proposal.
Also consider how this all fits into the roadmap for the project
and of the relevant sub-team.

This is also a good place to "dump ideas", if they are out of scope for the
RFC you are writing but otherwise related.

If you have tried and cannot think of any future possibilities,
you may simply state that you cannot think of anything.

Note that having something written down in the future-possibilities section
is not a reason to accept the current or a future RFC; such notes should be
in the section on motivation or rationale in this or subsequent RFCs.
The section merely provides additional information.
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="3052-optional-authors-field.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="3085-edition-2021.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="3052-optional-authors-field.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="3085-edition-2021.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
