<!DOCTYPE HTML>
<html lang="en_US" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>3425-return-position-impl-trait-in-traits - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-0060737d.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Feature Name: return_position_impl_trait_in_traits</li>
<li>Start Date: 2023-04-27</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/3425">rust-lang/rfcs#3425</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/91611">rust-lang/rust#91611</a></li>
<li>Initiative: <a href="https://github.com/rust-lang/impl-trait-initiative">impl trait initiative</a></li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>Permit <code>impl Trait</code> in fn return position within traits and trait impls.</li>
<li>Allow <code>async fn</code> in traits and trait impls to be used interchangeably with its equivalent <code>impl Trait</code> desugaring.</li>
<li>Allow trait impls to <code>#[refine]</code> an <code>impl Trait</code> return type with added bounds or a concrete type.<sup class="footnote-reference" id="fr-refine-1"><a href="#footnote-refine">1</a></sup></li>
</ul>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>The <code>impl Trait</code> syntax is currently accepted in a variety of places within the Rust language to mean “some type that implements <code>Trait</code>” (for an overview, see the <a href="https://rust-lang.github.io/impl-trait-initiative/explainer.html">explainer</a> from the impl trait initiative). For function arguments, <code>impl Trait</code> is <a href="https://rust-lang.github.io/impl-trait-initiative/explainer/apit.html">equivalent to a generic parameter</a> and it is accepted in all kinds of functions (free functions, inherent impls, traits, and trait impls).</p>
<p>In return position, <code>impl Trait</code> <a href="https://rust-lang.github.io/impl-trait-initiative/explainer/rpit.html">corresponds to an opaque type whose value is inferred</a>. This is necessary for returning unnameable types, like those created by closures and <code>async</code> blocks, and also a convenient way to avoid naming complicated types like nested iterators. In return position, <code>impl Trait</code> is currently accepted only in free functions and inherent impls. This RFC extends the support to traits and trait impls.</p>
<h3 id="example-use-case"><a class="header" href="#example-use-case">Example use case</a></h3>
<p>The use case for <code>-&gt; impl Trait</code> in trait functions is similar to its use in other contexts: traits often wish to return “some type” without specifying the exact type. As a simple example that we will use through the RFC, consider the <code>NewIntoIterator</code> trait, which is a variant of the existing <code>IntoIterator</code> that uses <code>impl Iterator</code> as the return type:</p>
<pre><code class="language-rust">trait NewIntoIterator {
    type Item;
    fn into_iter(self) -&gt; impl Iterator&lt;Item = Self::Item&gt;;
}</code></pre>
<h2 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h2>
<p><em>This section assumes familiarity with the <a href="https://rust-lang.github.io/impl-trait-initiative/explainer/rpit.html">basic semantics of impl trait in return position</a>.</em></p>
<p>When you use <code>impl Trait</code> as the return type for a function within a trait definition or trait impl, the intent is the same: impls that implement this trait return “some type that implements <code>Trait</code>”, and users of the trait can only rely on that.</p>
<!--However, the desugaring to achieve that effect looks somewhat different than other cases of impl trait in return position. This is because we cannot desugar to a type alias in the surrounding module; we need to desugar to an associated type (effectively, a type alias in the trait).-->
<p>Consider the following trait:</p>
<pre><code class="language-rust">trait IntoNumIterator {
    fn into_int_iter(self) -&gt; impl Iterator&lt;Item = u32&gt;;
}</code></pre>
<p>The semantics of this are analogous to introducing a new associated type within the surrounding trait;</p>
<pre><code class="language-rust">trait IntoNumIterator { // desugared
    type IntoNumIter: Iterator&lt;Item = u32&gt;;
    fn into_int_iter(self) -&gt; Self::IntoNumIter;
}</code></pre>
<p>When using <code>-&gt; impl Trait</code>, however, there is no associated type that users can name.</p>
<p>By default, the impl for a trait like <code>IntoNumIterator</code> must also use <code>impl Trait</code> in return position.</p>
<pre><code class="language-rust">impl IntoNumIterator for Vec&lt;u32&gt; {
    fn into_int_iter(self) -&gt; impl Iterator&lt;Item = u32&gt; {
        self.into_iter()
    }
}</code></pre>
<p>It can, however, give a more specific type with <code>#[refine]</code>:<sup class="footnote-reference" id="fr-refine-2"><a href="#footnote-refine">1</a></sup></p>
<pre><code class="language-rust">impl IntoNumIterator for Vec&lt;u32&gt; {
    #[refine]
    fn into_int_iter(self) -&gt; impl Iterator&lt;Item = u32&gt; + ExactSizeIterator {
        self.into_iter()
    }

    // ..or even..

    #[refine]
    fn into_int_iter(self) -&gt; std::vec::IntoIter&lt;u32&gt; {
        self.into_iter()
    }
}</code></pre>
<p>Users of this impl are then able to rely on the refined return type, as long as the compiler can prove this impl specifically is being used. Conversely, in this example, code that is generic over the trait can only rely on the fact that the return type implements <code>Iterator&lt;Item = u32&gt;</code>.</p>
<h3 id="async-fn-desugaring"><a class="header" href="#async-fn-desugaring">async fn desugaring</a></h3>
<p><code>async fn</code> always desugars to a regular function returning <code>-&gt; impl Future</code>. When used in a trait, the <code>async fn</code> syntax can be used interchangeably with the equivalent desugaring in the trait and trait impl:</p>
<pre><code class="language-rust">trait UsesAsyncFn {
    // Equivalent to:
    // fn do_something(&amp;self) -&gt; impl Future&lt;Output = ()&gt; + '_;
    async fn do_something(&amp;self);
}

// OK!
impl UsesAsyncFn for MyType {
    fn do_something(&amp;self) -&gt; impl Future&lt;Output = ()&gt; + '_ {
        async {}
    }
}</code></pre>
<pre><code class="language-rust">trait UsesDesugaredFn {
    // Equivalent to:
    // async fn do_something(&amp;self);
    fn do_something(&amp;self) -&gt; impl Future&lt;Output = ()&gt; + '_;
}

// Also OK!
impl UsesDesugaredFn for MyType {
    async fn do_something(&amp;self) {}
}</code></pre>
<h2 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h2>
<h3 id="equivalent-desugaring-for-traits"><a class="header" href="#equivalent-desugaring-for-traits">Equivalent desugaring for traits</a></h3>
<p>Each <code>-&gt; impl Trait</code> notation appearing in a trait fn return type is effectively desugared to an anonymous associated type. In this RFC, we will use the placeholder name <code>$</code> when illustrating desugarings and the like.</p>
<p>As a simple example, consider the following (more complex examples follow):</p>
<pre><code class="language-rust">trait NewIntoIterator {
    type Item;
    fn into_iter(self) -&gt; impl Iterator&lt;Item = Self::Item&gt;;
}

// becomes

trait NewIntoIterator {
    type Item;

    type $: Iterator&lt;Item = Self::Item&gt;;

    fn into_iter(self) -&gt; &lt;Self as NewIntoIterator&gt;::$;
}</code></pre>
<h3 id="equivalent-desugaring-for-trait-impls"><a class="header" href="#equivalent-desugaring-for-trait-impls">Equivalent desugaring for trait impls</a></h3>
<p>Each <code>impl Trait</code> notation appearing in a trait impl fn return type is desugared to the same anonymous associated type <code>$</code> defined in the trait along with a function that returns it. The value of this associated type <code>$</code> is an <code>impl Trait</code>.</p>
<pre><code class="language-rust">impl NewIntoIterator for Vec&lt;u32&gt; {
    type Item = u32;

    fn into_iter(self) -&gt; impl Iterator&lt;Item = Self::Item&gt; {
        self.into_iter()
    }
}

// becomes

impl NewIntoIterator for Vec&lt;u32&gt; {
    type Item = u32;

    type $ = impl Iterator&lt;Item = Self::Item&gt;;

    fn into_iter(self) -&gt; &lt;Self as NewIntoIterator&gt;::$ {
        self.into_iter()
    }
}</code></pre>
<p>The desugaring works the same for provided methods of traits.</p>
<h3 id="scoping-rules-for-generic-parameters"><a class="header" href="#scoping-rules-for-generic-parameters">Scoping rules for generic parameters</a></h3>
<p>We say a generic parameter is “in scope” for an <code>impl Trait</code> type if the actual revealed type is allowed to name that parameter. The scoping rules for return position <code>impl Trait</code> in traits are the same as <a href="https://rust-lang.github.io/rfcs/1951-expand-impl-trait.html#scoping-for-type-and-lifetime-parameters">those for return position <code>impl Trait</code> generally</a>: All type and const parameters are considered in-scope, while lifetime parameters are only considered in-scope if they are mentioned in the <code>impl Trait</code> type directly.</p>
<p>Formally, given a trait method with a return type like <code>-&gt; impl A + ... + Z</code> and an implementation of that trait, the hidden type for that implementation is allowed to reference:</p>
<ul>
<li>Concrete types, constant expressions, and <code>'static</code></li>
<li>Any generic type and const parameters in scope, including:
<ul>
<li>Type and const parameters on the impl</li>
<li>Explicit type and const parameters on the method</li>
<li>Implicit type parameters on the method (argument-position <code>impl Trait</code> types)</li>
</ul>
</li>
<li>Lifetime parameters that appear anywhere in the <code>impl A + ... + Z</code> type, including elided lifetimes</li>
</ul>
<p>Lifetime parameters not in scope may still be indirectly named by one of the type parameters in scope.</p>
<p><em>Note</em>: The term “captured” is sometimes used as an alternative to “in scope”.</p>
<p>When desugaring, captured parameters from the method are reflected as generic parameters on the <code>$</code> associated type. Furthermore, the <code>$</code> associated type brings whatever where clauses are declared on the method into scope, excepting those which reference parameters that are not captured.</p>
<p>This transformation is precisely the same as the one which is applied to other forms of <code>-&gt; impl Trait</code>, except that it applies to an associated type and not a top-level type alias.</p>
<p>Example:</p>
<pre><code class="language-rust">trait RefIterator for Vec&lt;u32&gt; {
    type Item&lt;'me&gt;
    where
        Self: 'me;

    fn iter&lt;'a&gt;(&amp;'a self) -&gt; impl Iterator&lt;Item = Self:Item&lt;'a&gt;&gt;;
}

// Since 'a is named in the bounds, it is captured.
// `RefIterator` thus becomes:

trait RefIterator for Vec&lt;u32&gt; {
    type Item&lt;'me&gt;
    where
        Self: 'me;

    type $&lt;'a&gt;: impl Iterator&lt;Item = Self::Item&lt;'a&gt;&gt;
    where
        Self: 'a; // Implied bound from fn

    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::$&lt;'a&gt;;
}</code></pre>
<h3 id="validity-constraint-on-impls"><a class="header" href="#validity-constraint-on-impls">Validity constraint on impls</a></h3>
<p>Given a trait method where <code>impl Trait</code> appears in return position,</p>
<pre><code class="language-rust">trait Trait {
    fn method() -&gt; impl T_0 + ... + T_m;
}</code></pre>
<p>where <code>T_0 + ... + T_m</code> are bounds, for any impl of that trait to be valid, the following conditions must hold:</p>
<ul>
<li>The return type named in the corresponding impl method must implement all bounds <code>T_0 + ... + T_m</code> specified in the trait.
<ul>
<li>This must be proven using only the information in the signature, with the exception that if the impl uses <code>impl Trait</code> syntax for the return type, the usual auto trait leakage rules apply.</li>
</ul>
</li>
<li>Either the impl method must have <code>#[refine]</code>,<sup class="footnote-reference" id="fr-refine-3"><a href="#footnote-refine">1</a></sup> OR
<ul>
<li>The impl must use <code>impl Trait</code> syntax to name the corresponding type, and</li>
<li>The return type in the trait must implement all bounds <code>I_0 + ... + I_n</code> specified in the impl return type. (Taken with the first outer bullet point, we can say that the bounds in the trait and the bounds in the impl imply each other.)</li>
</ul>
</li>
</ul>
<pre><code class="language-rust">trait NewIntoIterator {
    type Item;
    fn into_iter(self) -&gt; impl Iterator&lt;Item = Self::Item&gt;;
}

// OK:
impl NewIntoIterator for Vec&lt;u32&gt; {
    type Item = u32;
    fn into_iter(self) -&gt; impl Iterator&lt;Item = u32&gt; {
        self.into_iter()
    }
}

// OK:
impl NewIntoIterator for Vec&lt;u32&gt; {
    type Item = u32;
    #[refine]
    fn into_iter(self) -&gt; impl Iterator&lt;Item = u32&gt; + DoubleEndedIterator {
        self.into_iter()
    }
}

// OK:
impl NewIntoIterator for Vec&lt;u32&gt; {
    type Item = u32;
    #[refine]
    fn into_iter(self) -&gt; std::vec::IntoIter&lt;u32&gt; {
        self.into_iter()
    }
}

// Not OK (requires `#[refine]`):
impl NewIntoIterator for Vec&lt;u32&gt; {
    type Item = u32;
    fn into_iter(self) -&gt; std::vec::IntoIter&lt;u32&gt; {
        self.into_iter()
    }
}</code></pre>
<p>Additionally, using <code>-&gt; impl Trait</code> notation in an impl is only legal if the trait also uses that notation. Each occurrence of <code>impl Trait</code> in an impl must unify with an occurrence of <code>impl Trait</code> in the trait.</p>
<pre><code class="language-rust">trait Trait {
    fn foo() -&gt; i32;
    fn bar() -&gt; impl Sized;
}

impl Trait for () {
    // Not OK
    fn foo() -&gt; impl Sized { 0 }

    // Not OK
    fn bar() -&gt; Result&lt;impl Sized, impl Sized&gt; { Ok::&lt;(), ()&gt;(()) }
}</code></pre>
<p>An interesting consequence of auto trait leakage is that a trait is allowed to specify an auto trait in its return type bounds, but the impl does not have to <em>repeat</em> that auto trait in its signature, as long as its return type actually implements the required bound. For example:</p>
<pre><code class="language-rust">/// Converts `self` into an iterator that is always `Send`.
trait IntoSendIterator {
    type Item;
    fn into_iter(self) -&gt; impl Iterator&lt;Item = Self::Item&gt; + Send;
}

// OK (signatures match exactly):
impl IntoSendIterator for Vec&lt;u32&gt; {
    type Item = u32;
    fn into_iter(self) -&gt; impl Iterator&lt;Item = u32&gt; + Send {
        self.into_iter()
    }
}

// OK (auto traits leak, so adding `+ Send` here is NOT required):
impl IntoSendIterator for Vec&lt;u32&gt; {
    type Item = u32;
    fn into_iter(self) -&gt; impl Iterator&lt;Item = u32&gt; {
        self.into_iter()
    }
}

// OK:
impl&lt;T: Send&gt; IntoSendIterator for Vec&lt;T&gt; {
    //  ^^^^ Required for our iterator to be Send!
    type Item = T;
    fn into_iter(self) -&gt; impl Iterator&lt;Item = T&gt; {
        self.into_iter()
    }
}

// Not OK (returned iterator is not known to be `Send`):
impl&lt;T&gt; IntoSendIterator for Vec&lt;T&gt; {
    type Item = T;
    fn into_iter(self) -&gt; impl Iterator&lt;Item = T&gt; {
        self.into_iter()
    }
}</code></pre>
<h4 id="interaction-with-async-fn-in-trait"><a class="header" href="#interaction-with-async-fn-in-trait">Interaction with <code>async fn</code> in trait</a></h4>
<p>This RFC modifies the “Static async fn in traits” RFC so that async fn in traits may be satisfied by implementations that return <code>impl Future&lt;Output = ...&gt;</code> as long as the return-position impl trait type matches the async fn’s desugared impl trait with the same rules as above.</p>
<pre><code class="language-rust">trait Trait {
  async fn async_fn(&amp;self);

  async fn async_fn_refined(&amp;self);
}

impl Trait for MyType {
  fn async_fn(&amp;self) -&gt; impl Future&lt;Output = ()&gt; + '_ { .. }

  #[refine]
  fn async_fn_refined(&amp;self) -&gt; BoxFuture&lt;'_, ()&gt; { .. }
}</code></pre>
<p>Similarly, the equivalent <code>-&gt; impl Future</code> signature in a trait can be satisfied by using <code>async fn</code> in an impl of that trait.</p>
<h3 id="legal-positions-for-impl-trait-to-appear"><a class="header" href="#legal-positions-for-impl-trait-to-appear">Legal positions for <code>impl Trait</code> to appear</a></h3>
<p><code>impl Trait</code> can appear in the return type of a trait method in all the same positions as it can in a free function.</p>
<p>For example, return position impl trait in traits may be nested in associated types bounds:</p>
<pre><code class="language-rust">trait Nested {
    fn deref(&amp;self) -&gt; impl Deref&lt;Target = impl Display&gt; + '_;
}

// This desugars into:

trait Nested {
    type $1&lt;'a&gt;: Deref&lt;Target = Self::$2&gt; + 'a;

    type $2: Display;

    fn deref(&amp;self) -&gt; Self::$1&lt;'_&gt;;
}</code></pre>
<p>It may also be used in type argument position of a generic type, including tuples:</p>
<pre><code class="language-rust">trait Foo {
    fn bar(&amp;self) -&gt; (impl Debug, impl Debug);
}

// This desugars into:

trait Foo {
    type $1: Debug;
    type $2: Debug;

    fn bar(&amp;self) -&gt; (Self::$1, Self::$2);
}</code></pre>
<p>But following the same rules as the allowed positions for return-position impl trait, it is not allowed to be nested in trait generics:</p>
<pre><code class="language-rust">trait Nested {
    fn deref(&amp;self) -&gt; impl AsRef&lt;impl Sized&gt;; // ❌
}</code></pre>
<h3 id="dyn-safety"><a class="header" href="#dyn-safety">Dyn safety</a></h3>
<p>To start, traits that use <code>-&gt; impl Trait</code> will not be considered dyn safe, <em>unless the method has a <code>where Self: Sized</code> bound</em>. This is because dyn types currently require that all associated types are named, and the <code>$</code> type cannot be named. The other reason is that the value of <code>impl Trait</code> is often a type that is unique to a specific impl, so even if the <code>$</code> type <em>could</em> be named, specifying its value would defeat the purpose of the <code>dyn</code> type, since it would effectively identify the dynamic type.</p>
<p>On the other hand, if the method has a <code>where Self: Sized</code> bound, the method will not exist on <code>dyn Trait</code> and therefore there will be no type to name.</p>
<h4 id="dyn-safety-for-async-fn-in-trait"><a class="header" href="#dyn-safety-for-async-fn-in-trait">Dyn safety for <code>async fn</code> in trait</a></h4>
<p>This RFC modifies the “Static async fn in traits” RFC to allow traits with <code>async fn</code> to be dyn-safe if the method has a <code>where Self: Sized</code> bound. This is consistent with how <code>async fn foo()</code> desugars to <code>fn foo() -&gt; impl Future</code>.</p>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>This section discusses known drawbacks of the proposal as presently designed and (where applicable) plans for mitigating them in the future.</p>
<h3 id="cannot-migrate-off-of-impl-trait"><a class="header" href="#cannot-migrate-off-of-impl-trait">Cannot migrate off of impl Trait</a></h3>
<p>In this RFC, if you use <code>-&gt; impl Trait</code> in a trait definition, you cannot “migrate away” from that without changing all impls. In other words, we cannot evolve:</p>
<pre><code class="language-rust">trait NewIntoIterator {
    type Item;
    fn into_iter(self) -&gt; impl Iterator&lt;Item = Self::Item&gt;;
}</code></pre>
<p>into</p>
<pre><code class="language-rust">trait NewIntoIterator {
    type Item;
    type IntoIter: Iterator&lt;Item = Self::Item&gt;;
    fn into_iter(self) -&gt; Self::IntoIter;
}</code></pre>
<p>without breaking semver compatibility for your trait. The <a href="#future-possibilities">future possibilities</a> section discusses one way to resolve this, by permitting impls to elide the definition of associated types whose values can be inferred from a function return type.</p>
<h3 id="clients-of-the-trait-cannot-name-the-resulting-associated-type-limiting-extensibility"><a class="header" href="#clients-of-the-trait-cannot-name-the-resulting-associated-type-limiting-extensibility">Clients of the trait cannot name the resulting associated type, limiting extensibility</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/pull/3193#issuecomment-965505149">As @Gankra highlighted in a comment on a previous RFC</a>, the traditional <code>IntoIterator</code> trait permits clients of the trait to name the resulting iterator type and apply additional bounds:</p>
<pre><code class="language-rust">fn is_palindrome&lt;Iter, T&gt;(iterable: Iter) -&gt; bool
where
    Iter: IntoIterator&lt;Item = T&gt;,
    Iter::IntoIter: DoubleEndedIterator,
    T: Eq;</code></pre>
<p>The <code>NewIntoIterator</code> trait used as an example in this RFC, however, doesn’t support this kind of usage, because there is no way for users to name the <code>IntoIter</code> type (and, as discussed in the previous section, there is no way for users to migrate to a named associated type, either!). The same problem applies to async functions in traits, which sometimes wish to be able to <a href="https://rust-lang.github.io/async-fundamentals-initiative/evaluation/challenges/bounding_futures.html">add <code>Send</code> bounds to the resulting futures</a>.</p>
<p>The <a href="#future-possibilities">future possibilities</a> section discusses a planned extension to support naming the type returned by an impl trait, which could work to overcome this limitation for clients.</p>
<h3 id="difference-in-scoping-rules-from-async-fn"><a class="header" href="#difference-in-scoping-rules-from-async-fn">Difference in scoping rules from <code>async fn</code></a></h3>
<p><code>async fn</code> behaves <a href="https://doc.rust-lang.org/reference/items/functions.html#async-functions">slightly differently</a> than return-position <code>impl Trait</code> when it comes to the scoping rules defined above. It considers <em>all</em> lifetime parameters in-scope for the returned future.</p>
<p>In the case of there being one lifetime in scope (usually for <code>self</code>), the desugaring we’ve shown above is exactly equivalent:</p>
<pre><code class="language-rust">trait Trait {
    async fn async_fn(&amp;self);
}

impl Trait for MyType {
    fn async_fn(&amp;self) -&gt; impl Future&lt;Output = ()&gt; + '_ { .. }
}</code></pre>
<p>It’s worth taking a moment to discuss <em>why</em> this works. The <code>+ '_</code> syntax here does two things:</p>
<ol>
<li>It brings the lifetime of the <code>self</code> borrow into scope for the return type.</li>
<li>It promises that the return type will outlive the borrow of <code>self</code>.</li>
</ol>
<p>In reality, the second point is not part of the <code>async fn</code> desugaring, but it does not matter: We can already reason that because our return type has only one lifetime in scope, it must outlive that lifetime.<sup class="footnote-reference" id="fr-OutlivesProjectionComponents-1"><a href="#footnote-OutlivesProjectionComponents">2</a></sup></p>
<p>When there are multiple lifetimes however, writing an equivalent desugaring becomes awkward.</p>
<pre><code class="language-rust">trait Trait {
    async fn async_fn(&amp;self, num: &amp;u32);
}</code></pre>
<p>We might be tempted to add another outlives bound:</p>
<pre><code class="language-rust">impl Trait for MyType {
    fn async_fn&lt;'b&gt;(&amp;self, num: &amp;'b u32) -&gt; impl Future&lt;Output = ()&gt; + '_ + 'b { .. }
}</code></pre>
<p>But this signature actually promises <em>more</em> than the original trait does, and would require <code>#[refine]</code>. The <code>async fn</code> desugaring allows the returned future to name both lifetimes, but does not promise that it <em>outlives</em> both lifetimes.<sup class="footnote-reference" id="fr-intersection-1"><a href="#footnote-intersection">3</a></sup></p>
<p>One way to get around this is to “collapse” the lifetimes together:</p>
<pre><code class="language-rust">impl Trait for MyType {
    fn async_fn&lt;'a&gt;(&amp;'a self, num: &amp;'a u32) -&gt; impl Future&lt;Output = ()&gt; + 'a { .. }
}</code></pre>
<p>In most cases<sup class="footnote-reference" id="fr-lifetime-collapse-1"><a href="#footnote-lifetime-collapse">4</a></sup> the type system actually recognizes these signatures as equivalent. This means it should be possible to write this trait with RPITIT now and move to async fn in the future. In the general case where these are not equivalent, it is possible to write an equivalent desugaring with a bit of a hack:</p>
<pre><code class="language-rust">trait Trait {
    async fn async_fn(&amp;self, num_ref: &amp;mut &amp;u32);
    //                                     ^^^^
    // The lifetime of this inner reference is invariant!
}

impl Trait for MyType {
    // Let's say we do not want to use `async fn` here.
    // We cannot use the `+ 'a` syntax in this case,
    // so we use `Captures` to bring the lifetimes in scope.
    fn async_fn&lt;'a, 'b&gt;(&amp;'a self, num_ref: &amp;'a mut &amp;'b u32)
    -&gt; impl Future&lt;Output = ()&gt; + Captures&lt;(&amp;'a (), &amp;'b ())&gt; { .. }
}

trait Captures&lt;T&gt; {}
impl&lt;T, U&gt; Captures&lt;T&gt; for U {}</code></pre>
<p>Note that the <code>Captures</code> trait doesn’t promise anything at all; its sole purpose is to give you a place to name lifetime parameters you would like to be in scope for the return type.</p>
<p>This difference is pre-existing, but it’s worth highlighting in this RFC the implications for the adoption of this feature. If we stabilize this feature first, people will use it to emulate <code>async fn</code> in traits. Care will be needed not to create forward-compatibility hazards for traits that want to migrate to <code>async fn</code> later. The best strategy for someone in that situation might be to simulate such a migration with the nightly compiler.</p>
<p>We leave open the question of whether to stabilize these two features together. In the future we can provide a nicer syntax for dealing with these cases, or remove the difference in scoping rules altogether.</p>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<h3 id="does-auto-trait-leakage-still-occur-for---impl-trait-in-traits"><a class="header" href="#does-auto-trait-leakage-still-occur-for---impl-trait-in-traits">Does auto trait leakage still occur for <code>-&gt; impl Trait</code> in traits?</a></h3>
<p>Yes, so long as the compiler has enough type information to figure out which impl you are using. In other words, given a trait function <code>SomeTrait::foo</code>, if you invoke a function <code>&lt;T as SomeTrait&gt;::foo()</code> where the self type is some generic parameter <code>T</code>, then the compiler doesn’t really know what impl is being used, so no auto trait leakage can occur. But if you were to invoke <code>&lt;u32 as SomeTrait&gt;::foo()</code>, then the compiler could resolve to a specific impl, and hence a specific <a href="https://rust-lang.github.io/impl-trait-initiative/explainer/tait.html">impl trait type alias</a>, and auto trait leakage would occur as normal.</p>
<h3 id="can-traits-migrate-from-a-named-associated-type-to-impl-trait"><a class="header" href="#can-traits-migrate-from-a-named-associated-type-to-impl-trait">Can traits migrate from a named associated type to <code>impl Trait</code>?</a></h3>
<p>Not compatibly, no, because they would no longer have a named associated type. The “future directions” section discusses the possibility of allowing users to explicitly give a name for the associated type created, which would enable this use case.</p>
<h3 id="can-traits-migrate-from-impl-trait-to-a-named-associated-type"><a class="header" href="#can-traits-migrate-from-impl-trait-to-a-named-associated-type">Can traits migrate from <code>impl Trait</code> to a named associated type?</a></h3>
<p>Generally yes, but all impls would have to be rewritten to include the definition of the associated type. In many cases, some form of type-alias impl trait (or impl trait in associated type values) would also be required.</p>
<p>For example, if we changed the <code>IntoNumIterator</code> trait from the motivation to use an explicit associated type..</p>
<pre><code class="language-rust">trait IntoNumIterator {
    type IntIter: Iterator&lt;Item = u32&gt;;
    fn into_iter(self) -&gt; Self::IntIter;
}</code></pre>
<p>…then impls like…</p>
<pre><code class="language-rust">impl IntoNumIterator for MyType {
    fn into_int_iter(self) -&gt; impl Iterator&lt;Item = u32&gt; {
        (0..self.len()).map(|x| x * 2)
    }
}</code></pre>
<p>…would no longer compile, because they are not specifying the value of the <code>IntIter</code> associated type. Moreover, the value for this type would be impossible to express without <code>impl Trait</code> notation, as it embeds a closure type.</p>
<h3 id="would-there-be-any-way-to-make-it-possible-to-migrate-from-impl-trait-to-a-named-associated-type-compatibly"><a class="header" href="#would-there-be-any-way-to-make-it-possible-to-migrate-from-impl-trait-to-a-named-associated-type-compatibly">Would there be any way to make it possible to migrate from <code>impl Trait</code> to a named associated type compatibly?</a></h3>
<p>Potentially! There have been proposals to allow the values of associated types that appear in function return types to be inferred from the function declaration. So, using the example from the previous question, the impl for <code>IntoNumIterator</code> could infer the value of <code>IntIter</code> based on the return type of <code>into_int_iter</code>. This may be a good idea, but it is not proposed as part of this RFC.</p>
<h3 id="what-about-using-an-implicitly-defined-associated-type"><a class="header" href="#what-about-using-an-implicitly-defined-associated-type">What about using an implicitly-defined associated type?</a></h3>
<p>One alternative under consideration was to use a named associated type instead of the anonymous <code>$</code> type. The name could be derived by converting “snake case” methods to “camel case”, for example. This has the advantage that users of the trait can refer to the return type by name.</p>
<p>We decided against this proposal:</p>
<ul>
<li>Introducing a name by converting to camel-case feels surprising and inelegant.</li>
<li>Return position impl Trait in other kinds of functions doesn’t introduce any sort of name for the return type, so it is not analogous.</li>
<li>We would like to allow <code>-&gt; impl Trait</code> methods to work with dynamic dispatch (see <a href="#future-possibilities">Future possibilities</a>). <code>dyn</code> types typically require naming all associated types of a trait. That would not be desirable for this feature, and these associated types would therefore not be consistent with other named associated types.</li>
</ul>
<p>There is a need to introduce a mechanism for naming the return type for functions that use <code>-&gt; impl Trait</code>; we plan to introduce a second RFC addressing this need uniformly across all kinds of functions.</p>
<p>As a backwards compatibility note, named associated types could likely be introduced later, although there is always the possibility of users having introduced associated types with the same name.</p>
<h3 id="what-about-using-a-normal-associated-type"><a class="header" href="#what-about-using-a-normal-associated-type">What about using a normal associated type?</a></h3>
<p>Giving users the ability to write an explicit <code>type Foo = impl Bar;</code> is already covered as part of the <code>type_alias_impl_trait</code> feature, which is not yet stable at the time of writing, and which represents an extension to the Rust language both inside and outside of traits. This RFC is about making trait methods consistent with normal free functions and inherent methods.</p>
<p>There are different situations where you would want to use an explicit associated type:</p>
<ol>
<li>The type is central to the trait and deserves to be named.</li>
<li>You want to give users the ability to use concrete types without <code>#[refine]</code>.</li>
<li>You want to give generic users of your trait the ability specify a particular type, instead of just bounding it.</li>
<li>You want to give users the ability to easily name and bound the type without using (to-be-RFC’d) special syntax to name the type.</li>
<li>You want the trait to work with dynamic dispatch today.</li>
<li>In the future, you want the associated type to be specified as part of <code>dyn Trait</code>, instead of using dynamic dispatch itself.</li>
</ol>
<p>Using our hypothetical <code>NewIntoIterator</code> example, most of these are not met for the <code>IntoIter</code> type:</p>
<ol>
<li>While the <code>Item</code> type is pretty central to users of the trait, the specific iterator type <code>IntoIter</code> is usually not.</li>
<li>The concrete type of an impl may or may not be useful, but usually what’s important is the specific extra bounds like <code>ExactSizeIterator</code> that a user can use. Using <code>#[refine]</code> to explicitly choose to expose this (or a fully concrete type) is not overly burdensome.</li>
<li>Rarely does a function taking <code>impl IntoIterator</code> specify a particular iterator type; it would be rare to see a function like this, for example:
<pre><code class="language-rust">fn iterate_over_anything_as_long_as_it_is_vec&lt;T&gt;(
    vec: impl IntoIterator&lt;IntoIter = std::vec::IntoIter&lt;T&gt;, Item = T&gt;
)</code></pre>
</li>
<li>Bounding the iterator by adding extra bounds like <code>DoubleEndedIterator</code> is useful, but not the common case for <code>IntoIterator</code>. It therefore shouldn’t be overly burdensome to use a (reasonably ergonomic) special syntax in the cases where it’s needed.</li>
<li>Using <code>IntoIterator</code> with dynamic dispatch would be surprising; more common would be to call <code>.into_iter()</code> using static dispatch and then pass the resulting iterator to a function that uses dynamic dispatch.</li>
<li>If we did use <code>IntoIterator</code> with dynamic dispatch, the resulting iterator being dynamically dispatched would make the most sense.</li>
</ol>
<p>Therefore, if we were writing <code>IntoIterator</code> today, it would probably use <code>-&gt; impl Trait</code> in return position instead of having an explicit <code>IntoIter</code> type.</p>
<p>The same is not true for <code>Iterator::Item</code>: because <code>Item</code> is so central to what an <code>Iterator</code> is, and because it rarely makes sense to use an opaque type for the item, it would remain an explicit associated type.</p>
<h2 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h2>
<h3 id="should-library-traits-migrate-to-use-impl-trait"><a class="header" href="#should-library-traits-migrate-to-use-impl-trait">Should library traits migrate to use <code>impl Trait</code>?</a></h3>
<p>Potentially, but not necessarily. Using <code>impl Trait</code> in traits imposes some limitations on generic code referencing those traits. While <code>impl Trait </code>desugars internally to an associated type, that associated type is anonymous and cannot be directly referenced by users, which prevents them from putting bounds on it or naming it for use in struct declarations. This is similar to <code>-&gt; impl Trait</code> in free and inherent functions, which also returns an anonymous type that cannot be directly named. Just as in those cases, this likely means that widely used libraries should avoid the use of <code>-&gt; impl Trait</code> and prefer to use an explicit named associated type, at least until some of the “future possibilities” are completed. However, this decision is best reached on a case-by-case basis: the real question is whether the bounds named in the trait will be sufficient, or whether users will wish to put additional bounds. In a trait like <code>IntoIterator</code>, for example, it is common to wish to bound the resulting iterator with additional traits, like <code>ExactLenIterator</code>. But given a trait that returns <code>-&gt; impl Debug</code>, this concern may not apply.
[prior-art]: #prior-art</p>
<p>There are a number of crates that do desugaring like this manually or with procedural macros. One notable example is <a href="https://crates.io/crates/real-async-trait">real-async-trait</a>.</p>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<ul>
<li>Should we stabilize this feature together with <code>async fn</code> to mitigate hazards of writing a trait that is not forwards-compatible with its desugaring? (See <a href="#drawbacks">drawbacks</a>.)</li>
<li>Resolution of <a href="https://github.com/rust-lang/rust/issues/112194">#112194: RPITIT is allowed to name any in-scope lifetime parameter, unlike inherent RPIT methods</a></li>
<li>Should we limit the legal positions for <code>impl Trait</code> to positions that are nameable using upcoming features like return-type notation (RTN)? (See <a href="https://github.com/rust-lang/rfcs/pull/3425#pullrequestreview-1467880633">this comment</a> for an example.)</li>
</ul>
<h2 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h2>
<h3 id="naming-return-types"><a class="header" href="#naming-return-types">Naming return types</a></h3>
<p>This RFC does not include a way for generic code to name or bound the result of <code>-&gt; impl Trait</code> return types. This means, for example, that for the <code>IntoNumIterator</code> trait introduced in the motivation, it is not possible to write a function that takes a <code>T: IntoNumIterator</code> which returns an <code>ExactLenIterator</code>; for async functions, the most common time this comes up is code that wishes to take an async function that returns a <code>Send</code> future. We expect future RFCs will address these use cases.</p>
<h3 id="dynamic-dispatch"><a class="header" href="#dynamic-dispatch">Dynamic dispatch</a></h3>
<p>Similarly, we expect to introduce language extensions to address the inability to use <code>-&gt; impl Trait</code> types with dynamic dispatch. These mechanisms are needed for async fn as well. A good writeup of the challenges can be found on the “challenges” page of the <a href="https://rust-lang.github.io/async-fundamentals-initiative/evaluation/challenges/dyn_traits.html">async fundamentals initiative</a>.</p>
<h3 id="migration-to-associated-type"><a class="header" href="#migration-to-associated-type">Migration to associated type</a></h3>
<p>It would be possible to introduce a mechanism that allows users to migrate from an <code>impl Trait</code> to a named associated type.</p>
<p>Existing users of the trait won’t specify an associated type bound for the new associated type, nor will existing implementers of the trait specify the type. This can be fixed with <a href="https://github.com/rust-lang/rfcs/blob/master/text/2532-associated-type-defaults.md">associated type defaults</a>. So given a trait like <code>NewIntoIterator</code>, we could choose to introduce an associated type for the iterator like so:</p>
<pre><code class="language-rust">// Now old again!
trait NewIntoIterator {
    type Item;
    type IntoIter = impl Iterator&lt;Item = Self::Item&gt;;
    fn into_iter(self) -&gt; Self::IntoIter;
}</code></pre>
<p>The only problem remaining is with <code>#[refine]</code>. If an existing implementation refined its return value of an RPITIT method, we would need the existing <code>#[refine]</code> attribute to stand in for an overriding of the associated type default.</p>
<p>Whatever rules we decide to make this work, they will interact with some ongoing discussions of proposals for <code>#[defines]</code> or <code>#[defined_by]</code> attributes on <code>type_alias_impl_trait</code>. We therefore leave the details of this to a future RFC.</p>
<h3 id="adding-new-occurrences-of-impl-trait-in-refinements"><a class="header" href="#adding-new-occurrences-of-impl-trait-in-refinements">Adding new occurrences of <code>impl Trait</code> in refinements</a></h3>
<p>We may want to allow the following pattern:</p>
<pre><code class="language-rust">trait Trait {
    fn test() -&gt; impl Sized;
}

impl Trait for () {
    #[refine]
    fn test() -&gt; Result&lt;impl Sized, impl Sized&gt; { Ok::&lt;(), ()&gt;(()) }
}</code></pre>
<p>Then uses of <code>impl Trait</code> in a trait impl would not necessarily correspond to a use of <code>impl Trait</code> in the trait.</p>
<hr>
<ol class="footnote-definition">
<li id="footnote-refine">
<p><code>#[refine]</code> was added in <a href="https://rust-lang.github.io/rfcs/3245-refined-impls.html">RFC 3245: Refined trait implementations</a>. This feature is not yet stable. Examples in this RFC requiring the use of <code>#[refine]</code> will not work until that feature is stabilized. <a href="#fr-refine-1">↩</a> <a href="#fr-refine-2">↩2</a> <a href="#fr-refine-3">↩3</a></p>
</li>
<li id="footnote-OutlivesProjectionComponents">
<p>After all, the return type cannot possibly reference any lifetimes <em>shorter</em> than the one lifetime it is allowed to reference. This behavior is specified as the rule <code>OutlivesProjectionComponents</code> in <a href="https://rust-lang.github.io/rfcs/1214-projections-lifetimes-and-wf.html#outlives-for-projections">RFC 1214</a>. Note that it only works when there are no type parameters in scope. <a href="#fr-OutlivesProjectionComponents-1">↩</a></p>
</li>
<li id="footnote-intersection">
<p>Technically speaking, we can reason that the returned future outlives the <em>intersection</em> of all named lifetimes. In other words, when all lifetimes the future is allowed to name are valid, we can reason that the future must also be valid. But at the time of this RFC, Rust has no syntax for intersection lifetimes. <a href="#fr-intersection-1">↩</a></p>
</li>
<li id="footnote-lifetime-collapse">
<p>Both lifetimes must be <a href="https://rust-lang.github.io/rfcs/0387-higher-ranked-trait-bounds.html#distinguishing-early-vs-late-bound-lifetimes-in-impls">late-bound</a> and the type checker must be able to pick a lifetime that is the intersection of all input lifetimes, which is the case when either both are <a href="https://doc.rust-lang.org/reference/subtyping.html#variance">covariant</a> or both are contravariant. The reason for this is described in more detail in <a href="https://github.com/rust-lang/rust/issues/32330#issuecomment-202536977">this comment</a>. In practice the equivalence can be checked <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=56faadfc236bb9acfb4af1b51a214a79">using the compiler</a>. (Note that at the time of writing, a bug in the nightly compiler prevents it from accepting the example.) <a href="#fr-lifetime-collapse-1">↩</a></p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="3424-cargo-script.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="3453-f16-and-f128.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="3424-cargo-script.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="3453-f16-and-f128.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
