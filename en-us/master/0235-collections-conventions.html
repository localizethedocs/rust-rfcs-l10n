<!DOCTYPE HTML>
<html lang="en_US" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>0235-collections-conventions - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-0060737d.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Start Date: 2014-10-29</li>
<li>RFC PR #: <a href="https://github.com/rust-lang/rfcs/pull/235">rust-lang/rfcs#235</a></li>
<li>Rust Issue #: <a href="https://github.com/rust-lang/rust/issues/18424">rust-lang/rust#18424</a></li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This is a combined <em>conventions</em> and <em>library stabilization</em> RFC. The goal is to
establish a set of naming and signature conventions for <code>std::collections</code>.</p>
<p>The major components of the RFC include:</p>
<ul>
<li>
<p>Removing most of the traits in <code>collections</code>.</p>
</li>
<li>
<p>A general proposal for solving the “equiv” problem, as well as improving
<code>MaybeOwned</code>.</p>
</li>
<li>
<p>Patterns for overloading on by-need values and predicates.</p>
</li>
<li>
<p>Initial, forwards-compatible steps toward <code>Iterable</code>.</p>
</li>
<li>
<p>A coherent set of API conventions across the full variety of collections.</p>
</li>
</ul>
<p><em>A big thank-you to @Gankro, who helped collect API information and worked
through an initial pass of some of the proposals here.</em></p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>This RFC aims to improve the design of the <code>std::collections</code> module in
preparation for API stabilization. There are a number of problems that need to
be addressed, as spelled out in the subsections below.</p>
<h3 id="collection-traits"><a class="header" href="#collection-traits">Collection traits</a></h3>
<p>The <code>collections</code> module defines several traits:</p>
<ul>
<li>Collection</li>
<li>Mutable</li>
<li>MutableSeq</li>
<li>Deque</li>
<li>Map, MutableMap</li>
<li>Set, MutableSet</li>
</ul>
<p>There are several problems with the current trait design:</p>
<ul>
<li>
<p>Most important: the traits do not provide iterator methods like <code>iter</code>. It is
not possible to do so in a clean way without higher-kinded types, as the RFC
explains in more detail below.</p>
</li>
<li>
<p>The split between mutable and immutable traits is not well-motivated by
any of the existing collections.</p>
</li>
<li>
<p>The methods defined in these traits are somewhat anemic compared to the suite
of methods provided on the concrete collections that implement them.</p>
</li>
</ul>
<h3 id="divergent-apis"><a class="header" href="#divergent-apis">Divergent APIs</a></h3>
<p>Despite the current collection traits, the APIs of various concrete collections
has diverged; there is not a globally coherent design, and there are many
inconsistencies.</p>
<p>One problem in particular is the lack of clear guiding principles for the API
design. This RFC proposes a few along the way.</p>
<h3 id="providing-slice-apis-on-vec-and-string"><a class="header" href="#providing-slice-apis-on-vec-and-string">Providing slice APIs on <code>Vec</code> and <code>String</code></a></h3>
<p>The <code>String</code> and <code>Vec</code> types each provide a limited subset of the methods
provides on string and vector slices, but there is not a clear reason to limit
the API in this way. Today, one has to write things like
<code>some_str.as_slice().contains(...)</code>, which is not ergonomic or intuitive.</p>
<h3 id="the-equiv-problem"><a class="header" href="#the-equiv-problem">The <code>Equiv</code> problem</a></h3>
<p>There is a more subtle problem related to slices. It’s common to use a <code>HashMap</code>
with owned <code>String</code> keys, but then the natural API for things like lookup is not
very usable:</p>
<pre><code class="language-rust">fn find(&amp;self, k: &amp;K) -&gt; Option&lt;&amp;V&gt;</code></pre>
<p>The problem is that, since <code>K</code> will be <code>String</code>, the <code>find</code> function requests a
<code>&amp;String</code> value – whereas one typically wants to work with the more flexible
<code>&amp;str</code> slices. In particular, using <code>find</code> with a literal string requires
something like:</p>
<pre><code class="language-rust">map.find(&amp;"some literal".to_string())</code></pre>
<p>which is unergonomic and requires an extra allocation just to get a borrow that,
in some sense, was already available.</p>
<p>The current <code>HashMap</code> API works around this problem by providing an <em>additional</em>
set of methods that uses a generic notion of “equivalence” of values that have
different types:</p>
<pre><code class="language-rust">pub trait Equiv&lt;T&gt; {
    fn equiv(&amp;self, other: &amp;T) -&gt; bool;
}

impl Equiv&lt;str&gt; for String {
    fn equiv(&amp;self, other: &amp;str) -&gt; bool {
        self.as_slice() == other
    }
}

fn find_equiv&lt;Q: Hash&lt;S&gt; + Equiv&lt;K&gt;&gt;(&amp;self, k: &amp;Q) -&gt; Option&lt;&amp;V&gt;</code></pre>
<p>There are a few downsides to this approach:</p>
<ul>
<li>
<p>It requires a duplicated <code>_equiv</code> variant of each method taking a reference to
the key. (This downside could likely be mitigated using
<a href="https://github.com/rust-lang/rfcs/pull/195">multidispatch</a>.)</p>
</li>
<li>
<p>Its correctness depends on equivalent values producing the same hash, which is
not checked.</p>
</li>
<li>
<p><code>String</code>-keyed hash maps are very common, so newcomers are likely to run
headlong into the problem. First, <code>find</code> will fail to work in the expected
way. But the signature of <code>find_equiv</code> is more difficult to understand than
<code>find</code>, and it it’s not immediately obvious that it solves the problem.</p>
</li>
<li>
<p>It is the right API for <code>HashMap</code>, but not helpful for e.g. <code>TreeMap</code>, which
would want an analog for <code>Ord</code>.</p>
</li>
</ul>
<p>The <code>TreeMap</code> API currently deals with this problem in an entirely different
way:</p>
<pre><code class="language-rust">/// Returns the value for which f(key) returns Equal.
/// f is invoked with current key and guides tree navigation.
/// That means f should be aware of natural ordering of the tree.
fn find_with(&amp;self, f: |&amp;K| -&gt; Ordering) -&gt; Option&lt;&amp;V&gt;</code></pre>
<p>Besides being less convenient – you cannot write <code>map.find_with("some literal")</code> –
this function navigates the tree according to an ordering that may have no
relationship to the actual ordering of the tree.</p>
<h3 id="maybeowned"><a class="header" href="#maybeowned"><code>MaybeOwned</code></a></h3>
<p>Sometimes a function does not know in advance whether it will need or produce an
owned copy of some data, or whether a borrow suffices. A typical example is the
<code>from_utf8_lossy</code> function:</p>
<pre><code class="language-rust">fn from_utf8_lossy&lt;'a&gt;(v: &amp;'a [u8]) -&gt; MaybeOwned&lt;'a&gt;</code></pre>
<p>This function will return a string slice if the input was correctly utf8 encoded
– without any allocation. But if the input has invalid utf8 characters, the
function allocates a new <code>String</code> and inserts utf8 “replacement characters”
instead. Hence, the return type is an <code>enum</code>:</p>
<pre><code class="language-rust">pub enum MaybeOwned&lt;'a&gt; {
    Slice(&amp;'a str),
    Owned(String),
}</code></pre>
<p>This interface makes it possible to allocate only when necessary, but the
<code>MaybeOwned</code> type (and connected machinery) are somewhat ad hoc – and
specialized to <code>String</code>/<code>str</code>. It would be somewhat more palatable if there were
a single “maybe owned” abstraction usable across a wide range of types.</p>
<h3 id="iterable"><a class="header" href="#iterable"><code>Iterable</code></a></h3>
<p>A frequently-requested feature for the <code>collections</code> module is an <code>Iterable</code>
trait for “values that can be iterated over”. There are two main motivations:</p>
<ul>
<li>
<p><em>Abstraction</em>. Today, you can write a function that takes a single <code>Iterator</code>,
but you cannot write a function that takes a container and then iterates over
it multiple times (perhaps with differing mutability levels). An <code>Iterable</code>
trait could allow that.</p>
</li>
<li>
<p><em>Ergonomics</em>. You’d be able to write</p>
<pre><code class="language-rust">for v in some_vec { ... }</code></pre>
<p>rather than</p>
<pre><code class="language-rust">for v in some_vec.iter() { ... }</code></pre>
<p>and <code>consume_iter(some_vec)</code> rather than <code>consume_iter(some_vec.iter())</code>.</p>
</li>
</ul>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed design</a></h2>
<h3 id="the-collections-today"><a class="header" href="#the-collections-today">The collections today</a></h3>
<p>The concrete collections currently available in <code>std</code> fall into roughly three categories:</p>
<ul>
<li>
<p>Sequences</p>
<ul>
<li>Vec</li>
<li>String</li>
<li>Slices</li>
<li>Bitv</li>
<li>DList</li>
<li>RingBuf</li>
<li>PriorityQueue</li>
</ul>
</li>
<li>
<p>Sets</p>
<ul>
<li>HashSet</li>
<li>TreeSet</li>
<li>TrieSet</li>
<li>EnumSet</li>
<li>BitvSet</li>
</ul>
</li>
<li>
<p>Maps</p>
<ul>
<li>HashMap</li>
<li>TreeMap</li>
<li>TrieMap</li>
<li>LruCache</li>
<li>SmallIntMap</li>
</ul>
</li>
</ul>
<p>The primary goal of this RFC is to establish clean and consistent APIs that
apply across each group of collections.</p>
<p>Before diving into the details, there is one high-level changes that should be
made to these collections. The <code>PriorityQueue</code> collection should be renamed to
<code>BinaryHeap</code>, following the convention that concrete collections are named according
to their implementation strategy, not the abstract semantics they implement. We
may eventually want <code>PriorityQueue</code> to be a <em>trait</em> that’s implemented by
multiple concrete collections.</p>
<p>The <code>LruCache</code> could be renamed for a similar reason (it uses a <code>HashMap</code> in its
implementation), However, the implementation is actually generic with respect to
this underlying map, and so in the long run (with HKT and other language
changes) <code>LruCache</code> should probably add a type parameter for the underlying map,
defaulted to <code>HashMap</code>.</p>
<h3 id="design-principles"><a class="header" href="#design-principles">Design principles</a></h3>
<ul>
<li>
<p><em>Centering on <code>Iterator</code>s</em>. The <code>Iterator</code> trait is a strength of Rust’s
collections library. Because so many APIs can produce iterators, adding an API
that consumes one is very powerful – and conversely as well.  Moreover,
iterators are highly efficient, since you can chain several layers of
modification without having to materialize intermediate results.  Thus,
whenever possible, collection APIs should strive to work with iterators.</p>
<p>In particular, some existing convenience methods avoid iterators for either
performance or ergonomic reasons. We should instead improve the ergonomics and
performance of iterators, so that these extra convenience methods are not
necessary and so that <em>all</em> collections can benefit.</p>
</li>
<li>
<p><em>Minimizing method variants</em>. One problem with some of the current collection
APIs is the proliferation of method variants. For example, <code>HashMap</code> include
<em>seven</em> methods that begin with the name <code>find</code>! While each method has a
motivation, the API as a whole can be bewildering, especially to newcomers.</p>
<p>When possible, we should leverage the trait system, or find other
abstractions, to reduce the need for method variants while retaining their
ergonomics and power.</p>
</li>
<li>
<p><em>Conservatism</em>. It is easier to add APIs than to take them away.  This RFC
takes a fairly conservative stance on what should be included in the
collections APIs. In general, APIs should be very clearly motivated by a wide
variety of use cases, either for expressiveness, performance, or ergonomics.</p>
</li>
</ul>
<h3 id="removing-the-traits"><a class="header" href="#removing-the-traits">Removing the traits</a></h3>
<p>This RFC proposes a somewhat radical step for the collections traits: rather
than reform them, we should eliminate them altogether – <em>for now</em>.</p>
<p>Unlike inherent methods, which can easily be added and deprecated over time, a
trait is “forever”: there are very few backwards-compatible modifications to
traits. Thus, for something as fundamental as collections, it is prudent to take
our time to get the traits right.</p>
<h4 id="lack-of-iterator-methods"><a class="header" href="#lack-of-iterator-methods">Lack of iterator methods</a></h4>
<p>In particular, there is one way in which the current traits are clearly <em>wrong</em>:
they do not provide standard methods like <code>iter</code>, despite these being
fundamental to working with collections in Rust. Sadly, this gap is due to
inexpressiveness in the language, which makes directly defining iterator methods
in a trait impossible:</p>
<pre><code class="language-rust">trait Iter {
    type A;
    type I: Iterator&lt;&amp;'a A&gt;;    // what is the lifetime here?
    fn iter&lt;'a&gt;(&amp;'a self) -&gt; I; // and how to connect it to self?
}</code></pre>
<p>The problem is that, when implementing this trait, the return type <code>I</code> of <code>iter</code>
should depend on the <em>lifetime</em> of self. For example, the corresponding
method in <code>Vec</code> looks like the following:</p>
<pre><code class="language-rust">impl&lt;T&gt; Vec&lt;T&gt; {
    fn iter(&amp;'a self) -&gt; Items&lt;'a, T&gt; { ... }
}</code></pre>
<p>This means that, given a <code>Vec&lt;T&gt;</code>, there isn’t a <em>single</em> type <code>Items&lt;T&gt;</code> for
iteration – rather, there is a <em>family</em> of types, one for each input lifetime.
In other words, the associated type <code>I</code> in the <code>Iter</code> needs to be
“higher-kinded”: not just a single type, but rather a family:</p>
<pre><code class="language-rust">trait Iter {
    type A;
    type I&lt;'a&gt;: Iterator&lt;&amp;'a A&gt;;
    fn iter&lt;'a&gt;(&amp;self) -&gt; I&lt;'a&gt;;
}</code></pre>
<p>In this case, <code>I</code> is parameterized by a lifetime, but in other cases (like
<code>map</code>) an associated type needs to be parameterized by a type.</p>
<p>In general, such higher-kinded types (HKTs) are a much-requested feature for
Rust. But the design and implementation of higher-kinded types is, by itself, a
significant investment.</p>
<p>HKT would also allow for parameterization over smart pointer types, which has
many potential use cases in the context of collections.</p>
<p>Thus, the goal in this RFC is to do the best we can without HKT <em>for now</em>,
while allowing a graceful migration if or when HKT is added.</p>
<h4 id="persistentimmutable-collections"><a class="header" href="#persistentimmutable-collections">Persistent/immutable collections</a></h4>
<p>Another problem with the current collection traits is the split between
immutable and mutable versions. In the long run, we will probably want to
provide <em>persistent</em> collections (which allow non-destructive “updates” that
create new collections that share most of their data with the old ones).</p>
<p>However, persistent collection APIs have not been thoroughly explored in Rust;
it would be hasty to standardize on a set of traits until we have more
experience.</p>
<h4 id="downsides-of-removal"><a class="header" href="#downsides-of-removal">Downsides of removal</a></h4>
<p>There are two main downsides to removing the traits without a replacement:</p>
<ol>
<li>
<p>It becomes impossible to write code using generics over a “kind” of
collection (like <code>Map</code>).</p>
</li>
<li>
<p>It becomes more difficult to ensure that the collections share a common API.</p>
</li>
</ol>
<p>For point (1), first, if the APIs are sufficiently consistent it should be
possible to transition code from e.g. a <code>TreeMap</code> to a <code>HashMap</code> by changing
very few lines of code. Second, generic programming is currently quite limited,
given the inability to iterate. Finally, generic programming over collections is
a large design space (with much precedent in C++, for example), and we should
take our time and gain more experience with a variety of concrete collections
before settling on a design.</p>
<p>For point (2), first, the current traits have failed to keep the APIs in line,
as we will see below. Second, this RFC is the antidote: we establish a clear set
of conventions and APIs for concrete collections up front, and stabilize on
those, which should make it easy to add traits later on.</p>
<h4 id="why-not-leave-the-traits-as-experimental"><a class="header" href="#why-not-leave-the-traits-as-experimental">Why not leave the traits as “experimental”?</a></h4>
<p>An alternative to removal would be to leave the traits intact, but marked as
experimental, with the intent to radically change them later.</p>
<p>Such a strategy doesn’t buy much relative to removal (given the arguments
above), but risks the traits becoming “de facto” stable if people begin using
them en masse.</p>
<h3 id="solving-the-_equiv-and-maybeowned-problems"><a class="header" href="#solving-the-_equiv-and-maybeowned-problems">Solving the <code>_equiv</code> and <code>MaybeOwned</code> problems</a></h3>
<p>The basic problem that leads to <code>_equiv</code> methods is that:</p>
<ul>
<li><code>&amp;String</code> and <code>&amp;str</code> are not the same type.</li>
<li>The <code>&amp;str</code> type is more flexible and hence more widely used.</li>
<li>Code written for a generic type <code>T</code> that takes a reference <code>&amp;T</code> will therefore
not be suitable when <code>T</code> is instantiated with <code>String</code>.</li>
</ul>
<p>A similar story plays out for <code>&amp;Vec&lt;T&gt;</code> and <code>&amp;[T]</code>, and with DST and custom
slice types the same problem will arise elsewhere.</p>
<h4 id="the-borrow-trait"><a class="header" href="#the-borrow-trait">The <code>Borrow</code> trait</a></h4>
<p>This RFC proposes to use a <em>trait</em>, <code>Borrow</code> to connect borrowed and owned data
in a generic fashion:</p>
<pre><code class="language-rust">/// A trait for borrowing.
trait Borrow&lt;Sized? B&gt; {
    /// Immutably borrow from an owned value.
    fn borrow(&amp;self) -&gt; &amp;B;

    /// Mutably borrow from an owned value.
    fn borrow_mut(&amp;mut self) -&gt; &amp;mut B;
}

// The Sized bound means that this impl does not overlap with the impls below.
impl&lt;T: Sized&gt; Borrow&lt;T&gt; for T {
    fn borrow(a: &amp;T) -&gt; &amp;T {
        a
    }
    fn borrow_mut(a: &amp;mut T) -&gt; &amp;mut T {
        a
    }
}

impl Borrow&lt;str&gt; for String {
    fn borrow(s: &amp;String) -&gt; &amp;str {
        s.as_slice()
    }
    fn borrow_mut(s: &amp;mut String) -&gt; &amp;mut str {
        s.as_mut_slice()
    }
}

impl&lt;T&gt; Borrow&lt;[T]&gt; for Vec&lt;T&gt; {
    fn borrow(s: &amp;Vec&lt;T&gt;) -&gt; &amp;[T] {
        s.as_slice()
    }
    fn borrow_mut(s: &amp;mut Vec&lt;T&gt;) -&gt; &amp;mut [T] {
        s.as_mut_slice()
    }
}</code></pre>
<p><em>(Note: thanks to @epdtry for <a href="https://github.com/rust-lang/rfcs/pull/235#issuecomment-55337168">suggesting this variation</a>! The original proposal
is listed <a href="#variants-of-borrow">in the Alternatives</a>.)</em></p>
<p>A primary goal of the design is allowing a <em>blanket</em> <code>impl</code> for non-sliceable
types (the first <code>impl</code> above). This blanket <code>impl</code> ensures that all new sized,
cloneable types are automatically borrowable; new <code>impl</code>s are required only for
new <em>unsized</em> types, which are rare. The <code>Sized</code> bound on the initial impl means
that we can freely add impls for unsized types (like <code>str</code> and <code>[T]</code>) without
running afoul of coherence.</p>
<p>Because of the blanket <code>impl</code>, the <code>Borrow</code> trait can largely be ignored except
when it is actually used – which we describe next.</p>
<h4 id="using-borrow-to-replace-_equiv-methods"><a class="header" href="#using-borrow-to-replace-_equiv-methods">Using <code>Borrow</code> to replace <code>_equiv</code> methods</a></h4>
<p>With the <code>Borrow</code> trait in place, we can eliminate the <code>_equiv</code> method variants
by asking map keys to be <code>Borrow</code>:</p>
<pre><code class="language-rust">impl&lt;K,V&gt; HashMap&lt;K,V&gt; where K: Hash + Eq {
    fn find&lt;Q&gt;(&amp;self, k: &amp;Q) -&gt; &amp;V where K: Borrow&lt;Q&gt;, Q: Hash + Eq { ... }
    fn contains_key&lt;Q&gt;(&amp;self, k: &amp;Q) -&gt; bool where K: Borrow&lt;Q&gt;, Q: Hash + Eq { ... }
    fn insert(&amp;mut self, k: K, v: V) -&gt; Option&lt;V&gt; { ... }

    ...
}</code></pre>
<p>The benefits of this approach over <code>_equiv</code> are:</p>
<ul>
<li>
<p>The <code>Borrow</code> trait captures the borrowing relationship between an owned data
structure and both references to it and slices from it – once and for all.
This means that it can be used <em>anywhere</em> we need to program generically over
“borrowed” data. In particular, the single trait works for both <code>HashMap</code> and
<code>TreeMap</code>, and should work for other kinds of data structures as well. It also
helps generalize <code>MaybeOwned</code>, for similar reasons (see below.)</p>
<p>A <em>very important</em> consequence is that the map methods using <code>Borrow</code> can
potentially be put into a common <code>Map</code> trait that’s implemented by <code>HashMap</code>,
<code>TreeMap</code>, and others. While we do not propose to do so now, we definitely
want to do so later on.</p>
</li>
<li>
<p>When using a <code>HashMap&lt;String, T&gt;</code>, all of the basic methods like <code>find</code>,
<code>contains_key</code> and <code>insert</code> “just work”, without forcing you to think about
<code>&amp;String</code> vs <code>&amp;str</code>.</p>
</li>
<li>
<p>We don’t need separate <code>_equiv</code> variants of methods. (However, this could
probably be addressed with
<a href="https://github.com/rust-lang/rfcs/pull/195">multidispatch</a> by providing a
blanket <code>Equiv</code> implementation.)</p>
</li>
</ul>
<p>On the other hand, this approach retains some of the downsides of <code>_equiv</code>:</p>
<ul>
<li>
<p>The signature for methods like <code>find</code> and <code>contains_key</code> is more complex than
their current signatures. There are two counterpoints. First, over time the
<code>Borrow</code> trait is likely to become a well-known concept, so the signature will
not appear completely alien. Second, what is perhaps more important than the
signature is that, when using <code>find</code> on <code>HashMap&lt;String, T&gt;</code>, various method
arguments <em>just work</em> as expected.</p>
</li>
<li>
<p>The API does not guarantee “coherence”: the <code>Hash</code> and <code>Eq</code> (or <code>Ord</code>, for
<code>TreeMap</code>) implementations for the owned and borrowed keys might differ,
breaking key invariants of the data structure. This is already the case with
<code>_equiv</code>.</p>
</li>
</ul>
<p>The <a href="#variants-of-borrow">Alternatives section</a> includes a variant of <code>Borrow</code>
that doesn’t suffer from these downsides, but has some downsides of its own.</p>
<h4 id="clone-on-write-cow-pointers"><a class="header" href="#clone-on-write-cow-pointers">Clone-on-write (<code>Cow</code>) pointers</a></h4>
<p>A side-benefit of the <code>Borrow</code> trait is that we can give a more general version
of the <code>MaybeOwned</code> as a “clone-on-write” smart pointer:</p>
<pre><code class="language-rust">/// A generalization of Clone.
trait FromBorrow&lt;Sized? B&gt;: Borrow&lt;B&gt; {
    fn from_borrow(b: &amp;B) -&gt; Self;
}

/// A clone-on-write smart pointer
pub enum Cow&lt;'a, T, B&gt; where T: FromBorrow&lt;B&gt; {
    Shared(&amp;'a B),
    Owned(T)
}

impl&lt;'a, T, B&gt; Cow&lt;'a, T, B&gt; where T: FromBorrow&lt;B&gt; {
    pub fn new(shared: &amp;'a B) -&gt; Cow&lt;'a, T, B&gt; {
        Shared(shared)
    }

    pub fn new_owned(owned: T) -&gt; Cow&lt;'static, T, B&gt; {
        Owned(owned)
    }

    pub fn is_owned(&amp;self) -&gt; bool {
        match *self {
            Owned(_) =&gt; true,
            Shared(_) =&gt; false
        }
    }

    pub fn to_owned_mut(&amp;mut self) -&gt; &amp;mut T {
        match *self {
            Shared(shared) =&gt; {
                *self = Owned(FromBorrow::from_borrow(shared));
                self.to_owned_mut()
            }
            Owned(ref mut owned) =&gt; owned
        }
    }

    pub fn into_owned(self) -&gt; T {
        match self {
            Shared(shared) =&gt; FromBorrow::from_borrow(shared),
            Owned(owned) =&gt; owned
        }
    }
}

impl&lt;'a, T, B&gt; Deref&lt;B&gt; for Cow&lt;'a, T, B&gt; where T: FromBorrow&lt;B&gt;  {
    fn deref(&amp;self) -&gt; &amp;B {
        match *self {
            Shared(shared) =&gt; shared,
            Owned(ref owned) =&gt; owned.borrow()
        }
    }
}

impl&lt;'a, T, B&gt; DerefMut&lt;B&gt; for Cow&lt;'a, T, B&gt; where T: FromBorrow&lt;B&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut B {
        self.to_owned_mut().borrow_mut()
    }
}</code></pre>
<p>The type <code>Cow&lt;'a, String, str&gt;</code> is roughly equivalent to today’s <code>MaybeOwned&lt;'a&gt;</code>
(and <code>Cow&lt;'a, Vec&lt;T&gt;, [T]&gt;</code> to <code>MaybeOwnedVector&lt;'a, T&gt;</code>).</p>
<p>By implementing <code>Deref</code> and <code>DerefMut</code>, the <code>Cow</code> type acts as a smart pointer
– but in particular, the <code>mut</code> variant actually <em>clones</em> if the pointed-to
value is not currently owned. Hence “clone on write”.</p>
<p>One slight gotcha with the design is that <code>&amp;mut str</code> is not very useful, while
<code>&amp;mut String</code> is (since it allows extending the string, for example). On the
other hand, <code>Deref</code> and <code>DerefMut</code> must deref to the <em>same</em> underlying type, and
for <code>Deref</code> to not require cloning, it must yield a <code>&amp;str</code> value.</p>
<p>Thus, the <code>Cow</code> pointer offers a separate <code>to_owned_mut</code> method that yields a
mutable reference to the <em>owned</em> version of the type.</p>
<p>Note that, by not using <code>into_owned</code>, the <code>Cow</code> pointer itself may be owned by
some other data structure (perhaps as part of a collection) and will internally
track whether an owned copy is available.</p>
<p>Altogether, this RFC proposes to introduce <code>Borrow</code> and <code>Cow</code> as above, and to
deprecate <code>MaybeOwned</code> and <code>MaybeOwnedVector</code>. The API changes for the
collections are discussed <a href="#the-apis">below</a>.</p>
<h3 id="intoiterator-and-iterable"><a class="header" href="#intoiterator-and-iterable"><code>IntoIterator</code> (and <code>Iterable</code>)</a></h3>
<p>As discussed in <a href="#iterable">earlier</a>, some form of an <code>Iterable</code> trait is
desirable for both expressiveness and ergonomics. Unfortunately, a full
treatment of <code>Iterable</code> requires HKT for similar reasons to
<a href="#lack-of-iterator-methods">the collection traits</a>. However, it’s possible to
get some of the way there in a forwards-compatible fashion.</p>
<p>In particular, the following two traits work fine (with
<a href="https://github.com/rust-lang/rfcs/pull/195">associated items</a>):</p>
<pre><code class="language-rust">trait Iterator {
    type A;
    fn next(&amp;mut self) -&gt; Option&lt;A&gt;;
    ...
}

trait IntoIterator {
    type A;
    type I: Iterator&lt;A = A&gt;;

    fn into_iter(self) -&gt; I;
}</code></pre>
<p>Because <code>IntoIterator</code> consumes <code>self</code>, lifetimes are not an issue.</p>
<p>It’s tempting to also define a trait like:</p>
<pre><code class="language-rust">trait Iterable&lt;'a&gt; {
    type A;
    type I: Iterator&lt;&amp;'a A&gt;;

    fn iter(&amp;'a self) -&gt; I;
}</code></pre>
<p>(along the lines of those proposed by
<a href="https://github.com/rust-lang/rfcs/pull/17">an earlier RFC</a>).</p>
<p>The problem with <code>Iterable</code> as defined above is that it’s locked to a particular
lifetime up front. But in many cases, the needed lifetime is not even nameable
in advance:</p>
<pre><code class="language-rust">fn iter_through_rc&lt;I&gt;(c: Rc&lt;I&gt;) where I: Iterable&lt;?&gt; {
    // the lifetime of the borrow is established here,
    // so cannot even be named in the function signature
    for x in c.iter() {
        // ...
    }
}</code></pre>
<p>To make this kind of example work, you’d need to be able to say something like:</p>
<pre><code class="language-rust">where &lt;'a&gt; I: Iterable&lt;'a&gt;</code></pre>
<p>that is, that <code>I</code> implements <code>Iterable</code> for <em>every</em> lifetime <code>'a</code>. While such a
feature is feasible to add to <code>where</code> clauses, the HKT solution is undoubtedly
cleaner.</p>
<p>Fortunately, we can have our cake and eat it too. This RFC proposes the
<code>IntoIterator</code> trait above, together with the following blanket <code>impl</code>:</p>
<pre><code class="language-rust">impl&lt;I: Iterator&gt; IntoIterator for I {
    type A = I::A;
    type I = I;
    fn into_iter(self) -&gt; I {
        self
    }
}</code></pre>
<p>which means that taking <code>IntoIterator</code> is strictly more flexible than taking
<code>Iterator</code>. Note that in other languages (like Java), iterators are <em>not</em>
iterable because the latter implies an unlimited number of iterations. But
because <code>IntoIterator</code> consumes <code>self</code>, it yields only a single iteration, so
all is good.</p>
<p>For individual collections, one can then implement <code>IntoIterator</code> on both the
collection and borrows of it:</p>
<pre><code class="language-rust">impl&lt;T&gt; IntoIterator for Vec&lt;T&gt; {
    type A = T;
    type I = MoveItems&lt;T&gt;;
    fn into_iter(self) -&gt; MoveItems&lt;T&gt; { ... }
}

impl&lt;'a, T&gt; IntoIterator for &amp;'a Vec&lt;T&gt; {
    type A = &amp;'a T;
    type I = Items&lt;'a, T&gt;;
    fn into_iter(self) -&gt; Items&lt;'a, T&gt; { ... }
}

impl&lt;'a, T&gt; IntoIterator for &amp;'a mut Vec&lt;T&gt; {
    type A = &amp;'a mut T;
    type I = ItemsMut&lt;'a, T&gt;;
    fn into_iter(self) -&gt; ItemsMut&lt;'a, T&gt; { ... }
}</code></pre>
<p>If/when HKT is added later on, we can add an <code>Iterable</code> trait and a blanket
<code>impl</code> like the following:</p>
<pre><code class="language-rust">// the HKT version
trait Iterable {
    type A;
    type I&lt;'a&gt;: Iterator&lt;&amp;'a A&gt;;
    fn iter&lt;'a&gt;(&amp;'a self) -&gt; I&lt;'a&gt;;
}

impl&lt;'a, C: Iterable&gt; IntoIterator for &amp;'a C {
    type A = &amp;'a C::A;
    type I = C::I&lt;'a&gt;;
    fn into_iter(self) -&gt; I {
        self.iter()
    }
}</code></pre>
<p>This gives a clean migration path: once <code>Vec</code> implements <code>Iterable</code>, it can drop
the <code>IntoIterator</code> <code>impl</code>s for borrowed vectors, since they will be covered by
the blanket implementation. No code should break.</p>
<p>Likewise, if we add a feature like the “universal” <code>where</code> clause mentioned
above, it can be used to deal with embedded lifetimes as in the
<code>iter_through_rc</code> example; and if the HKT version of <code>Iterable</code> is later added,
thanks to the suggested blanket <code>impl</code> for <code>IntoIterator</code> that <code>where</code> clause
could be changed to use <code>Iterable</code> instead, again without breakage.</p>
<h4 id="benefits-of-intoiterator"><a class="header" href="#benefits-of-intoiterator">Benefits of <code>IntoIterator</code></a></h4>
<p>What do we gain by incorporating <code>IntoIterator</code> today?</p>
<p>This RFC proposes that <code>for</code> loops should use <code>IntoIterator</code> rather than
<code>Iterator</code>. With the blanket <code>impl</code> of <code>IntoIterator</code> for any <code>Iterator</code>, this
is not a breaking change. However, given the <code>IntoIterator</code> <code>impl</code>s for <code>Vec</code>
above, we would be able to write:</p>
<pre><code class="language-rust">let v: Vec&lt;Foo&gt; = ...

for x in &amp;v { ... }     // iterate over &amp;Foo
for x in &amp;mut v { ... } // iterate over &amp;mut Foo
for x in v { ... }      // iterate over Foo</code></pre>
<p>Similarly, methods that currently take slices or iterators can be changed to
take <code>IntoIterator</code> instead, immediately becoming more general and more
ergonomic.</p>
<p>In general, <code>IntoIterator</code> will allow us to move toward more <code>Iterator</code>-centric
APIs today, in a way that’s compatible with HKT tomorrow.</p>
<h4 id="additional-methods"><a class="header" href="#additional-methods">Additional methods</a></h4>
<p>Another typical desire for an <code>Iterable</code> trait is to offer defaulted versions of
methods that basically re-export iterator methods on containers (see
<a href="https://github.com/rust-lang/rfcs/pull/17">the earlier RFC</a>). Usually these
methods would go through a reference iterator (i.e. the <code>iter</code> method) rather
than a moving iterator.</p>
<p>It is possible to add such methods using the design proposed above, but there
are some drawbacks. For example, should <code>Vec::map</code> produce an iterator, or a new
vector?  It would be possible to do the latter generically, but only with
HKT. (See
<a href="https://github.com/rust-lang/rfcs/pull/17#issuecomment-43817453">this discussion</a>.)</p>
<p>This RFC only proposes to add the following method via <code>IntoIterator</code>, as a
convenience for a common pattern:</p>
<pre><code class="language-rust">trait IterCloned {
    type A;
    type I: Iterator&lt;A&gt;;
    fn iter_cloned(self) -&gt; I;
}

impl&lt;'a, T, I: IntoIterator&gt; IterCloned for I where I::A = &amp;'a T {
    type A = T;
    type I = ClonedItems&lt;I&gt;;
    fn into_iter(self) -&gt; I { ... }
}</code></pre>
<p>(The <code>iter_cloned</code> method will help reduce the number of method variants in
general for collections, as we will see below).</p>
<p>We will leave to later RFCs the incorporation of additional methods. Notice, in
particular, that such methods can wait until we introduce an <code>Iterable</code> trait
via HKT without breaking backwards compatibility.</p>
<h3 id="minimizing-variants-byneed-and-predicate-traits"><a class="header" href="#minimizing-variants-byneed-and-predicate-traits">Minimizing variants: <code>ByNeed</code> and <code>Predicate</code> traits</a></h3>
<p>There are several kinds of methods that, in their most general form take
closures, but for which convenience variants taking simpler data are common:</p>
<ul>
<li>
<p><em>Taking values by need</em>. For example, consider the <code>unwrap_or</code> and
<code>unwrap_or_else</code> methods in <code>Option</code>:</p>
<pre><code class="language-rust">fn unwrap_or(self, def: T) -&gt; T
fn unwrap_or_else(self, f: || -&gt; T) -&gt; T</code></pre>
<p>The <code>unwrap_or_else</code> method is the most general: it invokes the closure to
compute a default value <em>only when <code>self</code> is <code>None</code></em>. When the default value
is expensive to compute, this by-need approach helps. But often the default
value is cheap, and closures are somewhat annoying to write, so <code>unwrap_or</code>
provides a convenience wrapper.</p>
</li>
<li>
<p><em>Taking predicates</em>. For example, a method like <code>contains</code> often shows up
(inconsistently!) in two variants:</p>
<pre><code class="language-rust">fn contains(&amp;self, elem: &amp;T) -&gt; bool; // where T: PartialEq
fn contains_fn(&amp;self, pred: |&amp;T| -&gt; bool) -&gt; bool;</code></pre>
<p>Again, the <code>contains_fn</code> version is the more general, but it’s convenient to
provide a specialized variant when the element type can be compared for
equality, to avoid writing explicit closures.</p>
</li>
</ul>
<p>As it turns out, with
<a href="https://github.com/rust-lang/rfcs/pull/195">multidispatch</a>) it is possible to
use a <em>trait</em> to express these variants through overloading:</p>
<pre><code class="language-rust">trait ByNeed&lt;T&gt; {
    fn compute(self) -&gt; T;
}

impl&lt;T&gt; ByNeed&lt;T&gt; for T {
    fn compute(self) -&gt; T {
        self
    }
}

// Due to multidispatch, this impl does NOT overlap with the above one
impl&lt;T&gt; ByNeed&lt;T&gt; for || -&gt; T {
    fn compute(self) -&gt; T {
        self()
    }
}

impl&lt;T&gt; Option&lt;T&gt; {
    fn unwrap_or&lt;U&gt;(self, def: U) where U: ByNeed&lt;T&gt; { ... }
    ...
}</code></pre>
<pre><code class="language-rust">trait Predicate&lt;T&gt; {
    fn check(&amp;self, &amp;T) -&gt; bool;
}

impl&lt;T: Eq&gt; Predicate&lt;T&gt; for &amp;T {
    fn check(&amp;self, t: &amp;T) -&gt; bool {
        *self == t
    }
}

impl&lt;T&gt; Predicate&lt;T&gt; for |&amp;T| -&gt; bool {
    fn check(&amp;self, t: &amp;T) -&gt; bool {
        (*self)(t)
    }
}

impl&lt;T&gt; Vec&lt;T&gt; {
    fn contains&lt;P&gt;(&amp;self, pred: P) where P: Predicate&lt;T&gt; { ... }
    ...
}</code></pre>
<p>Since these two patterns are particularly common throughout <code>std</code>, this RFC
proposes adding both of the above traits, and using them to cut down on the
number of method variants.</p>
<p>In particular, some methods on string slices currently work with <code>CharEq</code>, which
is similar to <code>Predicate&lt;char&gt;</code>:</p>
<pre><code class="language-rust">pub trait CharEq {
    fn matches(&amp;mut self, char) -&gt; bool;
    fn only_ascii(&amp;self) -&gt; bool;
}</code></pre>
<p>The difference is the <code>only_ascii</code> method, which is used to optimize certain
operations when the predicate only holds for characters in the ASCII range.</p>
<p>To keep these optimizations intact while connecting to <code>Predicate</code>, this RFC
proposes the following restructuring of <code>CharEq</code>:</p>
<pre><code class="language-rust">pub trait CharPredicate: Predicate&lt;char&gt; {
    fn only_ascii(&amp;self) -&gt; bool {
        false
    }
}</code></pre>
<h4 id="why-not-leverage-unboxed-closures"><a class="header" href="#why-not-leverage-unboxed-closures">Why not leverage unboxed closures?</a></h4>
<p>A natural question is: why not use the traits for unboxed closures to achieve a
similar effect? For example, you could imagine writing a blanket <code>impl</code> for
<code>Fn(&amp;T) -&gt; bool</code> for any <code>T: PartialEq</code>, which would allow <code>PartialEq</code> values to
be used anywhere a predicate-like closure was requested.</p>
<p>The problem is that these blanket <code>impl</code>s will often conflict. In particular,
<em>any</em> type <code>T</code> could implement <code>Fn() -&gt; T</code>, and that single blanket <code>impl</code> would
preclude any others (at least, assuming that unboxed closure traits treat the
argument and return types as associated (output) types).</p>
<p>In addition, the explicit use of traits like <code>Predicate</code> makes the intended
semantics more clear, and the overloading less surprising.</p>
<h3 id="the-apis"><a class="header" href="#the-apis">The APIs</a></h3>
<p>Now we’ll delve into the detailed APIs for the various concrete
collections. These APIs will often be given in tabular form, grouping together
common APIs across multiple collections. When writing these function signatures:</p>
<ul>
<li>
<p>We will assume a type parameter <code>T</code> for <code>Vec</code>, <code>BinaryHeap</code>, <code>DList</code> and <code>RingBuf</code>;
we will also use this parameter for APIs on <code>String</code>, where it should be
understood as <code>char</code>.</p>
</li>
<li>
<p>We will assume type parameters <code>K: Borrow</code> and <code>V</code> for <code>HashMap</code> and
<code>TreeMap</code>; for <code>TrieMap</code> and <code>SmallIntMap</code> the <code>K</code> is assumed to be <code>uint</code></p>
</li>
<li>
<p>We will assume a type parameter <code>K: Borrow</code> for <code>HashSet</code> and <code>TreeSet</code>; for
<code>BitvSet</code> it is assumed to be <code>uint</code>.</p>
</li>
</ul>
<p>We will begin by outlining the most widespread APIs in tables, making it easy to
compare names and signatures across different kinds of collections. Then we will
focus on some APIs specific to particular classes of collections – e.g. sets
and maps.  Finally, we will briefly discuss APIs that are specific to a single
concrete collection.</p>
<h4 id="construction"><a class="header" href="#construction">Construction</a></h4>
<p>All of the collections should support a static function:</p>
<pre><code class="language-rust">fn new() -&gt; Self</code></pre>
<p>that creates an empty version of the collection; the constructor may take
arguments needed to set up the collection, e.g. the capacity for <code>LruCache</code>.</p>
<p>Several collections also support separate constructors for providing capacities in
advance; these are discussed <a href="#capacity-management">below</a>.</p>
<h5 id="the-fromiterator-trait"><a class="header" href="#the-fromiterator-trait">The <code>FromIterator</code> trait</a></h5>
<p>All of the collections should implement the <code>FromIterator</code> trait:</p>
<pre><code class="language-rust">pub trait FromIterator {
    type A:
    fn from_iter&lt;T&gt;(T) -&gt; Self where T: IntoIterator&lt;A = A&gt;;
}</code></pre>
<p>Note that this varies from today’s <code>FromIterator</code> by consuming an <code>IntoIterator</code>
rather than <code>Iterator</code>. As explained <a href="#intoiterator-and-iterable">above</a>, this
choice is strictly more general and will not break any existing code.</p>
<p>This constructor initializes the collection with the contents of the
iterator. For maps, the iterator is over key/value pairs, and the semantics is
equivalent to inserting those pairs in order; if keys are repeated, the last
value is the one left in the map.</p>
<h4 id="insertion"><a class="header" href="#insertion">Insertion</a></h4>
<p>The table below gives methods for inserting items into various concrete collections:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Collections</th></tr>
</thead>
<tbody>
<tr><td><code>fn push(&amp;mut self, T)</code></td><td><code>Vec</code>, <code>BinaryHeap</code>, <code>String</code></td></tr>
<tr><td><code>fn push_front(&amp;mut self, T)</code></td><td><code>DList</code>, <code>RingBuf</code></td></tr>
<tr><td><code>fn push_back(&amp;mut self, T)</code></td><td><code>DList</code>, <code>RingBuf</code></td></tr>
<tr><td><code>fn insert(&amp;mut self, uint, T)</code></td><td><code>Vec</code>, <code>RingBuf</code>, <code>String</code></td></tr>
<tr><td><code>fn insert(&amp;mut self, K::Owned) -&gt; bool</code></td><td><code>HashSet</code>, <code>TreeSet</code>, <code>TrieSet</code>, <code>BitvSet</code></td></tr>
<tr><td><code>fn insert(&amp;mut self, K::Owned, V) -&gt; Option&lt;V&gt;</code></td><td><code>HashMap</code>, <code>TreeMap</code>, <code>TrieMap</code>, <code>SmallIntMap</code></td></tr>
<tr><td><code>fn append(&amp;mut self, Self)</code></td><td><code>DList</code></td></tr>
<tr><td><code>fn prepend(&amp;mut self, Self)</code></td><td><code>DList</code></td></tr>
</tbody>
</table>
</div>
<p>There are a few changes here from the current state of affairs:</p>
<ul>
<li>
<p>The <code>DList</code> and <code>RingBuf</code> data structures no longer provide <code>push</code>, but rather
<code>push_front</code> and <code>push_back</code>. This change is based on (1) viewing them as
deques and (2) not giving priority to the “front” or the “back”.</p>
</li>
<li>
<p>The <code>insert</code> method on maps returns the value previously associated with the
key, if any. Previously, this functionality was provided by a <code>swap</code> method,
which has been dropped (consolidating needless method variants.)</p>
</li>
</ul>
<p>Aside from these changes, a number of insertion methods will be deprecated
(e.g. the <code>append</code> and <code>append_one</code> methods on <code>Vec</code>). These are discussed
further in the section on “specialized operations”
<a href="#specialized-operations">below</a>.</p>
<h5 id="the-extend-trait-was-extendable"><a class="header" href="#the-extend-trait-was-extendable">The <code>Extend</code> trait (was: <code>Extendable</code>)</a></h5>
<p>In addition to the standard insertion operations above, <em>all</em> collections will
implement the <code>Extend</code> trait. This trait was previously called <code>Extendable</code>, but
in general we
<a href="http://aturon.github.io/style/naming/README.html">prefer to avoid</a> <code>-able</code>
suffixes and instead name the trait using a verb (or, especially, the key method
offered by the trait.)</p>
<p>The <code>Extend</code> trait allows data from an arbitrary iterator to be inserted into a
collection, and will be defined as follows:</p>
<pre><code class="language-rust">pub trait Extend: FromIterator {
    fn extend&lt;T&gt;(&amp;mut self, T) where T: IntoIterator&lt;A = Self::A&gt;;
}</code></pre>
<p>As with <code>FromIterator</code>, this trait has been modified to take an <code>IntoIterator</code>
value.</p>
<h4 id="deletion"><a class="header" href="#deletion">Deletion</a></h4>
<p>The table below gives methods for removing items into various concrete collections:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Collections</th></tr>
</thead>
<tbody>
<tr><td><code>fn clear(&amp;mut self)</code></td><td><em>all</em></td></tr>
<tr><td><code>fn pop(&amp;mut self) -&gt; Option&lt;T&gt;</code></td><td><code>Vec</code>, <code>BinaryHeap</code>, <code>String</code></td></tr>
<tr><td><code>fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt;</code></td><td><code>DList</code>, <code>RingBuf</code></td></tr>
<tr><td><code>fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt;</code></td><td><code>DList</code>, <code>RingBuf</code></td></tr>
<tr><td><code>fn remove(&amp;mut self, uint) -&gt; Option&lt;T&gt;</code></td><td><code>Vec</code>, <code>RingBuf</code>, <code>String</code></td></tr>
<tr><td><code>fn remove(&amp;mut self, &amp;K) -&gt; bool</code></td><td><code>HashSet</code>, <code>TreeSet</code>, <code>TrieSet</code>, <code>BitvSet</code></td></tr>
<tr><td><code>fn remove(&amp;mut self, &amp;K) -&gt; Option&lt;V&gt;</code></td><td><code>HashMap</code>, <code>TreeMap</code>, <code>TrieMap</code>, <code>SmallIntMap</code></td></tr>
<tr><td><code>fn truncate(&amp;mut self, len: uint)</code></td><td><code>Vec</code>, <code>String</code>, <code>Bitv</code>, <code>DList</code>, <code>RingBuf</code></td></tr>
<tr><td><code>fn retain&lt;P&gt;(&amp;mut self, f: P) where P: Predicate&lt;T&gt;</code></td><td><code>Vec</code>, <code>DList</code>, <code>RingBuf</code></td></tr>
<tr><td><code>fn dedup(&amp;mut self)</code></td><td><code>Vec</code>, <code>DList</code>, <code>RingBuf</code> where <code>T: PartialEq</code></td></tr>
</tbody>
</table>
</div>
<p>As with the insertion methods, there are some differences from today’s API:</p>
<ul>
<li>
<p>The <code>DList</code> and <code>RingBuf</code> data structures no longer provide <code>pop</code>, but rather
<code>pop_front</code> and <code>pop_back</code> – similarly to the <code>push</code> methods.</p>
</li>
<li>
<p>The <code>remove</code> method on maps returns the value previously associated with the
key, if any. Previously, this functionality was provided by a separate <code>pop</code>
method, which has been dropped (consolidating needless method variants.)</p>
</li>
<li>
<p>The <code>retain</code> method takes a <code>Predicate</code>.</p>
</li>
<li>
<p>The <code>truncate</code>, <code>retain</code> and <code>dedup</code> methods are offered more widely.</p>
</li>
</ul>
<p>Again, some of the more specialized methods are not discussed here; see
“specialized operations” <a href="#specialized-operations">below</a>.</p>
<h4 id="inspectionmutation"><a class="header" href="#inspectionmutation">Inspection/mutation</a></h4>
<p>The next table gives methods for inspection and mutation of existing items in collections:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Collections</th></tr>
</thead>
<tbody>
<tr><td><code>fn len(&amp;self) -&gt; uint</code></td><td><em>all</em></td></tr>
<tr><td><code>fn is_empty(&amp;self) -&gt; bool</code></td><td><em>all</em></td></tr>
<tr><td><code>fn get(&amp;self, uint) -&gt; Option&lt;&amp;T&gt;</code></td><td><code>[T]</code>, <code>Vec</code>, <code>RingBuf</code></td></tr>
<tr><td><code>fn get_mut(&amp;mut self, uint) -&gt; Option&lt;&amp;mut T&gt;</code></td><td><code>[T]</code>, <code>Vec</code>, <code>RingBuf</code></td></tr>
<tr><td><code>fn get(&amp;self, &amp;K) -&gt; Option&lt;&amp;V&gt;</code></td><td><code>HashMap</code>, <code>TreeMap</code>, <code>TrieMap</code>, <code>SmallIntMap</code></td></tr>
<tr><td><code>fn get_mut(&amp;mut self, &amp;K) -&gt; Option&lt;&amp;mut V&gt;</code></td><td><code>HashMap</code>, <code>TreeMap</code>, <code>TrieMap</code>, <code>SmallIntMap</code></td></tr>
<tr><td><code>fn contains&lt;P&gt;(&amp;self, P) where P: Predicate&lt;T&gt;</code></td><td><code>[T]</code>, <code>str</code>, <code>Vec</code>, <code>String</code>, <code>DList</code>, <code>RingBuf</code>, <code>BinaryHeap</code></td></tr>
<tr><td><code>fn contains(&amp;self, &amp;K) -&gt; bool</code></td><td><code>HashSet</code>, <code>TreeSet</code>, <code>TrieSet</code>, <code>EnumSet</code></td></tr>
<tr><td><code>fn contains_key(&amp;self, &amp;K) -&gt; bool</code></td><td><code>HashMap</code>, <code>TreeMap</code>, <code>TrieMap</code>, <code>SmallIntMap</code></td></tr>
</tbody>
</table>
</div>
<p>The biggest changes from the current APIs are:</p>
<ul>
<li>
<p>The <code>find</code> and <code>find_mut</code> methods have been renamed to <code>get</code> and <code>get_mut</code>.
Further, all <code>get</code> methods return <code>Option</code> values and do not invoke <code>fail!</code>.
This is part of a general convention described in the next section (on the
<code>Index</code> traits).</p>
</li>
<li>
<p>The <code>contains</code> method is offered more widely.</p>
</li>
<li>
<p>There is no longer an equivalent of <code>find_copy</code> (which should be called
<code>find_clone</code>). Instead, we propose to add the following method to the <code>Option&lt;&amp;'a T&gt;</code>
type where <code>T: Clone</code>:</p>
<pre><code class="language-rust">fn cloned(self) -&gt; Option&lt;T&gt; {
    self.map(|x| x.clone())
}</code></pre>
<p>so that <code>some_map.find_copy(key)</code> will instead be written
<code>some_map.find(key).cloned()</code>. This method chain is slightly longer, but is
more clear and allows us to drop the <code>_copy</code> variants. Moreover, <em>all</em> users
of <code>Option</code> benefit from the new convenience method.</p>
</li>
</ul>
<h5 id="the-index-trait"><a class="header" href="#the-index-trait">The <code>Index</code> trait</a></h5>
<p>The <code>Index</code> and <code>IndexMut</code> traits provide indexing notation like <code>v[0]</code>:</p>
<pre><code class="language-rust">pub trait Index {
    type Index;
    type Result;
    fn index(&amp;'a self, index: &amp;Index) -&gt; &amp;'a Result;
}

pub trait IndexMut {
    type Index;
    type Result;
    fn index_mut(&amp;'a mut self, index: &amp;Index) -&gt; &amp;'a mut Result;
}</code></pre>
<p>These traits will be implemented for: <code>[T]</code>, <code>Vec</code>, <code>RingBuf</code>, <code>HashMap</code>, <code>TreeMap</code>, <code>TrieMap</code>, <code>SmallIntMap</code>.</p>
<p>As a general convention, implementation of the <code>Index</code> traits will <em>fail the
task</em> if the index is invalid (out of bounds or key not found); they will
therefore return direct references to values. Any collection implementing <code>Index</code>
(resp. <code>IndexMut</code>) should also provide a <code>get</code> method (resp. <code>get_mut</code>) as a
non-failing variant that returns an <code>Option</code> value.</p>
<p>This allows us to keep indexing notation maximally concise, while still
providing convenient non-failing variants (which can be used to provide a check
for index validity).</p>
<h4 id="iteration"><a class="header" href="#iteration">Iteration</a></h4>
<p>Every collection should provide the standard trio of iteration methods:</p>
<pre><code class="language-rust">fn iter(&amp;'a self) -&gt; Items&lt;'a&gt;;
fn iter_mut(&amp;'a mut self) -&gt; ItemsMut&lt;'a&gt;;
fn into_iter(self) -&gt; ItemsMove;</code></pre>
<p>and in particular implement the <code>IntoIterator</code> trait on both the collection type
and on (mutable) references to it.</p>
<h4 id="capacity-management"><a class="header" href="#capacity-management">Capacity management</a></h4>
<p>many of the collections have some notion of “capacity”, which may be fixed, grow
explicitly, or grow implicitly:</p>
<ul>
<li>No capacity/fixed capacity: <code>DList</code>, <code>TreeMap</code>, <code>TreeSet</code>, <code>TrieMap</code>, <code>TrieSet</code>, slices, <code>EnumSet</code></li>
<li>Explicit growth: <code>LruCache</code></li>
<li>Implicit growth: <code>Vec</code>, <code>RingBuf</code>, <code>HashMap</code>, <code>HashSet</code>, <code>BitvSet</code>, <code>BinaryHeap</code></li>
</ul>
<p>Growable collections provide functions for capacity management, as follows.</p>
<h5 id="explicit-growth"><a class="header" href="#explicit-growth">Explicit growth</a></h5>
<p>For explicitly-grown collections, the normal constructor (<code>new</code>) takes a
capacity argument. Capacity can later be inspected or updated as follows:</p>
<pre><code class="language-rust">fn capacity(&amp;self) -&gt; uint
fn set_capacity(&amp;mut self, capacity: uint)</code></pre>
<p>(Note, this renames <code>LruCache::change_capacity</code> to <code>set_capacity</code>, the
prevailing style for setter method.)</p>
<h5 id="implicit-growth"><a class="header" href="#implicit-growth">Implicit growth</a></h5>
<p>For implicitly-grown collections, the normal constructor (<code>new</code>) does not take a
capacity, but there is an explicit <code>with_capacity</code> constructor, along with other
functions to work with the capacity later on:</p>
<pre><code class="language-rust">fn with_capacity(uint) -&gt; Self
fn capacity(&amp;self) -&gt; uint
fn reserve(&amp;mut self, additional: uint)
fn reserve_exact(&amp;mut self, additional: uint)
fn shrink_to_fit(&amp;mut self)</code></pre>
<p>There are some important changes from the current APIs:</p>
<ul>
<li>
<p>The <code>reserve</code> and <code>reserve_exact</code> methods now take as an argument the <em>extra</em>
space to reserve, rather than the final desired capacity, as this usage is
vastly more common. The <code>reserve</code> function may grow the capacity by a larger
amount than requested, to ensure amortization, while <code>reserve_exact</code> will
reserve exactly the requested additional capacity. The <code>reserve_additional</code>
methods are deprecated.</p>
</li>
<li>
<p>The <code>with_capacity</code> constructor does <em>not</em> take any additional arguments, for
uniformity with <code>new</code>. This change affects <code>Bitv</code> in particular.</p>
</li>
</ul>
<h5 id="bounded-iterators"><a class="header" href="#bounded-iterators">Bounded iterators</a></h5>
<p>Some of the maps (e.g. <code>TreeMap</code>) currently offer specialized iterators over
their entries starting at a given key (called <code>lower_bound</code>) and above a given
key (called <code>upper_bound</code>), along with <code>_mut</code> variants. While the functionality
is worthwhile, the names are not very clear, so this RFC proposes the following
replacement API (thanks to <a href="https://github.com/rust-lang/rfcs/pull/235#issuecomment-55512788">@Gankro for the suggestion</a>):</p>
<pre><code class="language-rust">Bound&lt;T&gt; {
    /// An inclusive bound
    Included(T),

    /// An exclusive bound
    Excluded(T),

    Unbounded,
}

/// Creates a double-ended iterator over a sub-range of the collection's items,
/// starting at min, and ending at max. If min is `Unbounded`, then it will
/// be treated as "negative infinity", and if max is `Unbounded`, then it will
/// be treated as "positive infinity". Thus range(Unbounded, Unbounded) will yield
/// the whole collection.
fn range(&amp;self, min: Bound&lt;&amp;T&gt;, max: Bound&lt;&amp;T&gt;) -&gt; RangedItems&lt;'a, T&gt;;

fn range_mut(&amp;self, min: Bound&lt;&amp;T&gt;, max: Bound&lt;&amp;T&gt;) -&gt; RangedItemsMut&lt;'a, T&gt;;</code></pre>
<p>These iterators should be provided for any maps over ordered keys (<code>TreeMap</code>,
<code>TrieMap</code> and <code>SmallIntMap</code>).</p>
<p>In addition, analogous methods should be provided for sets over ordered keys
(<code>TreeSet</code>, <code>TrieSet</code>, <code>BitvSet</code>).</p>
<h4 id="set-operations"><a class="header" href="#set-operations">Set operations</a></h4>
<h5 id="comparisons"><a class="header" href="#comparisons">Comparisons</a></h5>
<p>All sets should offer the following methods, as they do today:</p>
<pre><code class="language-rust">fn is_disjoint(&amp;self, other: &amp;Self) -&gt; bool;
fn is_subset(&amp;self, other: &amp;Self) -&gt; bool;
fn is_superset(&amp;self, other: &amp;Self) -&gt; bool;</code></pre>
<h5 id="combinations"><a class="header" href="#combinations">Combinations</a></h5>
<p>Sets can also be combined using the standard operations – union, intersection,
difference and symmetric difference (exclusive or). Today’s APIs for doing so
look like this:</p>
<pre><code class="language-rust">fn union&lt;'a&gt;(&amp;'a self, other: &amp;'a Self) -&gt; I;
fn intersection&lt;'a&gt;(&amp;'a self, other: &amp;'a Self) -&gt; I;
fn difference&lt;'a&gt;(&amp;'a self, other: &amp;'a Self) -&gt; I;
fn symmetric_difference&lt;'a&gt;(&amp;'a self, other: &amp;'a Self) -&gt; I;</code></pre>
<p>where the <code>I</code> type is an iterator over keys that varies by concrete
set. Working with these iterators avoids materializing intermediate
sets when they’re not needed; the <code>collect</code> method can be used to
create sets when they are. This RFC proposes to keep these names
intact, following the
<a href="https://github.com/rust-lang/rfcs/pull/344">RFC</a> on iterator
conventions.</p>
<p>Sets should also implement the <code>BitOr</code>, <code>BitAnd</code>, <code>BitXor</code> and <code>Sub</code> traits from
<code>std::ops</code>, allowing overloaded notation <code>|</code>, <code>&amp;</code>, <code>|^</code> and <code>-</code> to be used with
sets. These are equivalent to invoking the corresponding <code>iter_</code> method and then
calling <code>collect</code>, but for some sets (notably <code>BitvSet</code>) a more efficient direct
implementation is possible.</p>
<p>Unfortunately, we do not yet have a set of traits corresponding to operations
<code>|=</code>, <code>&amp;=</code>, etc, but again in some cases doing the update in place may be more
efficient. Right now, <code>BitvSet</code> is the only concrete set offering such operations:</p>
<pre><code class="language-rust">fn union_with(&amp;mut self, other: &amp;BitvSet)
fn intersect_with(&amp;mut self, other: &amp;BitvSet)
fn difference_with(&amp;mut self, other: &amp;BitvSet)
fn symmetric_difference_with(&amp;mut self, other: &amp;BitvSet)</code></pre>
<p>This RFC punts on the question of naming here: it does <em>not</em> propose a new set
of names. Ideally, we would add operations like <code>|=</code> in a separate RFC, and use
those conventionally for sets. If not, we will choose fallback names during the
stabilization of <code>BitvSet</code>.</p>
<h4 id="map-operations"><a class="header" href="#map-operations">Map operations</a></h4>
<h5 id="combined-methods"><a class="header" href="#combined-methods">Combined methods</a></h5>
<p>The <code>HashMap</code> type currently provides a somewhat bewildering set of <code>find</code>/<code>insert</code> variants:</p>
<pre><code class="language-rust">fn find_or_insert(&amp;mut self, k: K, v: V) -&gt; &amp;mut V
fn find_or_insert_with&lt;'a&gt;(&amp;'a mut self, k: K, f: |&amp;K| -&gt; V) -&gt; &amp;'a mut V
fn insert_or_update_with&lt;'a&gt;(&amp;'a mut self, k: K, v: V, f: |&amp;K, &amp;mut V|) -&gt; &amp;'a mut V
fn find_with_or_insert_with&lt;'a, A&gt;(&amp;'a mut self, k: K, a: A, found: |&amp;K, &amp;mut V, A|, not_found: |&amp;K, A| -&gt; V) -&gt; &amp;'a mut V</code></pre>
<p>These methods are used to couple together lookup and insertion/update
operations, thereby avoiding an extra lookup step. However, the current set of
method variants seems overly complex.</p>
<p>There is <a href="https://github.com/rust-lang/rfcs/pull/216">another RFC</a> already in
the queue addressing this problem in a very nice way, and this RFC defers to
that one</p>
<h5 id="key-and-value-iterators"><a class="header" href="#key-and-value-iterators">Key and value iterators</a></h5>
<p>In addition to the standard iterators, maps should provide by-reference
convenience iterators over keys and values:</p>
<pre><code class="language-rust">fn keys(&amp;'a self) -&gt; Keys&lt;'a, K&gt;
fn values(&amp;'a self) -&gt; Values&lt;'a, V&gt;</code></pre>
<p>While these iterators are easy to define in terms of the main <code>iter</code> method,
they are used often enough to warrant including convenience methods.</p>
<h4 id="specialized-operations"><a class="header" href="#specialized-operations">Specialized operations</a></h4>
<p>Many concrete collections offer specialized operations beyond the ones given
above. These will largely be addressed through the API stabilization process
(which focuses on local API issues, as opposed to general conventions), but a
few broad points are addressed below.</p>
<h5 id="relating-vec-and-string-to-slices"><a class="header" href="#relating-vec-and-string-to-slices">Relating <code>Vec</code> and <code>String</code> to slices</a></h5>
<p>One goal of this RFC is to supply all of the methods on (mutable) slices on
<code>Vec</code> and <code>String</code>. There are a few ways to achieve this, so concretely the
proposal is for <code>Vec&lt;T&gt;</code> to implement <code>Deref&lt;[T]&gt;</code> and <code>DerefMut&lt;[T]&gt;</code>, and
<code>String</code> to implement <code>Deref&lt;str&gt;</code>. This will automatically allow all slice
methods to be invoked from vectors and strings, and will allow writing <code>&amp;*v</code>
rather than <code>v.as_slice()</code>.</p>
<p>In this scheme, <code>Vec</code> and <code>String</code> are really “smart pointers” around the
corresponding slice types. While counterintuitive at first, this perspective
actually makes a fair amount of sense, especially with DST.</p>
<p>(Initially, it was unclear whether this strategy would play well with method
resolution, but the planned resolution rules should work fine.)</p>
<h5 id="string-api"><a class="header" href="#string-api"><code>String</code> API</a></h5>
<p>One of the key difficulties with the <code>String</code> API is that strings use utf8
encoding, and some operations are only efficient when working at the byte level
(and thus taking this encoding into account).</p>
<p>As a general principle, we will move the API toward the following convention:
index-related operations always work in terms of bytes, other operations deal
with chars by default (but can have suffixed variants for working at other
granularities when appropriate.)</p>
<h5 id="dlist"><a class="header" href="#dlist"><code>DList</code></a></h5>
<p>The <code>DList</code> type offers a number of specialized methods:</p>
<pre><code class="language-rust">swap_remove, insert_when, insert_ordered, merge, rotate_forward and rotate_backward</code></pre>
<p>Prior to stabilizing the <code>DList</code> API, we will attempt to simplify its API
surface, possibly by using idea from the
<a href="https://github.com/rust-lang/rfcs/pull/216">collection views RFC</a>.</p>
<h4 id="minimizing-method-variants-via-iterators"><a class="header" href="#minimizing-method-variants-via-iterators">Minimizing method variants via iterators</a></h4>
<h5 id="partitioning-via-fromiterator"><a class="header" href="#partitioning-via-fromiterator">Partitioning via <code>FromIterator</code></a></h5>
<p>One place we can move toward iterators is functions like <code>partition</code> and
<code>partitioned</code> on vectors and slices:</p>
<pre><code class="language-rust">// on Vec&lt;T&gt;
fn partition(self, f: |&amp;T| -&gt; bool) -&gt; (Vec&lt;T&gt;, Vec&lt;T&gt;);

// on [T] where T: Clone
fn partitioned(&amp;self, f: |&amp;T| -&gt; bool) -&gt; (Vec&lt;T&gt;, Vec&lt;T&gt;);</code></pre>
<p>These two functions transform a vector/slice into a pair of vectors, based on a
“partitioning” function that says which of the two vectors to place elements
into. The <code>partition</code> variant works by moving elements of the vector, while
<code>partitioned</code> clones elements.</p>
<p>There are a few unfortunate aspects of an API like this one:</p>
<ul>
<li>
<p>It’s specific to vectors/slices, although in principle both the source and
target containers could be more general.</p>
</li>
<li>
<p>The fact that two variants have to be exposed, for owned versus clones, is
somewhat unfortunate.</p>
</li>
</ul>
<p>This RFC proposes the following alternative design:</p>
<pre><code class="language-rust">pub enum Either&lt;T, U&gt; {
    pub Left(T),
    pub Right(U),
}

impl&lt;A, B&gt; FromIterator for (A, B) where A: Extend, B: Extend {
    fn from_iter&lt;I&gt;(mut iter: I) -&gt; (A, B) where I: IntoIterator&lt;Either&lt;T, U&gt;&gt; {
        let mut left: A = FromIterator::from_iter(None::&lt;T&gt;);
        let mut right: B = FromIterator::from_iter(None::&lt;U&gt;);

        for item in iter {
            match item {
                Left(t) =&gt; left.extend(Some(t)),
                Right(u) =&gt; right.extend(Some(u)),
            }
        }

        (left, right)
    }
}

trait Iterator {
    ...
    fn partition(self, |&amp;A| -&gt; bool) -&gt; Partitioned&lt;A&gt; { ... }
}

// where Partitioned&lt;A&gt;: Iterator&lt;A = Either&lt;A, A&gt;&gt;</code></pre>
<p>This design drastically generalizes the partitioning functionality, allowing it
be used with arbitrary collections and iterators, while removing the
by-reference and by-value distinction.</p>
<p>Using this design, you have:</p>
<pre><code class="language-rust">// The following two lines are equivalent:
let (u, w) = v.partition(f);
let (u, w): (Vec&lt;T&gt;, Vec&lt;T&gt;) = v.into_iter().partition(f).collect();

// The following two lines are equivalent:
let (u, w) = v.as_slice().partitioned(f);
let (u, w): (Vec&lt;T&gt;, Vec&lt;T&gt;) = v.iter_cloned().partition(f).collect();</code></pre>
<p>There is some extra verbosity, mainly due to the type annotations for <code>collect</code>,
but the API is much more flexible, since the partitioned data can now be
collected into other collections (or even differing collections). In addition,
partitioning is supported for <em>any</em> iterator.</p>
<h5 id="removing-methods-like-from_elem-from_fn-grow-and-grow_fn"><a class="header" href="#removing-methods-like-from_elem-from_fn-grow-and-grow_fn">Removing methods like <code>from_elem</code>, <code>from_fn</code>, <code>grow</code>, and <code>grow_fn</code></a></h5>
<p>Vectors and some other collections offer constructors and growth functions like
the following:</p>
<pre><code class="language-rust">fn from_elem(length: uint, value: T) -&gt; Vec&lt;T&gt;
fn from_fn(length: uint, op: |uint| -&gt; T) -&gt; Vec&lt;T&gt;
fn grow(&amp;mut self, n: uint, value: &amp;T)
fn grow_fn(&amp;mut self, n: uint, f: |uint| -&gt; T)</code></pre>
<p>These extra variants can easily be dropped in favor of iterators, and this RFC
proposes to do so.</p>
<p>The <code>iter</code> module already contains a <code>Repeat</code> iterator; this RFC proposes to add
a free function <code>repeat</code> to <code>iter</code> as a convenience for <code>iter::Repeat::new</code>.</p>
<p>With that in place, we have:</p>
<pre><code class="language-rust">// Equivalent:
let v = Vec::from_elem(n, a);
let v = Vec::from_iter(repeat(a).take(n));

// Equivalent:
let v = Vec::from_fn(n, f);
let v = Vec::from_iter(range(0, n).map(f));

// Equivalent:
v.grow(n, a);
v.extend(repeat(a).take(n));

// Equivalent:
v.grow_fn(n, f);
v.extend(range(0, n).map(f));</code></pre>
<p>While these replacements are slightly longer, an important aspect of ergonomics
is <em>memorability</em>: by placing greater emphasis on iterators, programmers will
quickly learn the iterator APIs and have those at their fingertips, while
remembering ad hoc method variants like <code>grow_fn</code> is more difficult.</p>
<h5 id="long-term-removing-push_all-and-push_all_move"><a class="header" href="#long-term-removing-push_all-and-push_all_move">Long-term: removing <code>push_all</code> and <code>push_all_move</code></a></h5>
<p>The <code>push_all</code> and <code>push_all_move</code> methods on vectors are yet more API variants
that could, in principle, go through iterators:</p>
<pre><code class="language-rust">// The following are *semantically* equivalent
v.push_all(some_slice);
v.extend(some_slice.iter_cloned());

// The following are *semantically* equivalent
v.push_all_move(some_vec);
v.extend(some_vec);</code></pre>
<p>However, currently the <code>push_all</code> and <code>push_all_move</code> methods can rely
on the <em>exact</em> size of the container being pushed, in order to elide
bounds checks. We do not currently have a way to “trust” methods like
<code>len</code> on iterators to elide bounds checks. A separate RFC will
introduce the notion of a “trusted” method which should support such
optimization and allow us to deprecate the <code>push_all</code> and
<code>push_all_move</code> variants. (This is unlikely to happen before 1.0, so
the methods will probably still be included with “experimental”
status, and likely with different names.)</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<h3 id="borrow-and-the-equiv-problem"><a class="header" href="#borrow-and-the-equiv-problem"><code>Borrow</code> and the <code>Equiv</code> problem</a></h3>
<h4 id="variants-of-borrow"><a class="header" href="#variants-of-borrow">Variants of <code>Borrow</code></a></h4>
<p>The original version of <code>Borrow</code> was somewhat more subtle:</p>
<pre><code class="language-rust">/// A trait for borrowing.
/// If `T: Borrow` then `&amp;T` represents data borrowed from `T::Owned`.
trait Borrow for Sized? {
    /// The type being borrowed from.
    type Owned;

    /// Immutably borrow from an owned value.
    fn borrow(&amp;Owned) -&gt; &amp;Self;

    /// Mutably borrow from an owned value.
    fn borrow_mut(&amp;mut Owned) -&gt; &amp;mut Self;
}

trait ToOwned: Borrow {
    /// Produce a new owned value, usually by cloning.
    fn to_owned(&amp;self) -&gt; Owned;
}

impl&lt;A: Sized&gt; Borrow for A {
    type Owned = A;
    fn borrow(a: &amp;A) -&gt; &amp;A {
        a
    }
    fn borrow_mut(a: &amp;mut A) -&gt; &amp;mut A {
        a
    }
}

impl&lt;A: Clone&gt; ToOwned for A {
    fn to_owned(&amp;self) -&gt; A {
        self.clone()
    }
}

impl Borrow for str {
    type Owned = String;
    fn borrow(s: &amp;String) -&gt; &amp;str {
        s.as_slice()
    }
    fn borrow_mut(s: &amp;mut String) -&gt; &amp;mut str {
        s.as_mut_slice()
    }
}

impl ToOwned for str {
    fn to_owned(&amp;self) -&gt; String {
        self.to_string()
    }
}

impl&lt;T&gt; Borrow for [T] {
    type Owned = Vec&lt;T&gt;;
    fn borrow(s: &amp;Vec&lt;T&gt;) -&gt; &amp;[T] {
        s.as_slice()
    }
    fn borrow_mut(s: &amp;mut Vec&lt;T&gt;) -&gt; &amp;mut [T] {
        s.as_mut_slice()
    }
}

impl&lt;T&gt; ToOwned for [T] {
    fn to_owned(&amp;self) -&gt; Vec&lt;T&gt; {
        self.to_vec()
    }
}

impl&lt;K,V&gt; HashMap&lt;K,V&gt; where K: Borrow + Hash + Eq {
    fn find(&amp;self, k: &amp;K) -&gt; &amp;V { ... }
    fn insert(&amp;mut self, k: K::Owned, v: V) -&gt; Option&lt;V&gt; { ... }
    ...
}

pub enum Cow&lt;'a, T&gt; where T: ToOwned {
    Shared(&amp;'a T),
    Owned(T::Owned)
}</code></pre>
<p>This approach ties <code>Borrow</code> directly to the borrowed data, and uses an
associated type to <em>uniquely determine</em> the corresponding owned data type.</p>
<p>For string keys, we would use <code>HashMap&lt;str, V&gt;</code>. Then, the <code>find</code> method would
take an <code>&amp;str</code> key argument, while <code>insert</code> would take an owned <code>String</code>. On the
other hand, for some other type <code>Foo</code> a <code>HashMap&lt;Foo, V&gt;</code> would take
<code>&amp;Foo</code> for <code>find</code> and <code>Foo</code> for <code>insert</code>. (More discussion on the choice of
ownership is given in the <a href="#ownership-management-for-keys">alternatives section</a>.</p>
<p><strong>Benefits of this alternative</strong>:</p>
<ul>
<li>
<p>Unlike the current <code>_equiv</code> or <code>find_with</code> methods, or the proposal in the
RFC, this approach guarantees coherence about hashing or ordering. For example,
<code>HashMap</code> above requires that <code>K</code> (the borrowed key type) is <code>Hash</code>, and will
produce hashes from owned keys by first borrowing from them.</p>
</li>
<li>
<p>Unlike the proposal in this RFC, the signature of the methods for maps is
<em>very simple</em> – essentially the same as the current <code>find</code>, <code>insert</code>, etc.</p>
</li>
<li>
<p>Like the proposal in this RFC, there is only a single <code>Borrow</code>
trait, so it would be possible to standardize on a <code>Map</code> trait later
on and include these APIs. The trait could be made somewhat simpler
with this alternative form of <code>Borrow</code>, but can be provided in
either case; see
<a href="https://github.com/rust-lang/rfcs/pull/235#issuecomment-55976755">these</a>
<a href="https://github.com/rust-lang/rfcs/pull/235#issuecomment-56070223">comments</a>
for details.</p>
</li>
<li>
<p>The <code>Cow</code> data type is simpler than in the RFC’s proposal, since it does not
need a type parameter for the owned data.</p>
</li>
</ul>
<p><strong>Drawbacks of this alternative</strong>:</p>
<ul>
<li>
<p>It’s quite subtle that you want to use <code>HashMap&lt;str, T&gt;</code> rather than
<code>HashMap&lt;String, T&gt;</code>. That is, if you try to use a map in the “obvious way”
you will not be able to use string slices for lookup, which is part of what
this RFC is trying to achieve. The same applies to <code>Cow</code>.</p>
</li>
<li>
<p>The design is somewhat less flexible than the one in the RFC, because (1)
there is a fixed choice of owned type corresponding to each borrowed type and
(2) you cannot use multiple borrow types for lookups at different types
(e.g. using <code>&amp;String</code> sometimes and <code>&amp;str</code> other times). On the other hand,
these restrictions guarantee coherence of hashing/equality/comparison.</p>
</li>
<li>
<p>This version of <code>Borrow</code>, mapping from borrowed to owned data, is
somewhat less intuitive.</p>
</li>
</ul>
<p>On the balance, the approach proposed in the RFC seems better, because using the
map APIs in the obvious ways works by default.</p>
<h4 id="the-hashmapkey-trait-and-friends"><a class="header" href="#the-hashmapkey-trait-and-friends">The <code>HashMapKey</code> trait and friends</a></h4>
<p>An earlier proposal for solving the <code>_equiv</code> problem was given in the
<a href="https://github.com/rust-lang/rfcs/pull/195">associated items RFC</a>):</p>
<pre><code class="language-rust">trait HashMapKey : Clone + Hash + Eq {
    type Query: Hash = Self;
    fn compare(&amp;self, other: &amp;Query) -&gt; bool { self == other }
    fn query_to_key(q: &amp;Query) -&gt; Self { q.clone() };
}

impl HashMapKey for String {
    type Query = str;
    fn compare(&amp;self, other: &amp;str) -&gt; bool {
        self.as_slice() == other
    }
    fn query_to_key(q: &amp;str) -&gt; String {
        q.into_string()
    }
}

impl&lt;K,V&gt; HashMap&lt;K,V&gt; where K: HashMapKey {
    fn find(&amp;self, q: &amp;K::Query) -&gt; &amp;V { ... }
}</code></pre>
<p>This solution has several drawbacks, however:</p>
<ul>
<li>
<p>It requires a separate trait for different kinds of maps – one for <code>HashMap</code>,
one for <code>TreeMap</code>, etc.</p>
</li>
<li>
<p>It requires that a trait be implemented on a given key without providing a
blanket implementation. Since you also need different traits for different
maps, it’s easy to imagine cases where a out-of-crate type you want to use as
a key doesn’t implement the key trait, forcing you to newtype.</p>
</li>
<li>
<p>It doesn’t help with the <code>MaybeOwned</code> problem.</p>
</li>
</ul>
<h4 id="daniel-micays-hack"><a class="header" href="#daniel-micays-hack">Daniel Micay’s hack</a></h4>
<p>@strcat has a <a href="https://github.com/rust-lang/rust/pull/16713">PR</a> that makes it
possible to, for example, coerce a <code>&amp;str</code> to an <code>&amp;String</code> value.</p>
<p>This provides some help for the <code>_equiv</code> problem, since the <code>_equiv</code> methods
could potentially be dropped. However, there are a few downsides:</p>
<ul>
<li>
<p>Using a map with string keys is still a bit more verbose:</p>
<pre><code class="language-rust">map.find("some static string".as_string()) // with the hack
map.find("some static string")             // with this RFC</code></pre>
</li>
<li>
<p>The solution is specialized to strings and vectors, and does not necessarily
support user-defined unsized types or slices.</p>
</li>
<li>
<p>It doesn’t help with the <code>MaybeOwned</code> problem.</p>
</li>
<li>
<p>It exposes some representation interplay between slices and references to
owned values, which we may not want to commit to or reveal.</p>
</li>
</ul>
<h3 id="for-intoiterator"><a class="header" href="#for-intoiterator">For <code>IntoIterator</code></a></h3>
<h4 id="handling-of-for-loops"><a class="header" href="#handling-of-for-loops">Handling of <code>for</code> loops</a></h4>
<p>The fact that <code>for x in v</code> moves elements from <code>v</code>, while <code>for x in v.iter()</code>
yields references, may be a bit surprising. On the other hand, moving is the
default almost everywhere in Rust, and with the proposed approach you get to use <code>&amp;</code> and
<code>&amp;mut</code> to easily select other forms of iteration.</p>
<p>(See
<a href="https://github.com/rust-lang/rfcs/pull/235/files#r17697796">@huon’s comment</a>
for additional drawbacks.)</p>
<p>Unfortunately, it’s a bit tricky to make for use by-ref iterators instead. The
problem is that an iterator is <code>IntoIterator</code>, but it is not <code>Iterable</code> (or
whatever we call the by-reference trait). Why? Because <code>IntoIterator</code> gives you
an iterator that can be used only <em>once</em>, while <code>Iterable</code> allows you to ask for
iterators repeatedly.</p>
<p>If <code>for</code> demanded an <code>Iterable</code>, then <code>for x in v.iter()</code> and <code>for x in v.iter_mut()</code>
would cease to work – we’d have to find some other approach. It might be
doable, but it’s not obvious how to do it.</p>
<h4 id="input-versus-output-type-parameters"><a class="header" href="#input-versus-output-type-parameters">Input versus output type parameters</a></h4>
<p>An important aspect of the <code>IntoIterator</code> design is that the element type is an
associated type, <em>not</em> an input type.</p>
<p>This is a tradeoff:</p>
<ul>
<li>
<p>Making it an associated type means that the <code>for</code> examples work, because the
type of <code>Self</code> uniquely determines the element type for iteration, aiding type
inference.</p>
</li>
<li>
<p>Making it an input type would forgo those benefits, but would allow some
additional flexibility. For example, you could implement <code>IntoIterator&lt;A&gt;</code> for
an iterator on <code>&amp;A</code> when <code>A</code> is cloned, therefore <em>implicitly</em> cloning as
needed to make the ownership work out (and obviating the need for
<code>iter_cloned</code>). However, we have generally kept away from this kind of
implicit magic, <em>especially</em> when it can involve hidden costs like cloning, so
the more explicit design given in this RFC seems best.</p>
</li>
</ul>
<h2 id="downsides"><a class="header" href="#downsides">Downsides</a></h2>
<p>Design tradeoffs were discussed inline.</p>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<h3 id="unresolved-conventionsapis"><a class="header" href="#unresolved-conventionsapis">Unresolved conventions/APIs</a></h3>
<p>As mentioned <a href="#combinations">above</a>, this RFC does not resolve the question of
what to call set operations that update the set in place.</p>
<p>It likewise does not settle the APIs that appear in only single concrete
collections. These will largely be handled through the API stabilization
process, unless radical changes are proposed.</p>
<p>Finally, additional methods provided via the <code>IntoIterator</code> API are left for
future consideration.</p>
<h3 id="coercions"><a class="header" href="#coercions">Coercions</a></h3>
<p>Using the <code>Borrow</code> trait, it might be possible to safely add a coercion for auto-slicing:</p>
<pre><code>  If T: Borrow:
    coerce  &amp;'a T::Owned      to  &amp;'a T
    coerce  &amp;'a mut T::Owned  to  &amp;'a mut T
</code></pre>
<p>For sized types, this coercion is <em>forced</em> to be trivial, so the only time it
would involve running user code is for unsized values.</p>
<p>A general story about such coercions will be left to a
<a href="https://github.com/rust-lang/rfcs/pull/241">follow-up RFC</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="0234-variants-namespace.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="0236-error-conventions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="0234-variants-namespace.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="0236-error-conventions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
