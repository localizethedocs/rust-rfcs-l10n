<!DOCTYPE HTML>
<html lang="en_US" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2045-target-feature - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-0060737d.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Feature Name: <code>target_feature</code> / <code>cfg_target_feature</code> / <code>cfg_feature_enabled</code></li>
<li>Start Date: 2017-06-26</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2045">rust-lang/rfcs#2045</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/44839">rust-lang/rust#44839</a></li>
</ul>
<h2 id="motivation-and-summary"><a class="header" href="#motivation-and-summary">Motivation and Summary</a></h2>
<p>While architectures like <code>x86_64</code> or <code>ARMv8</code> define the lowest-common denominator of instructions that all CPUs must support, many CPUs extend these with vector (<a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a>), bitwise manipulation (<a href="https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets">BMI</a>) and/or cryptographic (<a href="https://en.wikipedia.org/wiki/AES_instruction_set">AES</a>) instruction sets. By default, the Rust compiler produces portable binaries that are able to run on all CPUs of a particular architecture. Users that know in which CPUs their binaries are going to run on are able to allow the compiler to use these extra instructions by using the compiler flags <code>--target-feature</code> and <code>--target-cpu</code>. Running these binaries on mismatching CPUs is undefined behavior. Currently, these users have no way in stable Rust to:</p>
<ul>
<li>determine which features are available at compile-time, and</li>
<li>determine which features are available at run-time, and</li>
<li>embed code for different sets of features into the same binary,</li>
</ul>
<p>such that the programs can use different algorithms depending on the features available, and allowing portable ust binaries to efficiently run on many CPU families of a particular architecture.</p>
<p>The objective of this RFC is to extend the Rust language to solve these three problems, and it does so by adding the following three language features:</p>
<ul>
<li><strong>compile-time feature detection</strong>: using configuration macros <code>cfg!(target_feature = "avx2")</code> to detect whether a feature is enabled or disabled in a context (<code>#![cfg(target_feature = "avx2")]</code>, …),</li>
<li><strong>run-time feature detection</strong>: using the <code>cfg_feature_enabled!("avx2")</code> API to detect whether the current host supports the feature, and</li>
<li><strong>unconditional code generation</strong>: using the function attribute <code>#[target_feature(enable = "avx2")]</code> to allow the compiler to generate code under the assumption that this code will only be reached in hosts that support the feature.</li>
</ul>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed design</a></h2>
<h3 id="target-features"><a class="header" href="#target-features">Target features</a></h3>
<p>Each rustc target has a default set of target features that can be controlled via
the backend compilation options. The target features for each target should
be documented by the compiler and the backends (e.g. LLVM).</p>
<p>This RFC does not add any target features to the language but it
specifies the process for adding target features. Each target feature must:</p>
<ul>
<li>Be proposed in its own mini-RFC, RFC, or rustc-issue and follow a FCP period,</li>
<li>Be behind its own feature gate macro of the form <code>target_feature_feature_name</code>
(where <code>feature_name</code> should be replaced by the name of the feature ).</li>
<li>When possible, be detectable at run-time via the <code>cfg_feature_enabled!("name")</code> API.</li>
<li>Include whether some backend-specific compilation options should enable the
feature.</li>
</ul>
<p>To use unstable target features on nightly, crates must opt into them as usual by
writing, for example, <code>#![allow(target_feature_avx2)]</code>. Since this is currently
not required, a grace period of one full release cycle will be given in which
this will raise a soft error before turning this requirement into a hard error.</p>
<h3 id="backend-compilation-options"><a class="header" href="#backend-compilation-options">Backend compilation options</a></h3>
<p>There are currently two ways of passing target feature information to rustc’s code
generation backend on stable Rust.</p>
<ul>
<li>
<p><code>-C --target-feature=+/-backend_target_feature_name</code>: where <code>+/-</code> add/remove
features from the default feature set of the platform for the whole crate.</p>
</li>
<li>
<p><code>-C --target-cpu=backend_cpu_name</code>, which changes the default feature set of
the crate to be that of all features enabled for <code>backend_cpu_name</code>.</p>
</li>
</ul>
<p>These two options are available on stable Rust and have been defacto stabilized.
Their semantics are LLVM specific and depend on what LLVM actually does with the
features.</p>
<p>This RFC proposes to keep these options “as is”, and add one new compiler option,
<code>--enable-features="feature0,feature1,..."</code>, (the analogous <code>--disable-features</code>
is discussed in the “Future Extensions” section) that supports only stabilized
target features.</p>
<p>This allows us to preserve backwards compatibility while choosing different feature
names and semantics than the ones provided by the LLVM backend.</p>
<p>The effect of <code>--enable-features=feature-list</code> is to enable all features implicitly
for all functions of a crate. That is, anywhere within the crate the values of the macro
<code>cfg!(target_feature = "feature")</code> and <code>cfg_feature_enabled!("feature")</code> are <code>true</code>.</p>
<p>Whether the backend compilation options <code>-C --target-feature/--target-cpu</code> also enable
some stabilized features or not should be resolved by the RFCs suggesting the stabilization
of particular target features.</p>
<h3 id="unconditional-code-generation-target_feature"><a class="header" href="#unconditional-code-generation-target_feature">Unconditional code generation: <code>#[target_feature]</code></a></h3>
<p>(note: the function attribute <code>#[target_feature]</code> is similar to clang’s and
gcc’s
<a href="https://clang.llvm.org/docs/AttributeReference.html#target-gnu-target"><code>__attribute__ ((__target__ ("feature")))</code></a>.)</p>
<p>This RFC introduces a function attribute that only applies to unsafe functions: <a href="https://github.com/rust-lang/rust/pull/38079"><code>#[target_feature(enable = "feature_list")]</code></a> (the analogous <code>#[target_feature(disable = "feature_list")]</code> is discussed in the “Future Extensions” section):</p>
<ul>
<li>This attribute <em>extends</em> the feature set of a function beyond its default feature set, which <em>allows</em> the compiler to generate code under the assumption that the function’s code will only be reached on hardware that supports its feature set.</li>
<li>Calling a function on a target that does not support its features is <em>undefined behavior</em> (see the “On the unsafety of <code>#[target_feature]</code>” section).</li>
<li>The compiler will not inline functions in contexts that do not support all the functions features.</li>
<li>In <code>#[target_feature(enable = "feature")]</code> functions the value of <code>cfg!(target_feature = "feature")</code> and <code>cfg_feature_enabled!("feature")</code> is always <code>true</code> (otherwise undefined behavior did already happen).</li>
</ul>
<p>Note 0: the current RFC does not introduce any ABI issues in stable Rust. ABI issues with some unstable language features are explored in the “Unresolved Questions” section.</p>
<p>Note 1: a function has the features of the crate where the function is defined +/- <code>#[target_feature]</code> annotations. Iff the function
is inlined into a context that extends its feature set, then the compiler is allowed to generate code for the function using this extended feature set (sub-note: inlining is forbidden in the opposite case).</p>
<p><strong>Example 0 (basics):</strong></p>
<p>This example covers how to use <code>#[target_feature]</code> with run-time feature detection to dispatch to different
function implementations depending on the features supported by the CPU at run-time:</p>
<pre><code class="language-rust">// This function will be optimized for different targets
#[inline(always)] fn foo_impl() { ... }

// This generates a stub for CPUs that support SSE4:
#[target_feature(enable = "sse4")] unsafe fn foo_sse4() {
    // Inlining `foo_impl` here is fine because `foo_sse4`
    // extends `foo_impl` feature set
    foo_impl()
}

// This generates a stub for CPUs that support AVX:
#[target_feature(enable = "avx")] unsafe fn foo_avx() { foo_impl() }

// This function returns the best implementation of `foo` depending
// on which target features the host CPU does support at run-time:
fn initialize_global_foo_ptr() -&gt; fn () -&gt; () {
    if cfg_feature_enabled!("avx") {
      unsafe { foo_avx }
    } else if cfg_feature_enabled!("sse4") {
      unsafe { foo_sse4 }
    } else {
      foo_impl // use the default version
    }
}

// During binary initialization we can set a global function pointer
// to the best implementation of foo depending on the features that
// the CPU where the binary is running does support:
lazy_static! {
    static ref GLOBAL_FOO_PTR: fn() -&gt; () = {
        initialize_foo()
    };
}
// ^^ note: the ABI of this function pointer is independent of the target features


fn main() {
  // Finally, we can use the function pointer to dispatch to the best implementation:
  global_foo_ptr();
}</code></pre>
<p><strong>Example 1 (inlining):</strong></p>
<pre><code class="language-rust">#[target_feature(enable = "avx")] unsafe fn foo();
#[target_feature(enable = "avx")] #[inline] unsafe fn baz(); // OK
#[target_feature(enable = "avx")] #[inline(always)] unsafe fn bar(); // OK

#[target_feature(enable = "sse3")]
unsafe fn moo() {
  // This function supports SSE3 but not AVX
  if cfg_feature_enabled!("avx") {
      foo(); // OK: foo is not inlined into moo
      baz(); // OK: baz is not inlined into moo
      bar();
      // ^ ERROR: bar cannot be inlined across mismatching features
      // did you meant to make bar #[inline] instead of #[inline(always)]?
      // Note: the logic to detect this is the same as for the call
      // to baz, but in this case rustc must emit an error because an
      // #[inline(always)] function cannot be inlined in this call site.
  }
}</code></pre>
<h3 id="conditional-compilation-cfgtarget_feature"><a class="header" href="#conditional-compilation-cfgtarget_feature">Conditional compilation: <code>cfg!(target_feature)</code></a></h3>
<p>The
<a href="https://github.com/rust-lang/rust/issues/29717"><code>cfg!(target_feature = "feature_name")</code></a> macro
allows querying at compile-time whether a target feature is enabled in the
current context. It returns <code>true</code> if the feature is enabled, and <code>false</code>
otherwise.</p>
<p>In a function annotated with <code>#[target_feature(enable = "feature_name")]</code> the macro
<code>cfg!(target_feature = "feature_name")</code> expands to <code>true</code> if the generated
code for the function uses the feature (<a href="https://github.com/rust-lang/rust/issues/42515">current bug</a>.</p>
<p>Note: how accurate <code>cfg!(target_feature)</code> can be made is an “Unresolved Question” (see the section below). Ideally, when <code>cfg!(target_feature)</code> is used in a function that does not support the feature, it should still return true in the cases where the function gets inlined into a context that does support the feature. This can happen often if the function is generic, or an <code>#[inline]</code> function defined in a different crate. This can results in errors at monomorphization time only if <code>#![cfg(target_feature)]</code> is used, but not if <code>if cfg!(target_feature)</code> is used since in this case all branches need to type-check properly.</p>
<p><strong>Example 3 (conditional compilation):</strong></p>
<pre><code class="language-rust">fn bzhi_u32(x: u32, bit_position: u32) -&gt; u32 {
    // Conditional compilation: both branches must be syntactically valid,
    // but it suffices that the true branch type-checks:
    #[cfg(target_feature = "bmi2")] {
        // if this code is being compiled with BMI2 support, use a BMI2 instruction:
        unsafe { intrinsic::bmi2::bzhi(x, bit_position) }
    }
    #[cfg(not(target_feature = "bmi2"))] {
        // otherwise, call a portable emulation of the BMI2 instruction
        portable_emulation::bzhi(x, bit_position)
    }
}

fn bzhi_u64(x: u64, bit_position: u64) -&gt; u64 {
    // Here both branches must type-check and whether the false branch is removed
    // or not is left up to the optimizer.
    if cfg!(target_feature = "bmi2") {  // `cfg!` expands to `true` or `false` at compile-time
        // if target has the BMI2 instruction set, use a BMI2 instruction:
        unsafe { intrinsic::bmi2::bzhi(x, bit_position) }
        // ^^^ NOTE: this function cannot be inlined unless `bzhi_u64` supports
        // the required features
    } else {
        // otherwise call an algorithm that emulates the instruction:
        portable_emulation::bzhi(x, bit_position)
    }
}</code></pre>
<p><strong>Example 4 (value of <code>cfg!</code> within <code>#[target_feature]</code>):</strong></p>
<pre><code class="language-rust">#[target_feature("+avx")]
unsafe fn foo() {
  if cfg!(target_feature = "avx") { /* this branch is always taken */ }
  else { /* this branch is never taken */ }
  #[cfg(not(target_feature = "avx"))] {
    // this is dead code
  }
}</code></pre>
<h3 id="run-time-feature-detection"><a class="header" href="#run-time-feature-detection">Run-time feature detection</a></h3>
<p>Writing safe wrappers around <code>unsafe</code> functions annotated with
<code>#[target_feature]</code> requires run-time feature detection. This RFC adds the following
macro to the standard library:</p>
<ul>
<li><code>cfg_feature_enabled!("feature") -&gt; bool-expr</code></li>
</ul>
<p>with the following semantics: “if the host hardware on which the current code is running
supports the <code>"feature"</code>, the <code>bool-expr</code> that <code>cfg_feature_enabled!</code> expands to has
value <code>true</code>, and <code>false</code> otherwise.</p>
<p>If the result is known at compile-time, the macro approach allows expanding the result
without performing any run-time detection at all. This RFC does not guarantee that this
is the case, but <a href="https://github.com/rust-lang-nursery/stdsimd">the current implementation</a>
does this.</p>
<p>Examples of using run-time feature detection have been shown throughout this RFC, there
isn’t really more to it.</p>
<p>If the API of run-time feature detection turns out to be controversial before
stabilization, a follow-up RFC that focus on run-time feature detection will need
to be merged, blocking the stabilization of this RFC.</p>
<h2 id="how-we-teach-this"><a class="header" href="#how-we-teach-this">How We Teach This</a></h2>
<p>There are two parts to this story, the low-level part, and the high-level part.</p>
<p><strong>Example 5 (high-level usage of target features):</strong></p>
<p><strong>note</strong>: <code>ifunc</code> is not part of this RFC, but just an example of what can be built on top of it.</p>
<p>In the high-level part we have the <code>ifunc</code> function attribute, implemented as a procedural macro (some of these macros <a href="https://github.com/alexcrichton/cfg-specialize/blob/master/cfg-specialize-macros">already</a> <a href="https://github.com/parched/runtime-target-feature-rs">exist</a>):</p>
<pre><code class="language-rust">#[ifunc("default", "sse4", "avx", "avx2")]  //&lt; MAGIC
fn foo() {}

fn main() {
  foo(); // dispatches to the best implementation at run-time
  #[cfg(target_feature = "sse4")] {
    foo(); // dispatches to the sse4 implementation at compile-time
  }
}</code></pre>
<p>The following example covers what <code>ifunc</code> might expand to.</p>
<p><strong>Example 6 (ifunc expansion):</strong></p>
<pre><code class="language-rust">// Copy-pastes "foo" and generates code for multiple target features:
unsafe fn foo_default() { ...foo tokens... }
#[target_feature(enable = "sse4")] unsafe fn foo_sse4() { ...foo tokens... }
#[target_feature(enable = "avx")]  unsafe fn foo_avx() { ...foo tokens... }
#[target_feature(enable = "avx2")] unsafe fn foo_avx2() { ...foo tokens... }

// Initializes `foo` on binary initialization
static foo_ptr: fn() -&gt; () = initialize_foo();

fn initialize_foo() -&gt; typeof(foo) {
    // run-time feature detection:
    if cfg_feature_enabled!("avx2")  { return unsafe { foo_avx2 } }
    if cfg_feature_enabled!("avx")  { return unsafe { foo_avx } }
    if cfg_feature_enabled!("sse4")  { return unsafe { foo_sse4 } }
    foo_default
}

// Wrap foo to do compile-time dispatch
#[inline(always)] fn foo() {
  #[cfg(target_feature = "avx2")]
  { unsafe { foo_avx2() } }
  #[cfg(and(target_feature = "avx"), not(target_feature = "avx2")))]
  { unsafe { foo_avx() } }
  #[cfg(and(not(target_feature = "sse4")), not(target_feature = "avx")))]
  { unsafe { foo_sse4() } }
  #[cfg(not(target_feature = "sse4"))]
  { foo_ptr() }
}</code></pre>
<p>Note that there are many solutions to this problem and they have different
trade-offs, but these can be explored in procedural macros. When wrapping unsafe
intrinsics, conditional compilation can be used to create zero-cost wrappers:</p>
<p><strong>Example 7 (three-layered approach to target features):</strong></p>
<pre><code class="language-rust">// Raw unsafe intrinsic: in LLVM, std::intrinsic, etc.
// Calling this on an unsupported target is undefined behavior.
extern "C" { fn raw_intrinsic_function(f64, f64) -&gt; f64; }

// Software emulation of the intrinsic,
// works on all architectures.
fn software_emulation_of_raw_intrinsic_function(f64, f64) -&gt; f64;

// Safe zero-cost wrapper over the intrinsic
// (i.e. can be inlined)
fn my_intrinsic(a: f64, b: f64) -&gt; f64 {
  #[cfg(target_feature = "some_feature")] {
    // If "some_feature" is enabled, it is safe to call the
    // raw intrinsic function
    unsafe { raw_intrinsic_function(a, b) }
  }
  #[cfg(not(target_feature = "some_feature"))] {
     // if "some_feature" is disabled calling
     // the raw intrinsic function is undefined behavior (per LLVM),
     // we call the safe software emulation of the intrinsic:
     software_emulation_of_raw_intrinsic_function(a, b)
  }
}

#[ifunc("default", "avx")]
fn my_intrinsic_rt(a: f64, b: f64) -&gt; f64 { my_intrinsic(a, b) }</code></pre>
<p>Due to the low-level and high-level nature of these feature we will need two
kinds of documentation. For the low level part:</p>
<ul>
<li>document how to do compile-time and run-time feature detection using <code>cfg!(target_feature)</code> and <code>cfg_feature_enabled!</code>,</li>
<li>document how to use <code>#[target_feature]</code>,</li>
<li>document how to use all of these together to solve problems like in the examples of this RFC.</li>
</ul>
<p>For the high-level part we should aim to bring third-party crates implementing
<code>ifunc!</code> or similar close to 1.0 releases before stabilization.</p>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<ul>
<li>Obvious increase in language complexity.</li>
</ul>
<p>The main drawback of not solving this issue is that many libraries that require
conditional feature-dependent compilation or run-time selection of code for
different features (SIMD, BMI, AES, …) cannot be written efficiently in stable
Rust.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<h2 id="backend-options"><a class="header" href="#backend-options">Backend options</a></h2>
<p>An alternative would be to mix stable, unstable, unknown,
and backend-specific features into <code>--target-feature</code>.</p>
<h3 id="make-target_feature-safe"><a class="header" href="#make-target_feature-safe">Make <code>#[target_feature]</code> safe</a></h3>
<p>Calling a function annotated with <code>#[target_feature]</code> on a host that does not
support the feature invokes undefined behavior in LLVM, the assembler, and
possibly the hardware <a href="https://github.com/rust-lang/rfcs/pull/2045#issuecomment-311325202">See this comment</a>.</p>
<p>That is, calling a function on a target that does not support its feature set is
<em>undefined behavior</em> and this RFC cannot specify otherwise. The main reason is that <code>target_feature</code> is a promise from the user to the toolchain and the hardware, that the code will not be reached in a CPU that does not support the feature. LLVM, the assembler, and the hardware all assume that the user will not violate this contract, and there is little that the Rust compiler can do to make this safer:</p>
<ul>
<li>The Rust compiler cannot emit a compile-time diagnostic because it cannot know whether the user is going to run the binary in a CPU that supports the features or not.</li>
<li>A run-time diagnostic <em>always</em> incurs a run-time cost, and is only possible iff the absence of a feature can be detected at run-time (the “Future Extensions” section of this RFC discusses how to implement “Run-time diagnostics” to detect this, when possible).</li>
</ul>
<p>However, the <code>--target-feature/--target-cpu</code> compiler options allows one to implicitly generate binaries that reliably run into undefined behavior without needing any <code>unsafe</code> annotations at all, so the answer to the question “Should <code>#[target_feature]</code> be safe/unsafe?” is indeed a hard one.</p>
<p>The main differences between <code>#[target_feature]</code> and <code>--target-feature</code>/<code>--enable-feature</code> are the following:</p>
<ul>
<li><code>--target-feature/--enable-feature</code> are “backend options” while <code>#[target_feature]</code> is part of the language</li>
<li><code>--target-feature/--enable-feature</code> is specified by whoever compiles the code, while <code>#[target_feature]</code> is specified by whoever writes the code</li>
<li>compiling safe Rust code for a particular target, and then running the binary on that target, can only produce undefined behavior iff <code>#[target_feature]</code> is safe.</li>
</ul>
<p>This RFC chooses that the <code>#[target_feature]</code> attribute only applies to <code>unsafe fn</code>s, so that if one compiles safe Rust source code for a particular target, and then runs the binary on that particular target, no unsafety can result.</p>
<p>Note that we can always make <code>#[target_feature]</code> safe in the future without breaking backwards compatibility, but the opposite is not true. That is, if somebody figures out a way of making <code>#[target_feature]</code> safe such that the above holds, we can always make that change.</p>
<h3 id="guarantee-no-segfaults-from-unsafe-code"><a class="header" href="#guarantee-no-segfaults-from-unsafe-code">Guarantee no segfaults from <code>unsafe</code> code</a></h3>
<p>Calling a <code>#[target_feature]</code>-annotated function on a platform that does not
support it invokes undefined behavior. We could guarantee that this does not
happen by always doing run-time feature detection, introducing a run-time cost
in the process, and by only accepting features for which run-time feature
detection can be done.</p>
<p>This RFC considers that any run-time cost is unacceptable as a default
for a combination of language features whose main domain of use is a performance
sensitive one.</p>
<p>The “Future Extension“s section discusses how to implement this in an opt-in way,
e.g., as a sort of binary instrumentation.</p>
<h3 id="make-target_feature--inlinealways-incompatible"><a class="header" href="#make-target_feature--inlinealways-incompatible">Make <code>#[target_feature] + #[inline(always)]</code> incompatible</a></h3>
<p>This RFC requires the compiler to error when a function marked with both <code>#[target_feature]</code> and the <code>#[inline(always)]</code> attribute cannot be inlined in a particular call site due to incompatible features. So we might consider to simplify this RFC by just making these attributes incompatible.</p>
<p>While this is technically correct, the compiler must detect when any function (<code>#[inline(always)]</code>, <code>#[inline]</code>, generics, …) is inlined into an incompatible context, and prevent this from happening. Erroring if the function is <code>#[inline(always)]</code> does not significantly simplify the RFC nor the compiler implementation.</p>
<h3 id="removing-run-time-feature-detection-from-this-rfc"><a class="header" href="#removing-run-time-feature-detection-from-this-rfc">Removing run-time feature detection from this RFC</a></h3>
<p>This RFC adds an API for run-time feature detection to the
standard library.</p>
<p>The alternative would be to implement similar functionality as a third-party crate that
might eventually be moved into the nursery. <a href="https://docs.rs/cupid/">Such crates already exist</a></p>
<p>In particular, the API proposed in this RFC is “stringly-typed” (to make it uniform with the other features being proposed), but arguably a third party crate might want to use an <code>enum</code> to allow pattern-matching on features. These APIs have not been sufficiently explored in the ecosystem yet.</p>
<p>The main arguments in favor of including run-time feature detection in this RFC are:</p>
<ul>
<li>it is impossible to write safe wrappers around <code>#[target_feature]</code> without it</li>
<li>implementing it requires the <code>asm!</code> macro or linking to a C library (or linking
to a C wrapper around assembly),</li>
<li>run-time detection should be kept in sync with the addition of new target features,</li>
<li>the compiler might want to use LLVM’s run-time feature detection which is part
of compiler-rt.</li>
</ul>
<p>The consensus in the internal forums and previous discussions seem to be that this
is worth it.</p>
<p>It might turn out that the people from the future are able to come up with a better
API. But in that case we can always deprecate the current API and include the new
one in the standard library.</p>
<h3 id="adding-full-cpuid-support-to-the-standard-library"><a class="header" href="#adding-full-cpuid-support-to-the-standard-library">Adding full cpuid support to the standard library</a></h3>
<p>The <code>cfg_feature_enable!</code> macro is designed to work specifically with the features
that can be used via <code>cfg_target_feature</code> and <code>#[target_feature]</code>. However, in the
grand scheme of things, run-time detection of these features is only a small part
of the information provided by <code>cpuid</code>-like CPU instructions.</p>
<p>Currently at least two great implementations of cpuid-like functionality exists in
Rust for x86: <a href="https://github.com/shepmaster/cupid">cupid</a> and
<a href="https://github.com/gz/rust-cpuid">rust-cpuid</a>. Adding the macro to the standard library
does not prevent us from adding more comprehensive functionality in the future, and
it does not prevent us from reusing any of these libraries in the internal
implementation of the macro.</p>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<h3 id="how-accurate-should-cfgfeature-be"><a class="header" href="#how-accurate-should-cfgfeature-be">How accurate should cfg!(feature) be?</a></h3>
<p>What happens if the macro <code>cfg!(target_feature = "feature_name")</code> is used inside a function for which <code>feature_name</code> is not enabled, but that function gets inlined into a context in which the feature is enabled? We want the macro to accurately return <code>true</code> in this case, that is, to be as accurate as possible so that users always get the most efficient algorithms, but whether this is even possible is an unresolved question.</p>
<p>This might result in monomorphization errors if <code>#![cfg(target_feature)]</code> is used, but not if <code>if cfg!(target_feature)</code> is used since in this case all branches need to type-check properly.</p>
<p>We might want to amend this RFC with more concrete semantics about this as we improve the compiler.</p>
<h3 id="how-do-we-handle-abi-issues-with-portable-vector-types"><a class="header" href="#how-do-we-handle-abi-issues-with-portable-vector-types">How do we handle ABI issues with portable vector types?</a></h3>
<p>The ABI of <code>#[target_feature]</code> functions does not change for all types currently available in stable Rust. However, there are types that we might want to add to the language at some point, like portable vector types, for which this is not the case.</p>
<p>The behavior of <code>#[target_feature]</code> for those types should be specified in the RFC that proposes to stabilize those types, and this RFC should be amended as necessary.</p>
<p>The following examples showcase some potential problems when calling functions with mismatching ABIs, or when using function pointers.</p>
<p>Whether we can warn, or hard error at compile-time in these cases remains to be explored.</p>
<p><strong>Example 8 (ABI):</strong></p>
<pre><code class="language-rust">#[target_feature(enable = "sse2")]
unsafe fn foo_sse2(a: f32x8) -&gt; f32x8 { a } // ABI: 2x 128bit registers

#[target_feature(enable = "avx2")]
unsafe fn foo_avx2(a: f32x8) -&gt; f32x8 { // ABI: 1x 256bit register
  foo_sse2(a) // ABI mismatch:
  //^ should this perform an implicit conversion, produce a hard error, or just undefined behavior?
}

#[target_feature(enable = "sse2")]
unsafe fn bar() {
  type fn_ptr = fn(f32x8) -&gt; f32x8;
  let mut p0: fn_ptr = foo_sse2; // OK
  let p1: fn_ptr = foo_avx2; // ERROR: mismatching ABI
  let p2 = foo_avx2; // OK
  p0 = p2; // ERROR: mismatching ABI
}</code></pre>
<h2 id="future-extensions"><a class="header" href="#future-extensions">Future Extensions</a></h2>
<h3 id="mutually-exclusive-features"><a class="header" href="#mutually-exclusive-features">Mutually exclusive features</a></h3>
<p>In some cases, e.g., when enabling AVX but disabling SSE4 the compiler should probably produce an error, but for other features like <code>thumb_mode</code> the behavior is less clear. These issues should be addressed by the RFC proposing the stabilizaiton of the target features that need them, as future extensions to this RFC.</p>
<h3 id="safely-inlining-target_feature-functions-on-more-contexts"><a class="header" href="#safely-inlining-target_feature-functions-on-more-contexts">Safely inlining <code>#[target_feature]</code> functions on more contexts</a></h3>
<p>The problem is the following:</p>
<pre><code class="language-rust">#[target_feature(enable = "sse3")]
unsafe fn baz() {
    if some_opaque_code() {
        unsafe { foo_avx2(); }
    }
}</code></pre>
<p>If <code>foo_avx2</code> gets inlined into <code>baz</code>, optimizations that reorder its instructions
across the if condition might introduce undefined behavior.</p>
<p>Maybe, one could make <code>cfg_feature_enabled!</code> a bit magical, so that when it is
used in the typical ways the compiler can infer whether inlining is safe, e.g.,</p>
<pre><code class="language-rust">#[target_feature(enable = "sse3")]
unsafe fn baz() {
  // -- sse3 boundary start (applies to fn arguments as well)
  // -- sse3 boundary ends
  if cfg_feature_enabled!("avx") {
    // -- avx boundary starts
    unsafe { foo_avx(); }
    //    can be inlined here, but its code cannot be
    //    reordered out of the avx boundary
    // -- avx boundary ends
  }
  // -- sse3 boundary starts
  // -- sse3 boundary ends (applies to drop as well)
}</code></pre>
<p>Whether this is worth it or can be done at all is an unresolved question. This RFC does not propose any of this, but leaves the door open for such an extension to be explored and proposed independently in a follow-up RFC.</p>
<h3 id="run-time-diagnostics"><a class="header" href="#run-time-diagnostics">Run-time diagnostics</a></h3>
<p>Calling a <code>#[target_feature]</code>-annotated function on a platform that does not
support it invokes undefined behavior. A friendly compiler could use run-time
feature detection to check whether calling the function is safe and emit a nice
<code>panic!</code> message.</p>
<p>This can be done, for example, by desugaring this:</p>
<pre><code class="language-rust">#[target_feature(enable = "avx")] unsafe fn foo();</code></pre>
<p>into this:</p>
<pre><code class="language-rust">#[target_feature(enable = "avx")] unsafe fn foo_impl() { ...foo tokens... };

// this function will be called if avx is not available:
fn foo_fallback() {
    panic!("calling foo() requires a target with avx support")
}

// run-time feature detection on initialization
static foo_ptr: fn() -&gt; () = if cfg_feature_enabled!("avx") {
    unsafe { foo_impl }
} else {
    foo_fallback
};

// dispatches foo via function pointer to produce nice diagnostic
unsafe fn foo() { foo_ptr() }</code></pre>
<p>This is not required for safety and can be implemented into the compiler as an opt-in instrumentation pass without
going through the RFC process. However, a proposal to enable this by default should go through the RFC process.</p>
<h3 id="disabling-features"><a class="header" href="#disabling-features">Disabling features</a></h3>
<p>This RFC does not allow disabling target features, but suggest an analogous syntax to do so (<code>#[target_feature(disable = "feature-list")]</code>, <code>--disable-feature=feature-list</code>). Disabling features can result in some <a href="https://internals.rust-lang.org/t/pre-rfc-stabilization-of-target-feature/5176/26">non-sensical situations</a> and should be pursued as a future extension of this RFC once we want to stabilize a target feature for which it makes sense.</p>
<h2 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h2>
<p>@parched @burntsushi @alexcrichton @est31 @pedrocr @chandlerc @RalfJung @matthieu-m</p>
<ul>
<li><code>#[target_feature]</code> Pull-Request: https://github.com/rust-lang/rust/pull/38079</li>
<li><code>cfg_target_feature</code> tracking issue: https://github.com/rust-lang/rust/issues/29717</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="2044-license-rfcs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="2046-label-break-value.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="2044-license-rfcs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="2046-label-break-value.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
