<!DOCTYPE HTML>
<html lang="zh_TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>0550-macro-future-proofing - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-c5bb60c5.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Start Date: 2014-12-21</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/550">550</a></li>
<li>Rust Issues:
<ul>
<li><a href="https://github.com/rust-lang/rust/pull/20563">20563</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/31135">31135</a></li>
</ul>
</li>
</ul>
<h2 id="摘要"><a class="header" href="#摘要">摘要</a></h2>
<p>Future-proof the allowed forms that input to an MBE can take by requiring certain delimiters following NTs in a matcher. In the future, it will be possible to lift these restrictions backwards compatibly if desired.</p>
<h2 id="key-terminology"><a class="header" href="#key-terminology">Key Terminology</a></h2>
<ul>
<li><code>macro</code>: anything invocable as <code>foo!(...)</code> in source code.</li>
<li><code>MBE</code>: macro-by-example, a macro defined by <code>macro_rules</code>.</li>
<li><code>matcher</code>: the left-hand-side of a rule in a <code>macro_rules</code> invocation, or a subportion thereof.</li>
<li><code>macro parser</code>: the bit of code in the Rust parser that will parse the input using a grammar derived from all of the matchers.</li>
<li><code>fragment</code>: The class of Rust syntax that a given matcher will accept (or “match”).</li>
<li><code>repetition</code> : a fragment that follows a regular repeating pattern</li>
<li><code>NT</code>: non-terminal, the various “meta-variables” or repetition matchers that can appear in a matcher, specified in MBE syntax with a leading <code>$</code> character.</li>
<li><code>simple NT</code>: a “meta-variable” non-terminal (further discussion below).</li>
<li><code>complex NT</code>: a repetition matching non-terminal, specified via Kleene closure operators (<code>*</code>, <code>+</code>).</li>
<li><code>token</code>: an atomic element of a matcher; i.e. identifiers, operators, open/close delimiters, <em>and</em> simple NT’s.</li>
<li><code>token tree</code>: a tree structure formed from tokens (the leaves), complex NT’s, and finite sequences of token trees.</li>
<li><code>delimiter token</code>: a token that is meant to divide the end of one fragment and the start of the next fragment.</li>
<li><code>separator token</code>: an optional delimiter token in an complex NT that separates each pair of elements in the matched repetition.</li>
<li><code>separated complex NT</code>: a complex NT that has its own separator token.</li>
<li><code>delimited sequence</code>: a sequence of token trees with appropriate open- and close-delimiters at the start and end of the sequence.</li>
<li><code>empty fragment</code>: The class of invisible Rust syntax that separates tokens, i.e. whitespace, or (in some lexical contexts), the empty token sequence.</li>
<li><code>fragment specifier</code>: The identifier in a simple NT that specifies which fragment the NT accepts.</li>
<li><code>language</code>: a context-free language.</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust">macro_rules! i_am_an_mbe {
    (start $foo:expr $($i:ident),* end) =&gt; ($foo)
}</code></pre>
<p><code>(start $foo:expr $($i:ident),* end)</code> is a matcher. The whole matcher is a delimited sequence (with open- and close-delimiters <code>(</code> and <code>)</code>), and <code>$foo</code> and <code>$i</code> are simple NT’s with <code>expr</code> and <code>ident</code> as their respective fragment specifiers.</p>
<p><code>$(i:ident),*</code> is <em>also</em> an NT; it is a complex NT that matches a comma-separated repetition of identifiers. The <code>,</code> is the separator token for the complex NT; it occurs in between each pair of elements (if any) of the matched fragment.</p>
<p>Another example of a complex NT is <code>$(hi $e:expr ;)+</code>, which matches any fragment of the form <code>hi &lt;expr&gt;; hi &lt;expr&gt;; ...</code> where <code>hi &lt;expr&gt;;</code> occurs at least once. Note that this complex NT does not have a dedicated separator token.</p>
<p>(Note that Rust’s parser ensures that delimited sequences always occur with proper nesting of token tree structure and correct matching of open- and close-delimiters.)</p>
<h2 id="動機"><a class="header" href="#動機">動機</a></h2>
<p>In current Rust (version 0.12; i.e. pre 1.0), the <code>macro_rules</code> parser is very liberal in what it accepts in a matcher. This can cause problems, because it is possible to write an MBE which corresponds to an ambiguous grammar. When an MBE is invoked, if the macro parser encounters an ambiguity while parsing, it will bail out with a “local ambiguity” error. As an example for this, take the following MBE:</p>
<pre><code class="language-rust">macro_rules! foo {
    ($($foo:expr)* $bar:block) =&gt; (/*...*/)
};</code></pre>
<p>Attempts to invoke this MBE will never succeed, because the macro parser will always emit an ambiguity error rather than make a choice when presented an ambiguity. In particular, it needs to decide when to stop accepting expressions for <code>foo</code> and look for a block for <code>bar</code> (noting that blocks are valid expressions). Situations like this are inherent to the macro system. On the other hand, it’s possible to write an unambiguous matcher that becomes ambiguous due to changes in the syntax for the various fragments. As a concrete example:</p>
<pre><code class="language-rust">macro_rules! bar {
    ($in:ty ( $($arg:ident)*, ) -&gt; $out:ty;) =&gt; (/*...*/)
};</code></pre>
<p>When the type syntax was extended to include the unboxed closure traits, an input such as <code>FnMut(i8, u8) -&gt; i8;</code> became ambiguous. The goal of this proposal is to prevent such scenarios in the future by requiring certain “delimiter tokens” after an NT. When extending Rust’s syntax in the future, ambiguity need only be considered when combined with these sets of delimiters, rather than any possible arbitrary matcher.</p>
<hr>
<p>Another example of a potential extension to the language that motivates a restricted set of “delimiter tokens” is (<a href="https://github.com/rust-lang/rfcs/issues/961">postponed</a>) <a href="https://github.com/rust-lang/rfcs/pull/352">RFC 352</a>, “Allow loops to return values other than <code>()</code>”, where the <code>break</code> expression would now accept an optional input expression: <code>break &lt;expr&gt;</code>.</p>
<ul>
<li>
<p>This proposed extension to the language, combined with the facts that <code>break</code> and <code>{ &lt;stmt&gt; ... &lt;expr&gt;? }</code> are Rust expressions, implies that <code>{</code> should not be in the follow set for the <code>expr</code> fragment specifier.</p>
</li>
<li>
<p>Thus in a slightly more ideal world the following program would not be accepted, because the interpretation of the macro could change if we were to accept RFC 352:</p>
<pre><code class="language-rust">macro_rules! foo {
    ($e:expr { stuff }) =&gt; { println!("{:?}", $e) }
}

fn main() {
    loop { foo!(break { stuff }); }
}</code></pre>
<p>(in our non-ideal world, the program is legal in Rust versions 1.0 through at least 1.4)</p>
</li>
</ul>
<h2 id="詳細設計"><a class="header" href="#詳細設計">詳細設計</a></h2>
<p>We will tend to use the variable “M” to stand for a matcher, variables “t” and “u” for arbitrary individual tokens, and the variables “tt” and “uu” for arbitrary token trees. (The use of “tt” does present potential ambiguity with its additional role as a fragment specifier; but it will be clear from context which interpretation is meant.)</p>
<p>“SEP” will range over separator tokens, “OP” over the Kleene operators <code>*</code> and <code>+</code>, and “OPEN”/“CLOSE” over matching token pairs surrounding a delimited sequence (e.g. <code>[</code> and <code>]</code>).</p>
<p>We also use Greek letters “α” “β” “γ” “δ” to stand for potentially empty token-tree sequences. (However, the Greek letter “ε” (epsilon) has a special role in the presentation and does not stand for a token-tree sequence.)</p>
<ul>
<li>This Greek letter convention is usually just employed when the presence of a sequence is a technical detail; in particular, when I wish to <em>emphasize</em> that we are operating on a sequence of token-trees, I will use the notation “tt …” for the sequence, not a Greek letter</li>
</ul>
<p>Note that a matcher is merely a token tree. A “simple NT”, as mentioned above, is an meta-variable NT; thus it is a non-repetition. For example, <code>$foo:ty</code> is a simple NT but <code>$($foo:ty)+</code> is a complex NT.</p>
<p>Note also that in the context of this RFC, the term “token” generally <em>includes</em> simple NTs.</p>
<p>Finally, it is useful for the reader to keep in mind that according to the definitions of this RFC, no simple NT matches the empty fragment, and likewise no token matches the empty fragment of Rust syntax. (Thus, the <em>only</em> NT that can match the empty fragment is a complex NT.)</p>
<h3 id="the-matcher-invariant"><a class="header" href="#the-matcher-invariant">The Matcher Invariant</a></h3>
<p>This RFC establishes the following two-part invariant for valid matchers</p>
<ol>
<li>
<p>For any two successive token tree sequences in a matcher <code>M</code> (i.e. <code>M = ... tt uu ...</code>), we must have FOLLOW(<code>... tt</code>) ⊇ FIRST(<code>uu ...</code>)</p>
</li>
<li>
<p>For any separated complex NT in a matcher, <code>M = ... $(tt ...) SEP OP ...</code>, we must have <code>SEP</code> ∈ FOLLOW(<code>tt ...</code>).</p>
</li>
</ol>
<p>The first part says that whatever actual token that comes after a matcher must be somewhere in the predetermined follow set.  This ensures that a legal macro definition will continue to assign the same determination as to where <code>... tt</code> ends and <code>uu ...</code> begins, even as new syntactic forms are added to the language.</p>
<p>The second part says that a separated complex NT must use a separator token that is part of the predetermined follow set for the internal contents of the NT. This ensures that a legal macro definition will continue to parse an input fragment into the same delimited sequence of <code>tt ...</code>’s, even as new syntactic forms are added to the language.</p>
<p>(This is assuming that all such changes are appropriately restricted, by the definition of FOLLOW below, of course.)</p>
<p>The above invariant is only formally meaningful if one knows what FIRST and FOLLOW denote. We address this in the following sections.</p>
<h3 id="first-and-follow-informally"><a class="header" href="#first-and-follow-informally">FIRST and FOLLOW, informally</a></h3>
<p>FIRST and FOLLOW are defined as follows.</p>
<p>A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).</p>
<p>Each of the three sets is made up of tokens. FIRST(M) and LAST(M) may also contain a distinguished non-token element ε (“epsilon”), which indicates that M can match the empty fragment. (But FOLLOW(M) is always just a set of tokens.)</p>
<p>Informally:</p>
<ul>
<li>
<p>FIRST(M): collects the tokens potentially used first when matching a fragment to M.</p>
</li>
<li>
<p>LAST(M): collects the tokens potentially used last when matching a fragment to M.</p>
</li>
<li>
<p>FOLLOW(M): the set of tokens allowed to follow immediately after some fragment matched by M.</p>
<p>In other words: t ∈ FOLLOW(M) if and only if there exists (potentially empty) token sequences α, β, γ, δ where:</p>
<ul>
<li>M matches β,</li>
<li>t matches γ, and</li>
<li>The concatenation α β γ δ is a parseable Rust program.</li>
</ul>
</li>
</ul>
<p>We use the shorthand ANYTOKEN to denote the set of all tokens (including simple NTs).</p>
<ul>
<li>(For example, if any token is legal after a matcher M, then FOLLOW(M) = ANYTOKEN.)</li>
</ul>
<p>(To review one’s understanding of the above informal descriptions, the reader at this point may want to jump ahead to the <a href="#examples-of-first-and-last">examples of FIRST/LAST</a> before reading their formal definitions.)</p>
<h3 id="first-last"><a class="header" href="#first-last">FIRST, LAST</a></h3>
<p>Below are formal inductive definitions for FIRST and LAST.</p>
<p>“A ∪ B” denotes set union, “A ∩ B” denotes set intersection, and “A \ B” denotes set difference (i.e. all elements of A that are not present in B).</p>
<p>FIRST(M), defined by case analysis on the sequence M and the structure of its first token-tree (if any):</p>
<ul>
<li>
<p>if M is the empty sequence, then FIRST(M) = { ε },</p>
</li>
<li>
<p>if M starts with a token t, then FIRST(M) = { t },</p>
<p>(Note: this covers the case where M starts with a delimited token-tree sequence, <code>M = OPEN tt ... CLOSE ...</code>, in which case <code>t = OPEN</code> and thus FIRST(M) = { <code>OPEN</code> }.)</p>
<p>(Note: this critically relies on the property that no simple NT matches the empty fragment.)</p>
</li>
<li>
<p>Otherwise, M is a token-tree sequence starting with a complex NT: <code>M = $( tt ... ) OP α</code>, or <code>M = $( tt ... ) SEP OP α</code>, (where <code>α</code> is the (potentially empty) sequence of token trees for the rest of the matcher).</p>
<ul>
<li>
<p>Let sep_set = { SEP } if SEP present; otherwise sep_set = {}.</p>
</li>
<li>
<p>If ε ∈ FIRST(<code>tt ...</code>), then FIRST(M) = (FIRST(<code>tt ...</code>) \ { ε }) ∪ sep_set ∪ FIRST(<code>α</code>)</p>
</li>
<li>
<p>Else if OP = <code>*</code>, then FIRST(M) = FIRST(<code>tt ...</code>) ∪ FIRST(<code>α</code>)</p>
</li>
<li>
<p>Otherwise (OP = <code>+</code>), FIRST(M) = FIRST(<code>tt ...</code>)</p>
</li>
</ul>
</li>
</ul>
<p>Note: The ε-case above,</p>
<blockquote>
<p>FIRST(M) = (FIRST(<code>tt ...</code>) \ { ε }) ∪ sep_set ∪ FIRST(<code>α</code>)</p>
</blockquote>
<p>may seem complicated, so lets take a moment to break it down. In the ε case, the sequence <code>tt ...</code> may be empty. Therefore our first token may be <code>SEP</code> itself (if it is present), or it may be the first token of <code>α</code>); that’s why the result is including “sep_set ∪ FIRST(<code>α</code>)”. Note also that if <code>α</code> itself may match the empty fragment, then FIRST(<code>α</code>) will ensure that ε is included in our result, and conversely, if <code>α</code> cannot match the empty fragment, then we must <em>ensure</em> that ε is <em>not</em> included in our result; these two facts together are why we can and should unconditionally remove ε from FIRST(<code>tt ...</code>).</p>
<hr>
<p>LAST(M), defined by case analysis on M itself (a sequence of token-trees):</p>
<ul>
<li>
<p>if M is the empty sequence, then LAST(M) = { ε }</p>
</li>
<li>
<p>if M is a singleton token t, then LAST(M) = { t }</p>
</li>
<li>
<p>if M is the singleton complex NT repeating zero or more times, <code>M = $( tt ... ) *</code>, or <code>M = $( tt ... ) SEP *</code></p>
<ul>
<li>
<p>Let sep_set = { SEP } if SEP present; otherwise sep_set = {}.</p>
</li>
<li>
<p>if ε ∈ LAST(<code>tt ...</code>) then LAST(M) = LAST(<code>tt ...</code>) ∪ sep_set</p>
</li>
<li>
<p>otherwise, the sequence <code>tt ...</code> must be non-empty; LAST(M) = LAST(<code>tt ...</code>) ∪ { ε }</p>
</li>
</ul>
</li>
<li>
<p>if M is the singleton complex NT repeating one or more times, <code>M = $( tt ... ) +</code>, or <code>M = $( tt ... ) SEP +</code></p>
<ul>
<li>
<p>Let sep_set = { SEP } if SEP present; otherwise sep_set = {}.</p>
</li>
<li>
<p>if ε ∈ LAST(<code>tt ...</code>) then LAST(M) = LAST(<code>tt ...</code>) ∪ sep_set</p>
</li>
<li>
<p>otherwise, the sequence <code>tt ...</code> must be non-empty; LAST(M) = LAST(<code>tt ...</code>)</p>
</li>
</ul>
</li>
<li>
<p>if M is a delimited token-tree sequence <code>OPEN tt ... CLOSE</code>, then LAST(M) = { <code>CLOSE</code> }</p>
</li>
<li>
<p>if M is a non-empty sequence of token-trees <code>tt uu ...</code>,</p>
<ul>
<li>
<p>If ε ∈ LAST(<code>uu ...</code>), then LAST(M) = LAST(<code>tt</code>) ∪ (LAST(<code>uu ...</code>) \ { ε }).</p>
</li>
<li>
<p>Otherwise, the sequence <code>uu ...</code> must be non-empty; then LAST(M) = LAST(<code>uu ...</code>)</p>
</li>
</ul>
</li>
</ul>
<p>NOTE: The presence or absence of SEP <em>is</em> relevant to the above definitions, but solely in the case where the interior of the complex NT could be empty (i.e. ε ∈ FIRST(interior)). (I overlooked this fact in my first round of prototyping.)</p>
<p>NOTE: The above definition for LAST assumes that we keep our pre-existing rule that the separator token in a complex NT is <em>solely</em> for separating elements; i.e. that such NT’s do not match fragments that <em>end with</em> the separator token. If we choose to lift this restriction in the future, the above definition will need to be revised accordingly.</p>
<h3 id="examples-of-first-and-last"><a class="header" href="#examples-of-first-and-last">Examples of FIRST and LAST</a></h3>
<p>Below are some examples of FIRST and LAST. (Note in particular how the special ε element is introduced and eliminated based on the interaction between the pieces of the input.)</p>
<p>Our first example is presented in a tree structure to elaborate on how the analysis of the matcher composes. (Some of the simpler subtrees have been elided.)</p>
<pre><code>INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
            ~~~~~~~~   ~~~~~~~                ~
                |         |                   |
FIRST:   { $d:ident }  { $e:expr }          { h }


INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+
            ~~~~~~~~~~~~~~~~~~             ~~~~~~~           ~~~
                       |                      |               |
FIRST:          { $d:ident }               { h, ε }         { f }

INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~    ~~~~~~~~~   ~
                       |                       |              |       |
FIRST:        { $d:ident, ε }            {  h, ε, ;  }      { f }   { g }


INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                        |
FIRST:                       { $d:ident, h, ;,  f }
</code></pre>
<p>Thus:</p>
<ul>
<li>FIRST(<code>$($d:ident $e:expr );* $( $(h)* );* $( f ;)+ g</code>) = { <code>$d:ident</code>, <code>h</code>, <code>;</code>, <code>f</code> }</li>
</ul>
<p>Note however that:</p>
<ul>
<li>FIRST(<code>$($d:ident $e:expr );* $( $(h)* );* $($( f ;)+ g)*</code>) = { <code>$d:ident</code>, <code>h</code>, <code>;</code>, <code>f</code>, ε }</li>
</ul>
<p>Here are similar examples but now for LAST.</p>
<ul>
<li>LAST(<code>$d:ident $e:expr</code>) = { <code>$e:expr</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );*</code>) = { <code>$e:expr</code>, ε }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)*</code>) = { <code>$e:expr</code>, ε, <code>h</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)* $( f ;)+</code>) = { <code>;</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)* $( f ;)+ g</code>) = { <code>g</code> }</li>
</ul>
<p>and again, changing the end part of matcher changes its last set considerably:</p>
<ul>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)* $($( f ;)+ g)*</code>) = { <code>$e:expr</code>, ε, <code>h</code>, <code>g</code> }</li>
</ul>
<h3 id="followm"><a class="header" href="#followm">FOLLOW(M)</a></h3>
<p>Finally, the definition for <code>FOLLOW(M)</code> is built up incrementally atop more primitive functions.</p>
<p>We first assume a primitive mapping, <code>FOLLOW(NT)</code> (defined <a href="#follownt">below</a>) from a simple NT to the set of allowed tokens for the fragment specifier for that NT.</p>
<p>Second, we generalize FOLLOW to tokens: FOLLOW(t) = FOLLOW(NT) if t is (a simple) NT. Otherwise, t must be some other (non NT) token; in this case FOLLOW(t) = ANYTOKEN.</p>
<p>Finally, we generalize FOLLOW to arbitrary matchers by composing the primitive functions above:</p>
<pre><code>FOLLOW(M) = FOLLOW(t1) ∩ FOLLOW(t2) ∩ ... ∩ FOLLOW(tN)
            where { t1, t2, ..., tN } = (LAST(M) \ { ε })
</code></pre>
<p>Examples of FOLLOW (expressed as equality relations between sets, to avoid incorporating details of FOLLOW(NT) in these examples):</p>
<ul>
<li>FOLLOW(<code>$( $d:ident $e:expr )*</code>) = FOLLOW(<code>$e:expr</code>)</li>
<li>FOLLOW(<code>$( $d:ident $e:expr )* $(;)*</code>) = FOLLOW(<code>$e:expr</code>) ∩ ANYTOKEN = FOLLOW(<code>$e:expr</code>)</li>
<li>FOLLOW(<code>$( $d:ident $e:expr )* $(;)* $( f |)+</code>) = ANYTOKEN</li>
</ul>
<h3 id="follownt"><a class="header" href="#follownt">FOLLOW(NT)</a></h3>
<p>Here is the definition for FOLLOW(NT), which maps every simple NT to the set of tokens that are allowed to follow it, based on the fragment specifier for the NT.</p>
<p>The current legal fragment specifiers are: <code>item</code>, <code>block</code>, <code>stmt</code>, <code>pat</code>, <code>expr</code>, <code>ty</code>, <code>ident</code>, <code>path</code>, <code>meta</code>, and <code>tt</code>.</p>
<ul>
<li><code>FOLLOW(pat)</code> = <code>{FatArrow, Comma, Eq, Or, Ident(if), Ident(in)}</code></li>
<li><code>FOLLOW(expr)</code> = <code>{FatArrow, Comma, Semicolon}</code></li>
<li><code>FOLLOW(ty)</code> = <code>{OpenDelim(Brace), Comma, FatArrow, Colon, Eq, Gt, Semi, Or, Ident(as), Ident(where), OpenDelim(Bracket), Nonterminal(Block)}</code></li>
<li><code>FOLLOW(stmt)</code> = <code>FOLLOW(expr)</code></li>
<li><code>FOLLOW(path)</code> = <code>FOLLOW(ty)</code></li>
<li><code>FOLLOW(block)</code> = any token</li>
<li><code>FOLLOW(ident)</code> = any token</li>
<li><code>FOLLOW(tt)</code> = any token</li>
<li><code>FOLLOW(item)</code> = any token</li>
<li><code>FOLLOW(meta)</code> = any token</li>
</ul>
<p>(Note that close delimiters are valid following any NT.)</p>
<h3 id="examples-of-valid-and-invalid-matchers"><a class="header" href="#examples-of-valid-and-invalid-matchers">Examples of valid and invalid matchers</a></h3>
<p>With the above specification in hand, we can present arguments for why particular matchers are legal and others are not.</p>
<ul>
<li>
<p><code>($ty:ty &lt; foo ,)</code> : illegal, because FIRST(<code>&lt; foo ,</code>) = { <code>&lt;</code> } ⊈ FOLLOW(<code>ty</code>)</p>
</li>
<li>
<p><code>($ty:ty , foo &lt;)</code> :   legal, because FIRST(<code>, foo &lt;</code>) = { <code>,</code> }  is ⊆ FOLLOW(<code>ty</code>).</p>
</li>
<li>
<p><code>($pa:pat $pb:pat $ty:ty ,)</code> : illegal, because FIRST(<code>$pb:pat $ty:ty ,</code>) = { <code>$pb:pat</code> } ⊈ FOLLOW(<code>pat</code>), and also FIRST(<code>$ty:ty ,</code>) = { <code>$ty:ty</code> } ⊈ FOLLOW(<code>pat</code>).</p>
</li>
<li>
<p><code>( $($a:tt $b:tt)* ; )</code> : legal, because FIRST(<code>$b:tt</code>) = { <code>$b:tt</code> } is ⊆ FOLLOW(<code>tt</code>) = ANYTOKEN, as is FIRST(<code>;</code>) = { <code>;</code> }.</p>
</li>
<li>
<p><code>( $($t:tt),* , $(t:tt),* )</code> : legal (though any attempt to actually use this macro will signal a local ambiguity error during expansion).</p>
</li>
<li>
<p><code>($ty:ty $(; not sep)* -)</code> : illegal, because FIRST(<code>$(; not sep)* -</code>) = { <code>;</code>, <code>-</code> } is not in FOLLOW(<code>ty</code>).</p>
</li>
<li>
<p><code>($($ty:ty)-+)</code> : illegal, because separator <code>-</code> is not in FOLLOW(<code>ty</code>).</p>
</li>
</ul>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>It does restrict the input to a MBE, but the choice of delimiters provides reasonable freedom and can be extended in the future.</p>
<h2 id="替代方案"><a class="header" href="#替代方案">替代方案</a></h2>
<ol>
<li>Fix the syntax that a fragment can parse. This would create a situation where a future MBE might not be able to accept certain inputs because the input uses newer features than the fragment that was fixed at 1.0. For example, in the <code>bar</code> MBE above, if the <code>ty</code> fragment was fixed before the unboxed closure sugar was introduced, the MBE would not be able to accept such a type. While this approach is feasible, it would cause unnecessary confusion for future users of MBEs when they can’t put certain perfectly valid Rust code in the input to an MBE. Versioned fragments could avoid this problem but only for new code.</li>
<li>Keep <code>macro_rules</code> unstable. Given the great syntactical abstraction that <code>macro_rules</code> provides, it would be a shame for it to be unusable in a release version of Rust. If ever <code>macro_rules</code> were to be stabilized, this same issue would come up.</li>
<li>Do nothing. This is very dangerous, and has the potential to essentially freeze Rust’s syntax for fear of accidentally breaking a macro.</li>
</ol>
<h2 id="edit-history"><a class="header" href="#edit-history">Edit History</a></h2>
<ul>
<li>
<p>Updated by https://github.com/rust-lang/rfcs/pull/1209, which added semicolons into the follow set for types.</p>
</li>
<li>
<p>Updated by https://github.com/rust-lang/rfcs/pull/1384:</p>
<ul>
<li>replaced detailed design with a specification-oriented presentation rather than an implementation-oriented algorithm.</li>
<li>fixed some oversights in the specification that led to matchers like <code>$e:expr { stuff }</code> being accepted (which match fragments like <code>break { stuff }</code>, significantly limiting future language extensions),</li>
<li>expanded the follows sets for <code>ty</code> to include <code>OpenDelim(Brace), Ident(where), Or</code> (since Rust’s grammar already requires all of <code>|foo:TY| {}</code>, <code>fn foo() -&gt; TY {}</code> and <code>fn foo() -&gt; TY where {}</code> to work).</li>
<li>expanded the follow set for <code>pat</code> to include <code>Or</code> (since Rust’s grammar already requires <code>match (true,false) { PAT | PAT =&gt; {} }</code> and <code>|PAT| {}</code> to work); see also <a href="https://github.com/rust-lang/rfcs/issues/1336">RFC issue 1336</a>. Also added <code>If</code> and <code>In</code> to follow set for <code>pat</code> (to make the specification match the old implementation).</li>
</ul>
</li>
<li>
<p>Updated by https://github.com/rust-lang/rfcs/pull/1462, which added open square bracket into the follow set for types.</p>
</li>
<li>
<p>Updated by https://github.com/rust-lang/rfcs/pull/1494, which adjusted the follow set for types to include block nonterminals.</p>
</li>
</ul>
<h2 id="appendices"><a class="header" href="#appendices">Appendices</a></h2>
<h3 id="appendix-a-algorithm-for-recognizing-valid-matchers"><a class="header" href="#appendix-a-algorithm-for-recognizing-valid-matchers">Appendix A: Algorithm for recognizing valid matchers.</a></h3>
<p>The detailed design above only sought to provide a <em>specification</em> for what a correct matcher is (by defining FIRST, LAST, and FOLLOW, and specifying the invariant relating FIRST and FOLLOW for all valid matchers.</p>
<p>The above specification can be implemented efficiently; we here give one example algorithm for recognizing valid matchers.</p>
<ul>
<li>
<p>This is not the only possible algorithm; for example, one could precompute a table mapping every suffix of every token-tree sequence to its FIRST set, by augmenting <code>FirstSet</code> below accordingly.</p>
<p>Or one could store a subset of such information during the precomputation, such as just the FIRST sets for complex NT’s, and then use that table to inform a <em>forward scan</em> of the input.</p>
<p>The latter is in fact what my prototype implementation does; I must emphasize the point that the algorithm here is not prescriptive.</p>
</li>
<li>
<p>The intent of this RFC is that the specifications of FIRST and FOLLOW above will take precedence over this algorithm if the two are found to be producing inconsistent results.</p>
</li>
</ul>
<p>The algorithm for recognizing valid matchers <code>M</code> is named ValidMatcher.</p>
<p>To define it, we will need a mapping from submatchers of M to the FIRST set for that submatcher; that is handled by <code>FirstSet</code>.</p>
<h4 id="procedure-firstsetm"><a class="header" href="#procedure-firstsetm">Procedure FirstSet(M)</a></h4>
<p><em>input</em>: a token tree <code>M</code> representing a matcher</p>
<p><em>output</em>: <code>FIRST(M)</code></p>
<pre><code>Let M = tts[1] tts[2] ... tts[n].
Let curr_first = { ε }.

For i in n down to 1 (inclusive):
  Let tt = tts[i].

  1. If tt is a token, curr_first := { tt }

  2. Else if tt is a delimited sequence `OPEN uu ... ClOSE`,
     curr_first := { OPEN }

  3. Else tt is a complex NT `$(uu ...) SEP OP`

     Let inner_first = FirstSet(`uu ...`) i.e. recursive call

     if OP == `*` or ε ∈ inner_first then
         curr_first := curr_first ∪ inner_first
     else
         curr_first := inner_first

return curr_first
</code></pre>
<p>(Note: If we were precomputing a full table in this procedure, we would need a recursive invocation on (uu …) in step 2 of the for-loop.)</p>
<h4 id="predicate-validmatcherm"><a class="header" href="#predicate-validmatcherm">Predicate ValidMatcher(M)</a></h4>
<p>To simplify the specification, we assume in this presentation that all simple NT’s have a valid fragment specifier (i.e., one that has an entry in the FOLLOW(NT) table above.</p>
<p>This algorithm works by scanning forward across the matcher M = α β, (where α is the prefix we have scanned so far, and β is the suffix that remains to be scanned). We maintain LAST(α) as we scan, and use it to compute FOLLOW(α) and compare that to FIRST(β).</p>
<p><em>input</em>: a token tree, <code>M</code>, and a set of tokens that could follow it, <code>F</code>.</p>
<p><em>output</em>: LAST(M) (and also signals failure whenever M is invalid)</p>
<pre><code>Let last_of_prefix = { ε }

Let M = tts[1] tts[2] ... tts[n].

For i in 1 up to n (inclusive):
  // For reference:
  // α = tts[1] .. tts[i]
  // β = tts[i+1] .. tts[n]
  // γ is some outer token sequence; the input F represents FIRST(γ)

  1. Let tt = tts[i].

  2. Let first_of_suffix; // aka FIRST(β γ)

  3. let S = FirstSet(tts[i+1] .. tts[n]);

  4. if ε ∈ S then
     // (include the follow information if necessary)

     first_of_suffix := S ∪ F

  5. else

     first_of_suffix := S

  6. Update last_of_prefix via case analysis on tt:

     a. If tt is a token:
        last_of_prefix := { tt }

     b. Else if tt is a delimited sequence `OPEN uu ... CLOSE`:

        i.  run ValidMatcher( M = `uu ...`, F = { `CLOSE` })

       ii. last_of_prefix := { `CLOSE` }

     c. Else, tt must be a complex NT,
        in other words, `NT = $( uu .. ) SEP OP` or `NT = $( uu .. ) OP`:

        i. If SEP present,
          let sublast = ValidMatcher( M = `uu ...`, F = first_of_suffix ∪ { `SEP` })

       ii. else:
          let sublast = ValidMatcher( M = `uu ...`, F = first_of_suffix)

      iii. If ε in sublast then:
           last_of_prefix := last_of_prefix ∪ (sublast \ ε)

       iv. Else:
           last_of_prefix := sublast

  7. At this point, last_of_prefix == LAST(α) and first_of_suffix == FIRST(β γ).

     For each simple NT token t in last_of_prefix:

     a. If first_of_suffix ⊆ FOLLOW(t), then we are okay so far. &lt;/li&gt;

     b. Otherwise, we have found a token t whose follow set is not compatible
        with the FIRST(β γ), and must signal failure.

// After running the above for loop on all of `M`, last_of_prefix == LAST(M)

Return last_of_prefix
</code></pre>
<p>This algorithm should be run on every matcher in every <code>macro_rules</code> invocation, with <code>F</code> = { <code>EOF</code> }. If it rejects a matcher, an error should be emitted and compilation should not complete.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="0546-Self-not-sized-by-default.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="0556-raw-lifetime.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="0546-Self-not-sized-by-default.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="0556-raw-lifetime.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
