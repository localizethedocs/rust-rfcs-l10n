<!DOCTYPE HTML>
<html lang="zh_TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>0769-sound-generic-drop - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-c5bb60c5.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Start Date: 2013-08-29</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/769">rust-lang/rfcs#769</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/8861">rust-lang/rust#8861</a></li>
</ul>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<p>2015.09.18 – This RFC was partially superseded by <a href="https://github.com/rust-lang/rfcs/blob/master/text/1238-nonparametric-dropck.md">RFC 1238</a>, which removed the parametricity-based reasoning in favor of an attribute.</p>
<h2 id="摘要"><a class="header" href="#摘要">摘要</a></h2>
<p>Remove <code>#[unsafe_destructor]</code> from the Rust language.  Make it safe for developers to implement <code>Drop</code> on type- and lifetime-parameterized structs and enum (i.e. “Generic Drop”) by imposing new rules on code where such types occur, to ensure that the drop implementation cannot possibly read or write data via a reference of type <code>&amp;'a Data</code> where <code>'a</code> could have possibly expired before the drop code runs.</p>
<p>Note: This RFC is describing a feature that has been long in the making; in particular it was previously sketched in Rust <a href="https://github.com/rust-lang/rust/issues/8861">Issue #8861</a> “New Destructor Semantics” (the source of the tongue-in-cheek “Start Date” given above), and has a <a href="https://github.com/pnkfelix/rust/tree/77afdb70a1d4d5a20069f12412bfeda3ccd145bf">prototype implementation</a> that is being prepared to land.  The purpose of this RFC is two-fold:</p>
<ol>
<li>
<p>standalone documentation of the (admittedly conservative) rules imposed by the new destructor semantics, and</p>
</li>
<li>
<p>elicit community feedback on the rules, both in the form they will take for 1.0 (which is relatively constrained) and the form they might take in the future (which allows for hypothetical language extensions).</p>
</li>
</ol>
<h2 id="動機"><a class="header" href="#動機">動機</a></h2>
<p>Part of Rust’s design is rich use of Resource Acquisition Is Initialization (RAII) patterns, which requires destructors: code attached to certain types that runs only when a value of the type goes out of scope or is otherwise deallocated. In Rust, the <code>Drop</code> trait is used for this purpose.</p>
<p>Currently (as of Rust 1.0 alpha), a developer cannot implement <code>Drop</code> on a type- or lifetime-parametric type (e.g. <code>struct Sneetch&lt;'a&gt;</code> or <code>enum Zax&lt;T&gt;</code>) without attaching the <code>#[unsafe_destructor]</code> attribute to it. The reason this attribute is required is that the current implementation allows for such destructors to inject unsoundness accidentally (e.g. reads from or writes to deallocated memory, accessing data when its representation invariants are no longer valid).</p>
<p>Furthermore, while some destructors can be implemented with no danger of unsoundness, regardless of <code>T</code> (assuming that any <code>Drop</code> implementation attached to <code>T</code> is itself sound), as soon as one wants to interact with borrowed data within the <code>fn drop</code> code (e.g. access a field <code>&amp;'a StarOffMachine</code> from a value of type <code>Sneetch&lt;'a&gt;</code> ), there is currently no way to enforce a rule that <code>'a</code> <em>strictly</em> <em>outlive</em> the value itself. This is a huge gap in the language as it stands: as soon as a developer attaches <code>#[unsafe_destructor]</code> to such a type, it is imposing a subtle and <em>unchecked</em> restriction on clients of that type that they will not ever allow the borrowed data to expire first.</p>
<h3 id="lifetime-parameterization-the-sneetch-example"><a class="header" href="#lifetime-parameterization-the-sneetch-example">Lifetime parameterization: the Sneetch example</a></h3>
<p>If today Sylvester writes:</p>
<pre><code class="language-rust">// opt-in to the unsoundness!
#![feature(unsafe_destructor)]

pub mod mcbean {
    use std::cell::Cell;

    pub struct StarOffMachine {
        usable: bool,
        dollars: Cell&lt;u64&gt;,
    }

    impl Drop for StarOffMachine {
        fn drop(&amp;mut self) {
            let contents = self.dollars.get();
            println!("Dropping a machine; sending {} dollars to Sylvester.",
                     contents);
            self.dollars.set(0);
            self.usable = false;
        }
    }

    impl StarOffMachine {
        pub fn new() -&gt; StarOffMachine {
            StarOffMachine { usable: true, dollars: Cell::new(0) }
        }
        pub fn remove_star(&amp;self, s: &amp;mut Sneetch) {
            assert!(self.usable,
                    "No different than a read of a dangling pointer.");
            self.dollars.set(self.dollars.get() + 10);
            s.has_star = false;
        }
    }

    pub struct Sneetch&lt;'a&gt; {
        name: &amp;'static str,
        has_star: bool,
        machine: Cell&lt;Option&lt;&amp;'a StarOffMachine&gt;&gt;,
    }

    impl&lt;'a&gt; Sneetch&lt;'a&gt; {
        pub fn new(name: &amp;'static str) -&gt; Sneetch&lt;'a&gt; {
            Sneetch {
                name: name,
                has_star: true,
                machine: Cell::new(None)
            }
        }

        pub fn find_machine(&amp;self, m: &amp;'a StarOffMachine) {
            self.machine.set(Some(m));
        }
    }

    #[unsafe_destructor]
    impl&lt;'a&gt; Drop for Sneetch&lt;'a&gt; {
        fn drop(&amp;mut self) {
            if let Some(m) = self.machine.get() {
                println!("{} says ``before I die, I want to join my \
                          plain-bellied brethren.''", self.name);
                m.remove_star(self);
            }
        }
    }
}

fn unwary_client() {
    use mcbean::{Sneetch, StarOffMachine};
    let (s1, m, s2, s3); // (accommodate PR 21657)
    s1 = Sneetch::new("Sneetch One");
    m = StarOffMachine::new();
    s2 = Sneetch::new("Sneetch Two");
    s3 = Sneetch::new("Sneetch Zee");

    s1.find_machine(&amp;m);
    s2.find_machine(&amp;m);
    s3.find_machine(&amp;m);
}

fn main() {
    unwary_client();
}</code></pre>
<p>This compiles today; if you run it, it prints the following:</p>
<pre><code>Sneetch Zee says ``before I die, I want to join my plain-bellied brethren.''
Sneetch Two says ``before I die, I want to join my plain-bellied brethren.''
Dropping a machine; sending 20 dollars to Sylvester.
Sneetch One says ``before I die, I want to join my plain-bellied brethren.''
thread '&lt;main&gt;' panicked at 'No different than a read of a dangling pointer.', &lt;anon&gt;:27
</code></pre>
<p>Explanation: In Sylvester’s code, the <code>Drop</code> implementation for <code>Sneetch</code> invokes a method on the borrowed reference in the field <code>machine</code>. This implies there is an implicit restriction on an value <code>s</code> of type <code>Sneetch&lt;'a&gt;</code>: the lifetime <code>'a</code> must <em>strictly outlive</em> <code>s</code>.</p>
<p>(The example encodes this constraint in a dynamically-checked manner via an explicit <code>usable</code> boolean flag that is only set to false in the machine’s own destructor; it is important to keep in mind that this is just a method to illustrate the violation in a semi-reliable manner: Using a machine after <code>usable</code> is set to false by its <code>fn drop</code> code is analogous to dereferencing a <code>*mut T</code> that has been deallocated, or similar soundness violations.)</p>
<p>Sylvester’s API does not encode the constraint “<code>'a</code> must strictly outlive the <code>Sneetch&lt;'a&gt;</code>” explicitly; Rust currently has no way of expressing the constraint that one lifetime be strictly greater than another lifetime or type (the form <code>'a:'b</code> only formally says that <code>'a</code> must live <em>at least</em> as long as <code>'b</code>).</p>
<p>Thus, client code like that in <code>unwary_client</code> can inadvertently set up scenarios where Sylvester’s code may break, and Sylvester might be completely unaware of the vulnerability.</p>
<h3 id="type-parameterization-the-problem-of-trait-bounds"><a class="header" href="#type-parameterization-the-problem-of-trait-bounds">Type parameterization: the problem of trait bounds</a></h3>
<p>One might think that all instances of this problem can be identified by the use of a lifetime-parametric <code>Drop</code> implementation, such as <code>impl&lt;'a&gt; Drop for Sneetch&lt;'a&gt; { ..&gt; }</code></p>
<p>However, consider this trait and struct:</p>
<pre><code class="language-rust">trait Button { fn push(&amp;self); }
struct Zook&lt;B: Button&gt; { button: B, }
#[unsafe_destructor]
impl&lt;B: Button&gt; Drop for Zook&lt;B&gt; {
    fn drop(&amp;mut self) { self.button.push(); }
}</code></pre>
<p>In this case, it is not obvious that there is anything wrong here.</p>
<p>But if we continue the example:</p>
<pre><code class="language-rust">struct Bomb { usable: bool }
impl Drop for Bomb { fn drop(&amp;mut self) { self.usable = false; } }
impl Bomb { fn activate(&amp;self) { assert!(self.usable) } }

enum B&lt;'a&gt; { HarmlessButton, BigRedButton(&amp;'a Bomb) }
impl&lt;'a&gt; Button for B&lt;'a&gt; {
    fn push(&amp;self) {
        if let B::BigRedButton(borrowed) = *self {
            borrowed.activate();
        }
    }
}

fn main() {
    let (mut zook, ticking);
    zook = Zook { button: B::HarmlessButton };
    ticking = Bomb { usable: true };
    zook.button = B::BigRedButton(&amp;ticking);
}</code></pre>
<p>Within the <code>zook</code> there is a hidden reference to borrowed data, <code>ticking</code>, that is assigned the same lifetime as <code>zook</code> but that will be dropped before <code>zook</code> is.</p>
<p>(These examples may seem contrived; see <a href="#appendix-a-why-and-when-would-drop-read-from-borrowed-data">Appendix A</a> for a far less contrived example, that also illustrates how the use of borrowed data can lie hidden behind type parameters.)</p>
<h3 id="the-proposal"><a class="header" href="#the-proposal">The proposal</a></h3>
<p>This RFC is proposes to fix this scenario, by having the compiler ensure that types with destructors are only employed in contexts where either any borrowed data with lifetime <code>'a</code> within the type either strictly outlives the value of that type, or such borrowed data is provably not accessible from any <code>Drop</code> implementation via a reference of type <code>&amp;'a</code>/<code>&amp;'a mut</code>. This is the “Drop-Check” (aka <code>dropck</code>) rule.</p>
<h2 id="詳細設計"><a class="header" href="#詳細設計">詳細設計</a></h2>
<h3 id="the-drop-check-rule"><a class="header" href="#the-drop-check-rule">The Drop-Check Rule</a></h3>
<p>The Motivation section alluded to the compiler enforcing a new rule. Here is a more formal statement of that rule:</p>
<p>Let <code>v</code> be some value (either temporary or named) and <code>'a</code> be some lifetime (scope); if the type of <code>v</code> owns data of type <code>D</code>, where (1.) <code>D</code> has a lifetime- or type-parametric <code>Drop</code> implementation, and (2.) the structure of <code>D</code> can reach a reference of type <code>&amp;'a _</code>, and (3.) either:</p>
<ul>
<li>
<p>(A.) the <code>Drop impl</code> for <code>D</code> instantiates <code>D</code> at <code>'a</code> directly, i.e. <code>D&lt;'a&gt;</code>, or,</p>
</li>
<li>
<p>(B.) the <code>Drop impl</code> for <code>D</code> has some type parameter with a trait bound <code>T</code> where <code>T</code> is a trait that has at least one method,</p>
</li>
</ul>
<p>then <code>'a</code> must strictly outlive the scope of <code>v</code>.</p>
<p>(Note: This rule is using two phrases that deserve further elaboration and that are discussed further in sections that follow: <a href="#when-does-one-type-own-another">“the type owns data of type <code>D</code>”</a> and <a href="#strictly-outlives">“must strictly outlive”</a>.)</p>
<p>(Note: When encountering a <code>D</code> of the form <code>Box&lt;Trait+'b&gt;</code>, we conservatively assume that such a type has a <code>Drop</code> implementation parametric in <code>'b</code>.)</p>
<p>This rule allows much sound existing code to compile without complaint from <code>rustc</code>.  This is largely due to the fact that many <code>Drop</code> implementations enjoy near-complete parametricity: They tend to not impose any bounds at all on their type parameters, and thus the rule does not apply to them.</p>
<p>At the same time, this rule catches the cases where a destructor could possibly reference borrowed data via a reference of type <code>&amp;'a _</code> or <code>&amp;'a mut_</code>. Here is why:</p>
<p>Condition (A.) ensures that a type like <code>Sneetch&lt;'a&gt;</code> from <a href="#lifetime-parameterization-the-sneetch-example">the Sneetch example</a> will only be assigned to an expression <code>s</code> where <code>'a</code> strictly outlives <code>s</code>.</p>
<p>Condition (B.) catches cases like <code>Zook&lt;B&lt;'a&gt;&gt;</code> from <a href="#type-parameterization-the-problem-of-trait-bounds">the Zook example</a>, where the destructor’s interaction with borrowed data is hidden behind a method call in the <code>fn drop</code>.</p>
<h3 id="near-complete-parametricity-suffices"><a class="header" href="#near-complete-parametricity-suffices">Near-complete parametricity suffices</a></h3>
<h4 id="noncopy-types"><a class="header" href="#noncopy-types">Noncopy types</a></h4>
<p>All non-<code>Copy</code> type parameters are (still) assumed to have a destructor. Thus, one would be correct in noting that even a type <code>T</code> with no bounds may still have one hidden method attached; namely, its <code>Drop</code> implementation.</p>
<p>However, the drop implementation for <code>T</code> can only be called when running the destructor for value <code>v</code> if either:</p>
<ol>
<li>
<p>the type of <code>v</code> owns data of type <code>T</code>, or</p>
</li>
<li>
<p>the destructor of <code>v</code> constructs an instance of <code>T</code>.</p>
</li>
</ol>
<p>In the first case, the Drop-Check rule ensures that <code>T</code> must satisfy either Condition (A.) or (B.). In this second case, the freshly constructed instance of <code>T</code> will only be able to access either borrowed data from <code>v</code> itself (and thus such data will already have lifetime that strictly outlives <code>v</code>) or data created during the execution of the destructor.</p>
<h4 id="any-instances"><a class="header" href="#any-instances"><code>Any</code> instances</a></h4>
<p>All types implementing <code>Any</code> is forced to outlive <code>'static</code>. So one should not be able to hide borrowed data behind the <code>Any</code> trait, and therefore it is okay for the analysis to treat <code>Any</code> like a black box whose destructor is safe to run (at least with respect to not accessing borrowed data).</p>
<h3 id="strictly-outlives"><a class="header" href="#strictly-outlives">Strictly outlives</a></h3>
<p>There is a notion of “strictly outlives” within the compiler internals.  (This RFC is not adding such a notion to the language itself; expressing “’a strictly outlives ’b” as an API constraint is not a strict necessity at this time.)</p>
<p>The heart of the idea is this: we approximate the notion of “strictly outlives” by the following rule: if a value <code>U</code> needs to strictly outlive another value <code>V</code> with code extent <code>S</code>, we could just say that <code>U</code> needs to live at least as long as the parent scope of <code>S</code>.</p>
<p>There are likely to be sound generalizations of the model given here (and we will likely need to consider such to adopt future extensions like Single-Entry-Multiple-Exit (SEME) regions, but that is out of scope for this RFC).</p>
<p>In terms of its impact on the language, the main change has already landed in the compiler; see <a href="https://github.com/rust-lang/rust/pull/21657">Rust PR 21657</a>, which added <code>CodeExtent::Remainder</code>, for more direct details on the implications of that change written in a user-oriented fashion.</p>
<p>One important detail of the strictly-outlives relationship that comes in part from <a href="https://github.com/rust-lang/rust/pull/21657">Rust PR 21657</a>: All bindings introduced by a single <code>let</code> statement are modeled as having the <em>same</em> lifetime. In an example like</p>
<pre><code class="language-rust">let a;
let b;
let (c, d);
...</code></pre>
<p><code>a</code> strictly outlives <code>b</code>, and <code>b</code> strictly outlives both <code>c</code> and <code>d</code>. However, <code>c</code> and <code>d</code> are modeled as having the same lifetime; neither one strictly outlives the other. (Of course, during code execution, one of them will be dropped before the other; the point is that when <code>rustc</code> builds its internal model of the lifetimes of data, it approximates and assigns them both the same lifetime.) This is an important detail, because there are situations where one <em>must</em> assign the same lifetime to two distinct bindings in order to allow them to mutually refer to each other’s data.</p>
<p>For more details on this “strictly outlives” model, see <a href="#appendix-b-strictly-outlives-details">Appendix B</a>.</p>
<h3 id="when-does-one-type-own-another"><a class="header" href="#when-does-one-type-own-another">When does one type own another</a></h3>
<p>The definition of the Drop-Check Rule used the phrase “if the type owns data of type <code>D</code>”.</p>
<p>This criteria is based on recursive descent of the structure of an input type <code>E</code>.</p>
<ul>
<li>
<p>If <code>E</code> itself has a Drop implementation that satisfies either condition (A.) or (B.) then add, for all relevant <code>'a</code>, the constraint that <code>'a</code> must outlive the scope of the value that caused the recursive descent.</p>
</li>
<li>
<p>Otherwise, if we have previously seen <code>E</code> during the descent then skip it (i.e. we assume a type has no destructor of interest until we see evidence saying otherwise). This check prevents infinite-looping when we encounter recursive references to a type, which can arise in e.g. <code>Option&lt;Box&lt;Type&gt;&gt;</code>.</p>
</li>
<li>
<p>Otherwise, if <code>E</code> is a struct (or tuple), for each of the struct’s fields, recurse on the field’s type (i.e., a struct owns its fields).</p>
</li>
<li>
<p>Otherwise, if <code>E</code> is an enum, for each of the enum’s variants, and for each field of each variant, recurse on the field’s type (i.e., an enum owns its fields).</p>
</li>
<li>
<p>Otherwise, if <code>E</code> is of the form <code>&amp; T</code>, <code>&amp;mut T</code>, <code>* T</code>, or <code>fn (T, ...) -&gt; T</code>, then skip this <code>E</code> (i.e., references, native pointers, and bare functions do not own the types they refer to).</p>
</li>
<li>
<p>Otherwise, recurse on any immediate type substructure of <code>E</code>. (i.e., an instantiation of a polymorphic type <code>Poly&lt;T_1, T_2&gt;</code> is assumed to own <code>T_1</code> and <code>T_2</code>; note that structs and enums <em>do not</em> fall into this category, as they are handled up above; but this does cover cases like <code>Box&lt;Trait&lt;T_1, T_2&gt;+'a&gt;</code>).</p>
</li>
</ul>
<h4 id="phantom-data"><a class="header" href="#phantom-data">Phantom Data</a></h4>
<p>The above definition for type-ownership is (believed to be) sound for pure Rust programs that do not use <code>unsafe</code>, but it does not suffice for several important types without some tweaks.</p>
<p>In particular, consider the implementation of <code>Vec&lt;T&gt;</code>: as of “Rust 1.0 alpha”:</p>
<pre><code class="language-rust">pub struct Vec&lt;T&gt; {
    ptr: NonZero&lt;*mut T&gt;,
    len: uint,
    cap: uint,
}</code></pre>
<p>According to the above definition, <code>Vec&lt;T&gt;</code> does not own <code>T</code>. This is clearly wrong.</p>
<p>However, it generalizing the rule to say that <code>*mut T</code> owns <code>T</code> would be too conservative, since there are cases where one wants to use <code>*mut T</code> to model references to state that are not owned.</p>
<p>Therefore, we need some sort of marker, so that types like <code>Vec&lt;T&gt;</code> can express that values of that type own instances of <code>T</code>. The <code>PhantomData&lt;T&gt;</code> marker proposed by <a href="https://github.com/rust-lang/rfcs/pull/738">RFC 738</a> (“Support variance for type parameters”) is a good match for this. This RFC assumes that either <a href="https://github.com/rust-lang/rfcs/pull/738">RFC 738</a> will be accepted, or if necessary, this RFC will be amended so that it itself adds the concept of <code>PhantomData&lt;T&gt;</code> to the language. Therefore, as an additional special case to the criteria above for when the type <code>E</code> owns data of type <code>D</code>, we include:</p>
<ul>
<li>If <code>E</code> is <code>PhantomData&lt;T&gt;</code>, then recurse on <code>T</code>.</li>
</ul>
<h3 id="examples-of-changes-imposed-by-the-drop-check-rule"><a class="header" href="#examples-of-changes-imposed-by-the-drop-check-rule">Examples of changes imposed by the Drop-Check Rule</a></h3>
<h4 id="some-cyclic-structure-is-still-allowed"><a class="header" href="#some-cyclic-structure-is-still-allowed">Some cyclic structure is still allowed</a></h4>
<p>Earlier versions of the Drop-Check rule were quite conservative, to the point where cyclic data would be disallowed in many contexts. The Drop-Check rule presented in this RFC was crafted to try to keep many existing useful patterns working.</p>
<p>In particular, cyclic structure is still allowed in many contexts.  Here is one concrete example:</p>
<pre><code class="language-rust">use std::cell::Cell;

#[derive(Show)]
struct C&lt;'a&gt; {
    v: Vec&lt;Cell&lt;Option&lt;&amp;'a C&lt;'a&gt;&gt;&gt;&gt;,
}

impl&lt;'a&gt; C&lt;'a&gt; {
    fn new() -&gt; C&lt;'a&gt; {
        C { v: Vec::new() }
    }
}

fn f() {
    let (mut c1, mut c2, mut c3);
    c1 = C::new();
    c2 = C::new();
    c3 = C::new();

    c1.v.push(Cell::new(None));
    c1.v.push(Cell::new(None));
    c2.v.push(Cell::new(None));
    c2.v.push(Cell::new(None));
    c3.v.push(Cell::new(None));
    c3.v.push(Cell::new(None));

    c1.v[0].set(Some(&amp;c2));
    c1.v[1].set(Some(&amp;c3));
    c2.v[0].set(Some(&amp;c2));
    c2.v[1].set(Some(&amp;c3));
    c3.v[0].set(Some(&amp;c1));
    c3.v[1].set(Some(&amp;c2));
}</code></pre>
<p>In this code, each of the nodes { <code>c1</code>, <code>c2</code>, <code>c3</code> } contains a reference to the two other nodes, and those references are stored in a <code>Vec</code>.  Note that all of the bindings are introduced by a single let-statement; this is to accommodate the region inference system which wants to assign a single code extent to the <code>'a</code> lifetime, as discussed in the <a href="#strictly-outlives">strictly-outlives</a> section.</p>
<p>Even though <code>Vec&lt;T&gt;</code> itself is defined as implementing <code>Drop</code>, it puts no bounds on <code>T</code>, and therefore that <code>Drop</code> implementation is ignored by the Drop-Check rule.</p>
<h4 id="directly-mixing-cycles-and-drop-is-rejected"><a class="header" href="#directly-mixing-cycles-and-drop-is-rejected">Directly mixing cycles and <code>Drop</code> is rejected</a></h4>
<p><a href="#lifetime-parameterization-the-sneetch-example">The Sneetch example</a> illustrates a scenario were borrowed data is dropped while there is still an outstanding borrow that will be accessed by a destructor.  In that particular example, one can easily reorder the bindings to ensure that the <code>StarOffMachine</code> outlives all of the sneetches.</p>
<p>But there are other examples that have no such resolution.  In particular, graph-structured data where the destructor for each node accesses the neighboring nodes in the graph; this simply cannot be done soundly, because when there are cycles, there is no legal order in which to drop the nodes.</p>
<p>(At least, we cannot do it soundly without imperatively removing a node from the graph as the node is dropped; but we are not going to attempt to support verifying such an invariant as part of this RFC; to my knowledge it is not likely to be feasible with type-checking based static analyses).</p>
<p>In any case, we can easily show some code that will now start to be rejected due to the Drop-Check rule: we take the same <code>C&lt;'a&gt;</code> example of cyclic structure given above, but we now attach a <code>Drop</code> implementation to <code>C&lt;'a&gt;</code>:</p>
<pre><code class="language-rust">use std::cell::Cell;

#[derive(Show)]
struct C&lt;'a&gt; {
    v: Vec&lt;Cell&lt;Option&lt;&amp;'a C&lt;'a&gt;&gt;&gt;&gt;,
}

impl&lt;'a&gt; C&lt;'a&gt; {
    fn new() -&gt; C&lt;'a&gt; {
        C { v: Vec::new() }
    }
}

// (THIS IS NEW)
impl&lt;'a&gt; Drop for C&lt;'a&gt; {
    fn drop(&amp;mut self) { }
}

fn f() {
    let (mut c1, mut c2, mut c3);
    c1 = C::new();
    c2 = C::new();
    c3 = C::new();

    c1.v.push(Cell::new(None));
    c1.v.push(Cell::new(None));
    c2.v.push(Cell::new(None));
    c2.v.push(Cell::new(None));
    c3.v.push(Cell::new(None));
    c3.v.push(Cell::new(None));

    c1.v[0].set(Some(&amp;c2));
    c1.v[1].set(Some(&amp;c3));
    c2.v[0].set(Some(&amp;c2));
    c2.v[1].set(Some(&amp;c3));
    c3.v[0].set(Some(&amp;c1));
    c3.v[1].set(Some(&amp;c2));
}</code></pre>
<p>Now the addition of <code>impl&lt;'a&gt; Drop for C&lt;'a&gt;</code> changes the results entirely;</p>
<p>The Drop-Check rule sees the newly added <code>impl&lt;'a&gt; Drop for C&lt;'a&gt;</code>, which means that for every value of type <code>C&lt;'a&gt;</code>, <code>'a</code> must strictly outlive the value. But in the binding <code>let (mut c1, mut c2, mut c3)</code> , all three bindings are assigned the same type <code>C&lt;'scope_of_c1_c2_and_c3&gt;</code>, where <code>'scope_of_c1_c2_and_c3</code> does not strictly outlive any of the three. Therefore this code will be rejected.</p>
<p>(Note: it is irrelevant that the <code>Drop</code> implementation is a no-op above. The analysis does not care what the contents of that code are; it solely cares about the public API presented by the type to its clients.  After all, the <code>Drop</code> implementation for <code>C&lt;'a&gt;</code> could be rewritten tomorrow to contain code that accesses the neighboring nodes.</p>
<h4 id="some-temporaries-need-to-be-given-names"><a class="header" href="#some-temporaries-need-to-be-given-names">Some temporaries need to be given names</a></h4>
<p>Due to the way that <code>rustc</code> implements the <a href="#strictly-outlives">strictly-outlives</a> relation in terms of code-extents, the analysis does not know in an expression like <code>foo().bar().quux()</code> in what order the temporary values <code>foo()</code> and <code>foo().bar()</code> will be dropped.</p>
<p>Therefore, the Drop-Check rule sometimes forces one to rewrite the code so that it is apparent to the compiler that the value from <code>foo()</code> will definitely outlive the value from <code>foo().bar()</code>.</p>
<p>Thus, on occasion one is forced to rewrite:</p>
<pre><code class="language-rust">let q = foo().bar().quux();
...</code></pre>
<p>as:</p>
<pre><code class="language-rust">let foo = foo();
let q = foo.bar().quux()
...</code></pre>
<p>or even sometimes as:</p>
<pre><code class="language-rust">let foo = foo();
let bar = foo.bar();
let q = bar.quux();
...</code></pre>
<p>depending on the types involved.</p>
<p>In practice, pnkfelix saw this arise most often with code like this:</p>
<pre><code class="language-rust">for line in old_io::stdin().lock().lines() {
    ...
}</code></pre>
<p>Here, the result of <code>stdin()</code> is a <code>StdinReader</code>, which holds a <code>RaceBox</code> in a <code>Mutex</code> behind an <code>Arc</code>.  The result of the <code>lock()</code> method is a <code>StdinReaderGuard&lt;'a&gt;</code>, which owns a <code>MutexGuard&lt;'a, RaceBox&gt;</code>.  The <code>MutexGuard</code> has a <code>Drop</code> implementation that is parametric in <code>'a</code>; thus, the Drop-Check rule insists that the lifetime assigned to <code>'a</code> strictly outlive the <code>MutexGuard</code>.</p>
<p>So, under this RFC, we rewrite the code like so:</p>
<pre><code class="language-rust">let stdin = old_io::stdin();
for line in stdin.lock().lines() {
    ...
}</code></pre>
<p>(pnkfelix acknowledges that this rewrite is unfortunate.  Potential future work would be to further revise the code extent system so that the compiler knows that the temporary from <code>stdin()</code> will outlive the temporary from <code>stdin().lock()</code>.  However, such a change to the code extents could have unexpected fallout, analogous to the fallout that was associated with <a href="https://github.com/rust-lang/rust/pull/21657">Rust PR 21657</a>.)</p>
<h4 id="mixing-acyclic-structure-and-drop-is-sometimes-rejected"><a class="header" href="#mixing-acyclic-structure-and-drop-is-sometimes-rejected">Mixing acyclic structure and <code>Drop</code> is sometimes rejected</a></h4>
<p>This is an example of sound code, accepted today, that is unfortunately rejected by the Drop-Check rule (at least in pnkfelix’s prototype):</p>
<pre><code class="language-rust">#![feature(unsafe_destructor)]

use std::cell::Cell;

#[derive(Show)]
struct C&lt;'a&gt; {
    f: Cell&lt;Option&lt;&amp;'a C&lt;'a&gt;&gt;&gt;,
}

impl&lt;'a&gt; C&lt;'a&gt; {
    fn new() -&gt; C&lt;'a&gt; {
        C { f: Cell::new(None), }
    }
}

// force dropck to care about C&lt;'a&gt;
#[unsafe_destructor]
impl&lt;'a&gt; Drop for C&lt;'a&gt; {
    fn drop(&amp;mut self) { }
}

fn f() {
    let c2;
    let mut c1;

    c1 = C::new();
    c2 = C::new();

    c1.f.set(Some(&amp;c2));
}

fn main() {
    f();
}</code></pre>
<p>In principle this should work, since <code>c1</code> and <code>c2</code> are assigned to distinct code extents, and <code>c1</code> will be dropped before <code>c2</code>.  However, in the prototype, the region inference system is determining that the lifetime <code>'a</code> in <code>&amp;'a C&lt;'a&gt;</code> (from the <code>c1.f.set(Some(&amp;c2));</code> statement) needs to cover the whole block, rather than just the block remainder extent that is actually covered by the <code>let c2;</code>.</p>
<p>(This may just be a bug somewhere in the prototype, but for the time being pnkfelix is going to assume that it will be a bug that this RFC is forced to live with indefinitely.)</p>
<h3 id="unsound-apis-need-to-be-revised-or-removed-entirely"><a class="header" href="#unsound-apis-need-to-be-revised-or-removed-entirely">Unsound APIs need to be revised or removed entirely</a></h3>
<p>While the Drop-Check rule is designed to ensure that safe Rust code is sound in its use of destructors, it cannot assure us that unsafe code is sound. It is the responsibility of the author of unsafe code to ensure it does not perform unsound actions; thus, we need to audit our own API’s to ensure that the standard library is not providing functionality that circumvents the Drop-Check rule.</p>
<p>The most obvious instance of this is the <code>arena</code> crate: in particular: one can use an instance of <code>arena::Arena</code> to create cyclic graph structure where each node’s destructor accesses (via <code>&amp;_</code> references) its neighboring nodes.</p>
<p>Here is a version of our running <code>C&lt;'a&gt;</code> example (where we now do something interesting the destructor for <code>C&lt;'a&gt;</code>) that demonstrates the problem:</p>
<p>Example:</p>
<pre><code class="language-rust">extern crate arena;

use std::cell::Cell;

#[derive(Show)]
struct C&lt;'a&gt; {
    name: &amp;'static str,
    v: Vec&lt;Cell&lt;Option&lt;&amp;'a C&lt;'a&gt;&gt;&gt;&gt;,
    usable: bool,
}

impl&lt;'a&gt; Drop for C&lt;'a&gt; {
    fn drop(&amp;mut self) {
        println!("dropping {}", self.name);
        for neighbor in self.v.iter().map(|v|v.get()) {
            if let Some(neighbor) = neighbor {
                println!("  {} checking neighbor {}",
                         self.name, neighbor.name);
                assert!(neighbor.usable);
            }
        }
        println!("done dropping {}", self.name);
        self.usable = false;

    }
}

impl&lt;'a&gt; C&lt;'a&gt; {
    fn new(name: &amp;'static str) -&gt; C&lt;'a&gt; {
        C { name: name, v: Vec::new(), usable: true }
    }
}

fn f() {
    use arena::Arena;
    let arena = Arena::new();
    let (c1, c2, c3);

    c1 = arena.alloc(|| C::new("c1"));
    c2 = arena.alloc(|| C::new("c2"));
    c3 = arena.alloc(|| C::new("c3"));

    c1.v.push(Cell::new(None));
    c1.v.push(Cell::new(None));
    c2.v.push(Cell::new(None));
    c2.v.push(Cell::new(None));
    c3.v.push(Cell::new(None));
    c3.v.push(Cell::new(None));

    c1.v[0].set(Some(c2));
    c1.v[1].set(Some(c3));
    c2.v[0].set(Some(c2));
    c2.v[1].set(Some(c3));
    c3.v[0].set(Some(c1));
    c3.v[1].set(Some(c2));
}</code></pre>
<p>Calling <code>f()</code> results in the following printout:</p>
<pre><code>dropping c3
  c3 checking neighbor c1
  c3 checking neighbor c2
done dropping c3
dropping c1
  c1 checking neighbor c2
  c1 checking neighbor c3
thread '&lt;main&gt;' panicked at 'assertion failed: neighbor.usable', ../src/test/compile-fail/dropck_untyped_arena_cycle.rs:19
</code></pre>
<p>This is unsound. It should not be possible to express such a scenario without using <code>unsafe</code> code.</p>
<p>This RFC suggests that we revise the <code>Arena</code> API by adding a phantom lifetime parameter to its type, and bound the values the arena allocates by that phantom lifetime, like so:</p>
<pre><code class="language-rust">pub struct Arena&lt;'longer_than_self&gt; {
    _invariant: marker::InvariantLifetime&lt;'longer_than_self&gt;,
    ...
}

impl&lt;'longer_than_self&gt; Arena&lt;'longer_than_self&gt; {
    pub fn alloc&lt;T:'longer_than_self, F&gt;(&amp;self, op: F) -&gt; &amp;mut T
        where F: FnOnce() -&gt; T {
        ...
    }
}</code></pre>
<p>Admittedly, this is a severe limitation, since it forces the data allocated by the Arena to store only references to data that strictly outlives the arena, regardless of whether the allocated data itself even has a destructor. (I.e., <code>Arena</code> would become much weaker than <code>TypedArena</code> when attempting to work with cyclic structures). (pnkfelix knows of no way to fix this without adding further extensions to the language, e.g. some way to express “this type’s destructor accesses none of its borrowed data”, which is out of scope for this RFC.)</p>
<p>Alternatively, we could just deprecate the <code>Arena</code> API, (which is not marked as stable anyway.</p>
<p>The example given here can be adapted to other kinds of backing storage structures, in order to double-check whether the API is likely to be sound or not.  For example, the <code>arena::TypedArena&lt;T&gt;</code> type appears to be sound (as long as it carries <code>PhantomData&lt;T&gt;</code> just like <code>Vec&lt;T&gt;</code> does). In particular, when one ports the above example to use <code>TypedArena</code> instead of <code>Arena</code>, it is statically rejected by <code>rustc</code>.</p>
<h3 id="the-final-goal-remove-unsafe_destructor"><a class="header" href="#the-final-goal-remove-unsafe_destructor">The final goal: remove #[unsafe_destructor]</a></h3>
<p>Once all of the above pieces have landed, lifetime- and type-parameterized <code>Drop</code> will be safe, and thus we will be able to remove <code>#[unsafe_destructor]</code>!</p>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<ul>
<li>
<p>The Drop-Check rule is a little complex, and does disallow some sound code that would compile today.</p>
</li>
<li>
<p>The change proposed in this RFC places restrictions on uses of types with attached destructors, but provides no way for a type <code>Foo&lt;'a&gt;</code> to state as part of its public interface that its drop implementation will not read from any borrowed data of lifetime <code>'a</code>. (Extending the language with such a feature is potential future work, but is out of scope for this RFC.)</p>
</li>
<li>
<p>Some useful interfaces are going to be disallowed by this RFC. For example, the RFC recommends that the current <code>arena::Arena</code> be revised or simply deprecated, due to its unsoundness. (If desired, we could add an <code>UnsafeArena</code> that continues to support the current <code>Arena</code> API with the caveat that its users need to <em>manually</em> enforce the constraint that the destructors do not access data that has been already dropped. But again, that decision is out of scope for this RFC.)</p>
</li>
</ul>
<h2 id="替代方案"><a class="header" href="#替代方案">替代方案</a></h2>
<p>We considered simpler versions of <a href="#the-drop-check-rule">the Drop-Check rule</a>; in particular, an earlier version of it simply said that if the type of <code>v</code> owns any type <code>D</code> that implements <code>Drop</code>, then for any lifetime <code>'a</code> that <code>D</code> refers to, <code>'a</code> must strictly outlive the scope of <code>v</code>, because the destructor for <code>D</code> might hypothetically access borrowed data of lifetime <code>'a</code>.</p>
<ul>
<li>
<p>This rule is simpler in the sense that it more obviously sound.</p>
</li>
<li>
<p>But this rule disallowed far more code; e.g.  the <a href="#some-cyclic-structure-is-still-allowed">Cyclic structure still allowed</a> example was rejected under this more naive rule, because <code>C&lt;'a&gt;</code> owns D = <code>Vec&lt;Cell&lt;Option&lt;&amp;'a C&lt;'a&gt;&gt;&gt;&gt;</code>, and this particular D refers to <code>'a</code>.</p>
</li>
</ul>
<hr>
<p>Sticking with the current <code>#[unsafe_destructor]</code> approach to lifetime- and type-parametric types that implement <code>Drop</code> is not really tenable; we need to do something (and we have been planning to do something like this RFC for over a year).</p>
<h2 id="未解決的問題"><a class="header" href="#未解決的問題">未解決的問題</a></h2>
<ul>
<li>
<p>Is the Drop-Check rule provably sound?  pnkfelix has based his argument on informal reasoning about parametricity, but it would be good to put forth a more formal argument.  (And in the meantime, pnkfelix invites the reader to try to find holes in the rule, preferably with concrete examples that can be fed into the prototype.)</p>
</li>
<li>
<p>How much can covariance help with some of the lifetime issues?</p>
<p>See in particular <a href="https://github.com/rust-lang/rust/issues/21198">Rust Issue 21198</a> “new scoping rules for safe dtors may benefit from variance on type params”</p>
</li>
</ul>
<p>Before adding Condition (B.) to <a href="#the-drop-check-rule">the Drop-Check Rule</a>, it seemed like enabling covariance in more standard library types was going to be very important for landing this work.  And even now, it is possible that covariance could still play an important role. But nonetheless, there are some API’s whose current form is fundamentally incompatible with covariance; e.g. the current <code>TypedArena&lt;T&gt;</code> API is fundamentally invariant with respect to <code>T</code>.</p>
<h2 id="appendices"><a class="header" href="#appendices">Appendices</a></h2>
<h3 id="appendix-a-why-and-when-would-drop-read-from-borrowed-data"><a class="header" href="#appendix-a-why-and-when-would-drop-read-from-borrowed-data">Appendix A: Why and when would Drop read from borrowed data</a></h3>
<p>Here is a story, about two developers, Julia and Kurt, and the code they hacked on.</p>
<p>Julia inherited some code, and it is misbehaving.  It appears like key/value entries that the code inserts into the standard library’s <code>HashMap</code> are not always retrievable from the map. Julia’s current hypothesis is that something is causing the keys’ computed hash codes to change dynamically, sometime after the entries have been inserted into the map (but it is not obvious when or if this change occurs, nor what its source might be). Julia thinks this hypothesis is plausible, but does not want to audit all of the key variants for possible causes of hash code corruption until after she has hard evidence confirming the hypothesis.</p>
<p>Julia writes some code that walks a hash map’s internals and checks that all of the keys produce a hash code that is consistent with their location in the map.  However, since it is not clear when the keys’ hash codes are changing, it is not clear where in the overall code base she should add such checks. (The hash map is sufficiently large that she cannot simply add calls to do this consistency check everywhere.)</p>
<p>However, there is one spot in the control flow that is a clear contender: if the check is run right before the hash map is dropped, then that would surely be sometime after the hypothesized corruption had occurred.  In other words, a destructor for the hash map seems like a good place to start; Julia could make her own local copy of the hash map library and add this check to a <code>impl&lt;K,V,S&gt; Drop for HashMap&lt;K,V,S&gt; { ... }</code> implementation.</p>
<p>In this new destructor code, Julia needs to invoke the hash-code method on <code>K</code>.  So she adds the bound <code>where K: Eq + Hash&lt;H&gt;</code> to her <code>HashMap</code> and its <code>Drop</code> implementation, along with the corresponding code to walk the table’s entries and check that the hash codes for all the keys matches their position in the table.</p>
<p>Using this, Julia manages confirms her hypothesis (yay).  And since it was a reasonable amount of effort to do this experiment, she puts this variation of <code>HashMap</code> up on <code>crates.io</code>, calling it the <code>CheckedHashMap</code> type.</p>
<p>Sometime later, Kurt pulls a copy of <code>CheckHashMap</code> off of <code>crates.io</code>, and he happens to write some code that looks like this:</p>
<pre><code class="language-rust">fn main() {
    #[derive(PartialEq, Eq, Hash, Debug)]
    struct Key&lt;'a&gt; { name: &amp;'a str }

    {
        let (key, mut map, name) : (Key, CheckedHashMap&lt;&amp;Key, String&gt;, String);
        name = format!("k1");
        map = CheckedHashMap::new();
        key = Key { name: &amp;*name };
        map.map.insert(&amp;key, format!("Value for k1"));
    }
}</code></pre>
<p>And, kaboom: when the map goes out of scope, the destructor for <code>CheckedHashMap</code> attempts to compute a hashcode on a reference to <code>key</code> that may not still be valid, and even if <code>key</code> is still valid, it holds a reference to a slice of name that likewise may not still be valid.</p>
<p>This illustrates a case where one might legitimately mix destructor code with borrowed data.  (Is this example any less contrived than <a href="#lifetime-parameterization-the-sneetch-example">the Sneetch example</a>? That is in the eye of the beholder.)</p>
<h3 id="appendix-b-strictly-outlives-details"><a class="header" href="#appendix-b-strictly-outlives-details">Appendix B: strictly-outlives details</a></h3>
<p>The rest of this section gets into some low-level details of parts of how <code>rustc</code> is implemented, largely because the changes described here do have an impact on what results the <code>rustc</code> region inference system produces (or fails to produce). It serves mostly to explain (1.) why <a href="https://github.com/rust-lang/rust/pull/21657">Rust PR 21657</a> was implemented, and (2.) why one may sometimes see indecipherable region-inference errors.</p>
<h4 id="review-code-extents"><a class="header" href="#review-code-extents">Review: Code Extents</a></h4>
<p>(Nothing here is meant to be new; its just providing context for the next subsection.)</p>
<p>Every Rust expression evaluates to a value <code>V</code> that is either placed into some location with an associated lifetime such as <code>'l</code>, or <code>V</code> is associated with a block of code that statically delimits the <code>V</code>’s runtime extent (i.e. we know from the function’s text where <code>V</code> will be dropped). In the <code>rustc</code> source, the blocks of code are sometimes called “scopes” and sometimes “code extents”; I will try to stick to the latter term here, since the word “scope” is terribly overloaded.</p>
<p>Currently, the code extents in Rust are arranged into a tree hierarchy structured similarly to the abstract syntax tree; for any given code extent, the compiler can ask for its parent in this hierarchy.</p>
<p>Every Rust expression <code>E</code> has an associated “terminating extent” somewhere in its chain of parent code extents; temporary values created during the execution of <code>E</code> are stored at stack locations managed by <code>E</code>’s terminating extent. When we hit the end of the terminating extent, all such temporaries are dropped.</p>
<p>An example of a terminating extent: in a let-statement like:</p>
<pre><code class="language-rust">let &lt;pat&gt; = &lt;expr&gt;;</code></pre>
<p>the terminating extent of <code>&lt;expr&gt;</code> is the let-statement itself. So in an example like:</p>
<pre><code class="language-rust">let a1 = input.f().g();`
...</code></pre>
<p>there is a temporary value returned from <code>input.f()</code>, and it will live until the end of the let statement, but not into the subsequent code represented by <code>...</code>.  (The value resulting from <code>input.f().g()</code>, on the other hand, will be stored in <code>a1</code> and lives until the end of the block enclosing the let statement.)</p>
<p>(It is not important to this RFC to know the full set of rules dictating which parent expressions are deemed terminating extents; we just will assume that these things do exist.)</p>
<p>For any given code extent <code>S</code>, the parent code extent <code>P</code> of <code>S</code>, if it exists, potentially holds bits of code that will execute after <code>S</code> is done.  Any cleanup code for any values assigned to <code>P</code> will only run after we have finished with <em>all</em> code associated with <code>S</code>.</p>
<h4 id="a-problem-with-10-alpha-code-extents"><a class="header" href="#a-problem-with-10-alpha-code-extents">A problem with 1.0 alpha code extents</a></h4>
<p>So, with the above established, we have a hint at how to express that a lifetime <code>'a</code> needs to strictly outlive a particular code extent <code>S</code>: simply say that <code>'a</code> needs to live at least long as <code>P</code>.</p>
<p>However, this is a little too simplistic, at least for the Rust compiler circa Rust 1.0 alpha. The main problem is that all the bindings established by let statements in a block are assigned the same code extent.</p>
<p>This, combined with our simplistic definition, yields real problems. For example, in:</p>
<pre><code class="language-rust">{
    use std::fmt;
    #[derive(Debug)] struct DropLoud&lt;T:fmt::Debug&gt;(&amp;'static str, T);
    impl&lt;T:fmt::Debug&gt; Drop for DropLoud&lt;T&gt; {
        fn drop(&amp;mut self) { println!("dropping {}:{:?}", self.0, self.1); }
    }

    let c1 = DropLoud("c1", 1);
    let c2 = DropLoud("c2", &amp;c1);
}</code></pre>
<p>In principle, the code above is legal: <code>c2</code> will be dropped before <code>c1</code> is, and thus it is okay that <code>c2</code> holds a borrowed reference to <code>c1</code> that will be read when <code>c2</code> is dropped (indirectly via the <code>fmt::Debug</code> implementation.</p>
<p>However, with the structure of code extents as of Rust 1.0 alpha, <code>c1</code> and <code>c2</code> are both given the same code extent: that of the block itself.  Thus in that context, this definition of “strictly outlives” indicates that <code>c1</code> does <em>not</em> strictly outlive <code>c2</code>, because <code>c1</code> does not live at least as long as the parent of the block; it only lives until the end of the block itself.</p>
<p>This illustrates why “All the bindings established by let statements in a block are assigned the same code extent” is a problem</p>
<h4 id="block-remainder-code-extents"><a class="header" href="#block-remainder-code-extents">Block Remainder Code Extents</a></h4>
<p>The solution proposed here (motivated by experience with the prototype) is to introduce finer-grained code extents.  This solution is essentially <a href="https://github.com/rust-lang/rust/pull/21657">Rust PR 21657</a>, which has already landed in <code>rustc</code>. (That is in part why this is merely an appendix, rather than part of the body of the RFC itself.)</p>
<p>The code extents remain in a tree-hierarchy, but there are now extra entries in the tree, which provide the foundation for a more precise “strictly outlives” relation.</p>
<p>We introduce a new code extent, called a “block remainder” extent, for every let statement in a block, representing the suffix of the block covered by the bindings in that let statement.</p>
<p>For example, given <code>{ let (a, b) = EXPR_1; let c = EXPR_2; ... }</code>, which previously had a code extent structure like:</p>
<pre><code>{ let (a, b) = EXPR_1; let c = EXPR_2; ... }
               +----+          +----+
  +------------------+ +-------------+
+------------------------------------------+
</code></pre>
<p>so the parent extent of each let statement was the whole block.</p>
<p>But under the new rules, there are two new block remainder extents introduced, with this structure:</p>
<pre><code>{  let (a, b) = EXPR_1;  let c = EXPR_2; ...  }
                +----+           +----+
   +------------------+  +-------------+
                        +-------------------+   &lt;-- new: block remainder 2
  +------------------------------------------+  &lt;-- new: block remainder 1
+---------------------------------------------+
</code></pre>
<p>The first let-statement introduces a block remainder extent that covers the lifetime for <code>a</code> and <code>b</code>.  The second let-statement introduces a block remainder extent that covers the lifetime for <code>c</code>.</p>
<p>Each let-statement continues to be the terminating extent for its initializer expression.  But now, the parent of the extent of the second let statement is a block remainder extent (“block remainder 2”), and, importantly, the parent of block remainder 2 is another block remainder extent (“block remainder 1”).  This way, we precisely represent the lifetimes of the named values bound by each let statement, and know that <code>a</code> and <code>b</code> both strictly outlive <code>c</code> as well as the temporary values created during evaluation of <code>EXPR_2</code>. Likewise, <code>c</code> strictly outlives the bindings and temporaries created in the <code>...</code> that follows it.</p>
<h4 id="why-stop-at-let-statements"><a class="header" href="#why-stop-at-let-statements">Why stop at let-statements?</a></h4>
<p>This RFC does <em>not</em> propose that we attempt to go further and track the order of destruction of the values bound by a <em>single</em> let statement.</p>
<p>Such an experiment could be made part of future work, but for now, we just continue to assign <code>a</code> and <code>b</code> to the same scope; the compiler does not attempt to reason about what order they will be dropped in, and thus we cannot for example reference data borrowed from <code>a</code> in any destructor code for <code>b</code>.</p>
<p>The main reason that we do not want to attempt to produce even finer grain scopes, at least not right now, is that there are scenarios where it is <em>important</em> to be able to assign the same region to two distinct pieces of data; in particular, this often arises when one wants to build cyclic structure, as discussed in <a href="#some-cyclic-structure-is-still-allowed">Cyclic structure still allowed</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="0738-variance.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="0771-std-iter-once.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="0738-variance.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="0771-std-iter-once.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
