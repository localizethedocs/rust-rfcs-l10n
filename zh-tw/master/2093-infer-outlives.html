<!DOCTYPE HTML>
<html lang="zh_TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2093-infer-outlives - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-c5bb60c5.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Feature Name: <code>infer_outlives</code></li>
<li>Start Date: 2017-08-02</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2093">rust-lang/rfcs#2093</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/44493">rust-lang/rust#44493</a></li>
</ul>
<h2 id="摘要"><a class="header" href="#摘要">摘要</a></h2>
<p>Remove the need for explicit <code>T: 'x</code> annotations on structs. We will infer their presence based on the fields of the struct. In short, if the struct contains a reference, directly or indirectly, to <code>T</code> with lifetime <code>'x</code>, then we will infer that <code>T: 'x</code> is a requirement:</p>
<pre><code class="language-rust">struct Foo&lt;'x, T&gt; {
  // inferred: `T: 'x`
  field: &amp;'x T
}  </code></pre>
<p>Explicit annotations remain as an option used to control trait object lifetime defaults, and simply for backwards compatibility.</p>
<h2 id="動機"><a class="header" href="#動機">動機</a></h2>
<p>Today, when you write generic struct definitions that contain references, those structs require where-clauses of the form <code>T: 'a</code>:</p>
<pre><code class="language-rust">struct SharedRef&lt;'a, T&gt;
  where T: 'a // &lt;-- currently required
{
  data: &amp;'a T
}</code></pre>
<p>These clauses are called <em>outlives requirements</em>, and the next section (“Background”) goes into a bit more detail on what they mean semantically.  <strong>The overriding goal of this RFC is to make these <code>where T: 'a</code> annotations unnecessary by inferring them.</strong></p>
<p>Anecdotally, these annotations are not well understood. Instead, the most common thing is to wait and add the where-clauses when the compiler requests that you do so. This is annoying, of course, but the annotations also clutter up the code, and add to the perception of Rust’s complexity.</p>
<p>Experienced Rust users may have noticed that the compiler already performs a similar seeming kind of inference in other settings. In particular, in function definitions or impls, outlives requirements are rarely needed. This is due to the mechanism known as <em>implied bounds</em> (also explained in more detail in the next section), which allows a function (resp. impl) to infer outlives requirements based on the types of its parameters (resp. input types):</p>
<pre><code class="language-rust">fn foo&lt;'a, T&gt;(r: SharedRef&lt;'a, T&gt;) {
  // Gets to assume that `T: 'a` holds, because it is a requirement
  // of the parameter type `SharedRef&lt;'a, T&gt;`.
}  </code></pre>
<p>This RFC proposes a mechanism for also inferring the outlives requirements on structs. This is not an extension of the implied bounds system; in general, field types of a struct are not considered “inputs” to the struct definition, and hence implied bounds do not apply. Indeed, the annotations that we are attempting to infer are used to drive the implied bounds system. Instead, to infer these outlives requirements on structs, we will use a specialized, fixed-point inference similar to <a href="https://github.com/rust-lang/rfcs/blob/master/text/0738-variance.md">variance inference</a>.</p>
<p>There is one other, relatively obscure, place where explicit lifetime annotations are used today: trait object lifetime defaults (<a href="https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md">RFC 599</a>). The interaction there is discussed in the Guide-Level Explanation below.</p>
<h3 id="background-outlives-requirements-today"><a class="header" href="#background-outlives-requirements-today">Background: outlives requirements today</a></h3>
<p><a href="https://github.com/nikomatsakis/rfcs/blob/master/text/0034-bounded-type-parameters.md">RFC 34</a> established the current rules around “outlives requirements”. Specifically, in order for a reference type <code>&amp;'a T</code> to be “well formed” (valid), the compiler must know that the type <code>T</code> “outlives” the lifetime <code>'a</code> – meaning that all references contained in the type <code>T</code> must be valid for the lifetime <code>'a</code>. So, for example, the type <code>i32</code> outlives any lifetime, including <code>'static</code>, since it has no references at all. (The “outlives” rules were later tweaked by <a href="https://github.com/rust-lang/rfcs/blob/master/text/1214-projections-lifetimes-and-wf.md">RFC 1214</a> to be more syntactic in nature.)</p>
<p>In practice, this means that in Rust, when you define a struct that contains references to a generic type, or references to other references, you need to add various where clauses for that struct type to be considered valid. For example, consider the following (currently invalid) struct <code>SharedRef</code>:</p>
<pre><code class="language-rust">struct SharedRef&lt;'a, T&gt; {
  data: &amp;'a T
}</code></pre>
<p>In general, for a struct definition to be valid, its field types must be known to be well-formed, based only on the struct’s where-clauses. In this case, the field <code>data</code> has the <code>&amp;'a T</code> – for that to be well-formed, we must know that <code>T: 'a</code> holds. Since we do not know what <code>T</code> is, we require that a where-clause be added to the struct header to assert that <code>T: 'a</code> must hold:</p>
<pre><code class="language-rust">struct SharedRef&lt;'a, T&gt;
  where T: 'a // currently required...
{
  data: &amp;'a T // ...so that we know that this field's type is well-formed
}</code></pre>
<p>In principle, similar where clauses would be required on generic functions or impl to ensure that their parameters or inputs are well-formed.  However, as you may have noticed, this is not the case. For example, the following function is valid as written:</p>
<pre><code class="language-rust">fn foo&lt;'a, T&gt;(x: &amp;'a T) {
  ..
}  </code></pre>
<p>This is due to Rust’s support for <strong>implied bounds</strong> – in particular, every function and impl <strong>assumes</strong> that the types of its inputs are well-formed. In this case, since <code>foo</code> can assume that <code>&amp;'a T</code> is well-formed, it can also deduce that <code>T: 'a</code> must hold, and hence we do not require where-clauses asserting this fact. (Currently, implied bounds are only used for lifetime requirements; pending <a href="https://github.com/rust-lang/rfcs/pull/2089">RFC 2089</a> proposes to extend this mechanism to other sorts of bounds.)</p>
<h2 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h2>
<p>This RFC does not introduce any new concepts – rather, it (mostly) removes the need to be actively aware of outlives requirements. In particular, the compiler will infer the <code>T: 'a</code> requirements on behalf of the programmer.  Therefore, the <code>SharedRef</code> struct we have seen in the previous section would be accepted without any annotation:</p>
<pre><code class="language-rust">struct SharedRef&lt;'a, T&gt; {
    r: &amp;'a T
}</code></pre>
<p>The compiler would infer that <code>T: 'a</code> must hold for the type <code>SharedRef&lt;'a, T&gt;</code> to be valid. In some cases, the requirement may be inferred through several structs. So, for the struct <code>Indirect</code> below, we would also infer that <code>T: 'a</code> is required, because <code>Indirect</code> contains a <code>SharedRef&lt;'a, T&gt;</code>:</p>
<pre><code class="language-rust">struct Indirect&lt;'a, T&gt; {
  r: SharedRef&lt;'a, T&gt;
}</code></pre>
<h3 id="where-explicit-annotations-would-still-be-required"><a class="header" href="#where-explicit-annotations-would-still-be-required">Where explicit annotations would still be required</a></h3>
<p>Explicit outlives annotations would primarily be required in cases where the lifetime and the type are combined within the value of an associated type, but not in one of the impl’s input types. For example:</p>
<pre><code>trait MakeRef&lt;'a&gt; {
  type Type;
}

impl&lt;'a, T&gt; MakeRef&lt;'a&gt; for Vec&lt;T&gt;
  where T: 'a // still required
{
  type Type = &amp;'a T;
}
</code></pre>
<p>In this case, the impl has two inputs – the lifetime <code>'a</code> and the type <code>Vec&lt;T&gt;</code> (note that <code>'a</code> and <code>T</code> are the impl parameters; the inputs come from the parameters of the trait that is being implemented). Neither of these inputs requires that <code>T: 'a</code>. So, when we try to specify the value of the associated type as <code>&amp;'a T</code>, we still require a where clause to infer that <code>T: 'a</code> must hold.</p>
<p>In turn, if this associated type were used in a struct, where-clauses would be required. As we’ll see in the reference-level explanation, this is a consequence of the fact that we do inference without regard for associated type normalization, but it makes for a relatively simple rule – explicit where clauses are needed in the preseence of impls like the one above:</p>
<pre><code class="language-rust">struct Foo&lt;'a, T&gt;
  where T: 'a // still required, not inferred from `field`
{
  field: &lt;Vec&lt;T&gt; as MakeRef&lt;'a&gt;&gt;::Type
}    </code></pre>
<p>As the algorithm is currently framed, outlives requirements written on traits must also be explicitly propagated; however, this will typically occur as part of the existing bounds:</p>
<pre><code class="language-rust">trait Trait&lt;'a&gt; where Self: 'a {
  type Type;
}

struct Foo&lt;'a, T&gt;
  where T: Trait&lt;'a&gt; // implies `T: 'a` already, so no error
{
  r: &lt;T as Trait&lt;'a&gt;&gt;::Type // requires that `T: 'a` to be WF
}</code></pre>
<h3 id="trait-object-lifetime-defaults"><a class="header" href="#trait-object-lifetime-defaults">Trait object lifetime defaults</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md">RFC 599</a> (later amended by <a href="https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md">RFC 1156</a>) specified the defaulting rules for trait object types. Typically, a trait object type that appears as a parameter to a struct is given the implicit bound <code>'static</code>; hence <code>Box&lt;Debug&gt;</code> defaults to <code>Box&lt;Debug + 'static&gt;</code>. References to trait objects, however, are given by default the lifetime of the reference; hence <code>&amp;'a Debug</code> defaults to <code>&amp;'a (Debug + 'a)</code>.</p>
<p>Structs that contain explicit <code>T: 'a</code> where-clauses, however, use the default given lifetime <code>'a</code> as the default for trait objects. Therefore, given a struct definition like the following:</p>
<pre><code class="language-rust">struct Ref&lt;'a, T&gt; where T: 'a + ?Sized { .. }</code></pre>
<p>The type <code>Ref&lt;'x, Debug&gt;</code> defaults to <code>Ref&lt;'x, Debug + 'x&gt;</code> and not <code>Ref&lt;'x, Debug + 'static&gt;</code>. Effectively the <code>where T: 'a</code> declaration acts as a kind of signal that <code>Ref</code> acts as a “reference to <code>T</code>”.</p>
<p>This RFC does not change these defaulting rules. In particular, these defaults are applied <strong>before</strong> where-clause inference takes place, and hence are not affected by the results. Trait object defaulting therefore requires an explicit <code>where T: 'a</code> declaration on the struct; in fact, such explicit declarations can be thought of as existing primarily for the purpose of informing trait object lifetime defaults, since they are typically not needed otherwise.</p>
<h3 id="long-range-errors-and-why-they-are-considered-unlikely"><a class="header" href="#long-range-errors-and-why-they-are-considered-unlikely">Long-range errors, and why they are considered unlikely</a></h3>
<p>Initially, we avoided inferring the <code>T: 'a</code> annotations on struct types in part out of a fear of “long-range” error messages, where it becomes hard to see the origin of an outlives requirement.  Consider for example a setup like this one:</p>
<pre><code class="language-rust">struct Indirect&lt;'a, T&gt; {
  field: Direct&lt;'a, T&gt;
}

struct Direct&lt;'a, T&gt; {
  field: &amp;'a T
}</code></pre>
<p>Here, both of these structs require that <code>T: 'a</code>, but the requirement is not written explicitly. If you have access to the full definition of <code>Direct</code>, it might be obvious that the requirement arises from the <code>&amp;'a T</code> type, but discovering this for <code>Indirect</code> requires looking deeply into the definitions of all types that it references.</p>
<p>In principle, such errors can occur, but there are many reasons to believe that “long-range errors” will not be a source of problems in practice:</p>
<ul>
<li>The inferred bounds approach ensures that code that is given (e.g., as a parameter) an existing <code>Indirect</code> or <code>Direct</code> value will already be able to assume the required outlives relationship holds.</li>
<li>Code that creates an <code>Indirect</code> or <code>Direct</code> value must also create the <code>&amp;'a T</code> reference found in <code>Direct</code>, and creating <em>that</em> reference would only be legal if <code>T: 'a</code>.</li>
</ul>
<p>Put another way, think back on your experience writing Rust code: how often do you get an error that is solved by writing <code>where T: 'a</code> or <code>where 'a: 'b</code> <strong>outside of a struct definition</strong>? At least in the author’s experience, such errors are quite infrequent.</p>
<p>That said, long-range errors <em>can</em> still occur, typically around impls and associated type values, as mentioned in the previous section. For example, the following impl would not compile:</p>
<pre><code class="language-rust">trait MakeRef&lt;'a&gt; {
  type Type;
}

impl&lt;'a, T&gt; MakeRef&lt;'a&gt; for Vec&lt;T&gt; {
  type Type = Indirect&lt;'a, T&gt;;
}</code></pre>
<p>Here, we would be missing a where-clause that <code>T: 'a</code> due to the type <code>Indirect&lt;'a, T&gt;</code>, just as we saw in the previous section. In such cases, tweaking the wording of the error could help to make the cause clearer. Similarly to auto traits, the idea would be to help trace the path that led to the <code>T: 'a</code> requirement on the user’s behalf:</p>
<pre><code>error[E0309]: the type `T` may not live long enough
 --&gt; src/main.rs:6:3
   |
 6 |   type Type = Indirect&lt;'a, T&gt;;
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the type `Indirect&lt;'a, T&gt;` requires that `T: 'a`
   |
   = note: `Indirect&lt;'a, T&gt;` requires that `T: 'a` because it contains a field of type `Direct&lt;'a, T&gt;`
   = note: `Direct&lt;'a, T&gt;` requires that `T: 'a` because it contains a field of type `&amp;'a T`
</code></pre>
<h3 id="impact-on-semver"><a class="header" href="#impact-on-semver">Impact on semver</a></h3>
<p>Due to the implied bounds rules, it is currently the case that removing <code>where T: 'a</code> annotations is potentially a breaking change. After this RFC, the rule is a bit more subtle: removing an annotation is still potentially a breaking change (even if it would be inferred), due to the trait object rules; but also, adding or removing a field of type <code>&amp;'a T</code> could affect the results of inference, and hence may be a breaking change. As an example, consider a struct like the following:</p>
<pre><code class="language-rust">struct Iter&lt;'a, T&gt; {
  vec: &amp;'a Vec&lt;T&gt; // Implies: `T: 'a`
}</code></pre>
<p>Now imagine a function that takes <code>Iter</code> as an argument:</p>
<pre><code class="language-rust">fn foo&lt;'a, T&gt;(iter: Iter&lt;'a, T&gt;) { .. }</code></pre>
<p>Under this RFC, this function can assume that <code>T: 'a</code> due to the implied bounds of its parameter type. But if <code>Iter&lt;'a, T&gt;</code> were changed to (e.g.) remove the field <code>vec</code>, then it may no longer require that <code>T: 'a</code> holds, and hence <code>foo()</code> would no longer have the implied bound that <code>T: 'a</code> holds.</p>
<p>This situation is considered unlikely: typically, if a struct has a lifetime parameter (such as the <code>Iter</code> struct), then the fact that it contains (or may contain) a borrowed reference is rather fundamental to how it works. If that borrowed reference were to be removed entirely, then the struct’s API will likely be changing in other incompatible ways, since that implies that the struct is now taking ownership of data it used to borrow (or else has access to less data than it did before).</p>
<p><strong>Note:</strong> This is not the only case where changes to private field types can cause downstream errors: introducing object types can inhibit auto traits like <code>Send</code> and <code>Sync</code>. What these have in common is that they are both entangled with Rust’s memory safety checking. It is commonly observed that parallelim is anti-encapsulation, in that, to know if two bits of code can be run in parallel, you must know what data they access, but for the strongest encapsulation, you wish to hide that fact. Memory safety has a similar property: to guarantee that references are always valid, we need to know where they appear, even if it is deeply nested within a struct hierarchy. Probably the best way to mitigate these sorts of subtle semver complications is to have a tool that detects and warns for incompatible changes.</p>
<h2 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h2>
<p>The intention is that the outlives inference takes place at the same time in the compiler pipeline as variance inference. In particular, this is after the point where we have been able to construct “semantics” or “internal” types from the HIR (so we don’t have to define the inference in a purely syntactic fashion). However, this is still relatively early, so we wish to avoid doing things like solving traits. Like variance inference, the new inference is an iterative algorithm that continues to infer additional requirements until a fixed point is reached.</p>
<p>For each struct declared by the user, we will infer a set of implicit outlives annotations. These annotations take one of several forms:</p>
<ul>
<li><code>'a: 'b</code> – two lifetimes (typically parameters of the trait) are required to outlive one another</li>
<li><code>T: 'a</code> – a type parameter <code>T</code> of the trait is required to outlive the lifetime <code>'a</code>, which is either a parameter of the trait or <code>'static</code></li>
<li><code>&lt;T as Trait&lt;..&gt;&gt;::Item: 'a</code> – the value of an associated type is required to outlive the lifetime <code>'a</code>, which is either a parameter of the trait or <code>'static</code> (here <code>T</code> represents an arbitrary type).</li>
</ul>
<p>We will infer a minimal set of annotations <code>A[S]</code> for each struct <code>S</code>. This set must meet the constraints derived by the following algorithm.</p>
<p>First, if the struct contains a where-clause <code>C</code> matching the above forms, then we add the constraint that <code>C in A[S]</code>. So, for example, in the following struct:</p>
<pre><code class="language-rust">struct Foo&lt;'a, T&gt; where T: 'a { .. }</code></pre>
<p>we would add the constraint that <code>(T: 'a) in A[S]</code>.</p>
<p>Next, for each field <code>f</code> of type <code>T_f</code> of the struct <code>S</code>, we derive each outlives requirement that is needed for <code>T_f</code> to be well-formed and require that those be included in <code>A[S]</code>. <strong>This is done on the unnormalized type <code>T_f</code></strong>.  These rules can be derived in a fairly straightforward way from the inference rules given in <a href="https://github.com/rust-lang/rfcs/blob/master/text/1214-projections-lifetimes-and-wf.md">RFC 1214</a>. We won’t give an exhaustive accounting of the rules, but will just note the outlines of the algorithm:</p>
<ul>
<li>A field containing a reference type like <code>&amp;'a T</code> naturally requires that <code>T: 'a</code> must be satisfied (here <code>T</code> represents “some type” and not necessarily a type parameter; for example, <code>&amp;'a &amp;'b i32</code> would lead to the outlives requirement that <code>'b: 'a</code>).</li>
<li>A reference to a struct like <code>Foo&lt;'a, T&gt;</code> may also require outlives requirements. This is determined by checking the (current) value of <code>A[Foo]</code>, after substituting its parameters.</li>
<li>For an associated type reference like <code>&lt;T as BarTrait&lt;'a&gt;&gt;::Type</code>, we do not attempt normalization, but rather just check that <code>T</code> is well-formed.
<ul>
<li>This is partly looking forward to a time when, at this stage, we may not know which trait is being projected from (in the compiler as currently implemented, we already do).</li>
<li>Note that we do not infer additional requirements on traits, we simply use the values given by users.</li>
<li>Note further that where-clauses declared on impls are never relevant here.</li>
</ul>
</li>
</ul>
<p>Once inference is complete, the implicit outlives requirements inferred as part of <code>A</code> become part of the predicates on the struct for all intents and purposes after this point.</p>
<p>Note that inference is not “complete” – i.e., it is not guaranteed to find all the outlives requirements that are ultimately required (in particular, it does not find those that arise through normalization). Furthermore, it only covers outlives requirements, and not other sorts of well-formedness rules (e.g., trait requirements like <code>T: Eq</code>). Therefore, after inference completes, we still check that each type is well-formed just as today, but with the inferred outlives requirements in scope.</p>
<h3 id="example-1-a-reference"><a class="header" href="#example-1-a-reference">Example 1: A reference</a></h3>
<p>The simplest example is one where we have a reference type directly contained in the struct:</p>
<pre><code class="language-rust">struct Foo&lt;'a, T&gt; {
  bar: &amp;'a [T]
}</code></pre>
<p>Here, the reference type requires that <code>[T]: 'a</code> which in turn is true if <code>T: 'a</code>. Hence we will create a single constraint, that <code>(T: 'a) in A[Foo]</code>.</p>
<h3 id="example-2-projections"><a class="header" href="#example-2-projections">Example 2: Projections</a></h3>
<p>In some cases, the outlives requirements are not of the form <code>T: 'a</code>, as in this example:</p>
<pre><code class="language-rust">struct Foo&lt;'a, T: Iterator&gt; {
  bar: &amp;'a T::Item
}</code></pre>
<p>Here, the requirement will be that <code>&lt;T as Iterator&gt;::Item: 'a</code>.</p>
<h3 id="example-3-explicit-where-clauses"><a class="header" href="#example-3-explicit-where-clauses">Example 3: Explicit where-clauses</a></h3>
<p>In some cases, we may have constraints that arise from explicit where-clauses and not from field types, as in the following example:</p>
<pre><code class="language-rust">struct Foo&lt;'b, U&gt; {
  bar: Bar&lt;'b, U&gt;
}

struct Bar&lt;'a, T&gt; where T: 'a {
  x: &amp;'a (),
  y: T
}</code></pre>
<p>Here, <code>Bar</code> is declared with the where clause that <code>T: 'a</code>. This results in the requirement that <code>(T: 'a) in A[Bar]</code>. <code>Foo</code>, meanwhile, requires that any outlives requirements for <code>Bar&lt;'b, U&gt;</code> are satisfied, and hence as the rule that <code>('a =&gt; 'b, T =&gt; U) (A[Bar]) &lt;= A[Foo]</code>. The minimal solution to this is:</p>
<ul>
<li><code>A[Foo] = (U: 'b)</code></li>
<li><code>A[Bar] = (T: 'a)</code></li>
</ul>
<p>This means that we would infer an implicit outlives requirements of <code>U: 'b</code> for <code>Foo</code>; for <code>Bar</code> we would infer <code>T: 'a</code> but that was explicitly declared.</p>
<h3 id="example-4-normalization-or-lack-thereof"><a class="header" href="#example-4-normalization-or-lack-thereof">Example 4: Normalization or lack thereof</a></h3>
<p>Let us revisit the case where the where-clause is due to an impl:</p>
<pre><code class="language-rust">trait MakeRef&lt;'a&gt; {
  type Type;
}

impl&lt;'a, T&gt; MakeRef&lt;'a&gt; for Vec&lt;T&gt;
  where T: 'a
{
  type Type = &amp;'a T;
}

struct Foo&lt;'a, T&gt; { // Results in an error
  foo: &lt;Vec&lt;T&gt; as MakeRef&lt;'a&gt;::Type
}</code></pre>
<p>Here, for the struct <code>Foo&lt;'a, T&gt;</code>, we will in fact create no constraints for its where-clause set, and hence we will infer an empty set. This is because we encounter the field type <code>&lt;Vec&lt;T&gt; as MakeRef&lt;'a&gt;&gt;::Type</code>, and in such a case we ignore the trait reference itself and just require that <code>Vec&lt;T&gt;</code> is well-formed, which does not result in any outlives requirements as it contains no references.</p>
<p>Now, when we go to check the full well-formedness rules for <code>Foo</code>, we will get an error – this is because, in that context, we will try to normalize the associated type reference, but we will fail in doing so because we do not have any where-clause stating that <code>T: 'a</code> (which the impl requires).</p>
<h3 id="example-5-multiple-regions"><a class="header" href="#example-5-multiple-regions">Example 5: Multiple regions</a></h3>
<p>Sometimes the outlives relationship can be inferred between multiple regions, not only type parameters. Consider the following:</p>
<pre><code class="language-rust">struct Foo&lt;'a,'b,T&gt; {
    x: &amp;'a &amp;'b T
}</code></pre>
<p>Here the WF rules for the type <code>&amp;'a &amp;'b T</code> require that both:</p>
<ul>
<li><code>'b: 'a</code> holds, because of the outer reference; and,</li>
<li><code>T: 'b</code> holds, because of the inner reference.</li>
</ul>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>The primary drawbacks were covered in depth in the guide-level explanation, which also covers why they are not considered to be major problems:</p>
<ul>
<li>Long-range errors
<ul>
<li>can be readily mitigated by better explanations</li>
</ul>
</li>
<li>Removing fields can affect semver compatibility
<ul>
<li>considered unlikely to occur frequently in practice</li>
<li>already true that changing field types can affect semver compatibility</li>
<li>semver-like tool could help to mitigate</li>
</ul>
</li>
</ul>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and Alternatives</a></h2>
<p>Naturally, we might choose to retain the status quo, and continue to require outlives annotations on structs. Assuming however that we wish to remove them, the primary alternative is to consider going <em>farther</em> than this RFC in various ways.</p>
<p>We might make try to infer outlives requirements for impls as well, and thus eliminate the final place where <code>T: 'a</code> requirements are needed. However, this would introduce complications in the implementation – in order to propagate requirements from impls to structs, we must be able to do associated type normalization and hence trait solving, but we would have to do before we know the full WF requirements for each struct. The current setup avoids this complication.</p>
<h2 id="未解決的問題"><a class="header" href="#未解決的問題">未解決的問題</a></h2>
<p>None.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="2091-inline-semantic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="2094-nll.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="2091-inline-semantic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="2094-nll.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
