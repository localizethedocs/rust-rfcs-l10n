<!DOCTYPE HTML>
<html lang="zh_TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2500-needle - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-c5bb60c5.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Feature Name: <code>needle</code></li>
<li>Start Date: 2018-07-06</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2500">rust-lang/rfcs#2500</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/56345">rust-lang/rust#56345</a></li>
</ul>
<h2 id="this-rfc-was-previously-approved-but-later-withdrawn"><a class="header" href="#this-rfc-was-previously-approved-but-later-withdrawn">This RFC was previously approved, but later <strong>withdrawn</strong></a></h2>
<p>For details see the <a href="https://github.com/rust-lang/rust/pull/76901#issuecomment-880169952">summary comment</a>.</p>
<h2 id="ÊëòË¶Å"><a class="header" href="#ÊëòË¶Å">ÊëòË¶Å</a></h2>
<p>Generalize the needle (n√©e pattern) API to support <code>&amp;str</code>, <code>&amp;mut str</code>, <code>&amp;[T]</code>, <code>&amp;mut [T]</code>, <code>Vec&lt;T&gt;</code> and <code>&amp;OsStr</code>.</p>
<!-- TOC depthTo:2 -->
<ul>
<li><a href="#summary">Summary</a></li>
<li><a href="#motivation">Motivation</a>
<ul>
<li><a href="#stabilize-the-pattern-api">Stabilize the Pattern API</a></li>
<li><a href="#implement-omg-wtf-8">Implement OMG-WTF-8</a></li>
</ul>
</li>
<li><a href="#guide-level-explanation">Guide-level explanation</a></li>
<li><a href="#reference-level-explanation">Reference-level explanation</a>
<ul>
<li><a href="#api">API</a></li>
<li><a href="#standard-library-changes">Standard library changes</a></li>
<li><a href="#performance">Performance</a></li>
</ul>
</li>
<li><a href="#drawbacks">Drawbacks</a></li>
<li><a href="#rationale-and-alternatives">Rationale and alternatives</a>
<ul>
<li><a href="#principles">Principles</a></li>
<li><a href="#design-rationales">Design rationales</a></li>
<li><a href="#miscellaneous-decisions">Miscellaneous decisions</a></li>
<li><a href="#alternatives">Alternatives</a></li>
</ul>
</li>
<li><a href="#prior-art">Prior art</a>
<ul>
<li><a href="#previous-attempts">Previous attempts</a></li>
<li><a href="#haskell">Haskell</a></li>
</ul>
</li>
<li><a href="#unresolved-questions">Unresolved questions</a></li>
</ul>
<!-- /TOC -->
<h2 id="ÂãïÊ©ü"><a class="header" href="#ÂãïÊ©ü">ÂãïÊ©ü</a></h2>
<h3 id="stabilize-the-pattern-api"><a class="header" href="#stabilize-the-pattern-api">Stabilize the Pattern API</a></h3>
<p>Pattern API v1.0 (<a href="https://github.com/rust-lang/rfcs/pull/528">RFC 528</a> / <a href="https://github.com/rust-lang/rust/issues/27721">issue 27721</a>) has been implemented for nearly 3 years, but we still haven‚Äôt decided to stabilize. One of the blockers is attempting to generalize the API to support <code>str</code>, <code>[T]</code> and <code>OsStr</code>, though it only exists as sketches and never finalized.</p>
<p>This RFC is raised as attempt to</p>
<ol>
<li>
<p>Generalize the pattern API so that all built-in slice-like types <code>&amp;str</code>, <code>&amp;mut str</code>, <code>&amp;[T]</code>, <code>&amp;mut [T]</code>, <code>Vec&lt;T&gt;</code> and <code>&amp;OsStr</code> can be searched.</p>
</li>
<li>
<p>Revise the API to address some performance and usability issues identified in the previous attempts.</p>
</li>
</ol>
<p>We hope that this RFC could revitalize the Pattern API development and make its stabilization foreseeable.</p>
<h3 id="implement-omg-wtf-8"><a class="header" href="#implement-omg-wtf-8">Implement OMG-WTF-8</a></h3>
<p>The OMG-WTF-8 encoding was introduced to allow slicing an <code>&amp;OsStr</code>, and thus enable extending the Pattern API to <code>&amp;OsStr</code> without special-casing (<a href="https://github.com/rust-lang/rfcs/pull/2295">RFC 2295</a> / <a href="https://github.com/rust-lang/rust/issues/49802">issue 49802</a>). That RFC expects a Pattern API working with <code>OsStr</code> to generalize some methods (e.g. <code>OsStr::ends_with()</code>). This RFC would unblock the implementation of RFC 2295, as to decide whether to integrate with a Pattern API, or just go with the non-generic version.</p>
<h2 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h2>
<p>You may check the prototype package <a href="https://crates.io/crates/pattern-3"><code>pattern-3</code></a> for API documentation and source code.</p>
<h2 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h2>
<p>Key concepts:</p>
<ul>
<li>Searching is based on <em>trisection</em>, splitting a string into 3 parts: the substring before, being, and after the match. <code>"ab123cedf" == "ab" ++ "123" ++ "cdef"</code>.</li>
<li><em>Haystack</em> teaches the search algorithm how to perform splitting with proper ownership transfer.</li>
<li><em>Searcher</em> is responsible for finding the range of the match.</li>
<li>Utilizing these together to safely construct many useful algorithms related to string matching.</li>
</ul>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<p>All items below should be placed in the <code>core::needle</code> module, re-exported as <code>std::needle</code>.</p>
<p>We renamed ‚ÄúPattern API‚Äù into ‚ÄúNeedle API‚Äù to avoid confusion with the language‚Äôs pattern matching i.e. the <code>match</code> expression.</p>
<h4 id="hay"><a class="header" href="#hay">Hay</a></h4>
<p>A <code>Hay</code> is the core type which the search algorithm will run on. It is implemented on the unsized slice-like types like <code>str</code>, <code>OsStr</code> and <code>[T]</code>.</p>
<pre><code class="language-rust">pub unsafe trait Hay {
    type Index: Copy + Debug + Eq;

    fn empty&lt;'a&gt;() -&gt; &amp;'a Self;

    fn start_index(&amp;self) -&gt; Self::Index;
    fn end_index(&amp;self) -&gt; Self::Index;

    unsafe fn next_index(&amp;self, index: Self::Index) -&gt; Self::Index;
    unsafe fn prev_index(&amp;self, index: Self::Index) -&gt; Self::Index;

    unsafe fn slice_unchecked(&amp;self, range: Range&lt;Self::Index&gt;) -&gt; &amp;Self;
}</code></pre>
<p>The trait is unsafe to implement because it needs to guarantee all methods (esp. <code>.start_index()</code> and <code>.end_index()</code>) follow the documented requirements, which cannot be checked automatically.</p>
<p>We allow a hay to customize the <code>Index</code> type. While <code>str</code>, <code>[T]</code> and <code>OsStr</code> all  use <code>usize</code> as the index, we do want the Needle API to support other linear structures like <code>LinkedList&lt;T&gt;</code>, where a cursor/pointer would be more suitable for allowing sub-linear splitting.</p>
<pre><code>start_index() = 0   next_index(2) = 6
        |         +-------------------+
        v         ^                   v
        0    1    2    3    4    5    6    7
        +----+----+----+----+----+----+----+
        | 48 | 69 | f0   9f   8c   8d | 21 |
        +----+----+----+----+----+----+----+
        0    1    2    3    4    5    6    7
             ^    v                        ^
             +----+                        |
        prev_index(2) = 1            end_index() = 7
</code></pre>
<h4 id="haystack"><a class="header" href="#haystack">Haystack</a></h4>
<p>A <code>Haystack</code> is any linear structure which we can do string/array matching on, and can be sliced or split so they could be returned from the <code>matches()</code> and <code>split()</code> iterators.</p>
<p>Haystack is implemented on the reference or collection itself e.g. <code>&amp;[T]</code>, <code>&amp;mut [T]</code> and <code>Vec&lt;T&gt;</code>. A hay can <em>borrowed</em> from a haystack.</p>
<pre><code class="language-rust">pub unsafe trait Haystack: Deref&lt;Target: Hay&gt; + Sized {
    fn empty() -&gt; Self;
    unsafe fn split_around(self, range: Range&lt;Self::Target::Index&gt;) -&gt; [Self; 3];

    unsafe fn slice_unchecked(self, range: Range&lt;Self::Target::Index&gt;) -&gt; Self {
        let [_, middle, _] = self.split_around(range);
        middle
    }

    fn restore_range(
        &amp;self,
        original: Range&lt;Self::Target::Index&gt;,
        parent: Range&lt;Self::Target::Index&gt;,
    ) -&gt; Range&lt;Self::Target::Index&gt;;
}
// we assume either RFC 2089 (issue #44491) or RFC 2289 is implemented.
// for simplicity we're ignoring issue #38078 which forces us to write `&lt;Self::Target as Hay&gt;::Index`.</code></pre>
<blockquote>
<p>We assume either Implied Bounds (<a href="https://github.com/rust-lang/rfcs/pull/2089">RFC 2089</a> / <a href="https://github.com/rust-lang/rust/issues/44491">issue 44491</a>) is implemented (thus fixing [issue 20671]), or Associated Type Bounds (<a href="https://github.com/rust-lang/rfcs/pull/2289">RFC 2289</a>) has been accepted and implemented.</p>
<p>For simplicity we are ignoring <a href="https://github.com/rust-lang/rust/issues/38078">issue 38078</a>, which forces us to write <code>&lt;Self::Target as Hay&gt;::Index</code> instead of <code>Self::Target::Index</code>.</p>
</blockquote>
<p>The <code>self.restore_range(original, parent)</code> method is implemented to solve:</p>
<ul>
<li>given haystacks <code>a</code> and <code>b</code></li>
<li>given <code>a = b[original]</code> and <code>self = a[parent]</code></li>
<li>find <code>range</code> such that <code>self == b[original][parent] == b[range]</code></li>
</ul>
<p>This method is used to recover the original range in functions like <code>find()</code> and <code>match_indices()</code>. It is usually just implemented as <code>(original.start + parent.start)..(original.start + parent.end)</code>.</p>
<p>When an index is based on a pointer, splitting a haystack will <em>invalidate</em> those pointers. However, a pointer is persisted with slicing, so they could implement this method simply as <code>self.start_index()..self.end_index()</code>.</p>
<h4 id="shared-haystack"><a class="header" href="#shared-haystack">Shared haystack</a></h4>
<p>A <code>SharedHaystack</code> is a marker sub-trait which tells the compiler this haystack can cheaply be cheaply cloned (i.e. shared), e.g. a <code>&amp;H</code> or <code>Rc&lt;H&gt;</code>. Implementing this trait alters some behavior of the <code>Span</code> structure discussed next section.</p>
<pre><code class="language-rust">pub trait SharedHaystack: Haystack + Clone {}</code></pre>
<p><code>.restore_range()</code> will never be called with a shared haystack and should be implemented as <code>unreachable!()</code>.</p>
<h4 id="span"><a class="header" href="#span">Span</a></h4>
<p>A <code>Span</code> is a haystack coupled with information where the original span is found.</p>
<pre><code class="language-rust">pub struct Span&lt;H: Haystack&gt; { /* hidden */ }

impl&lt;H: Haystack&gt; Span&lt;H&gt; {
    pub fn original_range(&amp;self) -&gt; Range&lt;H::Target::Index&gt;;
    pub fn borrow(&amp;self) -&gt; Span&lt;&amp;H::Target&gt;;
    pub fn is_empty(&amp;self) -&gt; bool;
    pub fn take(&amp;mut self) -&gt; Self;

    pub unsafe fn split_around(self, subrange: Range&lt;H::Target::Index&gt;) -&gt; [Self; 3];
    pub unsafe fn slice_unchecked(self, subrange: Range&lt;H::Target::Index&gt;) -&gt; Self;
}

impl&lt;H: SharedHaystack&gt; Span&lt;H&gt; {
    pub fn into_parts(self) -&gt; (H, Range&lt;H::Target::Index&gt;);
    pub unsafe fn from_parts(haystack: H, range: Range&lt;H::Target::Index&gt;) -&gt; Self;
}

impl&lt;H: Haystack&gt; From&lt;H&gt; for Span&lt;H&gt; { ... }
impl&lt;H: Haystack&gt; From&lt;Span&lt;H&gt;&gt; for H { ... }</code></pre>
<p>The behavior of a span differs slightly between a shared haystack and unique haystack (this is also the main reason why the <code>Span</code> structure is introduced).</p>
<pre><code class="language-text">                     Span&lt;&amp;str&gt;                         Span&lt;&amp;mut str&gt;

               -+---+---+---+---+---+-               +---+---+---+---+---+
                | C | D | E | F | G |                | C | D | E | F | G |
               -+---+---+---+---+---+-               +---+---+---+---+---+
                ^___________________^                ^                   ^
                 3..8                                3                   8

split_around:           ^_______^                            ^_______^
                         5..7                                 2..4

               -+---+---+---+---+---+-               +---+---+
                | C | D | E | F | G |                | C | D |
               -+---+---+---+---+---+-               +---+---+
                ^_______^                            ^       ^
                 3..5                                3       5

               -+---+---+---+---+---+-                       +---+---+
                | C | D | E | F | G |                        | E | F |
               -+---+---+---+---+---+-                       +---+---+
                        ^_______^                            ^       ^
                         5..7                                5       7

               -+---+---+---+---+---+-                               +---+
                | C | D | E | F | G |                                | G |
               -+---+---+---+---+---+-                               +---+
                                ^___^                                ^   ^
                                 7..8                                7   8
</code></pre>
<p>A span of shared haystack will always store a copy of the original haystack when splitting, because the haystack can be cheaply cloned. Splitting is thus just manipulation of the range only. Slicing is only done when returning from an algorithm.</p>
<p>A non-shared haystack needs to maintain unique ownership for each haystack slice. Therefore, a haystack will be split as soon as the span is split. The ‚Äúoriginal range‚Äù becomes a value disconnected from the haystack, and this is where <code>.restore_range()</code> is needed: to recover the indices in the middle (<code>5 == 3 + 2</code> and <code>7 == 3 + 4</code>).</p>
<h4 id="searcher"><a class="header" href="#searcher">Searcher</a></h4>
<p>A searcher only provides a single method: <code>.search()</code>. It takes a span as input, and returns the first sub-range where the given needle is found.</p>
<pre><code class="language-rust">pub unsafe trait Searcher&lt;A: Hay + ?Sized&gt; {
    fn search(&amp;mut self, span: Span&lt;&amp;A&gt;) -&gt; Option&lt;Range&lt;A::Index&gt;&gt;;
}

pub unsafe trait ReverseSearcher&lt;A: Hay + ?Sized&gt;: Searcher&lt;A&gt; {
    fn rsearch(&amp;mut self, span: Span&lt;&amp;A&gt;) -&gt; Option&lt;Range&lt;A::Index&gt;&gt;;
}

pub unsafe trait DoubleEndedSearcher&lt;A: Hay + ?Sized&gt;: ReverseSearcher&lt;A&gt; {}</code></pre>
<p>The <code>.search()</code> function is safe because there is no safe ways to construct a <code>Span&lt;&amp;A&gt;</code> with invalid ranges. Implementations of <code>.search()</code> often start with:</p>
<pre><code class="language-rust">    fn search(&amp;mut self, span: Span&lt;&amp;A&gt;) -&gt; Option&lt;Range&lt;A::Index&gt;&gt; {
        let (hay, range) = span.into_parts();
        // search for needle from `hay` restricted to `range`.
    }</code></pre>
<p>The trait is unsafe to implement because it needs to guarantee the returned range is valid.</p>
<p>There is a ‚Äúreverse‚Äù version of the trait, which supports searching from the end with the <code>.rsearch()</code> method besides from the start.</p>
<p>Furthermore, there is a ‚Äúdouble-ended‚Äù version, which is a marker trait saying that searching from both ends will give consistent results. The searcher of a substring needle is an example which implements <code>ReverseSearcher</code> but not <code>DoubleEndedSearcher</code>, e.g.</p>
<ul>
<li>Forward searching the needle <code>xx</code> in the haystack <code>xxxxx</code> will yield <code>[xx][xx]x</code></li>
<li>Backward searching the needle <code>xx</code> in the haystack <code>xxxxx</code> will yield <code>x[xx][xx]</code></li>
</ul>
<h4 id="consumer"><a class="header" href="#consumer">Consumer</a></h4>
<p>A consumer provides the <code>.consume()</code> method to implement <code>starts_with()</code> and <code>trim_start()</code>. It takes a span as input, and if the beginning matches the needle, returns the end index of the match.</p>
<pre><code class="language-rust">pub unsafe trait Consumer&lt;A: Hay + ?Sized&gt; {
    fn consume(&amp;mut self, span: Span&lt;&amp;A&gt;) -&gt; Option&lt;A::Index&gt;;
}

pub unsafe trait ReverseConsumer&lt;A: Hay + ?Sized&gt;: Consumer&lt;A&gt; {
    fn rconsume(&amp;mut self, span: Span&lt;&amp;A&gt;) -&gt; Option&lt;A::Index&gt;;
}

pub unsafe trait DoubleEndedConsumer&lt;A: Hay + ?Sized&gt;: ReverseConsumer&lt;A&gt; {}</code></pre>
<p>Comparing searcher and consumer, the <code>.search()</code> method will look for the first slice matching the searcher‚Äôs needle in the span, and returns the range where the slice is found (relative to the hay‚Äôs start index). The <code>.consume()</code> method is similar, but anchored to the start of the span.</p>
<pre><code class="language-rust">let span = unsafe { Span::from_parts("CDEFG", 3..8) };
// we can find "CD" at the start of the span.
assert_eq!("CD".into_searcher().search(span.clone()), Some(3..5));
assert_eq!("CD".into_consumer().consume(span.clone()), Some(5));
// we can only find "EF" in the middle of the span.
assert_eq!("EF".into_searcher().search(span.clone()), Some(5..7));
assert_eq!("EF".into_consumer().consume(span.clone()), None);
// we cannot find "GH" in the span.
assert_eq!("GH".into_searcher().search(span.clone()), None);
assert_eq!("GH".into_consumer().consume(span.clone()), None);</code></pre>
<p>The trait also provides a <code>.trim_start()</code> method in case a faster specialization exists.</p>
<p>Similar to searchers, the consumers also have the ‚Äúreverse‚Äù and ‚Äúdouble-ended‚Äù variants.</p>
<h4 id="needle"><a class="header" href="#needle">Needle</a></h4>
<p>A needle is simply a ‚Äúfactory‚Äù of a searcher and consumer.</p>
<pre><code class="language-rust">trait Needle&lt;H: Haystack&gt;: Sized {
    type Searcher: Searcher&lt;H::Target&gt;;
    type Consumer: Consumer&lt;H::Target&gt;;

    fn into_searcher(self) -&gt; Self::Searcher;
    fn into_consumer(self) -&gt; Self::Consumer;
}</code></pre>
<p>Needles are the types where users used to supply into the algorithms. Needles are usually immutable (stateless), while searchers sometimes require pre-computation and mutable state when implementing some more sophisticated string searching algorithms.</p>
<p>The relation between <code>Needle</code> and <code>Searcher</code>/<code>Consumer</code> is thus like <code>IntoIterator</code> and <code>Iterator</code>.</p>
<p>There are two required methods <code>.into_searcher()</code> and <code>.into_consumer()</code>. In some needles (e.g. substring search), checking if a prefix match will require much less pre-computation than checking if any substring match. Therefore, a consumer could use a more efficient structure with this specialized purpose.</p>
<pre><code class="language-rust">impl&lt;H: Haystack&lt;Target = str&gt;&gt; Needle&lt;H&gt; for &amp;'p str {
    type Searcher = SliceSearcher&lt;'p, [u8]&gt;;
    type Consumer = NaiveSearcher&lt;'p, [u8]&gt;;
    #[inline]
    fn into_searcher(self) -&gt; Self::Searcher {
        // create a searcher based on Two-Way algorithm.
        SliceSearcher::new(self)
    }
    #[inline]
    fn into_consumer(self) -&gt; Self::Consumer {
        // create a searcher based on naive search (which requires no pre-computation)
        NaiveSearcher::new(self)
    }
}</code></pre>
<p>Note that, unlike <code>IntoIterator</code>, the standard library is unable to provide a blanket impl:</p>
<pre><code class="language-rust">impl&lt;H, S&gt; Needle&lt;H&gt; for S
where
    H: Haystack,
    S: Searcher&lt;H::Target&gt; + Consumer&lt;H::Target&gt;,
{
    type Searcher = Self;
    type Consumer = Self;
    fn into_searcher(self) -&gt; Self { self }
    fn into_consumer(self) -&gt; Self { self }
}</code></pre>
<p>This is because there is already an existing Needle impl:</p>
<pre><code class="language-rust">impl&lt;'h, F&gt; Needle&lt;&amp;'h str&gt; for F
where
    F: FnMut(char) -&gt; bool,
{ ... }</code></pre>
<p>and a type can implement all of <code>(FnMut(char) -&gt; bool) + Searcher&lt;str&gt; + Consumer&lt;str&gt;</code>, causing impl conflict.</p>
<h4 id="algorithms"><a class="header" href="#algorithms">Algorithms</a></h4>
<p>Standard algorithms are provided as <em>functions</em> in the <code>core::needle::ext</code> module.</p>
<details><summary>List of algorithms</summary>
<p><strong>Starts with, ends with</strong></p>
<pre><code class="language-rust">pub fn starts_with&lt;H, P&gt;(haystack: H, needle: P) -&gt; bool
where
    H: Haystack,
    P: Needle&lt;H&gt;;

pub fn ends_with&lt;H, P&gt;(haystack: H, needle: P) -&gt; bool
where
    H: Haystack,
    P: Needle&lt;H, Consumer: ReverseConsumer&lt;H::Target&gt;&gt;;</code></pre>
<p><strong>Trim</strong></p>
<pre><code class="language-rust">pub fn trim_start&lt;H, P&gt;(haystack: H, needle: P) -&gt; H
where
    H: Haystack,
    P: Needle&lt;H&gt;;

pub fn trim_end&lt;H, P&gt;(haystack: H, needle: P) -&gt; H
where
    H: Haystack,
    P: Needle&lt;H, Consumer: ReverseConsumer&lt;H::Target&gt;&gt;;

pub fn trim&lt;H, P&gt;(haystack: H, needle: P) -&gt; H
where
    H: Haystack,
    P: Needle&lt;H, Consumer: DoubleEndedConsumer&lt;H::Target&gt;&gt;;</code></pre>
<p><strong>Matches</strong></p>
<p>(These function do return concrete iterators in the actual implementation.)</p>
<pre><code class="language-rust">pub fn matches&lt;H, P&gt;(haystack: H, needle: P) -&gt; impl Iterator&lt;Item = H&gt;
where
    H: Haystack,
    P: Needle&lt;H&gt;;

pub fn rmatches&lt;H, P&gt;(haystack: H, needle: P) -&gt; impl Iterator&lt;Item = H&gt;
where
    H: Haystack,
    P: Needle&lt;H, Searcher: ReverseSearcher&lt;H::Target&gt;&gt;;

pub fn contains&lt;H, P&gt;(haystack: H, needle: P) -&gt; bool
where
    H: Haystack,
    P: Needle&lt;H&gt;;

pub fn match_indices&lt;H, P&gt;(haystack: H, needle: P) -&gt; impl Iterator&lt;Item = (H::Target::Index, H)&gt;
where
    H: Haystack,
    P: Needle&lt;H&gt;;

pub fn rmatch_indices&lt;H, P&gt;(haystack: H, needle: P) -&gt; impl Iterator&lt;Item = (H::Target::Index, H)&gt;
where
    H: Haystack,
    P: Needle&lt;H, Searcher: ReverseSearcher&lt;H::Target&gt;&gt;;

pub fn find&lt;H, P&gt;(haystack: H, needle: P) -&gt; Option&lt;H::Target::Index&gt;
where
    H: Haystack,
    P: Needle&lt;H&gt;;

pub fn rfind&lt;H, P&gt;(haystack: H, needle: P) -&gt; Option&lt;H::Target::Index&gt;
where
    H: Haystack,
    P: Needle&lt;H, Searcher: ReverseSearcher&lt;H::Target&gt;&gt;;

pub fn match_ranges&lt;H, P&gt;(haystack: H, needle: P) -&gt; impl Iterator&lt;Item = (Range&lt;H::Target::Index&gt;, H)&gt;
where
    H: Haystack,
    P: Needle&lt;H&gt;;

pub fn rmatch_ranges&lt;H, P&gt;(haystack: H, needle: P) -&gt; impl Iterator&lt;Item = (Range&lt;H::Target::Index&gt;, H)&gt;
where
    H: Haystack,
    P: Needle&lt;H, Searcher: ReverseSearcher&lt;H::Target&gt;&gt;;

pub fn find_range&lt;H, P&gt;(haystack: H, needle: P) -&gt; Option&lt;Range&lt;H::Target::Index&gt;&gt;
where
    H: Haystack,
    P: Needle&lt;H&gt;;

pub fn rfind_range&lt;H, P&gt;(haystack: H, needle: P) -&gt; Option&lt;Range&lt;H::Target::Index&gt;&gt;
where
    H: Haystack,
    P: Needle&lt;H, Searcher: ReverseSearcher&lt;H::Target&gt;&gt;;</code></pre>
<p><strong>Split</strong></p>
<pre><code class="language-rust">pub fn split&lt;H, P&gt;(haystack: H, needle: P) -&gt; impl Iterator&lt;Item = H&gt;
where
    H: Haystack,
    P: Needle&lt;H&gt;;

pub fn rsplit&lt;H, P&gt;(haystack: H, needle: P) -&gt; impl Iterator&lt;Item = H&gt;
where
    H: Haystack,
    P: Needle&lt;H, Searcher: ReverseSearcher&lt;H::Target&gt;&gt;;

pub fn split_terminator&lt;H, P&gt;(haystack: H, needle: P) -&gt; impl Iterator&lt;Item = H&gt;
where
    H: Haystack,
    P: Needle&lt;H&gt;;

pub fn rsplit_terminator&lt;H, P&gt;(haystack: H, needle: P) -&gt; impl Iterator&lt;Item = H&gt;
where
    H: Haystack,
    P: Needle&lt;H, Searcher: ReverseSearcher&lt;H::Target&gt;&gt;;

pub fn splitn&lt;H, P&gt;(haystack: H, n: usize, needle: P) -&gt; impl Iterator&lt;Item = H&gt;
where
    H: Haystack,
    P: Needle&lt;H&gt;;

pub fn rsplitn&lt;H, P&gt;(haystack: H, n: usize, needle: P) -&gt; impl Iterator&lt;Item = H&gt;
where
    H: Haystack,
    P: Needle&lt;H, Searcher: ReverseSearcher&lt;H::Target&gt;&gt;;</code></pre>
<p><strong>Replace</strong></p>
<pre><code class="language-rust">pub fn replace_with&lt;H, P, F, W&gt;(src: H, from: P, replacer: F, writer: W)
where
    H: Haystack,
    P: Needle&lt;H&gt;,
    F: FnMut(H) -&gt; H,
    W: FnMut(H);

pub fn replacen_with&lt;H, P, F, W&gt;(src: H, from: P, replacer: F, n: usize, writer: W)
where
    H: Haystack,
    P: Needle&lt;H&gt;,
    F: FnMut(H) -&gt; H,
    W: FnMut(H);</code></pre>
</details>
<p>Most algorithms are very simple to implement using trisection (<code>.split_around()</code>). For instance, <code>split()</code> can be implemented as:</p>
<pre><code class="language-rust">gen fn split&lt;H, P&gt;(haystack: H, needle: P) -&gt; impl Iterator&lt;Item = H&gt;
where
    H: Haystack,
    P: Needle&lt;H&gt;,
{
    let mut searcher = needle.into_searcher();
    let mut rest = Span::from(haystack);
    while let Some(range) = searcher.search(rest.borrow()) {
        let [left, _, right] = unsafe { rest.split_around(range) };
        yield left.into();
        rest = right;
    }
    yield rest;
}</code></pre>
<p>These functions are forwarded as <em>inherent methods</em> of the haystack type, e.g.</p>
<pre><code class="language-rust">impl str {
    ...

    pub fn split_mut&lt;'a&gt;(
        &amp;'a mut self,
        needle: impl Needle&lt;&amp;'a mut str&gt;,
    ) -&gt; impl Iterator&lt;Item = &amp;'a mut str&gt; {
        core::needle::split(self, needle)
    }

    pub fn replace&lt;'a&gt;(
        &amp;'a self,
        from: impl Needle&lt;&amp;'a str&gt;,
        to: &amp;str,
    ) -&gt; String {
        let mut res = String::with_capacity(self.len());
        core::needle::replace_with(self, from, |_| to, |r| res.push_str(r));
        res
    }

    ...
}</code></pre>
<h3 id="standard-library-changes"><a class="header" href="#standard-library-changes">Standard library changes</a></h3>
<ul>
<li>
<p>Remove the entire <code>core::str::pattern</code> module from public, as this is unstable.</p>
</li>
<li>
<p>Add the <code>core::needle</code> module with traits and structs shown above.</p>
</li>
<li>
<p>Implement <code>Hay</code> to <code>str</code>, <code>[T]</code> and <code>OsStr</code>.</p>
</li>
<li>
<p>Implement <code>Haystack</code> to <code>‚àÄH: Hay. &amp;H</code>, <code>&amp;mut str</code> and <code>&amp;mut [T]</code>.</p>
</li>
<li>
<p>Implement <code>Needle</code> as following:</p>
<ul>
<li><code>Needle&lt;&amp;{mut} str&gt;</code> for <code>char</code></li>
<li><code>Needle&lt;&amp;{mut} str&gt;</code> for <code>&amp;[char]</code> and <code>FnMut(char)-&gt;bool</code></li>
<li><code>Needle&lt;&amp;{mut} str&gt;</code> for <code>&amp;str</code>, <code>&amp;&amp;str</code> and <code>&amp;String</code></li>
<li><code>Needle&lt;&amp;{mut} [T]&gt;</code> for <code>FnMut(&amp;T)-&gt;bool</code></li>
<li><code>Needle&lt;&amp;{mut} [T]&gt;</code> for <code>&amp;[T]</code> where <code>T: PartialEq</code></li>
<li><code>Needle&lt;&amp;OsStr&gt;</code> for <code>&amp;OsStr</code> and <code>&amp;str</code></li>
</ul>
</li>
<li>
<p>Change the following methods of <code>str</code> to use the Needle API:</p>
<ul>
<li><code>.contains()</code>, <code>.starts_with()</code>, <code>.ends_with()</code></li>
<li><code>.find()</code>, <code>.rfind()</code></li>
<li><code>.split()</code>, <code>.rsplit()</code></li>
<li><code>.split_terminator()</code>, <code>.rsplit_terminator()</code></li>
<li><code>.splitn()</code>, <code>.rsplitn()</code></li>
<li><code>.matches()</code>, <code>.rmatches()</code></li>
<li><code>.match_indices()</code>, <code>.rmatch_indices()</code></li>
<li><code>.trim_matches()</code>, <code>.trim_left_matches()</code>, <code>.trim_right_matches()</code></li>
<li><code>.replace()</code>, <code>.replacen()</code>
Note also <a href="https://github.com/rust-lang/rust/issues/30459">issue 30459</a> suggests deprecating <code>trim_{left, right}</code> and rename them to <code>trim_{start, end}</code>.</li>
</ul>
</li>
<li>
<p>Add the following range-returning methods to <code>str</code>:</p>
<ul>
<li><code>.find_range()</code>, <code>.rfind_range()</code></li>
<li><code>.match_ranges()</code>, <code>.rmatch_ranges()</code></li>
</ul>
</li>
<li>
<p>Add the following mutable methods to <code>str</code>, they should all take <code>&amp;mut self</code>:</p>
<ul>
<li><code>.split_mut()</code>, <code>.rsplit_mut()</code></li>
<li><code>.split_terminator_mut()</code>, <code>.rsplit_terminator_mut()</code></li>
<li><code>.splitn_mut()</code>, <code>.rsplitn_mut()</code></li>
<li><code>.matches_mut()</code>, <code>.rmatches_mut()</code></li>
<li><code>.match_indices_mut()</code>, <code>.rmatch_indices_mut()</code></li>
<li><code>.match_ranges_mut()</code>, <code>.rmatch_ranges_mut()</code></li>
</ul>
</li>
<li>
<p>Modify the following iterators in <code>core::str</code> to type alias of the corresponding Needle API iterators, and mark them as deprecated:</p>
<pre><code class="language-rust">macro_rules! forward_to_needle_api {
    ($($name:ident)+) =&gt; {
        $(
            #[rustc_deprecated]
            pub type $name&lt;'a, P&gt; = needle::ext::$name&lt;&amp;'a str, &lt;P as Pattern&lt;&amp;'a str&gt;&gt;::Searcher&gt;;
        )+
    }
}

forward_to_needle_api! {
    MatchIndices Matches Split SplitN SplitTerminator
    RMatchIndices RMatches RSplit RSplitN RSplitTerminator
}</code></pre>
<p>Rust allows the type alias to be stable while the underlying type be unstable.</p>
</li>
<li>
<p>Generalize these methods of <code>[T]</code> to use the new Needle API:</p>
<ul>
<li><code>.split()</code>, <code>.split_mut()</code>, <code>.rsplit()</code>, <code>.rsplit_mut()</code></li>
<li><code>.splitn()</code>, <code>.splitn_mut()</code>, <code>.rsplitn()</code>, <code>rsplitn_mut()</code></li>
<li><code>.starts_with()</code>, <code>.ends_with()</code></li>
</ul>
</li>
<li>
<p>Add the following methods to <code>[T]</code>:</p>
<ul>
<li><code>.contains_match()</code> (<em>note</em>: the existing <code>.contains()</code> method is incompatible with Needle API)</li>
<li><code>.find()</code>, <code>.rfind()</code>, <code>.find_range()</code>, <code>.rfind_range()</code></li>
<li><code>.matches()</code>, <code>.matches_mut()</code>, <code>.rmatches()</code>, <code>.rmatches_mut()</code></li>
<li><code>.match_indices()</code>, <code>.match_indices_mut()</code>, <code>.rmatch_indices()</code>, <code>.rmatch_indices_mut()</code></li>
<li><code>.match_ranges()</code>, <code>.match_ranges_mut()</code>, <code>.rmatch_ranges()</code>, <code>.rmatch_ranges_mut()</code></li>
<li><code>.trim_matches()</code>, <code>.trim_start_matches()</code>, <code>.trim_end_matches()</code></li>
<li><code>.replace()</code>, <code>.replacen()</code> (produce a <code>Vec&lt;T&gt;</code>)</li>
</ul>
</li>
<li>
<p>Modify the following iterators in <code>core::slice</code> to type alias of the corresponding Needle API iterators, and mark them as deprecated:</p>
<pre><code class="language-rust">macro_rules! forward_to_needle_api {
    ($($name:ident $name_mut:ident)+) =&gt; {
        $(
            #[rustc_deprecated]
            pub type $name&lt;'a, T, P&gt; = needle::ext::$name&lt;&amp;'a [T], ElemSearcher&lt;P&gt;&gt;;
            #[rustc_deprecated]
            pub type $name_mut&lt;'a, T, P&gt; = needle::ext::$name&lt;&amp;'a mut [T], ElemSearcher&lt;P&gt;&gt;;
        )+
    }
}

forward_to_needle_api! {
    Split SplitMut
    SplitN SplitNMut
    RSplit RSplitMut
    RSplitN RSplitNMut
}</code></pre>
</li>
<li>
<p>Add all immutable Needle API algorithms to <code>OsStr</code>. The <code>.replace()</code> and <code>.replacen()</code> methods should produce an <code>OsString</code>.</p>
</li>
</ul>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>The benchmark of the <code>pattern_3</code> package shows that algorithms using the Needle API (‚Äúv3.0 API‚Äù) is close to or much faster than the corresponding methods in libstd using v1.0.</p>
<p>The main performance improvement comes from <code>trim()</code>. In v1.0, <code>trim()</code> depends on the <code>Searcher::next_reject()</code> method, which requires initializing a searcher and compute the critical constants for the Two-Way search algorithm. Search algorithms mostly concern about quickly skip through mismatches, but the purpose of <code>.next_reject()</code> is to find mismatches, so a searcher would be a job mismatch for <code>trim()</code>. This justifies the <code>Consumer</code> trait in v3.0.</p>
<details><summary>Summary of benchmark</summary>
<p>(The lower the number, the better)</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Test case</th><th style="text-align: right">v3.0 time change</th></tr>
</thead>
<tbody>
<tr><td><code>contains('!')</code></td><td style="text-align: right">‚àí75%</td></tr>
<tr><td><code>contains("!")</code></td><td style="text-align: right">‚àí26%</td></tr>
<tr><td><code>ends_with('/')</code></td><td style="text-align: right">‚àí31%</td></tr>
<tr><td><code>ends_with('üí§')</code></td><td style="text-align: right">+32%</td></tr>
<tr><td><code>find('_')</code></td><td style="text-align: right">‚àí80%</td></tr>
<tr><td><code>find('üí§')</code></td><td style="text-align: right">‚àí74%</td></tr>
<tr><td><code>find(_ == ' ')</code></td><td style="text-align: right">‚àí30%</td></tr>
<tr><td><code>match_indices("").count()</code></td><td style="text-align: right">‚àí26%</td></tr>
<tr><td><code>match_indices("a").count()</code></td><td style="text-align: right">‚àí5%</td></tr>
<tr><td><code>rfind('_')</code></td><td style="text-align: right">‚àí18%</td></tr>
<tr><td><code>rfind('üí§')</code></td><td style="text-align: right">‚àí18%</td></tr>
<tr><td><code>rfind(_ == ' ')</code></td><td style="text-align: right">‚àí8%</td></tr>
<tr><td><code>split(" ").count()</code></td><td style="text-align: right">‚àí4%</td></tr>
<tr><td><code>split("a").count()</code></td><td style="text-align: right">‚àí1%</td></tr>
<tr><td><code>split("ad").count()</code></td><td style="text-align: right">‚àí20%</td></tr>
<tr><td><code>starts_with('/')</code></td><td style="text-align: right">‚àí70%</td></tr>
<tr><td><code>starts_with('üí§')</code></td><td style="text-align: right">‚àí56%</td></tr>
<tr><td><code>starts_with("üí©üí©")</code></td><td style="text-align: right">‚àí40%</td></tr>
<tr><td><code>starts_with(_.is_ascii())</code></td><td style="text-align: right">‚àí11%</td></tr>
<tr><td><code>trim_end('!')</code></td><td style="text-align: right">‚àí19%</td></tr>
<tr><td><code>trim_end("m!")</code></td><td style="text-align: right">‚àí97%</td></tr>
<tr><td><code>trim_left(_.is_ascii())</code></td><td style="text-align: right">‚àí57%</td></tr>
<tr><td><code>trim_right(_.is_ascii())</code></td><td style="text-align: right">‚àí54%</td></tr>
<tr><td><code>trim_start('üí©')</code></td><td style="text-align: right">‚àí32%</td></tr>
<tr><td><code>trim_start("üí©üí©")</code></td><td style="text-align: right">‚àí97%</td></tr>
</tbody>
</table>
</div>
</details>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<ul>
<li>
<p>This RFC suggests generalizing some stabilized methods of <code>str</code> and <code>[T]</code> to adapt the Needle API. This might cause inference breakage.</p>
</li>
<li>
<p>Some parts of the Haystack trait (e.g. the <code>.restore_range()</code> method) may not be intuitive enough.</p>
</li>
<li>
<p>This RFC does not address some problems raised in <a href="https://github.com/rust-lang/rust/issues/27721">issue 27721</a>:</p>
<ol>
<li>
<p>v3.0 still assumes strict left-to-right or right-to-left searching. Some niche data structures like <a href="https://docs.rs/suffix/1.0.0/suffix/struct.SuffixTable.html#method.positions">suffix table</a> as a haystack would return matches without any particular order, and thus cannot be supported.</p>
</li>
<li>
<p>Needles are still moved when converting to a Searcher or Consumer. Taking the entire ownership of the needle might prevent some use cases‚Ä¶ ?</p>
</li>
</ol>
</li>
<li>
<p>Stabilization of this RFC is blocked by <a href="https://github.com/rust-lang/rfcs/pull/1672">RFC 1672</a> (disjointness based on associated types) which is postponed.</p>
<p>The default Needle implementation currently uses an impl that covers all haystacks (<code>impl&lt;H: Haystack&lt;Target = A&gt;&gt; Needle&lt;H&gt; for N</code>) for some types, and several impls for individual types for others (<code>impl&lt;'h&gt; Needle&lt;&amp;'h A&gt; for N</code>). Ideally <em>every</em> such impl should use the blanket impl. Unfortunately, due to lack of RFC 1672, there would be conflict between these impls:</p>
<pre><code class="language-rust">// 1.
impl&lt;'p, H&gt; Needle&lt;H&gt; for &amp;'p [char]
where
    H: Haystack&lt;Target = str&gt;,
{ ... }
impl&lt;'p, H&gt; Needle&lt;H&gt; for &amp;'p [T] // `T` can be `char`
where
    H: Haystack&lt;Target = [T]&gt;,
    T: PartialEq + 'p,
{ ... }

// 2.
impl&lt;H, F&gt; Needle&lt;H&gt; for F
where
    H: Haystack&lt;Target = str&gt;,
    F: FnMut(char) -&gt; bool,
{ ... }
impl&lt;T, H, F&gt; Needle&lt;H&gt; for F
where
    H: Haystack&lt;Target = [T]&gt;,
    F: FnMut(&amp;T) -&gt; bool, // `F` can impl both `FnMut(char)-&gt;bool` and `FnMut(&amp;T)-&gt;bool`.
    T: PartialEq,
{ ... }

// 3.
impl&lt;'p, H&gt; Needle&lt;H&gt; for &amp;'p str
where
    H: Haystack&lt;Target = str&gt;,
{ ... }
impl&lt;'p, H&gt; Needle&lt;H&gt; for &amp;'p str
where
    H: Haystack&lt;Target = OsStr&gt;,
{ ... }</code></pre>
<p>We currently provide concrete impls like <code>impl&lt;'h, 'p&gt; Needle&lt;&amp;'h OsStr&gt; for &amp;'p str</code> as workaround, but if we stabilize the <code>Needle</code> trait before RFC 1672 is implemented, a third-party crate can sneak in an impl:</p>
<pre><code class="language-rust">struct MyOsString { ... };
impl Deref for MyOsString {
    type Target = OsStr;
    ...
}
impl Haystack for MyOsString { ... }

impl&lt;'p&gt; Needle&lt;MyOsString&gt; for &amp;'p str { ... }</code></pre>
<p>and causes the standard library not able to further generalize (this is a breaking change).</p>
<p>RFC 1672 is currently blocked by <code>chalk</code> integration before it could be reopened.</p>
</li>
</ul>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<h3 id="principles"><a class="header" href="#principles">Principles</a></h3>
<p>These are some guiding principles v3.0 will adhere to.</p>
<h4 id="generic-algorithms"><a class="header" href="#generic-algorithms">Generic algorithms</a></h4>
<ol>
<li>
<p>The Needle API should define an interface which can be used to easily implement all algorithms the standard library currently provides:</p>
<ul>
<li><code>starts_with()</code>, <code>ends_with()</code></li>
<li><code>trim_left_matches()</code>, <code>trim_right_matches()</code>, <code>trim_matches()</code></li>
<li><code>contains()</code>, <code>find()</code>, <code>rfind()</code></li>
<li><code>matches()</code>, <code>rmatches()</code>, <code>match_indices()</code>, <code>rmatch_indices()</code></li>
<li><code>split()</code>, <code>rsplit()</code>, <code>split_terminator()</code>, <code>rsplit_terminator()</code></li>
<li><code>splitn()</code>, <code>rsplitn()</code></li>
<li><code>replace()</code>, <code>replacen()</code></li>
</ul>
</li>
<li>
<p>We should not need ‚Äúnon-local unsafety‚Äù when writing these algorithms. Mainly, we should not need to do borrowck by hand (e.g. ensuring there is no overlapping mutable slices across functions).</p>
</li>
</ol>
<h4 id="haystack-implementor"><a class="header" href="#haystack-implementor">Haystack implementor</a></h4>
<ol start="3">
<li>
<p>The standard slice types must be supported: <code>&amp;str</code>, <code>&amp;mut str</code>, <code>&amp;[T]</code>, <code>&amp;mut [T]</code>, <code>Vec&lt;T&gt;</code>, and <code>&amp;OsStr</code>.</p>
</li>
<li>
<p>The API should be compatible with linked list and rope data structure as haystack, assuming we get either custom DST or GATs implemented.</p>
</li>
</ol>
<h4 id="needlesearcher-implementor"><a class="header" href="#needlesearcher-implementor">Needle/Searcher implementor</a></h4>
<ol start="5">
<li>
<p>The existing needle for <code>&amp;str</code> and <code>&amp;mut str</code> should be supported:</p>
<ul>
<li><code>char</code></li>
<li><code>FnMut(char) -&gt; bool</code>, <code>&amp;[char]</code></li>
<li><code>&amp;str</code>, <code>&amp;&amp;str</code>, <code>&amp;String</code>
Additionally, these re-implementations should not be slower than the existing ones in the standard library.</li>
</ul>
</li>
<li>
<p>These needles for <code>&amp;[T]</code>, <code>&amp;mut [T]</code> and <code>Vec&lt;T&gt;</code> should be supported:</p>
<ul>
<li><code>FnMut(&amp;T) -&gt; bool</code></li>
<li><code>&amp;[T]</code> where <code>T: PartialEq</code></li>
</ul>
</li>
<li>
<p>These needles for <code>&amp;OsStr</code> should be supported:</p>
<ul>
<li><code>&amp;str</code></li>
<li><code>&amp;OsStr</code></li>
</ul>
</li>
<li>
<p>It should be possible to implement <code>Needle</code> for <code>&amp;Regex</code> within the <code>regex</code> package.</p>
</li>
<li>
<p>One should not need to implement a <code>Searcher</code> three times to support <code>&amp;[T]</code>, <code>&amp;mut [T]</code> and <code>Vec&lt;T&gt;</code>. The searcher should rely on that these all can be borrowed as an <code>&amp;[T]</code>.</p>
</li>
</ol>
<h3 id="design-rationales"><a class="header" href="#design-rationales">Design rationales</a></h3>
<p>The section lists some important use cases which shape v3.0.</p>
<h4 id="no-more-next_reject"><a class="header" href="#no-more-next_reject">No more <code>.next_reject()</code></a></h4>
<p>In v1.0 a searcher provides a <code>.next()</code> method which returns what is being seen ahead: a match, no-match, or end-to-string, and then advance the cursor.</p>
<p>None of the generic algorithms besides <code>starts_with()</code>/<code>ends_with()</code> uses the full power of <code>.next()</code>. The rest depend entirely on filtered versions of <code>.next()</code>:</p>
<ul>
<li><code>.next_match()</code>, which produces ranges of matches, is used for <code>matches()</code> and <code>split()</code> etc.</li>
<li><code>.next_reject()</code>, which produces ranges of non-matches, is used for <code>trim()</code>.</li>
</ul>
<p>Implementing <code>.next()</code> is sometimes not trivial. In v1.2 this method is entirely abolished in favor of implementing <code>.next_match()</code> and <code>.next_reject()</code> directly. The <code>starts_with()</code> methods are supported instead via a specialized method in the Needle trait.</p>
<p>However, we see that even <code>.next_reject()</code> is not something obvious. Given that <code>.next_reject()</code> is only used in <code>trim()</code>, in v3.0 we decide to remove this method as well, and instead make the Needle implement <code>trim()</code> directly.</p>
<h4 id="searching-in-a-mut-str"><a class="header" href="#searching-in-a-mut-str">Searching in a <code>&amp;mut str</code></a></h4>
<p>In all versions of Pattern APIs up to v2.0, the ‚Äúhaystack‚Äù is directly managed by the searcher.</p>
<pre><code class="language-rust">// v2.0
trait Pattern&lt;H: PatternHaystack&gt; {
    type Searcher: Searcher&lt;H&gt;;
    fn into_searcher(self, haystack: H) -&gt; Self::Searcher;
}
trait Searcher&lt;H: PatternHaystack&gt; {
    fn haystack(&amp;self) -&gt; H::Haystack; // e.g. returns (*mut u8, *mut u8) for H = &amp;mut str
    fn next_match(&amp;mut self) -&gt; Option&lt;(H::Cursor, H::Cursor)&gt;;
    ...
}</code></pre>
<p>The generic algorithms like <code>matches()</code> and <code>split()</code> would turn the cursor pair back into slices. With mutable slices, this means logically both the searcher and the <code>matches()</code>/<code>split()</code> iterators would hold a copy of the same mutable slice, which violates the ‚ÄúAliasing XOR Mutability‚Äù rule.</p>
<p>This could be avoid by having the searcher carefully written to not look back into parts given out via <code>next_match()</code>/<code>next_reject()</code>/<code>next_match_back()</code>/<code>next_reject_back()</code>, however this kind of unsafety is very un-rustic (contradicts with ‚Äúfearless concurrency‚Äù).</p>
<p>A better way to avoid this is to ensure there is a unique owner to the haystack. Therefore, the generic algorithm must now <em>borrow</em> the haystack for the searcher to work with:</p>
<pre><code class="language-rust">// v3.0-alpha.1
trait Needle&lt;H: Haystack&gt; {
    type Searcher: Searcher&lt;H&gt;;
    fn into_searcher(self) -&gt; Self::Searcher;
    //^ searcher no longer captures the haystack.
}
trait Searcher&lt;H: Haystack&gt; {
    // no more haystack() method.
    fn search(&amp;mut self, haystack: &amp;H) -&gt; Option&lt;Range&lt;H::Index&gt;&gt;;
}</code></pre>
<p>The <code>matches()</code> algorithm can then take the whole responsibility to split out non-overlapping slices of the haystack it owns:</p>
<pre><code class="language-rust">// v3.0-alpha.1
gen fn matches&lt;H: Haystack, P: Needle&lt;H&gt;&gt;(mut haystack: H, needle: P) -&gt; impl Iterator&lt;Item = H&gt; {
    let mut searcher = needle.into_searcher();
    while let Some(range) = searcher.search(&amp;haystack) {
        // split the haystack into 3 parts.
        let [_, matched, rest] = haystack.split_around(range);
        haystack = rest;
        yield matched;
    }
}</code></pre>
<h4 id="matching-a-regex"><a class="header" href="#matching-a-regex">Matching a <code>&amp;Regex</code></a></h4>
<p>In the prototype above, we always feed the remaining haystack into <code>.search()</code>. This works fine for built-in needle types like <code>char</code> and <code>&amp;str</code>, but is totally broken for more advanced regular expression needles.</p>
<p>The main issue is due to anchors and look-around. Anchors like <code>^</code> and <code>$</code> depend on the actual position where the slice appears. Look-around like <code>(?=foo)</code>, <code>(?&lt;!foo)</code> and <code>\b</code> depend on parts which may have already matched. These means to make regex work, we must pass the entire haystack (not just the remaining part), and a range indicating what‚Äôs the part should be matched.</p>
<p>In fact, this behavior is consistent with all regex libraries in the wild, e.g. <a href="https://crates.io/crates/regex"><code>regex</code></a>, <a href="https://crates.io/crates/onig"><code>onig</code></a> and <a href="https://crates.io/crates/pcre"><code>pcre</code></a>.</p>
<pre><code class="language-rust">// v3.0-alpha.2
trait Searcher&lt;H: Haystack&gt; {
    fn search(&amp;mut self, full_haystack: &amp;H, range: Range&lt;H::Index&gt;) -&gt; Option&lt;Range&lt;H::Index&gt;&gt;;
}</code></pre>
<p>This API completely conflicts with <code>&amp;mut str</code> as a haystack though. This is fine as a <code>&amp;mut str</code> is incompatible with look-around anyway, but it is not OK for <code>matches()</code> which need to support both ‚Äúmatching <code>&amp;mut str</code> with <code>char</code>‚Äù and ‚Äúmatching <code>&amp;str</code> with <code>&amp;Regex</code>‚Äù.</p>
<p>We fix this problem by treating the haystack and range as a single entity we call <strong>span</strong>:</p>
<pre><code class="language-rust">// v3.0-alpha.3
trait Searcher&lt;H: Haystack&gt; {
    fn search(&amp;mut self, span: (&amp;H, Range&lt;H::Index&gt;)) -&gt; Option&lt;Range&lt;H::Index&gt;&gt;;
}
gen fn matches&lt;H: Haystack, P: Needle&lt;H&gt;&gt;(haystack: H, needle: P) -&gt; impl Iterator&lt;Item = H&gt; {
    let mut searcher = needle.into_searcher();
    let mut span = (haystack, haystack.start_index()..haystack.end_index());
    while let Some(range) = searcher.search((&amp;span.0, span.1.clone())) {
        // split the span into 3 parts.
        let [_, matched, rest] = span.split_around(range);
        span = rest;
        yield matched.0.slice_unchecked(matched.1);
    }
}</code></pre>
<p>For a span of <code>&amp;str</code>, we will implement <code>.split_around()</code> to keep the original haystack, and only split the ranges. While for <code>&amp;mut str</code>, this method will split the haystack apart.</p>
<p>The call the these a <em>shared span</em> and <em>unique span</em> respectively. The split behavior of shared span in fact is independent of haystack, and the operation is done entirely on the Range alone. Thus we could reduce repetitive implementation by providing <code>Span&lt;H&gt;</code> in the standard library. The Haystack implementation only needs to specify which flavor is chosen by a marker trait.</p>
<pre><code class="language-rust">// v3.0-alpha.4
trait SharedHaystack: Haystack + Clone {}

struct Span&lt;H: Haystack&gt; {
    haystack: H,
    range: Range&lt;H::Index&gt;,
}

impl&lt;H: Haystack&gt; Span&lt;H&gt; {
    fn split_around(self, range: Range&lt;H::Index&gt;) -&gt; [Self; 3];
    fn borrow(&amp;self) -&gt; (&amp;H::Target, Range&lt;H::Index&gt;);
    ...
}

gen fn matches&lt;H: Haystack, P: Needle&lt;H&gt;&gt;(haystack: H, needle: P) -&gt; impl Iterator&lt;Item = H&gt; {
    let mut searcher = needle.into_searcher();
    let mut span = H::Span::from(haystack);
    while let Some(range) = searcher.search(span.borrow()) {
        let [_, matched, rest] = span.split_around(range);
        span = rest;
        yield H::from(matched);
    }
}</code></pre>
<h4 id="hay-dont-repeat-yourself"><a class="header" href="#hay-dont-repeat-yourself">Hay: Don‚Äôt repeat yourself</a></h4>
<p>When we support searching both <code>&amp;str</code> and <code>&amp;mut str</code>, we‚Äôll often need to implement the same algorithm to both types. v2.0 solves this by using macros, which works but is not elegant.</p>
<p>Since both <code>&amp;str</code> and <code>&amp;mut str</code> can be borrowed as a <code>str</code>, we could force every haystack to implement <code>Borrow</code>. We call the borrowed type a <strong>hay</strong>. The searcher can then only work on the hay, instead of haystack.</p>
<pre><code class="language-rust">// v3.0-alpha.5
unsafe trait Haystack: Deref&lt;Target: Hay&gt; {
    ...
}
trait Searcher&lt;A: Hay + ?Sized&gt; {
    fn search(&amp;mut self, span: Span&lt;&amp;A&gt;) -&gt; Option&lt;Range&lt;A::Index&gt;&gt;;
}</code></pre>
<p>Unfortunately, a Needle must be associated with the Haystack, because we must not allow ‚Äúmatch <code>&amp;mut str</code> with <code>&amp;Regex</code>‚Äù to happen. Thus macros would still be needed, though not surrounding the entire module.</p>
<pre><code class="language-rust">// v3.0-alpha.5
trait Needle&lt;H: Haystack&gt; {
    type Searcher: Searcher&lt;H::Target&gt;;
    ...
}</code></pre>
<h4 id="consumer-1"><a class="header" href="#consumer-1">Consumer</a></h4>
<p>In v2.0 and before, a pattern (needle) will need to specialize <code>starts_with()</code> and <code>ends_with()</code>.</p>
<pre><code class="language-rust">// v2.0
trait Pattern&lt;H: PatternHaystack&gt; {
    ...
    fn is_prefix_of(self, haystack: H) -&gt; bool;
    fn is_suffix_of(self, haystack: H) -&gt; bool where Self::Searcher: ReverseSearcher&lt;H&gt;;
}</code></pre>
<p>In v3.0, we have removed <code>.next_reject()</code> from Searcher, and thus Needle needs to provide <code>.trim_start()</code> and <code>.trim_end()</code> as well, making the <code>Needle</code> trait quite large.</p>
<p>There are many disadvantages by putting these specialization methods directly inside <code>Needle</code>:</p>
<ol>
<li><a href="https://github.com/rust-lang/rust/issues/20021">Issue 20021</a> means the <code>Needle</code> impl for <code>&amp;Regex</code> will still need to implement <code>.is_suffix_of()</code> and <code>.trim_end()</code> even if they are <code>unimplemented!()</code></li>
<li>These two methods do not use the searcher directly, but is bounded by <code>where Self::Searcher: ReverseSearcher&lt;H&gt;</code> which feels strange.</li>
<li>More code needs to be repeated to delegate an implementation e.g. from <code>&amp;str</code> to <code>&amp;[u8]</code>.</li>
</ol>
<p>A solution move <code>.is_prefix_of()</code> and <code>.trim_start()</code> directly into <code>Searcher</code>. However, a searcher sometimes requires preprocessing unnecessary for these operations. Therefore, instead we put them into a separate entity called a <em>consumer</em>.</p>
<pre><code class="language-rust">// v3.0-alpha.6
trait Needle&lt;H: Haystack&gt; {
    type Consumer: Consumer&lt;H::Target&gt;;
    fn into_consumer(self) -&gt; Self::Consumer;
    ...
}
trait Consumer&lt;A: Hay + ?Sized&gt; {
    fn is_prefix_of(&amp;mut self, hay: &amp;A) -&gt; bool;
    fn trim_start(&amp;mut self, hay: &amp;A) -&gt; A::Index;
}</code></pre>
<p>We observed that <code>.is_prefix_of()</code> and <code>.trim_start()</code> have one thing in common: they both only match the beginning of text. This allows us to require only a single method in the <code>Consumer</code> trait.</p>
<pre><code class="language-rust">// v3.0-alpha.7
trait Consumer&lt;A: Hay + ?Sized&gt; {
    fn consume(&amp;mut self, hay: Span&lt;&amp;A&gt;) -&gt; Option&lt;A::Index&gt;;
    fn trim_start(&amp;mut self, hay: &amp;A) -&gt; A::Index { /* default impl */ }
}</code></pre>
<p>Both <code>starts_with()</code> and <code>trim()</code> can be efficiently implemented in terms of <code>.consume()</code>, though for some needles a specialized <code>trim()</code> can be even faster, so we keep this default method.</p>
<h3 id="miscellaneous-decisions"><a class="header" href="#miscellaneous-decisions">Miscellaneous decisions</a></h3>
<h4 id="usize-as-index-instead-of-pointers"><a class="header" href="#usize-as-index-instead-of-pointers"><code>usize</code> as index instead of pointers</a></h4>
<p>Pattern API v1.3‚Äìv2.0 all used cursors (pointers) as the primary indexing method. v3.0 still supports cursor-based indexing, but reverts to <code>usize</code> for the built-in slice types (<code>str</code>, <code>[T]</code> and <code>OsStr</code>). There are two reasons for this:</p>
<ol>
<li>
<p><strong>Zero-sized types</strong>. All elements of a slice of ZSTs e.g. <code>[()]</code> have the same pointer. A proper haystack/searcher implementation would need to check <code>size_of::&lt;T&gt;()</code> and encode the index into (non-zero) pointers when the size is 0. This made the code very ugly and easy to get wrong (the v2.0 implementation does not consider ZSTs for instance).</p>
</li>
<li>
<p><strong>No performance advantage</strong>. We have tested the performance and found that using integer index or cursor pointer have similar performance.</p>
</li>
</ol>
<h4 id="dsts-instead-of-gats"><a class="header" href="#dsts-instead-of-gats">DSTs instead of GATs</a></h4>
<p>We share a searcher implementation by introducing the <code>Hay</code> trait, as the dereference target of the <code>Haystack</code> trait, i.e. <code>&amp;[T]</code>, <code>&amp;mut [T]</code> and <code>Vec&lt;T&gt;</code> will all be delegated to <code>[T]</code>:</p>
<pre><code class="language-rust">unsafe trait Haystack: Deref&lt;Target: Hay&gt; + Sized {
    ...
}
unsafe trait Searcher&lt;A: Hay + ?Sized&gt; {
    fn search(&amp;mut self, span: Span&lt;&amp;A&gt;) -&gt; Option&lt;Range&lt;A::Index&gt;&gt;;
}</code></pre>
<p>The problem is not every haystack can be dereferenced. Proper support of any types beyond slices would require custom dynamic-sized types (DSTs).</p>
<p>An alternative formation is delegating to a shared haystack by generic associated types (GATs):</p>
<pre><code class="language-rust">unsafe trait Haystack: Sized {
    type Shared&lt;'a&gt;: SharedHaystack;
    fn borrow(&amp;self) -&gt; Self::Shared&lt;'_&gt;;
    ...
}
unsafe trait Searcher&lt;H: SharedHaystack&gt; {
    fn search(&amp;mut self, span: Span&lt;H&gt;) -&gt; Option&lt;Range&lt;H::Index&gt;&gt;;
}</code></pre>
<p>We have decided to go with the DSTs approach because:</p>
<ol>
<li>
<p><strong>Non-slice haystacks are rare</strong>. The built-in types that v3.0 aims to support all have corresponding built-in DSTs (<code>str</code>, <code>[T]</code> and <code>OsStr</code>), making the problem of custom DSTs irrelevant in the standard library.</p>
</li>
<li>
<p><strong>GATs is still unimplemented</strong>. While the RFC for GATs has been accepted, the implementation has still not landed on the Rust compiler, making it impossible to create a test prototype.</p>
</li>
</ol>
<h4 id="deref-instead-of-borrow"><a class="header" href="#deref-instead-of-borrow"><code>Deref</code> instead of <code>Borrow</code></a></h4>
<p>The <code>Haystack</code> trait inherits <code>Deref</code> and requires its <code>Target</code> to implement <code>Hay</code>. An alternative is extending <code>Borrow</code> instead:</p>
<pre><code class="language-rust">unsafe trait Haystack: Borrow&lt;Self::Hay&gt; + Sized {
    type Hay: Hay + ?Sized;
    ...
}</code></pre>
<p>The advantage of <code>Borrow</code> is that it does not force us to rely on custom DST because <code>‚àÄT. T: Borrow&lt;T&gt;</code>, but that is not the whole picture ‚Äî the owned type <code>LinkedList&lt;T&gt;</code> cannot implement <code>Hay</code>, because it cannot properly implement <code>slice_unchecked(&amp;self, ...) -&gt; &amp;Self</code> (we cannot magically make up a borrowed sub-list).</p>
<p>And thus the more general <code>Borrow</code> trait offers no advantage over <code>Deref</code>.</p>
<h4 id="searcher-makes-hay-an-input-type-instead-of-associated-type"><a class="header" href="#searcher-makes-hay-an-input-type-instead-of-associated-type">Searcher makes Hay an input type instead of associated type</a></h4>
<p>The <code>Searcher</code> and <code>Consumer</code> traits makes the hay as input type. This makes any algorithm relying on a <code>ReverseSearcher</code> need to spell out the hay as well.</p>
<pre><code class="language-rust">trait Searcher&lt;A: Hay + ?Sized&gt; {
    fn search(&amp;mut self, span: Span&lt;&amp;A&gt;) -&gt; Option&lt;Range&lt;A::Index&gt;&gt;;
}

fn rfind&lt;H, P&gt;(haystack: H, needle: P) -&gt; Option&lt;H::Target::Index&gt;
where
    H: Haystack,
    P: Needle&lt;H&gt;,
    P::Searcher: ReverseSearcher&lt;H::Target&gt;; // &lt;---</code></pre>
<p>An alternative is to make Hay an associated type:</p>
<pre><code class="language-rust">trait Searcher {
    type Hay: Hay + ?Sized;
    fn search(&amp;mut self, span: Span&lt;&amp;Self::Hay&gt;) -&gt; Option&lt;Range&lt;Self::Hay::Index&gt;&gt;;
}

fn rfind&lt;H, P&gt;(haystack: H, needle: P) -&gt; Option&lt;H::Target::Index&gt;
where
    H: Haystack,
    P: Needle&lt;H&gt;,
    P::Searcher: ReverseSearcher;</code></pre>
<p>This would mean a searcher type can only search on one haystack. It turns out a searcher is shared quite frequently, e.g. the two-way search algorithm is shared among the needles of <code>&amp;[T]</code>, <code>&amp;str</code> and <code>&amp;OsStr</code>. Associated type would force creation of many wrapper types which is annoying.</p>
<p>Therefore we stay with having the hay as the input type, the same choice taken in v2.0 and before.</p>
<h4 id="specialization-of-contains"><a class="header" href="#specialization-of-contains">Specialization of <code>contains()</code></a></h4>
<p>v3.0 removed the <code>Needle::is_contained_in()</code> method. The <code>contains()</code> algorithm simply returned <code>searcher.search(span).is_some()</code>. The micro-benchmarks shows no performance decrease, thus the method is removed to reduce the API surface.</p>
<h4 id="needle-for-t-only-requires-t-partialeq"><a class="header" href="#needle-for-t-only-requires-t-partialeq">Needle for <code>&amp;[T]</code> only requires <code>T: PartialEq</code></a></h4>
<p>Sub-slice searching nowadays uses the Two-Way search algorithm, which requires ordered alphabet i.e. <code>T: Ord</code>. However, there are already two stabilized APIs only assuming <code>T: PartialEq</code>:</p>
<pre><code class="language-rust">impl&lt;T&gt; [T] {
    pub fn starts_with(&amp;self, needle: &amp;[T]) -&gt; bool
    where
        T: PartialEq;

    pub fn ends_with(&amp;self, needle: &amp;[T]) -&gt; bool
    where
        T: PartialEq;
}</code></pre>
<p>While we could allow only <code>starts_with</code>/<code>ends_with</code> to be bound on <code>PartialEq</code> and make the rest of the array searching algorithm require <code>T: Ord</code>, it feels very inconsistent to do so.</p>
<p>With specialization, this dilemma can be easily fixed: we will fallback to an algorithm which only requires <code>T: PartialEq</code> (e.g. <a href="https://crates.io/crates/galil-seiferas"><code>galil-seiferas</code></a> or even naive search), and use the faster Two-Way algorithm when <code>T: Ord</code>.</p>
<h4 id="not-having-default-implementations-for-search-and-consume"><a class="header" href="#not-having-default-implementations-for-search-and-consume">Not having default implementations for <code>search</code> and <code>consume</code></a></h4>
<p>In the <code>Searcher</code> and <code>Consumer</code> traits, <code>.search()</code> and <code>.consume()</code> can be implemented in terms of each other:</p>
<pre><code class="language-rust">impl&lt;A, C&gt; Searcher&lt;A&gt; for C
where
    A: Hay + ?Sized,
    C: Consumer&lt;A&gt;,
{
    fn search(&amp;mut self, span: Span&lt;&amp;A&gt;) -&gt; Option&lt;Range&lt;A::Index&gt;&gt; {
        // we can implement `search` in terms of `consume`
        let (hay, range) = span.into_parts();
        loop {
            unsafe {
                if let Some(end) = self.consume(Span::from_span(hay, range.clone())) {
                    return Some(range.start..end);
                }
                if range.start == range.end {
                    return None;
                }
                range.start = hay.next_index(range.start);
            }
        }
    }
}

impl&lt;A, S&gt; Consumer&lt;A&gt; for S
where
    A: Hay + ?Sized,
    S: Searcher&lt;A&gt;,
{
    fn consume(&amp;mut self, span: Span&lt;&amp;A&gt;) -&gt; Option&lt;A::Index&gt; {
        // we can implement `consume` in terms of `search`
        let start = span.original_range().start;
        let range = self.search(span)?;
        if range.start == start {
            Some(range.end)
        } else {
            None
        }
    }
}</code></pre>
<p>These fallbacks should only be used when the needle does not allow more efficient implementations, which is often not the case. To encourage needle implementations to support both primitives, where they should have full control of the details, we keep them as required methods.</p>
<h4 id="names-of-everything"><a class="header" href="#names-of-everything">Names of everything</a></h4>
<ul>
<li>
<p><strong>Haystack</strong>. Inherited from the v1.0 method <code>Searcher::haystack()</code>. v2.0 called it <code>PatternHaystack</code> since <code>Haystack</code> is an associated type referring to a range of cursors, but v3.0 does away the exclusive cursor-based design and thus can choose the shorter name for the trait.</p>
</li>
<li>
<p><strong>Hay</strong>. Chosen as a shorter but related name from ‚ÄúHaystack‚Äù, similar to the relation in <code>String</code> ‚Üí <code>str</code> and <code>PathBuf</code> ‚Üí <code>Path</code>.</p>
</li>
<li>
<p><strong>Needle</strong>. Renamed from <code>Pattern</code> to clear confusion with the language‚Äôs pattern matching. Calling it ‚Äúneedle‚Äù to pair up with ‚Äúhaystack‚Äù.</p>
</li>
<li>
<p><strong>Searcher::search()</strong>. The name ‚ÄúSearcher‚Äù is the same as v1.0. The method is renamed from <code>.next_match()</code> since it needs to take a span as input and thus no longer iterator-like. It is renamed to <code>.search()</code> as a shorter verb and also consistent with the trait name.</p>
</li>
<li>
<p><strong>Consumer::consume()</strong>. The name is almost randomly chosen as there‚Äôs no good name for this operation. This name is taken from the same function in the <a href="https://github.com/google/re2/blob/2018-07-01/re2/re2.h#L330-L334"><code>re2</code> library</a>.</p>
<ul>
<li>
<p><code>Consumer</code> is totally different from <code>Searcher</code>. Calling it <code>PrefixSearcher</code> or <code>AnchoredSearcher</code> would imply a non-existing sub-classing relationship.</p>
</li>
<li>
<p>We would also like a name which is only a single word.</p>
</li>
<li>
<p>We want the name <em>not</em> start with the letter <strong>S</strong> so we could easily distinguish between this and <code>Searcher</code> when quick-scanning the code, in particular when <code>ReverseXxxer</code> is involved.</p>
</li>
<li>
<p>‚ÄúMatcher‚Äù (using name from Python) is incompatible with the existing <code>.matches()</code> method. Besides, the meaning of ‚Äúmatch‚Äù is very ambiguous among other libraries.</p>
<details><summary>Names from other languages and libraries</summary>
</details></li>
</ul>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Library</th><th>Substring</th><th>Start of text</th><th>Entire string</th></tr>
</thead>
<tbody>
<tr><td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex">C# (.NET)</a></td><td><code>Match</code></td><td>-</td><td>-</td></tr>
<tr><td><a href="https://en.cppreference.com/w/cpp/regex">C++</a></td><td><code>regex_search</code></td><td>-</td><td><code>regex_match</code></td></tr>
<tr><td><a href="https://dlang.org/phobos/std_regex.html">D</a></td><td><code>matchFirst</code></td><td>-</td><td>-</td></tr>
<tr><td><a href="https://api.dartlang.org/stable/1.24.3/dart-core/Pattern-class.html">Dart</a></td><td><code>firstMatch</code></td><td><code>matchAsPrefix</code></td><td>-</td></tr>
<tr><td><a href="http://erlang.org/doc/man/re.html">Erlang</a></td><td><code>run</code></td><td>(<code>anchored</code>)</td><td>-</td></tr>
<tr><td><a href="https://golang.org/pkg/regexp/">Go</a></td><td><code>Find</code></td><td>-</td><td>-</td></tr>
<tr><td><a href="https://hackage.haskell.org/package/regex-base-0.93.2/docs/Text-Regex-Base-RegexLike.html">Haskell</a></td><td><code>match</code></td><td>-</td><td>-</td></tr>
<tr><td><a href="http://icu-project.org/apiref/icu4c/classRegexMatcher.html">ICU</a></td><td><code>find</code></td><td><code>lookingAt</code></td><td><code>matches</code></td></tr>
<tr><td><a href="https://docs.oracle.com/javase/10/docs/api/java/util/regex/Matcher.html">Java (JVM)</a></td><td><code>find</code></td><td><code>lookingAt</code></td><td><code>matches</code></td></tr>
<tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">JavaScript</a></td><td><code>exec</code>/<code>match</code></td><td>-</td><td>-</td></tr>
<tr><td><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/">Kotlin</a></td><td><code>find</code></td><td>-</td><td><code>matchEntire</code></td></tr>
<tr><td><a href="https://www.lua.org/manual/5.3/manual.html#6.4">Lua</a></td><td><code>find</code>/<code>match</code></td><td>-</td><td>-</td></tr>
<tr><td><a href="https://nim-lang.org/docs/re.html">Nim</a></td><td><code>find</code></td><td>-</td><td><code>match</code></td></tr>
<tr><td><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html">OCaml</a></td><td><code>search_forward</code></td><td><code>string_match</code></td><td>-</td></tr>
<tr><td><a href="https://github.com/kkos/oniguruma/blob/master/doc/API">Oniguruma</a></td><td><code>onig_search</code></td><td>-</td><td><code>onig_match</code></td></tr>
<tr><td><a href="https://pcre.org/current/doc/html/pcre2api.html#SEC27">PCRE2</a></td><td><code>pcre2_match</code></td><td>(<code>PCRE2_ANCHORED</code>)</td><td>(<code>PCRE2_ENDANCHORED</code>)</td></tr>
<tr><td><a href="http://pubs.opengroup.org/onlinepubs/9699919799//functions/regexec.html">POSIX</a></td><td><code>regexec</code></td><td>-</td><td>-</td></tr>
<tr><td><a href="https://docs.python.org/3/library/re.html">Python</a></td><td><code>search</code></td><td><code>match</code></td><td><code>fullmatch</code></td></tr>
<tr><td><a href="https://github.com/google/re2/blob/master/re2/re2.h">re2</a></td><td><code>PartialMatch</code></td><td><code>Consume</code></td><td><code>FullMatch</code></td></tr>
<tr><td><a href="https://ruby-doc.org/core-2.5.0/Regexp.html">Ruby</a></td><td><code>match</code></td><td>-</td><td>-</td></tr>
<tr><td><a href="https://docs.rs/regex/1.0.1/regex/struct.Regex.html">Rust</a></td><td><code>find</code></td><td>-</td><td>-</td></tr>
<tr><td><a href="https://www.scala-lang.org/api/current/scala/util/matching/Regex.html">Scala</a></td><td><code>findFirstIn</code></td><td><code>findPrefixOf</code></td><td>-</td></tr>
<tr><td><a href="https://developer.apple.com/documentation/foundation/nsregularexpression">Swift</a></td><td><code>firstMatch</code></td><td>-</td><td>-</td></tr>
</tbody>
</table>
</div>
  
</li>
<li>
<p><strong>rsearch()</strong>, <strong>rconsume()</strong>. The common naming convention of algorithms for reverse searching is adding an <code>r</code> prefix, so we do the same for the trait methods as well.</p>
</li>
<li>
<p><strong>Span</strong>. The name is taken from the rustc compiler.</p>
</li>
</ul>
<h3 id="Êõø‰ª£ÊñπÊ°à"><a class="header" href="#Êõø‰ª£ÊñπÊ°à">Êõø‰ª£ÊñπÊ°à</a></h3>
<ul>
<li>The names of everything except <code>Searcher</code> and <code>Haystack</code> are not finalized.</li>
</ul>
<h2 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h2>
<h3 id="previous-attempts"><a class="header" href="#previous-attempts">Previous attempts</a></h3>
<h4 id="v10"><a class="header" href="#v10">v1.0</a></h4>
<p>The existing <code>Pattern</code> API was introduced in <a href="https://github.com/rust-lang/rfcs/pull/528">RFC 528</a> to provide a common interface for several search-related operations on a string. There were several minor revisions after the RFC was accepted, but till nowadays is still an unstable API.</p>
<p>A <code>Pattern</code> is currently implemented for the following types:</p>
<ul>
<li><code>char</code> ‚Äî search for a single character in a string.</li>
<li><code>&amp;[char]</code> ‚Äî search for a character set in a string.</li>
<li><code>&amp;str</code>, <code>&amp;&amp;str</code>, <code>&amp;String</code> ‚Äî search for a substring.</li>
<li><code>FnMut(char) -&gt; bool</code> ‚Äî search by property of a character.</li>
<li><code>&amp;regex::Regex</code> ‚Äî search by regular expression (provided through the <code>regex</code> package).</li>
</ul>
<pre><code class="language-rust">trait Pattern&lt;'a&gt; {
    type Searcher: Searcher&lt;'a&gt;;
    fn into_searcher(self, haystack: &amp;'a str) -&gt; Self::Searcher;

    fn is_contained_in(self, haystack: &amp;'a str) -&gt; bool { ... }
    fn is_prefix_of(self, haystack: &amp;'a str) -&gt; bool { ... }
    fn is_suffix_of(self, haystack: &amp;'a str) -&gt; bool where Self::Searcher: ReverseSearcher&lt;'a&gt; { ... }
}</code></pre>
<p>The <code>Pattern</code> trait is a builder object. To perform searching, implementations will convert itself into a <code>Searcher</code> object. This conversion serves two purposes:</p>
<ol>
<li>Preprocess the pattern to allow for faster algorithm, e.g. the <code>Pattern::into_search</code> for substring search will calculate critical information to perform the Two-Way search algorithm.</li>
<li>Store the mutable search states.</li>
</ol>
<pre><code class="language-rust">unsafe trait Searcher&lt;'a&gt; {
    fn haystack(&amp;self) -&gt; &amp;'a str;
    fn next_match(&amp;mut self) -&gt; Option&lt;(usize, usize)&gt; { ... }
    fn next_reject(&amp;mut self) -&gt; Option&lt;(usize, usize)&gt; { ... }
    fn next(&amp;mut self) -&gt; SearchStep;
}</code></pre>
<p>Calling <code>next_match()</code> or <code>next_reject()</code> will yield a range:</p>
<ul>
<li><code>next_match()</code> ‚Äî returns the next substring range of the haystack which matches a single instance of the pattern.</li>
<li><code>next_reject()</code> ‚Äî returns the next longest substring range of the haystack which contains no pattern at all.</li>
</ul>
<p>(The <code>next()</code> call interleaves both methods above.)</p>
<pre><code class="language-rust">// for simplicity, `where` clauses involving ReverseSearcher and DoubleEndedSearcher are omitted.
impl str {
    fn contains(&amp;'a self, pat: impl Pattern&lt;'a&gt;) -&gt; bool;
    fn starts_with(&amp;'a self, pat: impl Pattern&lt;'a&gt;) -&gt; bool;
    fn find(&amp;'a self, pat: impl Pattern&lt;'a&gt;) -&gt; Option&lt;usize&gt;;
    fn split(&amp;'a self, pat: impl Pattern&lt;'a&gt;) -&gt; impl Iterator&lt;Item = &amp;'a str&gt;;
    fn split_terminator(&amp;'a self, pat: impl Pattern&lt;'a&gt;) -&gt; impl Iterator&lt;Item = &amp;'a str&gt;;
    fn splitn(&amp;'a self, n: usize, pat: impl Pattern&lt;'a&gt;) -&gt; impl Iterator&lt;Item = &amp;'a str&gt;;
    fn matches(&amp;'a self, pat: impl Pattern&lt;'a&gt;) -&gt; impl Iterator&lt;Item = &amp;'a str&gt;;
    fn match_indices(&amp;'a self, pat: impl Pattern&lt;'a&gt;) -&gt; impl Iterator&lt;Item = (usize, &amp;'a str)&gt;;
    fn trim_left_matches(&amp;'a self, pat: impl Pattern&lt;'a&gt;) -&gt; &amp;'a str;
    fn replace(&amp;'a self, from: impl Pattern&lt;'a&gt;, to: &amp;str) -&gt; String;
    fn replacen(&amp;'a self, from: impl Pattern&lt;'a&gt;, to: &amp;str, count usize) -&gt; String;

    // The following requires the Pattern's Searcher to additionally be constrained by `ReverseSearcher`
    fn ends_with(&amp;'a self, pat: impl Pattern&lt;'a&gt;) -&gt; bool;
    fn rfind(&amp;'a self, pat: impl Pattern&lt;'a&gt;) -&gt; Option&lt;usize&gt;;
    fn rsplit(&amp;'a self, pat: impl Pattern&lt;'a&gt;) -&gt; impl Iterator&lt;Item = &amp;'a str&gt;;
    fn rsplit_terminator(&amp;'a self, pat: impl Pattern&lt;'a&gt;) -&gt; impl Iterator&lt;Item = &amp;'a str&gt;;
    fn rsplitn(&amp;'a self, n: usize, pat: impl Pattern&lt;'a&gt;) -&gt; impl Iterator&lt;Item = &amp;'a str&gt;;
    fn rmatches(&amp;'a self, pat: impl Pattern&lt;'a&gt;) -&gt; impl Iterator&lt;Item = &amp;'a str&gt;;
    fn rmatch_indices(&amp;'a self, pat: impl Pattern&lt;'a&gt;) -&gt; impl Iterator&lt;Item = (usize, &amp;'a str)&gt;;
    fn trim_right_matches(&amp;'a self, pat: impl Pattern&lt;'a&gt;) -&gt; &amp;'a str;

    // The following requires the Pattern's Searcher to additionally be constrained by `DoubleEndedSearcher`
    fn trim_matches(&amp;'a self, pat: impl Pattern&lt;'a&gt;) -&gt; &amp;'a str;
}</code></pre>
<p>Using the result from the <code>SearchStep</code> stream, the <code>Pattern</code> API can be used to implement the above string methods.</p>
<p>While the pattern-to-searcher conversion is beneficial when searching the entire haystack, it is often wasteful in simple functions like <code>starts_with</code> and <code>ends_with</code> (a sub-slice equality check is optimal). Therefore, the specialized methods like <code>Pattern::is_prefix_of</code> are provided.</p>
<h4 id="v12v15"><a class="header" href="#v12v15">v1.2‚Äìv1.5</a></h4>
<p>The <code>Pattern</code> API in Rust only supports searching a string. An <a href="https://github.com/rust-lang/rust/issues/27721#issuecomment-185405392">attempt</a> to evolve this to arbitrary haystack type can be found in the repository <a href="https://github.com/Kimundi/pattern_api_sketch">Kimundi/pattern_api_sketch</a>.</p>
<pre><code class="language-rust">trait Pattern&lt;H: SearchPtrs&gt;: Sized {
    type Searcher: Searcher&lt;H&gt;;
    fn into_searcher(self, haystack: H) -&gt; Self::Searcher;
    ...
}

unsafe trait Searcher&lt;H: SearchPtrs&gt; {
    fn haystack(&amp;self) -&gt; H::Haystack;
    fn next_match(&amp;mut self) -&gt; Option&lt;(H::Cursor, H::Cursor)&gt;;
    fn next_reject(&amp;mut self) -&gt; Option&lt;(H::Cursor, H::Cursor)&gt;;
}</code></pre>
<p>The most obvious change is to replace all <code>&amp;'a str</code> by an arbitrary type <code>H</code>. The type still needs to ‚Äúbehave like a string‚Äù though, thus the <code>SearchPtrs</code> bound, which will be used to turn a pair of cursors (equivalent to byte offsets) into a ‚Äúsubstring‚Äù of the haystack for the <code>split</code> and <code>match</code> methods.</p>
<pre><code class="language-rust">trait SearchPtrs { // e.g. implemented for &amp;str
    type Haystack: Copy; // e.g. (*const u8, *const u8)
    type Cursor: Copy; // e.g. *const u8

    unsafe fn offset_from_start(hs: Self::Haystack, begin: Self::Cursor) -&gt; usize;
    unsafe fn range_to_self(hs: Self::Haystack, start: Self::Cursor, end: Self::Cursor) -&gt; Self;
    unsafe fn cursor_at_front(hs: Self::Haystack) -&gt; Self::Cursor;
    unsafe fn cursor_at_back(hs: Self::Haystack) -&gt; Self::Cursor;
}</code></pre>
<h4 id="v20"><a class="header" href="#v20">v2.0</a></h4>
<p>The <a href="https://github.com/Kimundi/rust_pattern_api_v2">v2.0 API</a> was introduced due to <a href="https://github.com/rust-lang/rfcs/pull/1309">RFC 1309</a>, trying to cover <code>OsStr</code> as well. But other than <code>OsStr</code> support the v2.0 API is essentially the same as the v1.5 API.</p>
<pre><code class="language-rust">trait Pattern&lt;H: PatternHaystack&gt;: Sized {
    type Searcher: Searcher&lt;H&gt;;
    fn into_searcher(self, haystack: H) -&gt; Self::Searcher;
    ...
}

unsafe trait Searcher&lt;H: PatternHaystack&gt; {
    fn haystack(&amp;self) -&gt; H::Haystack;
    fn next_match(&amp;mut self) -&gt; Option&lt;(H::Cursor, H::Cursor)&gt;;
    fn next_reject(&amp;mut self) -&gt; Option&lt;(H::Cursor, H::Cursor)&gt;;
}

trait PatternHaystack: Sized { // same as SearchPtrs in v1.5
    type Haystack: Copy;
    type Cursor: Copy + Ord;
    type MatchType; // yielded item types from `matches()` and `split()`

    fn into_haystack(self) -&gt; Self::Haystack;
    fn offset_from_front(hs: Self::Haystack, begin: Self::Cursor) -&gt; usize;
    fn cursor_at_front(hs: Self::Haystack) -&gt; Self::Cursor;
    fn cursor_at_back(hs: Self::Haystack) -&gt; Self::Cursor;
    unsafe fn range_to_self(hs: Self::Haystack, start: Self::Cursor, end: Self::Cursor) -&gt; Self::MatchType;
    fn match_type_len(mt: &amp;Self::MatchType) -&gt; usize;
}</code></pre>
<h3 id="haskell"><a class="header" href="#haskell">Haskell</a></h3>
<p>Haskell is perhaps one of the few languages where a generic string matching API is found, since it also has so many string types like Rust üòù, and there isn‚Äôt an official regex implementation (unlike C++ which won‚Äôt give insight how a <code>Searcher</code> interface should be designed).</p>
<p>Haskell‚Äôs <a href="https://hackage.haskell.org/package/regex-base"><code>regex-base</code></a> is the base package which provides the type classes for regex matching.</p>
<p>The type class <code>Extract</code> is corresponding to <code>Haystack</code> in this RFC.</p>
<pre><code class="language-haskell">class Extract source where
    empty :: source
    before :: Int -&gt; source -&gt; source
    after :: Int -&gt; source -&gt; source
</code></pre>
<pre><code class="language-rust">// equivalent meaning in terms of Rust.
trait Extract: Sized {
    fn empty() -&gt; Self;
    fn before(self, index: usize) -&gt; Self;
    fn after(self, index: usize) -&gt; Self;
}</code></pre>
<p>The type class <code>RegexLike</code> is corresponding to <code>Searcher</code> in this RFC.</p>
<pre><code class="language-haskell">class (Extract source) =&gt; RegexLike regex source where
    matchOnceText :: regex -&gt; source -&gt; Maybe (source, MatchText source, source)
    matchAllText :: regex -&gt; source -&gt; [MatchText source]
    -- the rest are default implementations depending on these two functions.
</code></pre>
<pre><code class="language-rust">// equivalent meaning in terms of Rust.
trait RegexLike&lt;Source: Extract&gt;: Sized {
    fn match_once_text(self, source: Source) -&gt; Option&lt;(Source, MatchText&lt;Source&gt;, Source)&gt;;
    fn match_all_text(self, source: Source) -&gt; impl IntoIterator&lt;Item = MatchText&lt;Source&gt;&gt;;
    // ...
}</code></pre>
<p>Similar to this RFC, the primary search method <code>matchOnceText</code> is trisection-based.</p>
<p>Unlike this RFC, the <code>Extract</code> class is much simpler.</p>
<ol>
<li>Haskell doesn‚Äôt have the shared/mutable/owned variant of the same type of string. Therefore it does not need the <code>Hay</code>/<code>Haystack</code> trait separation, and also does not need a dedicated <code>split :: Int -&gt; source -&gt; (source, source)</code> method.</li>
<li>Haskell‚Äôs strings do not enforce a particular encoding on its string types, thus <code>next_index</code> and <code>prev_index</code> become simply <code>(+ 1)</code> and <code>(‚àí 1)</code>.</li>
<li>The <code>Extract</code> class only supports indexing using an integer, so <code>start_index</code> must be <code>0</code>. <code>end_index</code> is also not needed since <code>before</code> and <code>after</code> (the slicing operations) will automatically clamp the index.</li>
</ol>
<h2 id="Êú™Ëß£Ê±∫ÁöÑÂïèÈ°å"><a class="header" href="#Êú™Ëß£Ê±∫ÁöÑÂïèÈ°å">Êú™Ëß£Ê±∫ÁöÑÂïèÈ°å</a></h2>
<ul>
<li>
<p>Currently, due to RFC 2089 and/or 2289 not being implemented, using a <code>Haystack</code> in any algorithm would need to a redundant where clause:</p>
<pre><code class="language-rust">fn starts_with&lt;H, P&gt;(haystack: H, needle: P) -&gt; bool
where
    H: Haystack,
    P: Needle&lt;H&gt;,
    H::Target: Hay, // &lt;-- this line
{ ... }</code></pre>
<p>This RFC assumes that before stabilizing, either RFC should have been implemented.</p>
</li>
<li>
<p>For simplicity the prototype implementation fallbacks to the ‚Äúnaive search algorithm‚Äù when <code>T: !Ord</code> by always factorizing the needle <code>arr</code> into <code>arr[..1] ++ arr[1..]</code>. It is not proven that this is equivalent to the ‚Äúnaive search‚Äù, though unit testing does suggest this works.</p>
<p>As mentioned in the RFC, there are faster algorithms for searching a <code>T: !Ord</code> slice. It is not decided if we should complicate the standard library to support this though.</p>
</li>
<li>
<p>We could represent <code>SharedHaystack</code> using a more general concept of ‚Äúcheaply cloneable‚Äù:</p>
<pre><code class="language-rust">pub trait ShallowClone: Clone {}
impl&lt;'a, T: ?Sized + 'a&gt; ShallowClone for &amp;'a T {}
impl&lt;T: ?Sized&gt; ShallowClone for Rc&lt;T&gt; {}
impl&lt;T: ?Sized&gt; ShallowClone for Arc&lt;T&gt; {}</code></pre>
<p>and all <code>H: SharedHaystack</code> bound can be replaced by <code>H: Haystack + ShallowClone</code>. But this generalization brings more questions e.g. should <code>[u32; N]: ShallowClone</code>. This should be better left to a new RFC, and since <code>SharedHaystack</code> is mainly used for the core type <code>&amp;A</code> only, we could keep <code>SharedHaystack</code> unstable longer (a separate track from the main Needle API) until this question is resolved.</p>
</li>
<li>
<p>With a benefit of simplified API, we may want to merge <code>Consumer</code> and <code>Searcher</code> into a single trait.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="2497-if-let-chains.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="2504-fix-error.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="2497-if-let-chains.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="2504-fix-error.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
