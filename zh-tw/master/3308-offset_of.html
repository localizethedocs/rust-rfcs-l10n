<!DOCTYPE HTML>
<html lang="zh_TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>3308-offset_of - The Rust RFC Book</title>


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-c5bb60c5.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5025baa3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <ul>
<li>Feature Name: <code>offset_of</code></li>
<li>Start Date: 2022-08-29</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/3308">rust-lang/rfcs#3308</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/106655">rust-lang/rust#106655</a></li>
</ul>
<h2 id="摘要"><a class="header" href="#摘要">摘要</a></h2>
<p>Introduce a new macro <code>core::mem::offset_of!</code>, which evaluates to a constant containing the offset in bytes of a field inside some type.</p>
<p>Specifically, this RFC allows usage like the following:</p>
<pre><code class="language-rs">use core::mem::offset_of;

const EXAMPLES: &amp;[usize] = &amp;[
    offset_of!(Struct, b),
    offset_of!(TupleStruct, 0),
    offset_of!(Union, y),
    offset_of!((i32, u32), 1),
    offset_of!(inner::SubmodGeneric&lt;i32&gt;, pub_field),
];

struct Struct { a: u64, b: &amp;'static str }
struct TupleStruct(u8, i32);
union Union { x: u8, y: u64 }

mod inner {
    pub struct SubmodAndGeneric&lt;T&gt; {
        private_field: T,
        pub pub_field: u8,
    }
}
</code></pre>
<h2 id="動機"><a class="header" href="#動機">動機</a></h2>
<p>Type layout information is very frequently needed in low level code, especially if it’s performing serialization, FFI, or implementing a data structure.</p>
<p>While often the needed information is limited to the size and required alignment of a given type, sometimes there is a need to access information about the fields of a type, most commonly (and most fundamentally) the offset (in bytes), at which the field may be found in the type which contains it.</p>
<p>Currently, Rust’s standard library provides good explicit APIs for providing information about the size and alignment of a given type (specifically, <code>core::mem</code> has <code>size_of</code>, <code>align_of</code>, <code>size_of_val</code>, and <code>align_of_val</code>). Unfortunately, it provides none for determining field-offset, leaving it to be computed based on implicitly-provided layout information.</p>
<p>This is an unfortunate gap, one we’ve seen countless workarounds for, which have caused no end of trouble in the ecosystem. The problem is that while recovering layout information in this manner is completely possible in rust (recovering the size and alignment would even be possible using the same technique), doing it correctly is very subtle. Most of the implementations which seem obvious are actually wrong, often because they invoke undefined behavior.</p>
<p>Unfortunately, this also means they often tend to work at first, but have a risk to be something of a “ticking time-bomb”, which may break in a future release of Rust or LLVM.</p>
<p>This is not a theoretical concern, and widespread breakage of incorrect <code>offset_of</code> implementations has happened in the past (e.g. when <code>mem::zeroed</code> started performing validity checks), and may happen again (e.g. the <code>deref_nullptr</code> lint revealed large bodies of code with incorrect implementations).</p>
<p>Unfortunately, previously there’s not been great alternative. Generally, the recommendation users are given is to either:</p>
<ol>
<li>Use a crate, for example <code>memoffset</code> and <code>bytemuck</code> both have <code>offset_of!</code> implementations.</li>
<li>Hardcode the constant.</li>
</ol>
<p>Both of which have several downsides, but even if the operation can be flawlessly performed by library code, it’s the opinion of the author of this RFC that this operation is fundamental enough that at a minimum, that the standard library should provide the implementation.</p>
<h2 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h2>
<p>In low level code, you may find you need to know the byte offset of a field within a type. This can be accomplished with the <code>core::mem::offset_of!</code> macro.</p>
<p><code>core::mem::offset_of!</code> takes two arguments, the type that holds the field, and the name of the field. For example, if you have:</p>
<pre><code class="language-rs">#[repr(C)]
struct Vertex {
    tex: [u16; 2],
    pos: [f32; 3],
}
</code></pre>
<p>Then you can use <code>core::mem::offset_of!(Vertex, tex)</code> to get the offset in bytes where <code>tex</code> begins, and <code>core::mem::offset_of!(Vertex, pos)</code> to get the offset in bytes where <code>pos</code> begins.</p>
<p>In this example, we also specified the layout algorithm to use, so we know that <code>offset_of!(Vertex, tex)</code> will be 0, and <code>offset_of!(Vertex, pos)</code> will be 4.</p>
<p>However, if a <code>#[repr(...)]</code> is not used, the compiler is free to place the fields of <code>Vertex</code> in whatever order it prefers (even if they aren’t the same as the order the fields are written in the struct declaration), so there’s no way to know in advance what the positions of the fields will be.</p>
<p>Thankfully, <code>offset_of!</code> is still usable here:</p>
<pre><code class="language-rs">// No `#[repr()]` needed!
struct Vertex {
    tex: [u16; 2],
    pos: [f32; 3],
}
// This time let's define some constants containing the offset value,
// which can be more readable if you need to use them several times.
const OFFSET_VERTEX_TEX: usize = core::mem::offset_of!(Vertex, tex);
const OFFSET_VERTEX_POS: usize = core::mem::offset_of!(Vertex, pos);
</code></pre>
<p>As you can see, the usage is the same as before, but because we didn’t specify <code>#[repr(C)]</code>, compiler may have changed the order or position, so the values may be different – it’s completely possible that <code>pos</code> is located at offset 0, for example! Thankfully, by using <code>core::mem::offset_of!</code>, this code is correct either way, and will continue to be correct, even if the layout algorithm changes in the future.</p>
<h3 id="offset_of-on-other-types"><a class="header" href="#offset_of-on-other-types"><code>offset_of!</code> On Other Types</a></h3>
<p>If your type doesn’t have named fields, <code>offset_of!</code> can still be used. For tuples and tuple structs, the “name” of the field is the numeral value you use to access it. For example:</p>
<pre><code class="language-rust">// Works with a tuple struct
struct KeyVal(&amp;'static str, Vec&lt;u8&gt;);
const OFFSET_KV_KEY: usize = core::mem::offset_of!(KeyVal, 0);
const OFFSET_KV_VAL: usize = core::mem::offset_of!(KeyVal, 1);
// Or with an anonymous tuple.
const OFFSET_ANON_KEY: usize = core::mem::offset_of!((&amp;'static str, Vec&lt;u8&gt;), 0);
const OFFSET_ANON_VAL: usize = core::mem::offset_of!((&amp;'static str, Vec&lt;u8&gt;), 1);</code></pre>
<p>Finally, <code>offset_of!</code> can be used to compute the offset of fields in unions too. While this may be surprising, the compiler is allowed to put padding in front of fields in unions which are not <code>#[repr(C)]</code>, which would lead to a non-zero field offset.</p>
<pre><code class="language-rs">use core::mem::offset_of;
union Buffer {
    metadata: [u64; 3],
    datadata: [u8; 1024 * 1024 * 32],
}
const METADATA_OFFSET: usize = offset_of!(Buffer, metadata);
</code></pre>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p>There are a few limitations worth mentioning. Some of these may be relaxed in the future, however.</p>
<ol>
<li>
<p>Perhaps unsurprisingly, it obeys privacy, so both the type and field you call <code>offset_of!</code> on must be visible to the code calling <code>offset_of!</code>.</p>
</li>
<li>
<p>The type holding the field must be <code>Sized</code>, so trying to compute where the slice begins in something like <code>offset_of!((i32, [u32]), 1)</code> isn’t supported.</p>
</li>
<li>
<p>Compared to <code>offsetof</code> in C and C++, you can’t access nested fields/arrays. That is, instead of <code>offset_of!(Foo, quank.zoop.2.quank[4])</code>, you’ll have to compute the offsets of each step manually, and sum them.</p>
</li>
<li>
<p>Finally, types other than tuples, structs, and unions are currently unsupported.</p>
</li>
</ol>
<h2 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h2>
<p><code>offset_of</code> is a new macro exported from <code>core::mem</code> which has a signature similar to the following:</p>
<pre><code class="language-rs">pub macro offset_of($Container:ty, $field:tt $(,)?) {
    // ...implementation defined...
}
</code></pre>
<p>Invoking this macro expands to a constant expression of type <code>usize</code>, which evaluates to the offset in bytes from the beginning of <code>$Container</code> where <code>$field</code> is found.</p>
<p><code>$Container</code> must be visible and must be or resolve to one of the following types:</p>
<ol>
<li>
<p>A <code>struct</code> or <code>union</code> type with either named or anonymous/tuple-style fields.</p>
<p>In this case, <code>$field</code> must share a name or tuple index with a field which:</p>
<ul>
<li>Exists on <code>$Container</code>.</li>
<li>Is visible at the location where <code>offset_of!</code> is invoked (but there is no requirement that fields other than <code>$field</code> be visible there)</li>
</ul>
</li>
<li>
<p>An anonymous tuple type.</p>
<p>In this case, <code>$field</code> must be a tuple index (that is, an integer literal) that exists on the tuple type in question.</p>
</li>
</ol>
<p>Use on other types is an error, although this may be relaxed in some cases in the future (see the <a href="#future-possibilities">Future possibilities</a> section).</p>
<p>As a note: the implementation is strongly encouraged to not have runtime resource usage dependent on the values of <code>$Container</code> or <code>$field</code>. In particular, the implementation should not allocate space for an instance of <code>$Container</code> on the runtime stack.</p>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<ol>
<li>
<p>This exposes layout information at compile time which is otherwise not exposed until runtime. This can cause compatibility hazards similar to <code>mem::size_of</code> or <code>mem::align_of</code>, but plausibly greater as it provides even more information.</p>
<p>That said, this API allows querying information which (if needed at compile time) would otherwise be hard-coded, so in some cases it may reduce the risk of a compatibility hazard.</p>
</li>
<li>
<p>Similarly, this reduces the amount of dynamism that a Rust implementation could use for <code>repr(Rust)</code> types.</p>
<p>For example, it forbids a Rust implementation from varying field offsets of <code>repr(Rust)</code> types between executions of the same compiled program (for example, by way of interpretation or code modification), unless it also performs modifications to adjust the result of <code>offset_of!</code> (and recompute the values of derived constants, and regenerate relevant code, …).</p>
</li>
<li>
<p>This is a feature most code won’t need to use, and it may be confusing to users unfamiliar with low level programming.</p>
</li>
</ol>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<p>The general rationale is that it should remove the need to hardcode, hand-roll, or pull in a third-party crate in order to compute field offsets. This hopefully should remove as many barriers</p>
<p>That said, there are several alternatives to this, some of which were even considered:</p>
<ol>
<li>
<p>Do nothing, and tell users to use the <a href="https://crates.io/crates/memoffset/0.6.5"><code>memoffset</code></a> crate, or to hard-code constant offsets.</p>
<p>This was not chosen as this operation seems fundamental enough to provided by the standard library, especially given how often it is incorrectly implemented in the wild.</p>
</li>
<li>
<p>Add <code>offset_of!</code>, but disallow use on <code>#[repr(Rust)]</code> types.</p>
<p>This would make <code>core::mem::offset_of!</code> have less functionality than the implementation from <code>memoffset</code>, or the implementation they could implement if they computed it manually.</p>
<p>Needing the offset of fields on <code>#[repr(Rust)]</code> is not as common, but still useful in code which needs to describe precise details of type layout to some other system, including GPU APIs which accept configurable vertex formats or binary serialization formats that contain descriptions of the field offsets for the record types they contain, etc.</p>
<p>It is also useful for implementing field projection as a library feature, as in cases like <a href="https://crates.io/crates/field-offset/0.3.4"><code>field-offset</code></a>.</p>
</li>
<li>
<p>Require that all fields of <code>$Container</code> be visible at the invocation site, rather than just requiring that <code>$field</code> is.</p>
<p>As above, this would make <code>core::mem::offset_of!</code> worse than the version they’d have written themselves and/or an off-the-shelf implementation.</p>
</li>
<li>
<p>Add <code>offset_of!</code>, but disallow use during constant evaluation.</p>
<p>This would mean that users which need const access to <code>offset_of!</code> must continue to hardcode the field offsets as constants, which is undesirable, error-prone, and can cause compatibility hazards.</p>
</li>
<li>
<p>Try to make <code>addr_of!((*null::&lt;$Container&gt;()).$field) as usize</code> work for this:</p>
<p>Currently this is UB (due to dereferencing a null pointer) and does not support use in const (due to accessing the address of a raw pointer). Changing both of these issues would be challenging, but may be possible.</p>
<p>This was not chosen because seems difficult, would be harder to teach (or read) than <code>core::mem::offset_of</code>, and is largely orthogonal to whether or not a dedicated field offset API is provided (in other words, fixing those issues seems unlikely to make <code>offset_of!</code> appear redundant).</p>
</li>
<li>
<p>Hold off until this can be integrated into some larger language feature, such as C++-style pointer-to-field, Swift-style field paths, …</p>
<p>Aside from avoiding scope creep, this wasn’t pursued as <code>offset_of!</code> does not prevent these in the future, and may not even be solved by them.</p>
</li>
<li>
<p>Use <code>offset_of!($Container::$field)</code> as the syntax instead.</p>
<p>This wasn’t chosen because it doesn’t really work with tuples, and seems like it may harm the quality of error messages (for example, if a user forgets <code>::$field</code>, and does <code>offset_of!(crate::path::to::SomeType)</code>).</p>
<p>Additionally, this does not generalize as well to some of the extensions in future work.</p>
</li>
<li>
<p>Expose a high level type-safe API instead, where <code>offset_of</code> returns a type with phantom parameters for container and field (for example, see the <a href="https://crates.io/crates/field-offset/0.3.4"><code>field-offset</code></a> crate, and the notes on it in the Prior Art section below):</p>
<p>This is not pursued for a few reasons:</p>
<ol>
<li>
<p>Field projection is just one of several use cases for getting the offset to a field, rather than the only one, or even the most common one. While the other uses could be supported by a function which returns the <code>usize</code>, it seems better to push this kind of thing into the ecosystem.</p>
</li>
<li>
<p>Add this to the stdlib risks conflicting with or restricting our ability to add a lang feature for field projection and/or pointer-to-member functionality.</p>
</li>
</ol>
<p>None of those are deal-breakers, but it seems better to keep this simple and limited. Such a type-safe API can be implemented on top of a <code>offset_of!</code> which returns integers.</p>
</li>
</ol>
<h2 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h2>
<p>There is quite a bit of prior art here, which I’ve grouped into:</p>
<ol>
<li>Crates: Rust libraries that expose similar or equivalent functionality to this proposal.</li>
<li>Languages: Other languages that provide access to this information either as a language builtin, or via a library.</li>
</ol>
<h3 id="prior-art-crates"><a class="header" href="#prior-art-crates">Prior Art: Crates</a></h3>
<p>Several crates in the ecosystem have <code>offset_of!</code> implementations. <a href="https://crates.io/crates/memoffset/0.6.5"><code>memoffset</code></a> and <a href="https://crates.io/crates/bytemuck/1.12.1"><code>bytemuck</code></a> are probably the two most popular, and provide this functionality in different ways.</p>
<ul>
<li>
<p>The <a href="https://crates.io/crates/memoffset/0.6.5"><code>memoffset</code></a> crate provides an <code>offset_of!</code> macro very similar to this proposal. It is a fairly straightforward implementation that avoids most pitfalls, although it does allocate an instance of the type on the stack, which can cause stack overflow during debug builds (the compiler removes this in release builds).</p>
<p>On nightly, if the <code>unstable_const</code> cargo feature is enabled, <code>memoffset::offset_of!</code> may be used during constant evaluation.</p>
</li>
<li>
<p>The <a href="https://crates.io/crates/bytemuck/1.12.1"><code>bytemuck</code></a> crate has an <a href="https://docs.rs/bytemuck/1.12.1/bytemuck/macro.offset_of.html"><code>offset_of!</code></a> implementation which differs from the one in <code>memoffset</code> in that it takes three arguments, where the first is an existing instance of the type (or, due to a quirk in how it is implemented, a reference to one).</p>
<p>This is intended to allow an implementation that does not require <code>unsafe</code> (as it was added in a time when it was unclear how to provide a sound <code>offset_of!</code>).</p>
<p>Somewhat interestingly, this first parameter may be used to avoid a large stack allocation by providing a reference to a const/static in this first parameter (for example as <code>bytemuck::offset_of!(&amp;SOME_STATIC, SomeTy,   field)</code>).</p>
<p>It does not support use during constant evaluation.</p>
</li>
<li>
<p>The <a href="https://crates.io/crates/field-offset/0.3.4"><code>field-offset</code></a> crate provides a higher level type-safe API for field offsets similar to the pointer-to-member functionality in C++. It uses <code>memoffset</code> to implement <code>offset_of!</code>.</p>
<p>Calling <code>field_offset::offset_of!</code> returns a <code>FieldOffset&lt;Field, Container&gt;</code> structure, which transparently wraps <code>usize</code> and while providing phantom annotations to ensure it is used with the correct container and field type. It uses this to provide some generic field projection functionality, mostly around <code>Pin</code>.</p>
</li>
</ul>
<h3 id="prior-art-languages"><a class="header" href="#prior-art-languages">Prior Art: Languages</a></h3>
<p>Many languages which support low level programming have some equivalent to this functionality.</p>
<ul>
<li>
<p>The C programming language supports this as an <a href="https://en.cppreference.com/w/c/types/offsetof"><code>offsetof</code></a> macro, for example: <code>offsetof(struct some_struct, some_field)</code> is morally equivalent to this proposal’s <code>offset_of!(SomeStruct, some_field)</code>. It produces a integer constant, so it can be used during C’s equivalent of constant evaluation.</p>
<p>Notably, C’s <code>offsetof</code> is more powerful than the <code>offset_of!</code> proposed in this RFC, as it supports access to fields of nested types, and even can project through arrays, for example <code>offsetof(some_type, foo.bar[1].baz)</code> is completely allowed.</p>
<p>Extending <code>core::mem::offset_of</code> to support some of these use-cases could be done in the future, as is discussed in the future possibilities section below.</p>
</li>
<li>
<p>C++ can an <a href="https://en.cppreference.com/w/cpp/types/offsetof"><code>offsetof</code></a> macro which is essentially compatible with C’s, although it is only “conditionally supported” to use it on types which are not “standard layout” (see the linked documentation for information on what the quoted text means).</p>
<p>C++ also has support for getting a pointer to a field via it’s pointer-to-member feature. This feature is powerful and while it replaces some uses of <code>offsetof</code>, it does not replace all of them</p>
</li>
<li>
<p>Zig supports this via the <a href="hhttps://ziglang.org/documentation/0.9.1/#offsetOf"><code>@offsetOf</code></a> function, which takes a <code>type</code> and <code>u8[]</code> that contains the field name as a string, for example <code>@offsetOf(SomeType, "some_field")</code> would be essentially equivalent to this proposal’s <code>core::mem::offset_of!(SomeType, some_field)</code>.</p>
<p>Zig also supports the <a href="https://ziglang.org/documentation/0.9.1/#bitOffsetOf"><code>@bitOffsetOf</code></a> function, as Zig allows structs to contain fields which are not byte-aligned (e.g. bitfields). The syntax and semantics are otherwise equivalent.</p>
<p>These are all <code>comptime</code> functions, which means they may be used in situations which are morally equivalent to Rust’s constant evaluation.</p>
</li>
<li>
<p>The D language allows accessing the offset via a property of each field. For example, <code>SomeType.some_field.offsetof</code> is essentially equivalent to this proposal’s <code>core::mem::offset_of!(SomeType, some_field)</code>.</p>
</li>
<li>
<p>Swift supports this via the <a href="https://github.com/apple/swift-evolution/blob/ec2028964daeda2600e49aa89fd9e59d2363433b/proposals/0210-key-path-offset.md"><code>MemoryLayout.offset(of:)</code></a> function (note: the link contains a good overview of the design). For example, <code>MemoryLayout&lt;SomeType&gt;.offset(of: \.some_field))</code> would be the equivalent to <code>core::mem::offset_of!(SomeType, some_field)</code>.</p>
<p>The <code>\.some_field</code> syntax is a partial key path (a Swift language feature). This can grant access to fields of nested structs in a manner similar to C’s <code>offsetof</code>, for example: <code>MemoryLayout&lt;SomeType&gt;.offset(of: \.foo.bar.baz)</code>.</p>
</li>
</ul>
<h2 id="未解決的問題"><a class="header" href="#未解決的問題">未解決的問題</a></h2>
<ol>
<li>Should any of the features listed as “Future possibilities” be supported initially?</li>
</ol>
<h2 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h2>
<p>This proposal is intentionally minimal, so there are a number of future possibilities.</p>
<h3 id="nested-field-access"><a class="header" href="#nested-field-access">Nested Field Access</a></h3>
<p>In C, expressions like <code>offsetof(struct some_struct, foo.bar.baz[3].quux)</code> are allowed, where <code>foo.bar.baz[3].quux</code> denotes a path to a derived field. This can be of somewhat arbitrary complexity, accessing fields of nested structs, performing array indexing (often this is used to access past the end of the array even), and so on. Similar functionality is offered by <code>MemoryLayout.offset</code> in Swift, where more complex language features are used to achieve it.</p>
<p>This was omitted from this proposal because it is not commonly used, and can generally be replaced (at the cost of convenience) by multiple invocations of the macro.</p>
<p>Additionally, in the future similar functionality could be added in a backwards-compatible way, either by directly allowing usage like <code>offset_of!(SomeStruct, foo.bar.baz[3].quux)</code>, or by requiring each field be comma-separated, as in <code>offset_of!(SomeStruct, foo, bar, baz, [3], quux)</code>.</p>
<p>Note that while this example shows a combination that supports array indexing, it’s unclear if this is actually desirable for Rust.</p>
<h3 id="enum-support-offset_ofsomeenumstructvariant-field_on_variant"><a class="header" href="#enum-support-offset_ofsomeenumstructvariant-field_on_variant">Enum support (<code>offset_of!(SomeEnum::StructVariant, field_on_variant)</code>)</a></h3>
<p>Eventually, it may be desirable to allow <code>offset_of!</code> to access the fields inside the struct and tuple variants of certain enums (possibly limited to enums with a primitive integer representation, such as <code>#[repr(C)]</code>, <code>#[repr(int)]</code>, or <code>#[repr(C, int)]</code> – where <code>int</code> is one of Rust’s primitive integer types — u8, isize, u128, etc).</p>
<p>For example, in the future something like the following could be allowed:</p>
<pre><code class="language-rs">use core::mem::offset_of;

#[repr(i8)]
enum Event {
    Key { pressed: bool, code: u32 },
    Resize(u32, u32),
}

const EVENT_KEY_CODE: usize = offset_of!(Event::Key, code);
const EVENT_KEY_PRESSED: usize = offset_of!(Event::Key, pressed);

const EVENT_RESIZE_W: usize = offset_of!(Event::Resize, 0);
const EVENT_RESIZE_H: usize = offset_of!(Event::Resize, 1);
</code></pre>
<p>In this example, the name/path of the variant is used as the first argument. While there are use-cases for this in low level FFI code (similar to the use cases for <code>#[repr(int)]</code> and <code>#[repr(C, int)]</code> enums), this may need further design work, and is left to the future.</p>
<p>A drawback is that it is unclear how to support these types in the “Nested Field Access” proposed above, so in the future should we decide to support one of these, a decision may need to be made about the other.</p>
<h3 id="memoffsetspan_of-functionality"><a class="header" href="#memoffsetspan_of-functionality"><code>memoffset::span_of!</code> Functionality</a></h3>
<p>The <code>memoffset</code> crate has support for a <a href="https://docs.rs/memoffset/0.6.5/memoffset/macro.span_of.html"><code>span_of!</code></a> macro (used like <code>memoffset::span_of!(SomeType, some_field)</code>), which expands to a <code>Range&lt;usize&gt;</code> indicating which bytes of <code>SomeType</code> are from the field <code>some_field</code>.</p>
<p>The use case for this is more limited than that of <code>offset_of!</code>, so it was omitted from this proposal. That said, should this prove sufficiently useful, it would be simple to add a similar macro to <code>core::mem</code> in the future.</p>
<h3 id="support-for-types-with-unsized-fields"><a class="header" href="#support-for-types-with-unsized-fields">Support for types with unsized fields</a></h3>
<h4 id="-via-offset_of_val"><a class="header" href="#-via-offset_of_val">… via <code>offset_of_val!</code></a></h4>
<p>Currently, we don’t support use with unsized types. That is, <code>(A, B, ... [T])</code> and/or <code>(A, B, ..., dyn Foo)</code>, or their equivalent in structs.</p>
<p>The reason for this is that the offset of the unsized field is not always known, such as in the case of the last field in <code>(Foo, dyn SomeTrait)</code>, where the offset depends on what the concrete type is. Notably, the compiler must read the alignment out of the vtable when you access such a field.</p>
<p>This is equivalent to not being able to determine the size and/or alignment of <code>?Sized</code> types, where we solve it by making the user provide the instance they’re interested in, as in <code>core::mem::{size_of_val, align_of_val}</code>, so we could provide an analogous <code>core::mem::offset_of_val!($val, $Type, $field)</code> to support this case.</p>
<p>It would be reasonable to add this in the future, but is left out for now.</p>
<h4 id="-by-only-forbidding-the-edge-case"><a class="header" href="#-by-only-forbidding-the-edge-case">… by only forbidding the edge case</a></h4>
<p>The only case where we currently do <em>not</em> know the offset of a field statically is when the user has requested the offset of the unsized field, and the unsized field is a trait object.</p>
<p>It’s possible for us to provide the offset of for:</p>
<ol>
<li>
<p>The fields before the unsized field, as in <code>offset_of!((i32, dyn Send), 0)</code>.</p>
</li>
<li>
<p>The unsized field itself if it is a type which whose offset is known without reading the metadata, such as <code>[T]</code>, <code>str</code>, and types that end with them, as in <code>offset_of!((i32, [u16]), 1)</code>, or <code>offset_of!((u16, (i64, str)), 2)</code>.</p>
</li>
</ol>
<p>Allowing these is somewhat inconsistent with <code>core::mem::align_of</code>, which could provide the alignment in some cases such as slices, but instead you must use <code>core::mem::align_of_val</code> for all <code>?Sized</code> types (admittedly, allowing <code>align_of::&lt;[T]&gt;()</code> is perhaps not very compelling, as it’s always the same as <code>align_of::&lt;T&gt;()</code>).</p>
<p>Either way, it’s trivially backwards compatible for us to eventually start allowing these, and for the trailing slice/str case, it seems difficult to pin down the cases where it’s allowed without risk of complicating potential future features (like custom DSTs, extern types, or whatever other new unsized types we might want to add).</p>
<p>As such, it’s left for future work.</p>
<h3 id="fields-in-traits"><a class="header" href="#fields-in-traits">Fields in Traits</a></h3>
<p>If support for fields in traits is ever added, then it would be an open question how <code>offset_of!</code> behaves when applied to a generic value of a trait type which has fields. Similarly, if an <code>offset_of_val!</code> is added, it would interact with trait objects of traits that have fields.</p>
<p>In either case, this could be forbidden or allowed, but decisions along these lines are deferred for now, as fields in traits do not yet exist.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="3307-de-rfc-type-ascription.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="3309-style-team.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="3307-de-rfc-type-ascription.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="3309-style-team.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
