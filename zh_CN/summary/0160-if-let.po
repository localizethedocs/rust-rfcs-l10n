msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:42Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0160-if-let.md:1
msgid "Start Date: 2014-08-26"
msgstr ""

#: src/0160-if-let.md:2
msgid ""
"RFC PR #: [rust-lang/rfcs#160](https://github.com/rust-lang/rfcs/pull/160)"
msgstr ""

#: src/0160-if-let.md:3
msgid ""
"Rust Issue #: [rust-lang/rust#16779](https://github.com/rust-lang/rust/"
"issues/16779)"
msgstr ""

#: src/0160-if-let.md:5
msgid "Summary"
msgstr ""

#: src/0160-if-let.md:7
msgid ""
"Introduce a new `if let PAT = EXPR { BODY }` construct. This allows for "
"refutable pattern matching without the syntactic and semantic overhead of a "
"full `match`, and without the corresponding extra rightward drift. "
"Informally this is known as an \"if-let statement\"."
msgstr ""

#: src/0160-if-let.md:11
msgid "Motivation"
msgstr ""

#: src/0160-if-let.md:13
msgid ""
"Many times in the past, people have proposed various mechanisms for doing a "
"refutable let-binding. None of them went anywhere, largely because the "
"syntax wasn't great, or because the suggestion introduced runtime failure if "
"the pattern match failed."
msgstr ""

#: src/0160-if-let.md:17
msgid ""
"This proposal ties the refutable pattern match to the pre-existing "
"conditional construct (i.e. `if` statement), which provides a clear and "
"intuitive explanation for why refutable patterns are allowed here (as "
"opposed to a `let` statement which disallows them) and how to behave if the "
"pattern doesn't match."
msgstr ""

#: src/0160-if-let.md:22
msgid ""
"The motivation for having any construct at all for this is to simplify the "
"cases that today call for a `match` statement with a single non-trivial "
"case. This is predominately used for unwrapping `Option<T>` values, but can "
"be used elsewhere."
msgstr ""

#: src/0160-if-let.md:26
msgid ""
"The idiomatic solution today for testing and unwrapping an `Option<T>` looks "
"like"
msgstr ""

#: src/0160-if-let.md:37
msgid ""
"This is unnecessarily verbose, with the `None => {}` (or `_ => {}`) case "
"being required, and introduces unnecessary rightward drift (this introduces "
"two levels of indentation where a normal conditional would introduce one)."
msgstr ""

#: src/0160-if-let.md:41
msgid "The alternative approach looks like this:"
msgstr ""

#: src/0160-if-let.md:50
msgid ""
"This is generally considered to be a less idiomatic solution than the "
"`match`. It has the benefit of fixing rightward drift, but it ends up "
"testing the value twice (which should be optimized away, but semantically "
"speaking still happens), with the second test being a method that "
"potentially introduces failure. From context, the failure won't happen, but "
"it still imposes a semantic burden on the reader. Finally, it requires "
"having a pre-existing let-binding for the optional value; if the value is a "
"temporary, then a new let-binding in the parent scope is required in order "
"to be able to test and unwrap in two separate expressions."
msgstr ""

#: src/0160-if-let.md:58
msgid ""
"The `if let` construct solves all of these problems, and looks like this:"
msgstr ""

#: src/0160-if-let.md:66
msgid "Detailed design"
msgstr ""

#: src/0160-if-let.md:68
msgid ""
"The `if let` construct is based on the precedent set by Swift, which "
"introduced its own `if let` statement. In Swift, `if let var = expr { ... }` "
"is directly tied to the notion of optional values, and unwraps the optional "
"value that `expr` evaluates to. In this proposal, the equivalent is `if let "
"Some(var) = expr { ... }`."
msgstr ""

#: src/0160-if-let.md:73
msgid "Given the following rough grammar for an `if` condition:"
msgstr ""

#: src/0160-if-let.md:81
msgid "The grammar is modified to add the following productions:"
msgstr ""

#: src/0160-if-let.md:87
msgid ""
"The `expression` is restricted to disallow a trailing braced block (e.g. for "
"struct literals) the same way the `expression` in the normal `if` statement "
"is, to avoid ambiguity with the then-block."
msgstr ""

#: src/0160-if-let.md:90
msgid ""
"Contrary to a `let` statement, the pattern in the `if let` expression allows "
"refutable patterns. The compiler should emit a warning for an `if let` "
"expression with an irrefutable pattern, with the suggestion that this should "
"be turned into a regular `let` statement."
msgstr ""

#: src/0160-if-let.md:94
msgid ""
"Like the `for` loop before it, this construct can be transformed in a syntax-"
"lowering pass into the equivalent `match` statement. The `expression` is "
"given to `match` and the `pattern` becomes a match arm. If there is an "
"`else` block, that becomes the body of the `_ => {}` arm, otherwise `_ => {}"
"` is provided."
msgstr ""

#: src/0160-if-let.md:99
msgid ""
"Optionally, one or more `else if` (not `else if let`) blocks can be placed "
"in the same `match` using pattern guards on `_`. This could be done to "
"simplify the code when pretty-printing the expansion result. Otherwise, this "
"is an unnecessary transformation."
msgstr ""

#: src/0160-if-let.md:103
msgid ""
"Due to some uncertainty regarding potentially-surprising fallout of AST "
"rewrites, and some worries about exhaustiveness-checking (e.g. a "
"tautological `if let` would be an error, which may be unexpected), this is "
"put behind a feature gate named `if_let`."
msgstr ""

#: src/0160-if-let.md:107
msgid "Examples"
msgstr ""

#: src/0160-if-let.md:109 src/0160-if-let.md:128 src/0160-if-let.md:151
msgid "Source:"
msgstr ""

#: src/0160-if-let.md:117 src/0160-if-let.md:138 src/0160-if-let.md:163
#: src/0160-if-let.md:192
msgid "Result:"
msgstr ""

#: src/0160-if-let.md:180
msgid "With the optional addition specified above:"
msgstr ""

#: src/0160-if-let.md:209
msgid "Drawbacks"
msgstr ""

#: src/0160-if-let.md:211
msgid "It's one more addition to the grammar."
msgstr ""

#: src/0160-if-let.md:213
msgid "Alternatives"
msgstr ""

#: src/0160-if-let.md:215
msgid ""
"This could plausibly be done with a macro, but the invoking syntax would be "
"pretty terrible and would largely negate the whole point of having this "
"sugar."
msgstr ""

#: src/0160-if-let.md:218
msgid ""
"Alternatively, this could not be done at all. We've been getting alone just "
"fine without it so far, but at the cost of making `Option` just a bit more "
"annoying to work with."
msgstr ""

#: src/0160-if-let.md:221
msgid "Unresolved questions"
msgstr ""

#: src/0160-if-let.md:223
msgid ""
"It's been suggested that alternates or pattern guards should be allowed. I "
"think if you need those you could just go ahead and use a `match`, and that "
"`if let` could be extended to support those in the future if a compelling "
"use-case is found."
msgstr ""

#: src/0160-if-let.md:227
msgid ""
"I don't know how many `match` statements in our current code base could be "
"replaced with this syntax. Probably quite a few, but it would be informative "
"to have real data on this."
msgstr ""
