msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:44Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2359-subslice-pattern-syntax.md:1
msgid "Feature Name: `slice_patterns`"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:2
msgid "Start Date: 2018-03-08"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2359](https://github.com/rust-lang/rfcs/pull/2359)"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:4
msgid ""
"Rust Issue: [rust-lang/rust#62254](https://github.com/rust-lang/rust/"
"issues/62254)"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:6
msgid "Summary"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:9
msgid ""
"Permit matching sub-slices and sub-arrays with the syntax `..`.  \n"
"Binding a variable to the expression matched by a subslice pattern can be "
"done using syntax `<IDENT> @ ..` similar to the existing `<IDENT> @ <PAT>` "
"syntax, for example:"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:14
msgid "// Binding a sub-array:\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:15
msgid "// `y: [i32, 2] = [2, 3]`\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:16
msgid "// Binding a sub-slice:\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:18
msgid "// `y: &[i32] = &[2, 3]`\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:21
msgid "Motivation"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:24
msgid "General motivation"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:25
msgid ""
"Stabilization of slice pattern with subslices is currently blocked on "
"finalizing syntax for these subslices.  \n"
"This RFC proposes a syntax for stabilization."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:29
msgid "Motivation for the specific syntax"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:31
msgid "The shortcut form: `..`"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:33
msgid ""
"This form is already used in the meaning \"rest of the list\" in struct "
"patterns, tuple struct patterns and tuple patterns so it would be logical to "
"use it for slice patterns as well.  \n"
"And indeed, in unstable Rust `..` is used in this meaning since long before "
"1.0."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:37
msgid "Guide-level explanation"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:40
msgid ""
"Sub-slices and sub-arrays can be matched using `..` and `<IDENT> @ ..` can "
"be used to bind these sub-slices and sub-arrays to an identifier."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:44
msgid "// Matching slices using `ref` and `ref mut`patterns:\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:47
#: src/2359-subslice-pattern-syntax.md:48
#: src/2359-subslice-pattern-syntax.md:49
#: src/2359-subslice-pattern-syntax.md:64
#: src/2359-subslice-pattern-syntax.md:65
#: src/2359-subslice-pattern-syntax.md:66
msgid "// typeof(subslice) == &[i32]\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:51
#: src/2359-subslice-pattern-syntax.md:58
#: src/2359-subslice-pattern-syntax.md:68
#: src/2359-subslice-pattern-syntax.md:75
msgid "// Always matches\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:54
#: src/2359-subslice-pattern-syntax.md:55
#: src/2359-subslice-pattern-syntax.md:56
#: src/2359-subslice-pattern-syntax.md:71
#: src/2359-subslice-pattern-syntax.md:72
#: src/2359-subslice-pattern-syntax.md:73
msgid "// typeof(subslice) == &mut [i32]\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:60
msgid "// Matching slices using default-binding-modes:\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:77
msgid "// Matching slices by value (error):\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:81
msgid "// ERROR cannot move out of type `[i32]`, a non-copy slice\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:83
msgid ""
"// Matching arrays by-value and by reference (explicitly or using default-"
"binding-modes):\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:87
msgid "// typeof(subarray) == [i32; 1]\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:88
#: src/2359-subslice-pattern-syntax.md:89
msgid "// typeof(subarray) == [i32; 2]\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:94
msgid "// typeof(subarray) == &[i32; 1]\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:95
#: src/2359-subslice-pattern-syntax.md:96
msgid "// typeof(subarray) == &[i32; 2]\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:101
msgid "// typeof(subarray) == &mut [i32; 1]\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:102
#: src/2359-subslice-pattern-syntax.md:103
msgid "// typeof(subarray) == &mut [i32; 2]\n"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:109
msgid "Reference-level explanation"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:112
msgid ""
"`..` can be used as a pattern fragment for matching sub-slices and sub-"
"arrays."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:114
msgid "The fragment's syntax is:"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:120
msgid ""
"The subslice fragment incorporates into the full subslice syntax in the same "
"way as the `..` fragment incorporates into the stable tuple pattern syntax "
"(with regards to allowed number of subslices, trailing commas, etc)."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:124
msgid "`@` can be used to bind the result of `..` to an identifier."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:126
msgid ""
"`..` is treated as a \"non-reference-pattern\" for the purpose of "
"determining default-binding-modes, and so shifts the binding mode to by-"
"`ref` or by-`ref mut` when used to match a subsection of a reference or "
"mutable reference to a slice or array."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:130
msgid ""
"When used to match against a non-reference slice (`[u8]`), `x @ ..` would "
"attempt to bind by-value, which would fail due a move from a non-copy type "
"`[u8]`."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:133
msgid ""
"`..` is not a full pattern syntax, but rather a part of slice, tuple and "
"tuple struct pattern syntaxes. In particular, `..` is not accepted by the "
"`pat` macro matcher. `BINDING @ ..` is also not a full pattern syntax, but "
"rather a part of slice pattern syntax, so it is not accepted by the `pat` "
"macro matcher either."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:138
msgid "Drawbacks"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:141
#: src/2359-subslice-pattern-syntax.md:248
msgid "None known."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:143
msgid "Rationale and alternatives"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:146
msgid ""
"More complex syntaxes derived from `..` are possible, they use additional "
"tokens to avoid the ambiguity with ranges, for example [`..PAT..`](https://"
"github.com/rust-lang/rust/issues/23121#issuecomment-301485132), or [`.. @ "
"PAT`](https://github.com/rust-lang/rust/issues/23121#issuecomment-280920062) "
"or [`PAT @ ..`](https://github.com/rust-lang/rust/"
"issues/23121#issuecomment-280906823), or other similar alternatives.  \n"
"We reject these syntaxes because they only bring benefits in contrived cases "
"using a feature that doesn't even exist yet, but normally they only add "
"symbolic noise."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:155
msgid ""
"More radical syntax changes do not keep consistency with `..`, for example "
"[`[1, 2, 3, 4] ++ ref v`](https://github.com/rust-lang/rust/"
"issues/23121#issuecomment-289220169)."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:158
msgid "`..PAT` or `PAT..`"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:160
msgid ""
"If `..` is used in the meaning \"match the subslice (`>=0` elements) and "
"ignore it\", then it's reasonable to expect that syntax for \"match the "
"subslice to a pattern\" should be some variation on `..`.  \n"
"The two simplest variations are `..PAT` and `PAT..`."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:165
msgid "Ambiguity"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:167
msgid ""
"The issue is that these syntaxes are ambiguous with half-bounded ranges `.."
"END` and `BEGIN..`, and the full range `..`.  \n"
"To be precise, such ranges are not currently supported in patterns, but they "
"may be supported in the future."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:172
msgid ""
"Syntactic ambiguity is not inherently bad. We see it every day in "
"expressions like `a + b * c`. What is important is to disambiguate it "
"reasonably by default and have a way to group operands in the alternative "
"way when default disambiguation turns out to be incorrect.  \n"
"In case of slice patterns the subslice interpretation seems more likely, so "
"we can take it as a default.  \n"
"There was very little demand for implementing half-bounded ranges in "
"patterns so far (see https://github.com/rust-lang/rfcs/issues/947), but if "
"they are implemented in the future they will be able to be used in slice "
"patterns as well, but they could require explicit grouping with recently "
"implemented [parentheses in patterns](https://github.com/rust-lang/rust/"
"pull/48500) (`[a, (..end)]`) or an explicitly written start boundary (`[a, "
"0 .. end]`).  \n"
"We can also make _some_ disambiguation effort and, for example, interpret `.."
"LITERAL` as a range because `LITERAL` can never match a subslice. Time will "
"show if such an effort is necessary or not."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:187
msgid ""
"If/when half-bounded ranges are supported in patterns, for better future "
"compatibility we could decide to reserve `..PAT` as \"rest of the list\" in "
"tuples and tuple structs as well, and avoid interpreting it as a range "
"pattern in those positions."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:191
msgid ""
"Note that ambiguity with unbounded ranges as they are used in expressions "
"(`..`) already exists in variant `Variant(..)` and tuple `(a, b, ..)` "
"patterns, but it's unlikely that the `..` syntax will ever be used in "
"patterns in the range meaning because it duplicates functionality of the "
"wildcard pattern `_`."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:196
msgid "`..PAT` vs `PAT..`"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:198
msgid ""
"Originally Rust used syntax `..PAT` for subslice patterns.  \n"
"In 2014 the syntax was changed to `PAT..` by [RFC 202](https://github.com/"
"rust-lang/rfcs/pull/202). That RFC received almost no discussion before it "
"got merged and its motivation is no longer relevant because arrays now use "
"syntax `[T; N]` instead of `[T, ..N]` used in old Rust."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:203
msgid ""
"This RFC originally proposed to switch back to `..PAT`. Some reasons to "
"switch were:"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:205
msgid ""
"Symmetry with expressions.  \n"
"One of the general ideas behind patterns is that destructuring with patterns "
"has the same syntax as construction with expressions, if possible.  \n"
"In expressions we already have something with the meaning \"rest of the "
"list\" - functional record update in struct expressions `S { field1, "
"field2, ..remaining_fields }`. Right now we can use `S { field1, field1, .. }"
"` in a pattern, but can't bind the remaining fields as a whole (by creating "
"a new struct type on the fly, for example). It's not inconceivable that in "
"Rust 2030 we have such ability and it's reasonable to expect it using syntax "
"`..remaining_fields` symmetric to expressions. It would be good for slice "
"patterns to be consistent with it.  \n"
"Without speculations, even if `..remaining_fields` in struct expressions and "
"`..subslice` in slice patterns are not entirely the same thing, they are "
"similar enough to keep them symmetric already."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:216
msgid ""
"Simple disambiguation.  \n"
"When we are parsing a slice pattern and see `..` we immediately know it's a "
"subslice and can parse following tokens as a pattern (unless they are `,` or "
"`]`, then it's just `..`, without an attached pattern).  \n"
"With `PAT..` we need to consume the pattern first, but that pattern may be "
"a... `RANGE_BEGIN..` range pattern, then it means that we consumed too much "
"and need to reinterpret the parsed tokens somehow. It's probably possible to "
"make this work, but it's some headache that we would like to avoid if "
"possible."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:225
msgid ""
"This RFC no longer includes the addition of `..PAT` or `PAT..`. The "
"currently-proposed change is a minimal addition to patterns (`..` for "
"slices) which already exists in other forms (e.g. tuples) and generalizes "
"well to pattern-matching out sub-tuples, e.g. `let (a, b @ .., c) = (1, 2, "
"3, 4);`."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:230
msgid ""
"Additionally, `@` is more consistent with the types of patterns that would "
"be allowable for matching slices (only identifiers), whereas `PAT..`/`..PAT` "
"suggest the ability to write e.g. `..(1, x)` or `..SomeStruct { x }` sub-"
"patterns, which wouldn't be possible since the resulting bound variables "
"don't form a slice (since they're spread out in memory)."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:235
msgid "Prior art"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:238
msgid ""
"Some other languages like Haskell (`first_elem : rest_of_the_list`), Scala, "
"or F# (`first_elem :: rest_of_the_list`) has list/array patterns, but their "
"syntactic choices are quite different from Rust's general style."
msgstr ""

#: src/2359-subslice-pattern-syntax.md:242
msgid ""
"\"Rest of the list\" in patterns was previously discussed in [RFC 1492]"
"(https://github.com/rust-lang/rfcs/pull/1492)"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:245
msgid "Unresolved questions"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:250
msgid "Future possibilities"
msgstr ""

#: src/2359-subslice-pattern-syntax.md:253
msgid ""
"Turn `..` into a full pattern syntactically accepted in any pattern "
"position, (including `pat` matchers in macros), but rejected semantically "
"outside of slice and tuple patterns."
msgstr ""
