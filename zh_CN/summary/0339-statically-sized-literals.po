msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:42Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0339-statically-sized-literals.md:1
msgid "Start Date: 2014-09-29"
msgstr ""

#: src/0339-statically-sized-literals.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#339](https://github.com/rust-lang/rfcs/pull/339)"
msgstr ""

#: src/0339-statically-sized-literals.md:3
msgid ""
"Rust Issue: [rust-lang/rust#18465](https://github.com/rust-lang/rust/"
"issues/18465)"
msgstr ""

#: src/0339-statically-sized-literals.md:5
msgid "Summary"
msgstr ""

#: src/0339-statically-sized-literals.md:7
msgid ""
"Change the types of byte string literals to be references to statically "
"sized types. Ensure the same change can be performed backward compatibly for "
"string literals in the future."
msgstr ""

#: src/0339-statically-sized-literals.md:10
msgid "Motivation"
msgstr ""

#: src/0339-statically-sized-literals.md:12
msgid ""
"Currently byte string and string literals have types `&'static [u8]` and "
"`&'static str`. Therefore, although the sizes of the literals are known at "
"compile time, they are erased from their types and inaccessible until "
"runtime. This RFC suggests to change the type of byte string literals to "
"`&'static [u8, ..N]`. In addition this RFC suggest not to introduce any "
"changes to `str` or string literals, that would prevent a backward "
"compatible addition of strings of fixed size `FixedString<N>` (the name "
"FixedString in this RFC is a placeholder and is open for bikeshedding) and "
"the change of the type of string literals to `&'static FixedString<N>` in "
"the future."
msgstr ""

#: src/0339-statically-sized-literals.md:17
msgid ""
"`FixedString<N>` is essentially a `[u8, ..N]` with UTF-8 invariants and "
"additional string methods/traits. It fills the gap in the vector/string "
"chart:"
msgstr ""

#: src/0339-statically-sized-literals.md:20
msgid "`Vec<T>`"
msgstr ""

#: src/0339-statically-sized-literals.md:20
msgid "`String`"
msgstr ""

#: src/0339-statically-sized-literals.md:22
msgid "`[T, ..N]`"
msgstr ""

#: src/0339-statically-sized-literals.md:22
msgid "???"
msgstr ""

#: src/0339-statically-sized-literals.md:23
msgid "`&[T]`"
msgstr ""

#: src/0339-statically-sized-literals.md:23
msgid "`&str`"
msgstr ""

#: src/0339-statically-sized-literals.md:25
msgid ""
"Today, given the lack of non-type generic parameters and compile time "
"(function) evaluation (CTE), strings of fixed size are not very useful. But "
"after introduction of CTE the need in compile time string operations will "
"raise rapidly. Even without CTE but with non-type generic parameters alone "
"fixed size strings can be used in runtime for \"heapless\" string "
"operations, which are useful in constrained environments or for "
"optimization. So the main motivation for changes today is forward "
"compatibility."
msgstr ""

#: src/0339-statically-sized-literals.md:29
msgid ""
"Examples of use for new literals, that are not possible with old literals:"
msgstr ""

#: src/0339-statically-sized-literals.md:31
msgid ""
"```\n"
"// Today: initialize mutable array with byte string literal\n"
"let mut arr: [u8, ..3] = *b\"abc\";\n"
"arr[0] = b'd';\n"
"\n"
"// Future with CTE: compile time string concatenation\n"
"static LANG_DIR: FixedString<5 /*The size should, probably, be inferred*/> = "
"*\"lang/\";\n"
"static EN_FILE: FixedString<_> = LANG_DIR + *\"en\"; // FixedString<N> "
"implements Add\n"
"static FR_FILE: FixedString<_> = LANG_DIR + *\"fr\";\n"
"\n"
"// Future without CTE: runtime \"heapless\" string concatenation\n"
"let DE_FILE = LANG_DIR + *\"de\"; // Performed at runtime if not optimized\n"
"```"
msgstr ""

#: src/0339-statically-sized-literals.md:45
msgid "Detailed design"
msgstr ""

#: src/0339-statically-sized-literals.md:47
msgid ""
"Change the type of byte string literals from `&'static [u8]` to `&'static "
"[u8, ..N]`. Leave the door open for a backward compatible change of the type "
"of string literals from `&'static str` to `&'static FixedString<N>`."
msgstr ""

#: src/0339-statically-sized-literals.md:50
msgid "Strings of fixed size"
msgstr ""

#: src/0339-statically-sized-literals.md:52
msgid ""
"If `str` is moved to the library today, then strings of fixed size can be "
"implemented like this:"
msgstr ""

#: src/0339-statically-sized-literals.md:56
msgid "Then string literals will have types `&'static str<[u8, ..N]>`."
msgstr ""

#: src/0339-statically-sized-literals.md:58
msgid ""
"Drawbacks of this approach include unnecessary exposition of the "
"implementation - underlying sized or unsized arrays `[u8]`/`[u8, ..N]` and "
"generic parameter `T`. The key requirement here is the autocoercion from "
"reference to fixed string to string slice an we are unable to meet it now "
"without exposing the implementation."
msgstr ""

#: src/0339-statically-sized-literals.md:61
msgid ""
"In the future, after gaining the ability to parameterize on integers, "
"strings of fixed size could be implemented in a better way:"
msgstr ""

#: src/0339-statically-sized-literals.md:62
msgid ""
"```\n"
"struct __StrImpl<Sized? T>(T); // private\n"
"\n"
"pub type str = __StrImpl<[u8]>; // unsized referent of string slice `&str`, "
"public\n"
"pub type FixedString<const N: uint> = __StrImpl<[u8, ..N]>; // string of "
"fixed size, public\n"
"\n"
"// &FixedString<N> -> &str : OK, including &'static FixedString<N> -> "
"&'static str for string literals\n"
"```"
msgstr ""

#: src/0339-statically-sized-literals.md:70
msgid ""
"So, we don't propose to make these changes today and suggest to wait until "
"generic parameterization on integers is added to the language."
msgstr ""

#: src/0339-statically-sized-literals.md:72
msgid "Precedents"
msgstr ""

#: src/0339-statically-sized-literals.md:74
msgid ""
"C and C++ string literals are lvalue `char` arrays of fixed size with static "
"duration. C++ library proposal for strings of fixed size ([link](http://www."
"open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4121.pdf)), the paper also "
"contains some discussion and motivation."
msgstr ""

#: src/0339-statically-sized-literals.md:77
msgid "Rejected alternatives and discussion"
msgstr ""

#: src/0339-statically-sized-literals.md:79
msgid "Array literals"
msgstr ""

#: src/0339-statically-sized-literals.md:81
msgid ""
"The types of array literals potentially can be changed from `[T, ..N]` to "
"`&'a [T, ..N]` for consistency with the other literals and ergonomics. The "
"major blocker for this change is the inability to move out from a "
"dereferenced array literal if `T` is not `Copy`."
msgstr ""

#: src/0339-statically-sized-literals.md:83
msgid ""
"```\n"
"let mut a = *[box 1i, box 2, box 3]; // Wouldn't work without special-casing "
"of array literals with regard to moving out from dereferenced borrowed "
"pointer\n"
"```"
msgstr ""

#: src/0339-statically-sized-literals.md:86
msgid ""
"Despite that array literals as references have better usability, possible "
"`static`ness and consistency with other literals."
msgstr ""

#: src/0339-statically-sized-literals.md:88
msgid "Usage statistics for array literals"
msgstr ""

#: src/0339-statically-sized-literals.md:90
msgid ""
"Array literals can be used both as slices, when a view to array is "
"sufficient to perform the task, and as values when arrays themselves should "
"be copied or modified. The exact estimation of the frequencies of both uses "
"is problematic, but some regex search in the Rust codebase gives the next "
"statistics: In approximately _70%_ of cases array literals are used as "
"slices (explicit `&` on array literals, immutable bindings). In "
"approximately _20%_ of cases array literals are used as values "
"(initialization of struct fields, mutable bindings,   boxes). In the rest "
"_10%_ of cases the usage is unclear."
msgstr ""

#: src/0339-statically-sized-literals.md:96
msgid ""
"So, in most cases the change to the types of array literals will lead to "
"shorter notation."
msgstr ""

#: src/0339-statically-sized-literals.md:98
msgid "Static lifetime"
msgstr ""

#: src/0339-statically-sized-literals.md:100
msgid ""
"Although all the literals under consideration are similar and are "
"essentially arrays of fixed size, array literals are different from byte "
"string and string literals with regard to lifetimes. While byte string and "
"string literals can always be placed into static memory and have static "
"lifetime, array literals can depend on local variables and can't have static "
"lifetime in general case. The chosen design potentially allows to trivially "
"enhance _some_ array literals with static lifetime in the future to allow "
"use like"
msgstr ""

#: src/0339-statically-sized-literals.md:109
msgid "Alternatives"
msgstr ""

#: src/0339-statically-sized-literals.md:111
msgid ""
"The alternative design is to make the literals the values and not the "
"references."
msgstr ""

#: src/0339-statically-sized-literals.md:113
msgid "The changes"
msgstr ""

#: src/0339-statically-sized-literals.md:116
msgid ""
"Keep the types of array literals as `[T, ..N]`. Change the types of byte "
"literals from `&'static [u8]` to `[u8, ..N]`. Change the types of string "
"literals form `&'static str` to `FixedString<N>`. 2) Introduce the missing "
"family of types - strings of fixed size - `FixedString<N>`. ... 3) Add the "
"autocoercion of array _literals_ (not arrays of fixed size in general) to "
"slices. Add the autocoercion of new byte literals to slices. Add the "
"autocoercion of new string literals to slices. Non-literal arrays and "
"strings do not autocoerce to slices, in accordance with the general "
"agreements on explicitness. 4) Make string and byte literals lvalues with "
"static lifetime."
msgstr ""

#: src/0339-statically-sized-literals.md:130
msgid "Examples of use:"
msgstr ""

#: src/0339-statically-sized-literals.md:131
msgid ""
"```\n"
"// Today: initialize mutable array with literal\n"
"let mut arr: [u8, ..3] = b\"abc\";\n"
"arr[0] = b'd';\n"
"\n"
"// Future with CTE: compile time string concatenation\n"
"static LANG_DIR: FixedString<_> = \"lang/\";\n"
"static EN_FILE: FixedString<_> = LANG_DIR + \"en\"; // FixedString<N> "
"implements Add\n"
"static FR_FILE: FixedString<_> = LANG_DIR + \"fr\";\n"
"\n"
"// Future without CTE: runtime \"heapless\" string concatenation\n"
"let DE_FILE = LANG_DIR + \"de\"; // Performed at runtime if not optimized\n"
"```"
msgstr ""

#: src/0339-statically-sized-literals.md:145
msgid "Drawbacks of the alternative design"
msgstr ""

#: src/0339-statically-sized-literals.md:147
msgid ""
"Special rules about (byte) string literals being static lvalues add a bit of "
"unnecessary complexity to the specification."
msgstr ""

#: src/0339-statically-sized-literals.md:149
msgid ""
"In theory `let s = \"abcd\";` copies the string from static memory to stack, "
"but the copy is unobservable an can, probably, be elided in most cases."
msgstr ""

#: src/0339-statically-sized-literals.md:151
msgid ""
"The set of additional autocoercions has to exist for ergonomic purpose (and "
"for backward compatibility). Writing something like:"
msgstr ""

#: src/0339-statically-sized-literals.md:153
msgid ""
"```\n"
"fn f(arg: &str) {}\n"
"f(\"Hello\"[]);\n"
"f(&\"Hello\");\n"
"```"
msgstr ""

#: src/0339-statically-sized-literals.md:158
msgid "for all literals would be just unacceptable."
msgstr ""

#: src/0339-statically-sized-literals.md:160
msgid "Minor breakage:"
msgstr ""

#: src/0339-statically-sized-literals.md:161
msgid ""
"```\n"
"fn main() {\n"
"    let s = \"Hello\";\n"
"    fn f(arg: &str) {}\n"
"    f(s); // Will require explicit slicing f(s[]) or implicit DST coercion "
"from reference f(&s)\n"
"}\n"
"```"
msgstr ""

#: src/0339-statically-sized-literals.md:169
msgid "Status quo"
msgstr ""

#: src/0339-statically-sized-literals.md:171
msgid ""
"Status quo (or partial application of the changes) is always an alternative."
msgstr ""

#: src/0339-statically-sized-literals.md:173
msgid "Drawbacks of status quo"
msgstr ""

#: src/0339-statically-sized-literals.md:175
msgid "Examples:"
msgstr ""

#: src/0339-statically-sized-literals.md:176
msgid ""
"```\n"
"// Today: can't use byte string literals in some cases\n"
"let mut arr: [u8, ..3] = [b'a', b'b', b'c']; // Have to use array literals\n"
"arr[0] = b'd';\n"
"\n"
"// Future: FixedString<N> is added, CTE is added, but the literal types "
"remain old\n"
"let mut arr: [u8, ..3] = b\"abc\".to_fixed(); // Have to use a conversion "
"method\n"
"arr[0] = b'd';\n"
"\n"
"static LANG_DIR: FixedString<_> = \"lang/\".to_fixed(); // Have to use a "
"conversion method\n"
"static EN_FILE: FixedString<_> = LANG_DIR + \"en\".to_fixed();\n"
"static FR_FILE: FixedString<_> = LANG_DIR + \"fr\".to_fixed();\n"
"\n"
"// Bad future: FixedString<N> is not added\n"
"// \"Heapless\"/compile-time string operations aren't possible, or performed "
"with \"magic\" like extended concat! or recursive macros.\n"
"```"
msgstr ""

#: src/0339-statically-sized-literals.md:192
msgid ""
"Note, that in the \"Future\" scenario the return _type_ of `to_fixed` "
"depends on the _value_ of `self`, so it requires sufficiently advanced CTE, "
"for example C++14 with its powerful `constexpr` machinery still doesn't "
"allow to write such a function."
msgstr ""

#: src/0339-statically-sized-literals.md:194
msgid "Drawbacks"
msgstr ""

#: src/0339-statically-sized-literals.md:196
#: src/0339-statically-sized-literals.md:200
msgid "None."
msgstr ""

#: src/0339-statically-sized-literals.md:198
msgid "Unresolved questions"
msgstr ""
