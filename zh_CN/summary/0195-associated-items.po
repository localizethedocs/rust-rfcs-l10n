msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:42Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0195-associated-items.md:1
msgid "Start Date: 2014-08-04"
msgstr ""

#: src/0195-associated-items.md:2
msgid ""
"RFC PR #: [rust-lang/rfcs#195](https://github.com/rust-lang/rfcs/pull/195)"
msgstr ""

#: src/0195-associated-items.md:3
msgid ""
"Rust Issue #: [rust-lang/rust#17307](https://github.com/rust-lang/rust/"
"issues/17307)"
msgstr ""

#: src/0195-associated-items.md:5
msgid "Summary"
msgstr ""

#: src/0195-associated-items.md:7
msgid ""
"This RFC extends traits with _associated items_, which make generic "
"programming more convenient, scalable, and powerful. In particular, traits "
"will consist of a set of methods, together with:"
msgstr ""

#: src/0195-associated-items.md:11
msgid "Associated functions (already present as \"static\" functions)"
msgstr ""

#: src/0195-associated-items.md:12
msgid "Associated consts"
msgstr ""

#: src/0195-associated-items.md:13
msgid "Associated types"
msgstr ""

#: src/0195-associated-items.md:14
msgid "Associated lifetimes"
msgstr ""

#: src/0195-associated-items.md:16
msgid ""
"These additions make it much easier to group together a set of related "
"types, functions, and constants into a single package."
msgstr ""

#: src/0195-associated-items.md:19
msgid ""
"This RFC also provides a mechanism for _multidispatch_ traits, where the "
"`impl` is selected based on multiple types. The connection to associated "
"items will become clear in the detailed text below."
msgstr ""

#: src/0195-associated-items.md:23
msgid ""
"_Note: This RFC was originally accepted before RFC 246 introduced the "
"distinction between const and static items. The text has been updated to "
"clarify that associated consts will be added rather than statics, and to "
"provide a summary of restrictions on the initial implementation of "
"associated consts. Other than that modification, the proposal has not been "
"changed to reflect newer Rust features or syntax._"
msgstr ""

#: src/0195-associated-items.md:30
msgid "Motivation"
msgstr ""

#: src/0195-associated-items.md:32
msgid ""
"A typical example where associated items are helpful is data structures like "
"graphs, which involve at least three types: nodes, edges, and the graph "
"itself."
msgstr ""

#: src/0195-associated-items.md:35
msgid ""
"In today's Rust, to capture graphs as a generic trait, you have to take the "
"additional types associated with a graph as _parameters_:"
msgstr ""

#: src/0195-associated-items.md:45
msgid ""
"The fact that the node and edge types are parameters is confusing, since any "
"concrete graph type is associated with a _unique_ node and edge type. It is "
"also inconvenient, because code working with generic graphs is likewise "
"forced to parameterize, even when not all of the types are relevant:"
msgstr ""

#: src/0195-associated-items.md:54
msgid ""
"With associated types, the graph trait can instead make clear that the node "
"and edge types are determined by any `impl`:"
msgstr ""

#: src/0195-associated-items.md:65
msgid ""
"and clients can abstract over them all at once, referring to them through "
"the graph type:"
msgstr ""

#: src/0195-associated-items.md:72
msgid ""
"The following subsections expand on the above benefits of associated items, "
"as well as some others."
msgstr ""

#: src/0195-associated-items.md:75
msgid "Associated types: engineering benefits for generics"
msgstr ""

#: src/0195-associated-items.md:77
msgid ""
"As the graph example above illustrates, associated _types_ do not increase "
"the expressiveness of traits _per se_, because you can always use extra type "
"parameters to a trait instead. However, associated types provide several "
"engineering benefits:"
msgstr ""

#: src/0195-associated-items.md:82
msgid "**Readability and scalability**"
msgstr ""

#: src/0195-associated-items.md:84
msgid ""
"Associated types make it possible to abstract over a whole family of types "
"at once, without having to separately name each of them. This improves the "
"readability of generic code (like the `distance` function above).  It also "
"makes generics more \"scalable\": traits can incorporate additional "
"associated types without imposing an extra burden on clients that don't care "
"about those types."
msgstr ""

#: src/0195-associated-items.md:91
msgid ""
"In today's Rust, by contrast, adding additional generic parameters to a "
"trait often feels like a very \"heavyweight\" move."
msgstr ""

#: src/0195-associated-items.md:94
msgid "**Ease of refactoring/evolution**"
msgstr ""

#: src/0195-associated-items.md:96
msgid ""
"Because users of a trait do not have to separately parameterize over its "
"associated types, new associated types can be added without breaking all "
"existing client code."
msgstr ""

#: src/0195-associated-items.md:100
msgid ""
"In today's Rust, by contrast, associated types can only be added by adding "
"more type parameters to a trait, which breaks all code mentioning the trait."
msgstr ""

#: src/0195-associated-items.md:103
msgid "Clearer trait matching"
msgstr ""

#: src/0195-associated-items.md:105
msgid "Type parameters to traits can either be \"inputs\" or \"outputs\":"
msgstr ""

#: src/0195-associated-items.md:107
msgid ""
"**Inputs**. An \"input\" type parameter is used to _determine_ which `impl` "
"to use."
msgstr ""

#: src/0195-associated-items.md:110
msgid ""
"**Outputs**. An \"output\" type parameter is uniquely determined _by_ the "
"`impl`, but plays no role in selecting the `impl`."
msgstr ""

#: src/0195-associated-items.md:113
msgid ""
"Input and output types play an important role for type inference and trait "
"coherence rules, which is described in more detail later on."
msgstr ""

#: src/0195-associated-items.md:116
msgid ""
"In the vast majority of current libraries, the only input type is the `Self` "
"type implementing the trait, and all other trait type parameters are "
"outputs. For example, the trait `Iterator<A>` takes a type parameter `A` for "
"the elements being iterated over, but this type is always determined by the "
"concrete `Self` type (e.g. `Items<u8>`) implementing the trait: `A` is "
"typically an output."
msgstr ""

#: src/0195-associated-items.md:122
msgid ""
"Additional input type parameters are useful for cases like binary operators, "
"where you may want the `impl` to depend on the types of _both_ arguments. "
"For example, you might want a trait"
msgstr ""

#: src/0195-associated-items.md:132
msgid ""
"to view the `Self` and `Rhs` types as inputs, and the `Sum` type as an "
"output (since it is uniquely determined by the argument types). This would "
"allow `impl`s to vary depending on the `Rhs` type, even though the `Self` "
"type is the same:"
msgstr ""

#: src/0195-associated-items.md:141
msgid ""
"Today's Rust does not make a clear distinction between input and output type "
"parameters to traits. If you attempted to provide the two `impl`s above, you "
"would receive an error like:"
msgstr ""

#: src/0195-associated-items.md:149
msgid "This RFC clarifies trait matching by:"
msgstr ""

#: src/0195-associated-items.md:151
msgid "Treating all trait type parameters as _input_ types, and"
msgstr ""

#: src/0195-associated-items.md:152
msgid "Providing associated types, which are _output_ types."
msgstr ""

#: src/0195-associated-items.md:154 src/0195-associated-items.md:1296
msgid ""
"In this design, the `Add` trait would be written and implemented as follows:"
msgstr ""

#: src/0195-associated-items.md:157
msgid "// Self and Rhs are *inputs*\n"
msgstr ""

#: src/0195-associated-items.md:159 src/0195-associated-items.md:1301
msgid "// Sum is an *output*\n"
msgstr ""

#: src/0195-associated-items.md:174
msgid ""
"With this approach, a trait declaration like `trait Add<Rhs> { ... }` is "
"really defining a _family_ of traits, one for each choice of `Rhs`. One can "
"then provide a distinct `impl` for every member of this family."
msgstr ""

#: src/0195-associated-items.md:178
msgid "Expressiveness"
msgstr ""

#: src/0195-associated-items.md:180
msgid ""
"Associated types, lifetimes, and functions can already be expressed in "
"today's Rust, though it is unwieldy to do so (as argued above)."
msgstr ""

#: src/0195-associated-items.md:183
msgid "But associated _consts_ cannot be expressed using today's traits."
msgstr ""

#: src/0195-associated-items.md:185
msgid ""
"For example, today's Rust includes a variety of numeric traits, including "
"`Float`, which must currently expose constants as static functions:"
msgstr ""

#: src/0195-associated-items.md:200
msgid ""
"Because these functions cannot be used in constant expressions, the modules "
"for float types _also_ export a separate set of constants as consts, not "
"using traits."
msgstr ""

#: src/0195-associated-items.md:204
msgid ""
"Associated constants would allow the consts to live directly on the traits:"
msgstr ""

#: src/0195-associated-items.md:218
msgid "Why now?"
msgstr ""

#: src/0195-associated-items.md:220
msgid ""
"The above motivations aside, it may not be obvious why adding associated "
"types _now_ (i.e., pre-1.0) is important. There are essentially two reasons."
msgstr ""

#: src/0195-associated-items.md:223
msgid ""
"First, the design presented here is _not_ backwards compatible, because it "
"re-interprets trait type parameters as inputs for the purposes of trait "
"matching. The input/output distinction has several ramifications on "
"coherence rules, type inference, and resolution, which are all described "
"later on in the RFC."
msgstr ""

#: src/0195-associated-items.md:229
msgid ""
"Of course, it might be possible to give a somewhat less ideal design where "
"associated types can be added later on without changing the interpretation "
"of existing trait type parameters. For example, type parameters could be "
"explicitly marked as inputs, and otherwise assumed to be outputs. That would "
"be unfortunate, since associated types would _also_ be outputs -- leaving "
"the language with two ways of specifying output types for traits."
msgstr ""

#: src/0195-associated-items.md:236
msgid "But the second reason is for the library stabilization process:"
msgstr ""

#: src/0195-associated-items.md:238
msgid ""
"Since most existing uses of trait type parameters are intended as outputs, "
"they should really be associated types instead. Making promises about these "
"APIs as they currently stand risks locking the libraries into a design that "
"will seem obsolete as soon as associated items are added. Again, this risk "
"could probably be mitigated with a different, backwards-compatible "
"associated item design, but at the cost of cruft in the language itself."
msgstr ""

#: src/0195-associated-items.md:245
msgid ""
"The binary operator traits (e.g. `Add`) should be multidispatch. It does not "
"seem possible to stabilize them _now_ in a way that will support moving to "
"multidispatch later."
msgstr ""

#: src/0195-associated-items.md:249
msgid ""
"There are some thorny problems in the current libraries, such as the "
"`_equiv` methods accumulating in `HashMap`, that can be solved using "
"associated items. (See \"Defaults\" below for more on this specific "
"example.) Additional examples include traits for error propagation and for "
"conversion (to be covered in future RFCs). Adding these traits would improve "
"the quality and consistency of our 1.0 library APIs."
msgstr ""

#: src/0195-associated-items.md:256
msgid "Detailed design"
msgstr ""

#: src/0195-associated-items.md:258
msgid "Trait headers"
msgstr ""

#: src/0195-associated-items.md:260
msgid "Trait headers are written according to the following grammar:"
msgstr ""

#: src/0195-associated-items.md:282
msgid ""
"**NOTE**: The grammar for `WHERE_CLAUSE` and `BOUND` is explained in detail "
"in the subsection \"Constraining associated types\" below."
msgstr ""

#: src/0195-associated-items.md:285
msgid ""
"All type parameters to a trait are considered inputs, and can be used to "
"select an `impl`; conceptually, each distinct instantiation of the types "
"yields a distinct trait. More details are given in the section \"The input/"
"output type distinction\" below."
msgstr ""

#: src/0195-associated-items.md:290
msgid "Trait bodies: defining associated items"
msgstr ""

#: src/0195-associated-items.md:292
msgid ""
"Trait bodies are expanded to include three new kinds of items: consts, "
"types, and lifetimes:"
msgstr ""

#: src/0195-associated-items.md:304
msgid ""
"Traits already support associated functions, which had previously been "
"called \"static\" functions."
msgstr ""

#: src/0195-associated-items.md:307
msgid ""
"The `BOUNDS` and `WHERE_CLAUSE` on associated types are _obligations_ for "
"the implementor of the trait, and _assumptions_ for users of the trait:"
msgstr ""

#: src/0195-associated-items.md:318
msgid "// Both MyNode and MyEdge must implement Show and Hash\n"
msgstr ""

#: src/0195-associated-items.md:325
msgid "// here, can assume G::N implements Show\n"
msgstr ""

#: src/0195-associated-items.md:330
msgid "Namespacing/shadowing for associated types"
msgstr ""

#: src/0195-associated-items.md:332
msgid ""
"Associated types may have the same name as existing types in scope, _except_ "
"for type parameters to the trait:"
msgstr ""

#: src/0195-associated-items.md:339
msgid "// this is allowed\n"
msgstr ""

#: src/0195-associated-items.md:340
msgid "// this refers to the trait's Foo\n"
msgstr ""

#: src/0195-associated-items.md:342
msgid "// this is NOT allowed\n"
msgstr ""

#: src/0195-associated-items.md:346
msgid ""
"By not allowing name clashes between input and output types, keep open the "
"possibility of later allowing syntax like:"
msgstr ""

#: src/0195-associated-items.md:353
msgid ""
"where both input and output parameters are constrained by name. And anyway, "
"there is no use for clashing input/output names."
msgstr ""

#: src/0195-associated-items.md:356
msgid ""
"In the case of a name clash like `Foo` above, if the trait needs to refer to "
"the outer `Foo` for some reason, it can always do so by using a `type` alias "
"external to the trait."
msgstr ""

#: src/0195-associated-items.md:360
msgid "Defaults"
msgstr ""

#: src/0195-associated-items.md:362
msgid ""
"Notice that associated consts and types both permit defaults, just as trait "
"methods and functions can provide defaults."
msgstr ""

#: src/0195-associated-items.md:365
msgid ""
"Defaults are useful both as a code reuse mechanism, and as a way to expand "
"the items included in a trait without breaking all existing implementors of "
"the trait."
msgstr ""

#: src/0195-associated-items.md:369
msgid ""
"Defaults for associated types, however, present an interesting question: can "
"default methods assume the default type? In other words, is the following "
"allowed?"
msgstr ""

#: src/0195-associated-items.md:395
msgid ""
"In this example, the `ContainerKey` trait is used to associate a \"`Query`\" "
"type (for lookups) with an owned key type. This resolves the thorny "
"\"equiv\" problem in `HashMap`, where the hash map keys are `String`s but "
"you want to index the hash map with `&str` values rather than `&String` "
"values, i.e. you want the following to work:"
msgstr ""

#: src/0195-associated-items.md:402
msgid "// H: HashMap<String, SomeType>\n"
msgstr ""

#: src/0195-associated-items.md:403 src/0195-associated-items.md:409
msgid "\"some literal\""
msgstr ""

#: src/0195-associated-items.md:406
msgid "rather than having to write"
msgstr ""

#: src/0195-associated-items.md:412
msgid ""
"The current solution involves duplicating the API surface with `_equiv` "
"methods that use the somewhat subtle `Equiv` trait, but the associated type "
"approach makes it easy to provide a simple, single API that covers the same "
"use cases."
msgstr ""

#: src/0195-associated-items.md:416
msgid ""
"The defaults for `ContainerKey` just assume that the owned key and lookup "
"key types are the same, but the default methods have to assume the default "
"associated types in order to work."
msgstr ""

#: src/0195-associated-items.md:420
msgid ""
"For this to work, it must _not_ be possible for an implementor of "
"`ContainerKey` to override the default `Query` type while leaving the "
"default methods in place, since those methods may no longer typecheck."
msgstr ""

#: src/0195-associated-items.md:424
msgid "We deal with this in a very simple way:"
msgstr ""

#: src/0195-associated-items.md:426
msgid ""
"If a trait implementor overrides any default associated types, they must "
"also override _all_ default functions and methods."
msgstr ""

#: src/0195-associated-items.md:429
msgid ""
"Otherwise, a trait implementor can selectively override individual default "
"methods/functions, as they can today."
msgstr ""

#: src/0195-associated-items.md:432
msgid "Trait implementations"
msgstr ""

#: src/0195-associated-items.md:434
msgid ""
"Trait `impl` syntax is much the same as before, except that const, type, and "
"lifetime items are allowed:"
msgstr ""

#: src/0195-associated-items.md:445
msgid ""
"Any `type` implementation must satisfy all bounds and where clauses in the "
"corresponding trait item."
msgstr ""

#: src/0195-associated-items.md:448
msgid "Referencing associated items"
msgstr ""

#: src/0195-associated-items.md:450
msgid ""
"Associated items are referenced through paths. The expression path grammar "
"was updated as part of [UFCS](https://github.com/rust-lang/rfcs/pull/132), "
"but to accommodate associated types and lifetimes we need to update the type "
"path grammar as well."
msgstr ""

#: src/0195-associated-items.md:455
msgid "The full grammar is as follows:"
msgstr ""

#: src/0195-associated-items.md:474
msgid "Here are some example paths, along with what they might be referencing"
msgstr ""

#: src/0195-associated-items.md:477
msgid ""
"// Expression "
"paths ///////////////////////////////////////////////////////////////\n"
msgstr ""

#: src/0195-associated-items.md:479
msgid "// reference to a function `c` in module `a::b`\n"
msgstr ""

#: src/0195-associated-items.md:480
msgid "// the function `a` instantiated with type arguments `T1`, `T2`\n"
msgstr ""

#: src/0195-associated-items.md:481
msgid "// reference to the function `new` associated with `Vec<T>`\n"
msgstr ""

#: src/0195-associated-items.md:483
msgid ""
"// reference to the function `some_fn` associated with `SomeTrait`,\n"
"                //   as implemented by `Vec<T>`\n"
msgstr ""

#: src/0195-associated-items.md:485
msgid "// the function `size_of` associated with the type or trait `T`\n"
msgstr ""

#: src/0195-associated-items.md:486
msgid "// the function `size_of` associated with `T` _viewed as a type_\n"
msgstr ""

#: src/0195-associated-items.md:488
msgid "// the function `size_of` associated with `T`'s impl of `SizeOf`\n"
msgstr ""

#: src/0195-associated-items.md:489
msgid ""
"// Type "
"paths /////////////////////////////////////////////////////////////////////\n"
msgstr ""

#: src/0195-associated-items.md:492
msgid "// reference to a type `C` in module `a::b`\n"
msgstr ""

#: src/0195-associated-items.md:493
msgid "// type A instantiated with type arguments `T1`, `T2`\n"
msgstr ""

#: src/0195-associated-items.md:494
msgid "// reference to the type `Iter` associated with `Vec<T>\n"
msgstr ""

#: src/0195-associated-items.md:496
msgid ""
"// reference to the type `SomeType` associated with `SomeTrait`,\n"
"                //   as implemented by `Vec<T>`\n"
msgstr ""

#: src/0195-associated-items.md:500
msgid "Ways to reference items"
msgstr ""

#: src/0195-associated-items.md:502
msgid "Next, we'll go into more detail on the meaning of each kind of path."
msgstr ""

#: src/0195-associated-items.md:504
msgid ""
"For the sake of discussion, we'll suppose we've defined a trait like the "
"following:"
msgstr ""

#: src/0195-associated-items.md:523
msgid "Via an `ID_SEGMENT` prefix"
msgstr ""

#: src/0195-associated-items.md:525
msgid "When the prefix resolves to a type"
msgstr ""

#: src/0195-associated-items.md:527
msgid ""
"The most common way to get at an associated item is through a type parameter "
"with a trait bound:"
msgstr ""

#: src/0195-associated-items.md:534
msgid "// reference to associated function\n"
msgstr ""

#: src/0195-associated-items.md:541
msgid ""
"For these references to be valid, the type parameter must be known to "
"implement the relevant trait:"
msgstr ""

#: src/0195-associated-items.md:545
msgid "// Knowledge via bounds\n"
msgstr ""

#: src/0195-associated-items.md:547
msgid "// ... or equivalently,  where clause\n"
msgstr ""

#: src/0195-associated-items.md:550
msgid "// Knowledge via ambient constraints\n"
msgstr ""

#: src/0195-associated-items.md:559
msgid ""
"Note that `Vec<T>::E` and `Vec::<T>::empty` are also valid type and function "
"references, respectively."
msgstr ""

#: src/0195-associated-items.md:562
msgid ""
"For cases like `C::E` or `Vec<T>::E`, the path begins with an `ID_SEGMENT` "
"prefix that itself resolves to a _type_: both `C` and `Vec<T>` are types.  "
"In general, a path `PREFIX::REST_OF_PATH` where `PREFIX` resolves to a type "
"is equivalent to using a `TYPE_SEGMENT` prefix `<PREFIX>::REST_OF_PATH`. So, "
"for example, following are all equivalent:"
msgstr ""

#: src/0195-associated-items.md:574
msgid ""
"The behavior of `TYPE_SEGMENT` prefixes is described in the next subsection."
msgstr ""

#: src/0195-associated-items.md:576
msgid "When the prefix resolves to a trait"
msgstr ""

#: src/0195-associated-items.md:578
msgid ""
"However, it is possible for an `ID_SEGMENT` prefix to resolve to a _trait_, "
"rather than a type. In this case, the behavior of an `ID_SEGMENT` varies "
"from that of a `TYPE_SEGMENT` in the following way:"
msgstr ""

#: src/0195-associated-items.md:583
msgid "// a reference Container::insert is roughly equivalent to:\n"
msgstr ""

#: src/0195-associated-items.md:585
msgid "// a reference <Container>::insert is roughly equivalent to:\n"
msgstr ""

#: src/0195-associated-items.md:590
msgid ""
"That is, if `PREFIX` is an `ID_SEGMENT` that resolves to a trait `Trait`:"
msgstr ""

#: src/0195-associated-items.md:593
msgid ""
"A path `PREFIX::REST` resolves to the item/path `REST` defined within "
"`Trait`, while treating the type implementing the trait as a type parameter."
msgstr ""

#: src/0195-associated-items.md:596
msgid ""
"A path `<PREFIX>::REST` treats `PREFIX` as a (DST-style) _type_, and is "
"hence usable only with trait objects. See the [UFCS RFC](https://github.com/"
"rust-lang/rfcs/pull/132) for more detail."
msgstr ""

#: src/0195-associated-items.md:600
msgid ""
"Note that a path like `Container::E`, while grammatically valid, will fail "
"to resolve since there is no way to tell which `impl` to use. A path like "
"`Container::empty`, however, resolves to a function roughly equivalent to:"
msgstr ""

#: src/0195-associated-items.md:608
msgid "Via a `TYPE_SEGMENT` prefix"
msgstr ""

#: src/0195-associated-items.md:610
msgid ""
"The following text is _slightly changed_ from the [UFCS RFC](https://github."
"com/rust-lang/rfcs/pull/132)."
msgstr ""

#: src/0195-associated-items.md:613
msgid ""
"When a path begins with a `TYPE_SEGMENT`, it is a type-relative path. If "
"this is the complete path (e.g., `<int>`), then the path resolves to the "
"specified type. If the path continues (e.g., `<int>::size_of`) then the next "
"segment is resolved using the following procedure.  The procedure is "
"intended to mimic method lookup, and hence any changes to method lookup may "
"also change the details of this lookup."
msgstr ""

#: src/0195-associated-items.md:620
msgid "Given a path `<T>::m::...`:"
msgstr ""

#: src/0195-associated-items.md:622
msgid ""
"Search for members of inherent impls defined on `T` (if any) with the name "
"`m`. If any are found, the path resolves to that item."
msgstr ""

#: src/0195-associated-items.md:625
msgid ""
"Otherwise, let `IN_SCOPE_TRAITS` be the set of traits that are in scope and "
"which contain a member named `m`:"
msgstr ""

#: src/0195-associated-items.md:627
msgid ""
"Let `IMPLEMENTED_TRAITS` be those traits from `IN_SCOPE_TRAITS` for which an "
"implementation exists that (may) apply to `T`."
msgstr ""

#: src/0195-associated-items.md:629
msgid ""
"There can be ambiguity in the case that `T` contains type inference "
"variables."
msgstr ""

#: src/0195-associated-items.md:631
msgid ""
"If `IMPLEMENTED_TRAITS` is not a singleton set, report an ambiguity error. "
"Otherwise, let `TRAIT` be the member of `IMPLEMENTED_TRAITS`."
msgstr ""

#: src/0195-associated-items.md:633
msgid ""
"If `TRAIT` is ambiguously implemented for `T`, report an ambiguity error and "
"request further type information."
msgstr ""

#: src/0195-associated-items.md:635
msgid "Otherwise, rewrite the path to `<T as Trait>::m::...` and continue."
msgstr ""

#: src/0195-associated-items.md:638
msgid "Via a `IMPL_SEGMENT` prefix"
msgstr ""

#: src/0195-associated-items.md:640
msgid ""
"The following text is _somewhat different_ from the [UFCS RFC](https://"
"github.com/rust-lang/rfcs/pull/132)."
msgstr ""

#: src/0195-associated-items.md:643
msgid ""
"When a path begins with an `IMPL_SEGMENT`, it is a reference to an item "
"defined from a trait. Note that such paths must always have a follow-on "
"member `m` (that is, `<T as Trait>` is not a complete path, but `<T as "
"Trait>::m` is)."
msgstr ""

#: src/0195-associated-items.md:647
msgid ""
"To resolve the path, first search for an applicable implementation of "
"`Trait` for `T`. If no implementation can be found -- or the result is "
"ambiguous -- then report an error.  Note that when `T` is a type parameter, "
"a bound `T: Trait` guarantees that there is such an implementation, but does "
"not count for ambiguity purposes."
msgstr ""

#: src/0195-associated-items.md:653
msgid ""
"Otherwise, resolve the path to the member of the trait with the substitution "
"`Self => T` and continue."
msgstr ""

#: src/0195-associated-items.md:656
msgid ""
"This apparently straightforward algorithm has some subtle consequences, as "
"illustrated by the following example:"
msgstr ""

#: src/0195-associated-items.md:664
msgid "// A blanket impl for any Show type T\n"
msgstr ""

#: src/0195-associated-items.md:672
msgid "// Here, we just constrain the associated type directly\n"
msgstr ""

#: src/0195-associated-items.md:673 src/0195-associated-items.md:679
#: src/0195-associated-items.md:685
msgid "\"{}\""
msgstr ""

#: src/0195-associated-items.md:677
msgid ""
"// the blanket impl applies to U, so we know that `U: Foo` and\n"
"    // <U as Foo>::T = U (and, of course, U: Show)\n"
msgstr ""

#: src/0195-associated-items.md:683
msgid ""
"// this will not compile, since <U as Trait>::T is not known to\n"
"    // implement Show\n"
msgstr ""

#: src/0195-associated-items.md:689
msgid ""
"This example includes three generic functions that make use of an associated "
"type; the first two will typecheck, while the third will not."
msgstr ""

#: src/0195-associated-items.md:692
msgid ""
"The first case, `bounded`, places a `Show` constraint directly on the "
"otherwise-abstract associated type `U::T`. Hence, it is allowed to assume "
"that `U::T: Show`, even though it does not know the concrete implementation "
"of `Foo` for `U`."
msgstr ""

#: src/0195-associated-items.md:697
msgid ""
"The second case, `blanket`, places a `Show` constraint on the type `U`, "
"which means that the blanket `impl` of `Foo` applies even though we do not "
"know the _concrete_ type that `U` will be. That fact means, moreover, that "
"we can compute exactly what the associated type `U::T` will be, and know "
"that it will satisfy `Show`. Coherence guarantees that that the blanket "
"`impl` is the only one that could apply to `U`. (See the section \"Impl "
"specialization\" under \"Unresolved questions\" for a deeper discussion of "
"this point.)"
msgstr ""

#: src/0195-associated-items.md:705
msgid ""
"The third case assumes only that `U: Foo`, and therefore nothing is known "
"about the associated type `U::T`. In particular, the function cannot assume "
"that `U::T: Show`."
msgstr ""

#: src/0195-associated-items.md:709
msgid ""
"The resolution rules also interact with instantiation of type parameters in "
"an intuitive way. For example:"
msgstr ""

#: src/0195-associated-items.md:726
msgid "// the type G::N is abstract here\n"
msgstr ""

#: src/0195-associated-items.md:732
msgid "// has type: <MyGraph as Graph>::N = MyNode\n"
msgstr ""

#: src/0195-associated-items.md:735
msgid ""
"Assuming there are no blanket implementations of `Graph`, the `pick_node` "
"function knows nothing about the associated type `G::N`. However, a _client_ "
"of `pick_node` that instantiates it with a particular concrete graph type "
"will also know the concrete type of the value returned from the function -- "
"here, `MyNode`."
msgstr ""

#: src/0195-associated-items.md:740
msgid "Scoping of `trait` and `impl` items"
msgstr ""

#: src/0195-associated-items.md:742
msgid ""
"Associated types are frequently referred to in the signatures of a trait's "
"methods and associated functions, and it is natural and convenient to refer "
"to them directly."
msgstr ""

#: src/0195-associated-items.md:746
msgid "In other words, writing this:"
msgstr ""

#: src/0195-associated-items.md:757
msgid "is more appealing than writing this:"
msgstr ""

#: src/0195-associated-items.md:768
msgid ""
"This RFC proposes to treat both `trait` and `impl` bodies (both inherent and "
"for traits) the same way we treat `mod` bodies: _all_ items being defined "
"are in scope. In particular, methods are in scope as UFCS-style functions:"
msgstr ""

#: src/0195-associated-items.md:780
msgid "// Note: 'assoc_lifetime and AssocType in scope:\n"
msgstr ""

#: src/0195-associated-items.md:784
msgid "// method in scope UFCS-style, assoc_fn in scope\n"
msgstr ""

#: src/0195-associated-items.md:786
msgid "// in scope\n"
msgstr ""

#: src/0195-associated-items.md:789
msgid "// Same scoping rules for impls, including inherent impls:\n"
msgstr ""

#: src/0195-associated-items.md:795
msgid "// foo in scope UFCS-style\n"
msgstr ""

#: src/0195-associated-items.md:801
msgid ""
"Items from super traits are _not_ in scope, however. See [the discussion on "
"super traits below](#super-traits) for more detail."
msgstr ""

#: src/0195-associated-items.md:804
msgid ""
"These scope rules provide good ergonomics for associated types in "
"particular, and a consistent scope model for language constructs that can "
"contain items (like traits, impls, and modules). In the long run, we should "
"also explore imports for trait items, i.e. `use Trait::some_method`, but "
"that is out of scope for this RFC."
msgstr ""

#: src/0195-associated-items.md:810
msgid ""
"Note that, according to this proposal, associated types/lifetimes are _not_ "
"in scope for the optional `where` clause on the trait header. For example:"
msgstr ""

#: src/0195-associated-items.md:815
msgid "// type parameters in scope, but associated types are not:\n"
msgstr ""

#: src/0195-associated-items.md:823
msgid ""
"This setup seems more intuitive than allowing the trait header to refer "
"directly to items defined within the trait body."
msgstr ""

#: src/0195-associated-items.md:826
msgid ""
"It's also worth noting that _trait-level_ `where` clauses are never needed "
"for constraining associated types anyway, because associated types also have "
"`where` clauses. Thus, the above example could (and should) instead be "
"written as follows:"
msgstr ""

#: src/0195-associated-items.md:838
msgid "Constraining associated types"
msgstr ""

#: src/0195-associated-items.md:840
msgid ""
"Associated types are not treated as parameters to a trait, but in some cases "
"a function will want to constrain associated types in some way. For example, "
"as explained in the Motivation section, the `Iterator` trait should treat "
"the element type as an output:"
msgstr ""

#: src/0195-associated-items.md:853
msgid ""
"For code that works with iterators generically, there is no need to "
"constrain this type:"
msgstr ""

#: src/0195-associated-items.md:860
msgid "But other code may have requirements for the element type:"
msgstr ""

#: src/0195-associated-items.md:862
msgid "That it implements some traits (bounds)."
msgstr ""

#: src/0195-associated-items.md:863
msgid "That it unifies with a particular type."
msgstr ""

#: src/0195-associated-items.md:865
msgid "These requirements can be imposed via `where` clauses:"
msgstr ""

#: src/0195-associated-items.md:872
msgid "In addition, there is a shorthand for equality constraints:"
msgstr ""

#: src/0195-associated-items.md:878
msgid "In general, a trait like:"
msgstr ""

#: src/0195-associated-items.md:890
msgid "can be written in a bound like:"
msgstr ""

#: src/0195-associated-items.md:901
msgid ""
"The output constraints must come after all input arguments, but can appear "
"in any order."
msgstr ""

#: src/0195-associated-items.md:904
msgid ""
"Note that output constraints are allowed when referencing a trait in a "
"_type_ or a _bound_, but not in an `IMPL_SEGMENT` path:"
msgstr ""

#: src/0195-associated-items.md:907
msgid "As a type: `fn foo(obj: Box<Iterator<A = uint>>` is allowed."
msgstr ""

#: src/0195-associated-items.md:908
msgid "In a bound: `fn foo<I: Iterator<A = uint>>(iter: I)` is allowed."
msgstr ""

#: src/0195-associated-items.md:909
msgid ""
"In an `IMPL_SEGMENT`: `<I as Iterator<A = uint>>::next` is _not_ allowed."
msgstr ""

#: src/0195-associated-items.md:911
msgid ""
"The reason not to allow output constraints in `IMPL_SEGMENT` is that such "
"paths are references to a trait implementation that has already been "
"determined -- it does not make sense to apply additional constraints to the "
"implementation when referencing it."
msgstr ""

#: src/0195-associated-items.md:916
msgid ""
"Output constraints are a handy shorthand when using trait bounds, but they "
"are a _necessity_ for trait objects, which we discuss next."
msgstr ""

#: src/0195-associated-items.md:919
msgid "Trait objects"
msgstr ""

#: src/0195-associated-items.md:921
msgid ""
"When using trait objects, the `Self` type is \"erased\", so different types "
"implementing the trait can be used under the same trait object type:"
msgstr ""

#: src/0195-associated-items.md:938
msgid ""
"One consequence of erasing `Self` is that methods using the `Self` type as "
"arguments or return values cannot be used on trait objects, since their "
"types would differ for different choices of `Self`."
msgstr ""

#: src/0195-associated-items.md:942
msgid ""
"In the model presented in this RFC, traits have additional input parameters "
"beyond `Self`, as well as associated types that may vary depending on all of "
"the input parameters. This raises the question: which of these types, if "
"any, are erased in trait objects?"
msgstr ""

#: src/0195-associated-items.md:947
msgid ""
"The approach we take here is the simplest and most conservative: when using "
"a trait as a _type_ (i.e., as a trait object), _all_ input and output types "
"must be provided as part of the type. In other words, _only_ the `Self` type "
"is erased, and all other types are specified statically in the trait object "
"type."
msgstr ""

#: src/0195-associated-items.md:952
msgid "Consider again the following example:"
msgstr ""

#: src/0195-associated-items.md:964
msgid ""
"Unlike the case for static trait bounds, which do not have to specify any of "
"the associated types, lifetimes, or consts, (but do have to specify the "
"input types), trait object types must specify all of the types:"
msgstr ""

#: src/0195-associated-items.md:969
msgid "// this is valid\n"
msgstr ""

#: src/0195-associated-items.md:970
msgid "// this is NOT valid\n"
msgstr ""

#: src/0195-associated-items.md:971
msgid "// but this IS valid:\n"
msgstr ""

#: src/0195-associated-items.md:976
msgid ""
"With this design, it is clear that none of the non-`Self` types are erased "
"as part of trait objects. But it leaves wiggle room to relax this "
"restriction later on: trait object types that are not allowed under this "
"design can be given meaning in some later design."
msgstr ""

#: src/0195-associated-items.md:981
msgid "Inherent associated items"
msgstr ""

#: src/0195-associated-items.md:983
msgid ""
"All associated items are also allowed in inherent `impl`s, so a definition "
"like the following is allowed:"
msgstr ""

#: src/0195-associated-items.md:995
msgid "// Note: associated types in scope, just as with trait bodies\n"
msgstr ""

#: src/0195-associated-items.md:1004
msgid ""
"Inherent associated items are referenced similarly to trait associated items:"
msgstr ""

#: src/0195-associated-items.md:1010
msgid ""
"Note, however, that output constraints do not make sense for inherent "
"outputs:"
msgstr ""

#: src/0195-associated-items.md:1013
msgid "// This is *not* a legal type:\n"
msgstr ""

#: src/0195-associated-items.md:1017
msgid "The input/output type distinction"
msgstr ""

#: src/0195-associated-items.md:1019
msgid ""
"When designing a trait that references some unknown type, you now have the "
"option of taking that type as an input parameter, or specifying it as an "
"output associated type. What are the ramifications of this decision?"
msgstr ""

#: src/0195-associated-items.md:1023
msgid "Coherence implications"
msgstr ""

#: src/0195-associated-items.md:1025
msgid ""
"Input types are used when determining which `impl` matches, even for the "
"same `Self` type:"
msgstr ""

#: src/0195-associated-items.md:1033
msgid "// These impls have distinct input types, so are allowed\n"
msgstr ""

#: src/0195-associated-items.md:1043
msgid "// These impls apply to a common input (Foo), so are NOT allowed\n"
msgstr ""

#: src/0195-associated-items.md:1049
msgid "More formally, the _coherence_ property is revised as follows:"
msgstr ""

#: src/0195-associated-items.md:1051
msgid ""
"Given a trait and values for all its type parameters (inputs, including "
"`Self`), there is at most one applicable `impl`."
msgstr ""

#: src/0195-associated-items.md:1054
msgid ""
"In the [trait reform RFC](https://github.com/rust-lang/rfcs/pull/48), "
"coherence is guaranteed by maintaining two other key properties, which are "
"revised as follows:"
msgstr ""

#: src/0195-associated-items.md:1058
msgid ""
"_Orphan check_: Every implementation must meet one of the following "
"conditions:"
msgstr ""

#: src/0195-associated-items.md:1061
msgid ""
"The trait being implemented (if any) must be defined in the current crate."
msgstr ""

#: src/0195-associated-items.md:1062
msgid ""
"At least one of the input type parameters (including but not necessarily "
"`Self`) must meet the following grammar, where `C` is a struct or enum "
"defined within the current crate:"
msgstr ""

#: src/0195-associated-items.md:1075
msgid ""
"_Overlapping instances_: No two implementations can be instantiable with the "
"same set of types for the input type parameters."
msgstr ""

#: src/0195-associated-items.md:1078
msgid ""
"See the [trait reform RFC](https://github.com/rust-lang/rfcs/pull/48) for "
"more discussion of these properties."
msgstr ""

#: src/0195-associated-items.md:1081
msgid "Type inference implications"
msgstr ""

#: src/0195-associated-items.md:1083
msgid ""
"Finally, _output_ type parameters can be inferred/resolved as soon as there "
"is a matching `impl` based on the input type parameters. Because of the "
"coherence property above, there can be at most one."
msgstr ""

#: src/0195-associated-items.md:1087
msgid ""
"On the other hand, even if there is only one applicable `impl`, type "
"inference is _not_ allowed to infer the input type parameters from it. This "
"restriction makes it possible to ensure _crate concatenation_: adding "
"another crate may add `impl`s for a given trait, and if type inference "
"depended on the absence of such `impl`s, importing a crate could break "
"existing code."
msgstr ""

#: src/0195-associated-items.md:1093
msgid ""
"In practice, these inference benefits can be quite valuable. For example, in "
"the `Add` trait given at the beginning of this RFC, the `Sum` output type is "
"immediately known once the input types are known, which can avoid the need "
"for type annotations."
msgstr ""

#: src/0195-associated-items.md:1098
msgid "Limitations"
msgstr ""

#: src/0195-associated-items.md:1100
msgid ""
"The main limitation of associated items as presented here is about "
"associated _types_ in particular. You might be tempted to write a trait like "
"the following:"
msgstr ""

#: src/0195-associated-items.md:1106
msgid "// what is the lifetime here?\n"
msgstr ""

#: src/0195-associated-items.md:1107
msgid "// and how to connect it to self?\n"
msgstr ""

#: src/0195-associated-items.md:1111
msgid ""
"The problem is that, when implementing this trait, the return type `I` of "
"`iter` must generally depend on the _lifetime_ of self. For example, the "
"corresponding method in `Vec` looks like the following:"
msgstr ""

#: src/0195-associated-items.md:1121
msgid ""
"This means that, given a `Vec<T>`, there isn't a _single_ type `Items<T>` "
"for iteration -- rather, there is a _family_ of types, one for each input "
"lifetime. In other words, the associated type `I` in the `Iterable` needs to "
"be \"higher-kinded\": not just a single type, but rather a family:"
msgstr ""

#: src/0195-associated-items.md:1134
msgid ""
"In this case, `I` is parameterized by a lifetime, but in other cases (like "
"`map`) an associated type needs to be parameterized by a type."
msgstr ""

#: src/0195-associated-items.md:1137
msgid ""
"In general, such higher-kinded types (HKTs) are a much-requested feature for "
"Rust, and they would extend the reach of associated types. But the design "
"and implementation of higher-kinded types is, by itself, a significant "
"investment. The point of view of this RFC is that associated items bring the "
"most important changes needed to stabilize our existing traits (and add a "
"few key others), while HKTs will allow us to define important traits in the "
"future but are not necessary for 1.0."
msgstr ""

#: src/0195-associated-items.md:1145
msgid "Encoding higher-kinded types"
msgstr ""

#: src/0195-associated-items.md:1147
msgid ""
"That said, it's worth pointing out that variants of higher-kinded types can "
"be encoded in the system being proposed here."
msgstr ""

#: src/0195-associated-items.md:1150
msgid ""
"For example, the `Iterable` example above can be written in the following "
"somewhat contorted style:"
msgstr ""

#: src/0195-associated-items.md:1167
msgid ""
"The idea here is to define a trait that takes, as input type/lifetimes "
"parameters, the parameters to any HKTs. In this case, the trait is "
"implemented on the type `&'a Self`, which includes the lifetime parameter."
msgstr ""

#: src/0195-associated-items.md:1171
msgid "We can in fact generalize this technique to encode arbitrary HKTs:"
msgstr ""

#: src/0195-associated-items.md:1174
msgid "// The kind * -> *\n"
msgstr ""

#: src/0195-associated-items.md:1200
msgid ""
"While the above demonstrates the versatility of associated types and `where` "
"clauses, it is probably too much of a hack to be viable for use in `libstd`."
msgstr ""

#: src/0195-associated-items.md:1203
msgid "Associated consts in generic code"
msgstr ""

#: src/0195-associated-items.md:1205
msgid ""
"If the value of an associated const depends on a type parameter (including "
"`Self`), it cannot be used in a constant expression. This restriction will "
"almost certainly be lifted in the future, but this raises questions outside "
"the scope of this RFC."
msgstr ""

#: src/0195-associated-items.md:1210
msgid "Staging"
msgstr ""

#: src/0195-associated-items.md:1212
msgid ""
"Associated lifetimes are probably not necessary for the 1.0 timeframe. While "
"we currently have a few traits that are parameterized by lifetimes, most of "
"these can go away once DST lands."
msgstr ""

#: src/0195-associated-items.md:1216
msgid ""
"On the other hand, associated lifetimes are probably trivial to implement "
"once associated types have been implemented."
msgstr ""

#: src/0195-associated-items.md:1219
msgid "Other interactions"
msgstr ""

#: src/0195-associated-items.md:1221
msgid "Interaction with implied bounds"
msgstr ""

#: src/0195-associated-items.md:1223
msgid ""
"As part of the [implied bounds](http://smallcultfollowing.com/babysteps/"
"blog/2014/07/06/implied-bounds/) idea, it may be desirable for this:"
msgstr ""

#: src/0195-associated-items.md:1231
msgid "to be sugar for this:"
msgstr ""

#: src/0195-associated-items.md:1237
msgid ""
"But this feature can easily be added later, as part of a general implied "
"bounds RFC."
msgstr ""

#: src/0195-associated-items.md:1239
msgid "Future-proofing: specialization of `impl`s"
msgstr ""

#: src/0195-associated-items.md:1241
msgid ""
"In the future, we may wish to relax the \"overlapping instances\" rule so "
"that one can provide \"blanket\" trait implementations and then "
"\"specialize\" them for particular types. For example:"
msgstr ""

#: src/0195-associated-items.md:1248
msgid "// note: not using &self here to avoid need for HKT\n"
msgstr ""

#: src/0195-associated-items.md:1263
msgid "But then there's a difficult question:"
msgstr ""

#: src/0195-associated-items.md:1265
msgid ""
"```\n"
"fn dice<A>(a: &A) -> &A::Slice where &A: Sliceable {\n"
"    a // is this allowed?\n"
"}\n"
"```"
msgstr ""

#: src/0195-associated-items.md:1271
msgid ""
"Here, the blanket and specialized implementations provide incompatible "
"associated types. When working with the trait generically, what can we "
"assume about the associated type? If we assume it is the blanket one, the "
"type may change during monomorphization (when specialization takes effect)!"
msgstr ""

#: src/0195-associated-items.md:1276
msgid ""
"The RFC _does_ allow generic code to \"see\" associated types provided by "
"blanket implementations, so this is a potential problem."
msgstr ""

#: src/0195-associated-items.md:1279
msgid ""
"Our suggested strategy is the following. If at some later point we wish to "
"add specialization, traits would have to _opt in_ explicitly. For such "
"traits, we would _not_ allow generic code to \"see\" associated types for "
"blanket implementations; instead, output types would only be visible when "
"all input types were concretely known. This approach is backwards-compatible "
"with the RFC, and is probably a good idea in any case."
msgstr ""

#: src/0195-associated-items.md:1286
msgid "Alternatives"
msgstr ""

#: src/0195-associated-items.md:1288
msgid "Multidispatch through tuple types"
msgstr ""

#: src/0195-associated-items.md:1290
msgid ""
"This RFC clarifies trait matching by making trait type parameters inputs to "
"matching, and associated types outputs."
msgstr ""

#: src/0195-associated-items.md:1293
msgid ""
"A more radical alternative would be to _remove type parameters from traits_, "
"and instead support multiple input types through a separate multidispatch "
"mechanism."
msgstr ""

#: src/0195-associated-items.md:1299
msgid "// Lhs and Rhs are *inputs*\n"
msgstr ""

#: src/0195-associated-items.md:1316
msgid ""
"The `for` syntax in the trait definition is used for multidispatch traits, "
"here saying that `impl`s must be for pairs of types which are bound to `Lhs` "
"and `Rhs` respectively. The `add` function can then be invoked in UFCS style "
"by writing"
msgstr ""

#: src/0195-associated-items.md:1325
msgid "_Advantages of the tuple approach_:"
msgstr ""

#: src/0195-associated-items.md:1327
msgid ""
"It does not force a distinction between `Self` and other input types, which "
"in some cases (including binary operators like `Add`) can be artificial."
msgstr ""

#: src/0195-associated-items.md:1330
msgid ""
"Makes it possible to specify input types without specifying the trait: `<(A, "
"B)>::Sum` rather than `<A as Add<B>>::Sum`."
msgstr ""

#: src/0195-associated-items.md:1333
msgid "_Disadvantages of the tuple approach_:"
msgstr ""

#: src/0195-associated-items.md:1335
msgid "It's more painful when you _do_ want a method rather than a function."
msgstr ""

#: src/0195-associated-items.md:1337
msgid ""
"Requires `where` clauses when used in bounds: `where (A, B): Trait` rather "
"than `A: Trait<B>`."
msgstr ""

#: src/0195-associated-items.md:1340
msgid ""
"It gives two ways to write single dispatch: either without `for`, or using "
"`for` with a single-element tuple."
msgstr ""

#: src/0195-associated-items.md:1343
msgid ""
"There's a somewhat jarring distinction between single/multiple dispatch "
"traits, making the latter feel \"bolted on\"."
msgstr ""

#: src/0195-associated-items.md:1346
msgid ""
"The tuple syntax is unusual in acting as a binder of its types, as opposed "
"to the `Trait<A, B>` syntax."
msgstr ""

#: src/0195-associated-items.md:1349
msgid ""
"Relatedly, the generics syntax for traits is immediately understandable (a "
"family of traits) based on other uses of generics in the language, while the "
"tuple notation stands alone."
msgstr ""

#: src/0195-associated-items.md:1353
msgid ""
"Less clear story for trait objects (although the fact that `Self` is the "
"only erased input type in this RFC may seem somewhat arbitrary)."
msgstr ""

#: src/0195-associated-items.md:1356
msgid ""
"On balance, the generics-based approach seems like a better fit for the "
"language design, especially in its interaction with methods and the object "
"system."
msgstr ""

#: src/0195-associated-items.md:1359
msgid "A backwards-compatible version"
msgstr ""

#: src/0195-associated-items.md:1361
msgid ""
"Yet another alternative would be to allow trait type parameters to be either "
"inputs or outputs, marking the inputs with a keyword `in`:"
msgstr ""

#: src/0195-associated-items.md:1370
msgid ""
"This would provide a way of adding multidispatch now, and then adding "
"associated items later on without breakage. If, in addition, output types "
"had to come after all input types, it might even be possible to migrate "
"output type parameters like `Sum` above into associated types later."
msgstr ""

#: src/0195-associated-items.md:1375
msgid ""
"This is perhaps a reasonable fallback, but it seems better to introduce a "
"clean design with both multidispatch and associated items together."
msgstr ""

#: src/0195-associated-items.md:1378
msgid "Unresolved questions"
msgstr ""

#: src/0195-associated-items.md:1380
msgid "Super traits"
msgstr ""

#: src/0195-associated-items.md:1382
msgid "This RFC largely ignores super traits."
msgstr ""

#: src/0195-associated-items.md:1384
msgid ""
"Currently, the implementation of super traits treats them identically to a "
"`where` clause that bounds `Self`, and this RFC does not propose to change "
"that. However, a follow-up RFC should clarify that this is the intended "
"semantics for super traits."
msgstr ""

#: src/0195-associated-items.md:1389
msgid ""
"Note that this treatment of super traits is, in particular, consistent with "
"the proposed scoping rules, which do not bring items from super traits into "
"scope in the body of a subtrait; they must be accessed via `Self::item_name`."
msgstr ""

#: src/0195-associated-items.md:1393
msgid "Equality constraints in `where` clauses"
msgstr ""

#: src/0195-associated-items.md:1395
msgid ""
"This RFC allows equality constraints on types for associated types, but does "
"not propose a similar feature for `where` clauses. That will be the subject "
"of a follow-up RFC."
msgstr ""

#: src/0195-associated-items.md:1399
msgid "Multiple trait object bounds for the same trait"
msgstr ""

#: src/0195-associated-items.md:1401
msgid ""
"The design here makes it possible to write bounds or trait objects that "
"mention the same trait, multiple times, with different inputs:"
msgstr ""

#: src/0195-associated-items.md:1409
msgid ""
"This seems like a potentially useful feature, and should be unproblematic "
"for bounds, but may have implications for vtables that make it problematic "
"for trait objects. Whether or not such trait combinations are allowed will "
"likely depend on implementation concerns, which are not yet clear."
msgstr ""

#: src/0195-associated-items.md:1414
msgid "Generic associated consts in match patterns"
msgstr ""

#: src/0195-associated-items.md:1416
msgid ""
"It seems desirable to allow constants that depend on type parameters in "
"match patterns, but it's not clear how to do so while still checking "
"exhaustiveness and reachability of the match arms. Most likely this requires "
"new forms of where clause, to constrain associated constant values."
msgstr ""

#: src/0195-associated-items.md:1421
msgid "For now, we simply defer the question."
msgstr ""

#: src/0195-associated-items.md:1423
msgid "Generic associated consts in array sizes"
msgstr ""

#: src/0195-associated-items.md:1425
msgid ""
"It would be useful to be able to use trait-associated constants in generic "
"code."
msgstr ""

#: src/0195-associated-items.md:1428
msgid "// Shouldn't this be OK?\n"
msgstr ""

#: src/0195-associated-items.md:1430
msgid "// Or...\n"
msgstr ""

#: src/0195-associated-items.md:1435
msgid ""
"However, this causes some problems. What should we do with the following "
"case in type checking, where we need to prove that a generic is valid for "
"any `T`?"
msgstr ""

#: src/0195-associated-items.md:1442
msgid ""
"We would like to handle at least some obvious cases (e.g. proving that `T::N "
"== T::N`), but without trying to prove arbitrary statements about "
"arithmetic. The question of how to do this is deferred."
msgstr ""
