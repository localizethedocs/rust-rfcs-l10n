msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:42Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0246-const-vs-static.md:1
msgid "Start Date: 2014-08-08"
msgstr ""

#: src/0246-const-vs-static.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#246](https://github.com/rust-lang/rfcs/pull/246)"
msgstr ""

#: src/0246-const-vs-static.md:3
msgid ""
"Rust Issue: [rust-lang/rust#17718](https://github.com/rust-lang/rust/"
"issues/17718)"
msgstr ""

#: src/0246-const-vs-static.md:5
msgid "Summary"
msgstr "摘要"

#: src/0246-const-vs-static.md:7
msgid "Divide global declarations into two categories:"
msgstr ""

#: src/0246-const-vs-static.md:9
msgid ""
"**constants** declare _constant values_. These represent a value, not a "
"memory address. This is the most common thing one would reach for and would "
"replace `static` as we know it today in almost all cases."
msgstr ""

#: src/0246-const-vs-static.md:13
msgid ""
"**statics** declare _global variables_. These represent a memory address.  "
"They would be rarely used: the primary use cases are global locks, global "
"atomic counters, and interfacing with legacy C libraries."
msgstr ""

#: src/0246-const-vs-static.md:18
msgid "Motivation"
msgstr "動機"

#: src/0246-const-vs-static.md:20
msgid ""
"We have been wrestling with the best way to represent globals for some "
"times. There are a number of interrelated issues:"
msgstr ""

#: src/0246-const-vs-static.md:23
msgid ""
"_Significant addresses and inlining:_ For optimization purposes, it is "
"useful to be able to inline constant values directly into the program. It is "
"even more useful if those constant values do not have known addresses, "
"because that means the compiler is free to replicate them as it wishes. "
"Moreover, if a constant is inlined into downstream crates, then they must be "
"recompiled whenever that constant changes."
msgstr ""

#: src/0246-const-vs-static.md:29
msgid ""
"_Read-only memory:_ Whenever possible, we'd like to place large constants "
"into read-only memory. But this means that the data must be truly immutable, "
"or else a segfault will result."
msgstr ""

#: src/0246-const-vs-static.md:32
msgid ""
"_Global atomic counters and the like:_ We'd like to make it possible for "
"people to create global locks or atomic counters that can be used without "
"resorting to unsafe code."
msgstr ""

#: src/0246-const-vs-static.md:35
msgid ""
"_Interfacing with C code:_ Some C libraries require the use of global, "
"mutable data. Other times it's just convenient and threading is not a "
"concern."
msgstr ""

#: src/0246-const-vs-static.md:38
msgid ""
"_Initializer constants:_ There must be a way to have initializer constants "
"for things like locks and atomic counters, so that people can write `static "
"MY_COUNTER: AtomicUint = INIT_ZERO` or some such. It should not be possible "
"to modify these initializer constants."
msgstr ""

#: src/0246-const-vs-static.md:44
msgid ""
"The current design is that we have only one keyword, `static`, which "
"declares a global variable. By default, global variables do not have "
"significant addresses and can be inlined into the program. You can make a "
"global variable have a _significant_ address by marking it "
"`#[inline(never)]`. Furthermore, you can declare a mutable global using "
"`static mut`: all accesses to `static mut` variables are considered unsafe. "
"Because we wish to allow `static` values to be placed in read-only memory, "
"they are forbidden from having a type that includes interior mutable data "
"(that is, an appearance of `UnsafeCell` type)."
msgstr ""

#: src/0246-const-vs-static.md:55
msgid "Some concrete problems with this design are:"
msgstr ""

#: src/0246-const-vs-static.md:57
msgid ""
"There is no way to have a safe global counter or lock. Those must be placed "
"in `static mut` variables, which means that access to them is illegal. To "
"resolve this, there is an alternative proposal, according to which, access "
"to `static mut` is considered safe if the type of the static mut meets the "
"`Sync` trait."
msgstr ""

#: src/0246-const-vs-static.md:62
msgid ""
"The significance (no pun intended) of the `#[inline(never)]` annotation is "
"not intuitive."
msgstr ""

#: src/0246-const-vs-static.md:64
msgid "There is no way to have a generic type constant."
msgstr ""

#: src/0246-const-vs-static.md:66
msgid "Other less practical and more aesthetic concerns are:"
msgstr ""

#: src/0246-const-vs-static.md:68
msgid ""
"Although `static` and `let` look and feel analogous, the two behave quite "
"differently.  Generally speaking, `static` declarations do not declare "
"variables but rather values, which can be inlined and which do not have "
"fixed addresses. You cannot have interior mutability in a `static` variable, "
"but you can in a `let`. So that `static` variables can appear in patterns, "
"it is illegal to shadow a `static` variable -- but `let` variables cannot "
"appear in patterns. Etc."
msgstr ""

#: src/0246-const-vs-static.md:75
msgid ""
"There are other constructs in the language, such as nullary enum variants "
"and nullary structs, which look like global data but in fact act quite "
"differently. They are actual values which do not have addresses. They are "
"categorized as rvalues and so forth."
msgstr ""

#: src/0246-const-vs-static.md:80
msgid "Detailed design"
msgstr "詳細設計"

#: src/0246-const-vs-static.md:82
msgid "Constants"
msgstr ""

#: src/0246-const-vs-static.md:84
msgid "Reintroduce a `const` declaration which declares a _constant_:"
msgstr ""

#: src/0246-const-vs-static.md:88
msgid ""
"Constants may be declared in any scope. They cannot be shadowed. Constants "
"are considered rvalues. Therefore, taking the address of a constant actually "
"creates a spot on the local stack -- they by definition have no significant "
"addresses. Constants are intended to behave exactly like nullary enum "
"variants."
msgstr ""

#: src/0246-const-vs-static.md:94
msgid "Possible extension: Generic constants"
msgstr ""

#: src/0246-const-vs-static.md:96
msgid ""
"As a possible extension, it is perfectly reasonable for constants to have "
"generic parameters. For example, the following constant is legal:"
msgstr ""

#: src/0246-const-vs-static.md:102
msgid ""
"Note that this makes no sense for a `static` variable, which represents a "
"memory location and hence must have a concrete type."
msgstr ""

#: src/0246-const-vs-static.md:105
msgid "Possible extension: constant functions"
msgstr ""

#: src/0246-const-vs-static.md:107
msgid ""
"It is possible to imagine constant functions as well. This could help to "
"address the problem of encapsulating initialization. To avoid the need to "
"specify what kinds of code can execute in a constant function, we can limit "
"them syntactically to a single constant expression that can be expanded at "
"compilation time (no recursion)."
msgstr ""

#: src/0246-const-vs-static.md:119
msgid ""
"This would allow us to make the `value` field on `UnsafeCell` private, among "
"other things."
msgstr ""

#: src/0246-const-vs-static.md:122
msgid "Static variables"
msgstr ""

#: src/0246-const-vs-static.md:124
msgid ""
"Repurpose the `static` declaration to declare static variables only. Static "
"variables always have single addresses. `static` variables can optionally be "
"declared as `mut`. The lifetime of a `static` variable is `'static`. It is "
"not legal to move from a static. Accesses to a static variable generate "
"actual reads and writes: the value is not inlined (but see \"Unresolved "
"Questions\" below)."
msgstr ""

#: src/0246-const-vs-static.md:131
msgid ""
"Non-`mut` statics must have a type that meets the `Sync` bound. All access "
"to the static is considered safe (that is, reading the variable and taking "
"its address).  If the type of the static does not contain an `UnsafeCell` in "
"its interior, the compiler may place it in read-only memory, but otherwise "
"it must be placed in mutable memory."
msgstr ""

#: src/0246-const-vs-static.md:137
msgid ""
"`mut` statics may have any type. All access is considered unsafe. They may "
"not be placed in read-only memory."
msgstr ""

#: src/0246-const-vs-static.md:140
msgid "Globals referencing Globals"
msgstr ""

#: src/0246-const-vs-static.md:142
msgid "const => const"
msgstr ""

#: src/0246-const-vs-static.md:144
msgid ""
"It is possible to create a `const` or a `static` which references another "
"`const` or another `static` by its address. For example:"
msgstr ""

#: src/0246-const-vs-static.md:151
msgid ""
"Constants are generally inlined into the stack frame from which they are "
"referenced, but in a static context there is no stack frame. Instead, the "
"compiler will reinterpret this as if it were written as:"
msgstr ""

#: src/0246-const-vs-static.md:162
msgid ""
"Here a `static` is introduced to be able to give the `const` a pointer which "
"does indeed have the `'static` lifetime. Due to this rewriting, the compiler "
"will disallow `SomeStruct` from containing an `UnsafeCell` (interior "
"mutability). In general, a constant A cannot reference the address of "
"another constant B if B contains an `UnsafeCell` in its interior."
msgstr ""

#: src/0246-const-vs-static.md:168
msgid "const => static"
msgstr ""

#: src/0246-const-vs-static.md:170
msgid ""
"It is illegal for a constant to refer to another static. A constant "
"represents a _constant_ value while a static represents a memory location, "
"and this sort of reference is difficult to reconcile in light of their "
"definitions."
msgstr ""

#: src/0246-const-vs-static.md:174
msgid "static => const"
msgstr ""

#: src/0246-const-vs-static.md:176
msgid ""
"If a `static` references the address of a `const`, then a similar rewriting "
"happens, but there is no interior mutability restriction (only a `Sync` "
"restriction)."
msgstr ""

#: src/0246-const-vs-static.md:180
msgid "static => static"
msgstr ""

#: src/0246-const-vs-static.md:182
msgid ""
"It is illegal for a `static` to reference another `static` by value. It is "
"required that all references be borrowed. Additionally, not all kinds of "
"borrows are allowed, only explicitly taking the address of another static is "
"allowed. For example, interior borrows of fields and elements or accessing "
"elements of an array are both disallowed."
msgstr ""

#: src/0246-const-vs-static.md:188
msgid ""
"If a by-value reference were allowed, then this sort of reference would "
"require that the static being referenced fall into one of two categories:"
msgstr ""

#: src/0246-const-vs-static.md:191
msgid "It's an initializer pattern. This is the purpose of `const`, however."
msgstr ""

#: src/0246-const-vs-static.md:192
msgid "The values are kept in sync. This is currently technically infeasible."
msgstr ""

#: src/0246-const-vs-static.md:194
msgid ""
"Instead of falling into one of these two categories, the compiler will "
"instead disallow any references to statics by value (from other statics)."
msgstr ""

#: src/0246-const-vs-static.md:197
msgid "Patterns"
msgstr ""

#: src/0246-const-vs-static.md:199
msgid ""
"Today, a `static` is allowed to be used in pattern matching. With the "
"introduction of `const`, however, a `static` will be forbidden from "
"appearing in a pattern match, and instead only a `const` can appear."
msgstr ""

#: src/0246-const-vs-static.md:203
msgid "Drawbacks"
msgstr ""

#: src/0246-const-vs-static.md:205
msgid ""
"This RFC introduces two keywords for global data. Global data is kind of an "
"edge feature so this feels like overkill. (On the other hand, the only "
"keyword that most Rust programmers should need to know is `const` -- I "
"imagine `static` variables will be used quite rarely.)"
msgstr ""

#: src/0246-const-vs-static.md:210
msgid "Alternatives"
msgstr "替代方案"

#: src/0246-const-vs-static.md:212
msgid ""
"The other design under consideration is to keep the current split but make "
"access to `static mut` be considered safe if the type of the static mut is "
"`Sync`. For the details of this discussion, please see [RFC 177](https://"
"github.com/rust-lang/rfcs/pull/177)."
msgstr ""

#: src/0246-const-vs-static.md:217
msgid ""
"One serious concern is with regard to timing. Adding more things to the Rust "
"1.0 schedule is inadvisable. Therefore, it would be possible to take a "
"hybrid approach: keep the current `static` rules, or perhaps the variation "
"where access to `static mut` is safe, for the time being, and create `const` "
"declarations after Rust 1.0 is released."
msgstr ""

#: src/0246-const-vs-static.md:223
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/0246-const-vs-static.md:225
msgid ""
"Should the compiler be allowed to inline the values of `static` variables "
"which are deeply immutable (and thus force recompilation)?"
msgstr ""

#: src/0246-const-vs-static.md:228
msgid ""
"Should we permit `static` variables whose type is not `Sync`, but simply "
"make access to them unsafe?"
msgstr ""

#: src/0246-const-vs-static.md:231
msgid ""
"Should we permit `static` variables whose type is not `Sync`, but whose "
"initializer value does not actually contain interior mutability? For "
"example, a `static` of `Option<UnsafeCell<uint>>` with the initializer of "
"`None` is in theory safe."
msgstr ""

#: src/0246-const-vs-static.md:236
msgid ""
"How hard are the envisioned extensions to implement? If easy, they would be "
"nice to have. If hard, they can wait."
msgstr ""
