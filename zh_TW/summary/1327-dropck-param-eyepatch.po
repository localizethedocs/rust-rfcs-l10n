msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:43Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/1327-dropck-param-eyepatch.md:1
msgid "Feature Name: dropck_eyepatch, generic_param_attrs"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:2
msgid "Start Date: 2015-10-19"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#1327](https://github.com/rust-lang/rfcs/pull/1327)"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:4
msgid ""
"Rust Issue: [rust-lang/rust#34761](https://github.com/rust-lang/rust/"
"issues/34761)"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:6
msgid "Summary"
msgstr "摘要"

#: src/1327-dropck-param-eyepatch.md:9
msgid ""
"Refine the unguarded-escape-hatch from [RFC 1238](https://github.com/rust-"
"lang/rfcs/blob/master/text/1238-nonparametric-dropck.md) (nonparametric "
"dropck) so that instead of a single attribute side-stepping _all_ dropck "
"constraints for a type's destructor, we instead have a more focused system "
"that specifies exactly which type and/or lifetime parameters the destructor "
"is guaranteed not to access."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:15
msgid ""
"Specifically, this RFC proposes adding the capability to attach attributes "
"to the binding sites for generic parameters (i.e. lifetime and type "
"parameters). Atop that capability, this RFC proposes adding a "
"`#[may_dangle]` attribute that indicates that a given lifetime or type holds "
"data that must not be accessed during the dynamic extent of that `drop` "
"invocation."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:22
msgid ""
"As a side-effect, enable adding attributes to the formal declarations of "
"generic type and lifetime parameters."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:25
msgid ""
"The proposal in this RFC is intended as a _temporary_ solution (along the "
"lines of `#[fundamental]` and _will not_ be stabilized as-is. Instead, we "
"anticipate a more comprehensive approach to be proposed in a follow-up RFC."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:33
msgid "Motivation"
msgstr "動機"

#: src/1327-dropck-param-eyepatch.md:36
msgid ""
"The unguarded escape hatch (UGEH) from [RFC 1238](https://github.com/rust-"
"lang/rfcs/blob/master/text/1238-nonparametric-dropck.md) is a blunt "
"instrument: when you use `unsafe_destructor_blind_to_params`, it is "
"asserting that your destructor does not access borrowed data whose type "
"includes _any_ lifetime or type parameter of the type."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:41
msgid ""
"For example, the current destructor for `RawVec<T>` (in `liballoc/`) looks "
"like this:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:47 src/1327-dropck-param-eyepatch.md:108
#: src/1327-dropck-param-eyepatch.md:324 src/1327-dropck-param-eyepatch.md:496
msgid ""
"/// Frees the memory owned by the RawVec *without* trying to Drop its "
"contents.\n"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:54
msgid ""
"The above is sound today, because the above destructor does not call any "
"methods that can access borrowed data in the values of type `T`, and so we "
"do not need to enforce the drop-ordering constraints imposed when you leave "
"out the `unsafe_destructor_blind_to_params` attribute."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:59
msgid ""
"While the above attribute suffices for many use cases today, it is not fine-"
"grain enough for other cases of interest. In particular, it cannot express "
"that the destructor will not access borrowed data behind a _subset_ of the "
"type parameters."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:64
msgid "Here are two concrete examples of where the need for this arises:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:66
msgid "Example: `CheckedHashMap`"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:68
msgid ""
"The original Sound Generic Drop proposal ([RFC 769](https://github.com/rust-"
"lang/rfcs/blob/master/text/0769-sound-generic-drop.md)) had an [appendix]"
"(https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop."
"md#appendix-a-why-and-when-would-drop-read-from-borrowed-data) with an "
"example of a `CheckedHashMap<K, V>` type that called the hashcode method for "
"all of the keys in the map in its destructor. This is clearly a type where "
"we _cannot_ claim that we do not access borrowed data potentially hidden "
"behind `K`, so it would be unsound to use the blunt "
"`unsafe_destructor_blind_to_params` attribute on this type."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:77
msgid ""
"However, the values of the `V` parameter to `CheckedHashMap` are, in all "
"likelihood, _not_ accessed by the `CheckedHashMap` destructor. If that is "
"the case, then it should be sound to instantiate `V` with a type that "
"contains references to other parts of the map (e.g., references to the keys "
"or to other values in the map). However, we cannot express this today: There "
"is no way to say that the `CheckedHashMap` will not access borrowed data "
"that is behind _just_ `V`."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:88
msgid "Example: `Vec<T, A:Allocator=DefaultAllocator>`"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:90
msgid ""
"The Rust developers have been talking for [a long time](https://github.com/"
"rust-lang/rfcs/issues/538) about adding an `Allocator` trait that would "
"allow users to override the allocator used for the backing storage of "
"collection types like `Vec` and `HashMap`."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:95
msgid ""
"For example, we would like to generalize the `RawVec` given above as follows:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:115
msgid ""
"However, we _cannot_ soundly add an allocator parameter to a collection that "
"today uses the `unsafe_destructor_blind_to_params` UGEH attribute in the "
"destructor that deallocates, because that blunt instrument would allow "
"someone to write this:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:121
msgid ""
"// (`ArenaAllocator`, when dropped, automatically frees its allocated "
"blocks)\n"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:122
msgid "// (Usual pattern for assigning same extent to `v` and `a`.)\n"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:130
msgid ""
"// at end of scope, `a` may be dropped before `v`, invalidating\n"
"// soundness of subsequent invocation of destructor for `v` (because\n"
"// that would try to free buffer of `v` via `v.buf.alloc` (== `&a`)).\n"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:136
msgid ""
"The only way today to disallow the above unsound code would be to remove "
"`unsafe_destructor_blind_to_params` from `RawVec`/ `Vec`, which would break "
"other code (for example, code using `Vec` as the backing storage for [cyclic "
"graph structures](https://github.com/rust-lang/rust/"
"blob/098a7a07ee6d11cf6d2b9d18918f26be95ee2f66/src/test/run-pass/"
"dropck_legal_cycles.rs))."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:145
msgid "Detailed design"
msgstr "詳細設計"

#: src/1327-dropck-param-eyepatch.md:148
msgid ""
"First off: The proposal in this RFC is intended as a _temporary_ solution "
"(along the lines of `#[fundamental]` and _will not_ be stabilized as-is. "
"Instead, we anticipate a more comprehensive approach to be proposed in a "
"follow-up RFC."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:153
msgid "Having said that, here is the proposed short-term solution:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:155
msgid ""
"Add the ability to attach attributes to syntax that binds formal lifetime or "
"type parameters. For the purposes of this RFC, the only place in the syntax "
"that requires such attributes are `impl` blocks, as in `impl<T> Drop for "
"Type<T> { ... }`"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:160
msgid ""
"Add a new fine-grained attribute, `may_dangle`, which is attached to the "
"binding sites for lifetime or type parameters on an `Drop` implementation. "
"This RFC will sometimes call this attribute the \"eyepatch\", since it does "
"not make dropck totally blind; just blind on one \"side\"."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:167
msgid ""
"Add a new requirement that any `Drop` implementation that uses the "
"`#[may_dangle]` attribute must be declared as an `unsafe impl`. This "
"reflects the fact that such `Drop` implementations have an additional "
"constraint on their behavior (namely that they cannot access certain kinds "
"of data) that will not be verified by the compiler and thus must be verified "
"by the programmer."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:174
msgid ""
"Remove `unsafe_destructor_blind_to_params`, since all uses of it should be "
"expressible via `#[may_dangle]`."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:177
msgid "Attributes on lifetime or type parameters"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:179
msgid "This is a simple extension to the syntax."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:181
msgid "It is guarded by the feature gate `generic_param_attrs`."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:183
msgid "Constructions like the following will now become legal."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:185
msgid "Example of eyepatch attribute on a single type parameter:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:192
msgid "Example of eyepatch attribute on a lifetime parameter:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:199
msgid "Example of eyepatch attribute on multiple parameters:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:206
msgid ""
"These attributes are only written next to the formal binding sites for the "
"generic parameters. The _usage_ sites, points which refer back to the "
"parameters, continue to disallow the use of attributes."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:211
msgid "So while this is legal syntax:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:219
msgid "the follow would be illegal syntax (at least for now):"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:228
msgid "The \"eyepatch\" attribute"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:230
msgid "Add a new attribute, `#[may_dangle]` (the \"eyepatch\")."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:232
msgid "It is guarded by the feature gate `dropck_eyepatch`."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:234
msgid ""
"The eyepatch is similar to `unsafe_destructor_blind_to_params`: it is part "
"of the `Drop` implementation, and it is meant to assert that a destructor is "
"guaranteed not to access certain kinds of data accessible via `self`."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:239
msgid ""
"The main difference is that the eyepatch is applied to a single generic "
"parameter: `#[may_dangle] ARG`. This specifies exactly _what_ the destructor "
"is blind to (i.e., what will dropck treat as inaccessible from the "
"destructor for this type)."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:245
msgid ""
"There are two things one can supply as the `ARG` for a given eyepatch: one "
"of the type parameters for the type, or one of the lifetime parameters for "
"the type."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:250
msgid ""
"When used on a type, e.g. `#[may_dangle] T`, the programmer is asserting the "
"only uses of values of that type will be to move or drop them. Thus, no "
"fields will be accessed nor methods called on values of such a type (apart "
"from any access performed by the destructor for the type when the values are "
"dropped). This ensures that no dangling references (such as when `T` is "
"instantiated with `&'a u32`) are ever accessed in the scenario where `'a` "
"has the same lifetime as the value being currently destroyed (and thus the "
"precise order of destruction between the two is unknown to the compiler)."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:260
msgid ""
"When used on a lifetime, e.g. `#[may_dangle] 'a`, the programmer is "
"asserting that no data behind a reference of lifetime `'a` will be accessed "
"by the destructor. Thus, no fields will be accessed nor methods called on "
"values of type `&'a Struct`, ensuring that again no dangling references are "
"ever accessed by the destructor."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:266
msgid "Require `unsafe` on Drop implementations using the eyepatch"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:268
msgid ""
"The final detail is to add an additional check to the compiler to ensure "
"that any use of `#[may_dangle]` on a `Drop` implementation imposes a "
"requirement that that implementation block use `unsafe impl`.<sup>[2]"
"(#footnote1)</sup>"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:273
msgid ""
"This reflects the fact that use of `#[may_dangle]` is a programmer-provided "
"assertion about the behavior of the `Drop` implementation that must be "
"valided manually by the programmer. It is analogous to other uses of `unsafe "
"impl` (apart from the fact that the `Drop` trait itself is not an `unsafe "
"trait`)."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:279
msgid "Examples adapted from the Rustonomicon"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:283
msgid ""
"So, adapting some examples from the Rustonomicon [Drop Check](https://doc."
"rust-lang.org/nightly/nomicon/dropck.html) chapter, we would be able to "
"write the following."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:287
msgid "Example of eyepatch on a lifetime parameter::"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:294
msgid "\"InspectorA(_, {}) knows when *not* to inspect.\""
msgstr ""

#: src/1327-dropck-param-eyepatch.md:299
msgid "Example of eyepatch on a type parameter:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:308
msgid "\"InspectorB(_, {}) knows when *not* to inspect.\""
msgstr ""

#: src/1327-dropck-param-eyepatch.md:313
msgid ""
"Both of the above two examples are much the same as if we had used the old "
"`unsafe_destructor_blind_to_params` UGEH attribute."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:316
msgid "Example: RawVec"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:318
msgid ""
"To generalize `RawVec` from the [motivation](#motivation) with an "
"`Allocator` correctly (that is, soundly and without breaking existing code), "
"we would now write:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:331
msgid ""
"The use of `#[may_dangle] T` here asserts that even though the destructor "
"may access borrowed data through `A` (and thus dropck must impose drop-"
"ordering constraints for lifetimes occurring in the type of `A`), the "
"developer is guaranteeing that no access to borrowed data will occur via the "
"type `T`."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:337
msgid ""
"The latter is not expressible today even with "
"`unsafe_destructor_blind_to_params`; there is no way to say that a type will "
"not access `T` in its destructor while also ensuring the proper drop-"
"ordering relationship between `RawVec<T, A>` and `A`."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:342
msgid "Example; Multiple Lifetimes"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:344
msgid ""
"Example: The above `InspectorA` carried a `&'static str` that was always "
"safe to access from the destructor."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:347
msgid "If we wanted to generalize this type a bit, we might write:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:354
msgid "\"InspectorA(_, {}, _) knows when *not* to inspect.\""
msgstr ""

#: src/1327-dropck-param-eyepatch.md:359
msgid ""
"This type, like `InspectorA`, is careful to only access the `&str` that it "
"holds in its destructor; but now the borrowed string slice does not have "
"`'static` lifetime, so we must make sure that we do not claim that we are "
"blind to its lifetime (`'b`)."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:364
msgid ""
"(This example also illustrates that one can attach multiple instances of the "
"eyepatch attribute to a destructor, each with a distinct input for its "
"`ARG`.)"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:368
msgid "Given the definition above, this code will compile and run properly:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:372
msgid "// ensure that `b` strictly outlives `i`.\n"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:374 src/1327-dropck-param-eyepatch.md:387
msgid "\"a\""
msgstr ""

#: src/1327-dropck-param-eyepatch.md:375 src/1327-dropck-param-eyepatch.md:388
msgid "\"b\""
msgstr ""

#: src/1327-dropck-param-eyepatch.md:376 src/1327-dropck-param-eyepatch.md:389
msgid "\"c\""
msgstr ""

#: src/1327-dropck-param-eyepatch.md:381
msgid "while this code will be rejected by the compiler:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:386
msgid "// OOPS: `b` not guaranteed to survive for `i`'s destructor.\n"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:394
msgid "Semantics"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:396
msgid "How does this work, you might ask?"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:398
msgid ""
"The idea is actually simple: the dropck rule stays mostly the same, except "
"for a small twist."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:401
msgid "The Drop-Check rule at this point essentially says:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:403
msgid "if the type of `v` owns data of type `D`, where"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:405
msgid ""
"(1.) the `impl Drop for D` is either type-parametric, or lifetime-parametric "
"over `'a`, and (2.) the structure of `D` can reach a reference of type `&'a "
"_`,"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:408
msgid "then `'a` must strictly outlive the scope of `v`"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:410
msgid ""
"The main change we want to make is to the second condition. Instead of just "
"saying \"the structure of `D` can reach a reference of type `&'a _`\", we "
"want first to replace eyepatched lifetimes and types within `D` with "
"`'static` and `()`, respectively. Call this revised type `patched(D)`."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:415
msgid "Then the new condition is:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:417
msgid "(2.) the structure of patched(D) can reach a reference of type `&'a _`,"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:419
msgid "_Everything_ else is the same."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:421
msgid ""
"In particular, the patching substitution is _only_ applied with respect to a "
"particular destructor. Just because `Vec<T>` is blind to `T` does not mean "
"that we will ignore the actual type instantiated at `T` in terms of drop-"
"ordering constraints."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:426
msgid ""
"For example, in `Vec<InspectorC<'a,'name,'c>>`, even though `Vec` itself is "
"blind to the whole type `InspectorC<'a, 'name, 'c>` when we are considering "
"the `impl Drop for Vec`, we _still_ honor the constraint that `'name` must "
"strictly outlive the `Vec` (because we continue to consider all `D` that is "
"data owned by a value `v`, including when `D` == `InspectorC<'a,'name,'c>`)."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:433
msgid "Prototype"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:436
msgid ""
"pnkfelix has implemented a proof-of-concept [implementation](https://github."
"com/pnkfelix/rust/commits/dropck-eyepatch) of the `#[may_dangle]` attribute. "
"It uses the substitution machinery we already have in the compiler to "
"express the semantics above."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:441
msgid "Limitations of prototype (not part of design)"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:443
msgid ""
"Here we note a few limitations of the current prototype. These limitations "
"are _not_ being proposed as part of the specification of the feature."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:447
msgid ""
"<a name=\"footnote1\">2.</a> The compiler does not yet enforce (or even "
"allow) the use of `unsafe impl` for `Drop` implementations that use the "
"`#[may_dangle]` attribute."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:451
msgid ""
"Fixing the above limitations should just be a matter of engineering, not a "
"fundamental hurdle to overcome in the feature's design in the context of the "
"language."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:457
msgid "Drawbacks"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:460
msgid "Ugliness"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:462
msgid ""
"This attribute, like the original `unsafe_destructor_blind_to_params` UGEH "
"attribute, is ugly."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:465
msgid "Unchecked assertions boo"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:467
msgid ""
"It would be nicer if to actually change the language in a way where we could "
"check the assertions being made by the programmer, rather than trusting "
"them. (pnkfelix has some thoughts on this, which are mostly reflected in "
"what he wrote in the [RFC 1238 alternatives](https://github.com/rust-lang/"
"rfcs/blob/master/text/1238-nonparametric-dropck.md#continue-supporting-"
"parametricity).)"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:474
msgid "Alternatives"
msgstr "替代方案"

#: src/1327-dropck-param-eyepatch.md:477
msgid ""
"Note: The alternatives section for this RFC is particularly note-worthy "
"because the ideas here may serve as the basis for a more comprehensive long-"
"term approach."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:481
msgid "Make dropck \"see again\" via (focused) where-clauses"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:483
msgid ""
"The idea is that we keep the UGEH attribute, blunt hammer that it is. You "
"first opt out of the dropck ordering constraints via that, and then you add "
"back in ordering constraints via `where` clauses."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:487
msgid ""
"(The ordering constraints in question would normally be _implied_ by the "
"dropck analysis; the point is that UGEH is opting out of that analysis, and "
"so we are now adding them back in.)"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:491
msgid "Here is the allocator example expressed in this fashion:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:498
msgid ""
"//                        ~~~~~~~~~~~\n"
"    //                             |\n"
"    //                             |\n"
"    // This constraint (that `A` outlives `'s`), and other conditions\n"
"    // relating `'s` and `Self` are normally implied by Rust's type\n"
"    // system, but `unsafe_destructor_blind_to_params` opts out of\n"
"    // enforcing them. This `where`-clause is opting back into *just*\n"
"    // the `A:'s` again.\n"
"    //\n"
"    // Note we are *still* opting out of `T: 's` via\n"
"    // `unsafe_destructor_blind_to_params`, and thus our overall\n"
"    // goal (of not breaking code that relies on `T` not having to\n"
"    // survive the destructor call) is accomplished.\n"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:517
msgid ""
"This approach, if we can make it work, seems fine to me. It certainly avoids "
"a number of problems that the eyepatch attribute has."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:520
msgid "Advantages of fn-drop-with-where-clauses:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:522
msgid ""
"Since the eyepatch attribute is to be limited to type and lifetime "
"parameters, this approach is more expressive, since it would allow one to "
"put type-projections into the constraints."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:527
msgid "Drawbacks of fn-drop-with-where-clauses:"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:529
msgid ""
"Its not 100% clear what our implementation strategy will be for it, while "
"the eyepatch attribute does have a [prototype](#prototype)."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:532
msgid ""
"I actually do not give this drawback much weight; resolving this may be "
"merely a matter of just trying to do it: e.g., build up the set of where-"
"clauses when we make the ADT's representations, and then have `dropck` "
"insert instantiate and insert them as needed."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:537
msgid ""
"It might have the wrong ergonomics for developers: It seems bad to have the "
"blunt hammer introduce all sorts of potential unsoundness, and rely on the "
"developer to keep the set of `where`\\-clauses on the `fn drop` up to date."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:542
msgid ""
"This would be a pretty bad drawback, _if_ the language and compiler were to "
"stagnate. But my intention/goal is to eventually put in a [sound compiler "
"analysis](#wait-for-proper-parametricity). In other words, in the future, I "
"will be more concerned about the ergonomics of the code that uses the sound "
"analysis. I will not be concerned about \"gotcha's\" associated with the "
"UGEH escape hatch."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:549
msgid ""
"(The most important thing I want to convey is that I believe that both the "
"eyepatch attribute and fn-drop-with-where-clauses are capable of resolving "
"the real issues that I face today, and I would be happy for either proposal "
"to be accepted.)"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:554
msgid "Wait for proper parametricity"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:557
msgid ""
"As alluded to in the [drawbacks](#drawbacks), in principle we could provide "
"similar expressiveness to that offered by the eyepatch (which is acting as a "
"fine-grained escape hatch from dropck) by instead offering some language "
"extension where the compiler would actually analyze the code based on "
"programmer annotations indicating which types and lifetimes are not used by "
"a function."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:564
msgid ""
"In my opinion I am of two minds on this (but they are both in favor this RFC "
"rather than waiting for a sound compiler analysis):"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:567
msgid ""
"We will always need an escape hatch. The programmer will always need a way "
"to assert something that she knows to be true, even if the compiler cannot "
"prove it. (A simple example: Calling a third-party API that has not yet "
"added the necessary annotations.)"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:572
msgid ""
"This RFC is proposing that we keep an escape hatch, but we make it more "
"expressive."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:575
msgid ""
"If we eventually _do_ have a sound compiler analysis, I see the compiler "
"changes and library annotations suggested by this RFC as being in line with "
"what that compiler analysis would end up using anyway. In other words: "
"Assume we _did_ add some way for the programmer to write that `T` is "
"parametric (e.g. `T: ?Special` in the [RFC 1238 alternatives](https://github."
"com/rust-lang/rfcs/blob/master/text/1238-nonparametric-dropck.md#continue-"
"supporting-parametricity)). Even then, we would still need the compiler "
"changes suggested by this RFC, and at that point hopefully the task would be "
"for the programmer to mechanically replace occurrences of `#[may_dangle] T` "
"with `T: ?Special` (and then see if the library builds)."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:585
msgid ""
"In other words, I see the form suggested by this RFC as being a step "
"_towards_ a proper analysis, in the sense that it is getting programmers "
"used to thinking about the individual parameters and their relationship with "
"the container, rather than just reasoning about the container on its own "
"without any consideration of each type/lifetime parameter."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:591
msgid "Do nothing"
msgstr ""

#: src/1327-dropck-param-eyepatch.md:593
msgid "If we do nothing, then we cannot add `Vec<T, A:Allocator>` soundly."
msgstr ""

#: src/1327-dropck-param-eyepatch.md:595
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/1327-dropck-param-eyepatch.md:598
msgid ""
"Is the definition of the drop-check rule sound with this `patched(D)` "
"variant?  (We have not proven any previous variation of the rule sound; I "
"think it would be an interesting student project though.)"
msgstr ""
