msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:44Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2344-const-looping.md:1
msgid "Feature Name: `const_looping`"
msgstr ""

#: src/2344-const-looping.md:2
msgid "Start Date: 2018-02-18"
msgstr ""

#: src/2344-const-looping.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2344](https://github.com/rust-lang/rfcs/pull/2344)"
msgstr ""

#: src/2344-const-looping.md:4
msgid ""
"Rust Issue: [rust-lang/rust#52000](https://github.com/rust-lang/rust/"
"issues/52000)"
msgstr ""

#: src/2344-const-looping.md:6
msgid "Summary"
msgstr "摘要"

#: src/2344-const-looping.md:9
msgid ""
"Allow the use of `loop`, `while` and `while let` during constant evaluation. "
"`for` loops are technically allowed, too, but can't be used in practice "
"because each iteration calls `iterator.next()`, which is not a `const fn` "
"and thus can't be called within constants. Future RFCs (like https://github."
"com/rust-lang/rfcs/pull/2237) might lift that restriction."
msgstr ""

#: src/2344-const-looping.md:15
msgid "Motivation"
msgstr "動機"

#: src/2344-const-looping.md:18
msgid ""
"Any iteration is expressible with recursion. Since we already allow "
"recursion via const fn and termination of said recursion via `if` or "
"`match`, all code enabled by const recursion is already legal now. Some "
"algorithms are better expressed as imperative loops and a lot of Rust code "
"uses loops instead of recursion. Allowing loops in constants will allow more "
"functions to become const fn without requiring any changes."
msgstr ""

#: src/2344-const-looping.md:25
msgid "Guide-level explanation"
msgstr ""

#: src/2344-const-looping.md:28
msgid ""
"If you previously had to write functional code inside constants, you can now "
"change it to imperative code. For example if you wrote a fibonacci like"
msgstr ""

#: src/2344-const-looping.md:41
msgid ""
"which takes exponential time to compute a fibonacci number, you could have "
"changed it to the functional loop"
msgstr ""

#: src/2344-const-looping.md:57
msgid ""
"but now you can just write it as an imperative loop, which also finishes in "
"linear time."
msgstr ""

#: src/2344-const-looping.md:75
msgid "Reference-level explanation"
msgstr ""

#: src/2344-const-looping.md:78
msgid ""
"A loop in MIR is a cyclic graph of `BasicBlock`s. Evaluating such a loop is "
"no different from evaluating a linear sequence of `BasicBlock`s, except that "
"termination is not guaranteed. To ensure that the compiler never hangs "
"indefinitely, we count the number of terminators processed and whenever we "
"reach a fixed limit, we report a lint mentioning that we cannot guarantee "
"that the evaluation will terminate and reset the counter to zero. This lint "
"should recur in a non-annoying amount of time (e.g. at least 30 seconds "
"between occurrences). This means that there's an internal deterministic "
"counter (for the terminators) and a timestamp of the last (if any) loop "
"warning emission. Both the counter needs to reach its limit and 30 seconds "
"have to have passed since the last warning emission in order for a new "
"warning to be emitted."
msgstr ""

#: src/2344-const-looping.md:90
msgid "Drawbacks"
msgstr ""

#: src/2344-const-looping.md:93
msgid ""
"Infinite loops will cause the compiler to never finish if the lint is not "
"denied"
msgstr ""

#: src/2344-const-looping.md:95
msgid "Rationale and alternatives"
msgstr ""

#: src/2344-const-looping.md:98
msgid "Do nothing, users can keep using recursion"
msgstr ""

#: src/2344-const-looping.md:100
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/2344-const-looping.md:103
msgid ""
"Should we add a true recursion check that hashes the interpreter state and "
"detects if it has reached the same state again?"
msgstr ""

#: src/2344-const-looping.md:105
msgid ""
"This will slow down const evaluation enormously and for complex iterations "
"is essentially useless because it'll take forever (e.g. counting from 0 to "
"`u64::max_value()`)"
msgstr ""
