msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:42Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0445-extension-trait-conventions.md:1
msgid "Start Date: 2014-11-05"
msgstr ""

#: src/0445-extension-trait-conventions.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#445](https://github.com/rust-lang/rfcs/pull/445)"
msgstr ""

#: src/0445-extension-trait-conventions.md:3
msgid ""
"Rust Issue: [rust-lang/rust#19324](https://github.com/rust-lang/rust/"
"issues/19324)"
msgstr ""

#: src/0445-extension-trait-conventions.md:5
msgid "Summary"
msgstr "摘要"

#: src/0445-extension-trait-conventions.md:7
msgid ""
"This is a conventions RFC establishing a definition and naming convention "
"for _extension traits_: `FooExt`."
msgstr ""

#: src/0445-extension-trait-conventions.md:10
msgid "Motivation"
msgstr "動機"

#: src/0445-extension-trait-conventions.md:12
msgid ""
"This RFC is part of the ongoing API conventions and stabilization effort."
msgstr ""

#: src/0445-extension-trait-conventions.md:15
msgid ""
"Extension traits are a programming pattern that makes it possible to add "
"methods to an existing type outside of the crate defining that type. While "
"they should be used sparingly, the new [object safety rules](https://github."
"com/rust-lang/rfcs/pull/255) have increased the need for this kind of trait, "
"and hence the need for a clear convention."
msgstr ""

#: src/0445-extension-trait-conventions.md:22
msgid "Detailed design"
msgstr "詳細設計"

#: src/0445-extension-trait-conventions.md:24
msgid "What is an extension trait?"
msgstr ""

#: src/0445-extension-trait-conventions.md:26
msgid ""
"Rust currently allows inherent methods to be defined on a type only in the "
"crate where that type is defined. But it is often the case that clients of a "
"type would like to incorporate additional methods to it. Extension traits "
"are a pattern for doing so:"
msgstr ""

#: src/0445-extension-trait-conventions.md:44
msgid ""
"By defining a new trait, a client of `foo` can add new methods to `Foo`."
msgstr ""

#: src/0445-extension-trait-conventions.md:46
msgid ""
"Of course, adding methods via a new trait happens all the time. What makes "
"it an _extension_ trait is that the trait is not designed for _generic_ use, "
"but only as way of adding methods to a specific type or family of types."
msgstr ""

#: src/0445-extension-trait-conventions.md:51
msgid ""
"This is of course a somewhat subjective distinction. Whenever designing an "
"extension trait, one should consider whether the trait could be used in some "
"more generic way. If so, the trait should be named and exported as if it "
"were just a \"normal\" trait. But traits offering groups of methods that "
"really only make sense in the context of some particular type(s) are true "
"extension traits."
msgstr ""

#: src/0445-extension-trait-conventions.md:58
msgid ""
"The new [object safety rules](https://github.com/rust-lang/rfcs/pull/255) "
"mean that a trait can only be used for trait objects if _all_ of its methods "
"are usable; put differently, it ensures that for \"object safe traits\" "
"there is always a canonical way to implement `Trait` for `Box<Trait>`. To "
"deal with this new rule, it is sometimes necessary to break traits apart "
"into an object safe trait and extension traits:"
msgstr ""

#: src/0445-extension-trait-conventions.md:67
msgid "// The core, object-safe trait\n"
msgstr ""

#: src/0445-extension-trait-conventions.md:71
msgid "// The extension trait offering object-unsafe methods\n"
msgstr ""

#: src/0445-extension-trait-conventions.md:79
msgid "// A blanket impl\n"
msgstr ""

#: src/0445-extension-trait-conventions.md:86
msgid ""
"Note that, although this split-up definition is somewhat more complex, it is "
"also more flexible: because `Box<Iterator<A>>` will implement `Iterator<A>`, "
"you can now use _all_ of the adapter methods provided in `IteratorExt` on "
"trait objects, even though they are not object safe."
msgstr ""

#: src/0445-extension-trait-conventions.md:92
msgid "The convention"
msgstr ""

#: src/0445-extension-trait-conventions.md:94
msgid ""
"The proposed convention is, first of all, to (1) prefer adding default "
"methods to existing traits or (2) prefer generically useful traits to "
"extension traits whenever feasible."
msgstr ""

#: src/0445-extension-trait-conventions.md:98
msgid ""
"For true extension traits, there should be a clear type or trait that they "
"are extending. The extension trait should be called `FooExt` where `Foo` is "
"that type or trait."
msgstr ""

#: src/0445-extension-trait-conventions.md:102
msgid ""
"In some cases, the extension trait only applies conditionally. For example, "
"`AdditiveIterator` is an extension trait currently in `std` that applies to "
"iterators over numeric types. These extension traits should follow a similar "
"convention, putting together the type/trait name and the qualifications, "
"together with the `Ext` suffix: `IteratorAddExt`."
msgstr ""

#: src/0445-extension-trait-conventions.md:109
msgid "What about `Prelude`?"
msgstr ""

#: src/0445-extension-trait-conventions.md:111
msgid ""
"A [previous convention](https://github.com/rust-lang/rfcs/pull/344) used a "
"`Prelude` suffix for extension traits that were also part of the `std` "
"prelude; this new convention deprecates that one."
msgstr ""

#: src/0445-extension-trait-conventions.md:115
msgid "Future proofing"
msgstr ""

#: src/0445-extension-trait-conventions.md:117
msgid ""
"In the future, the need for many of these extension traits may disappear as "
"other languages features are added. For example, method-level `where` "
"clauses will eliminate the need for `AdditiveIterator`. And allowing "
"inherent `impl`s like `impl<T: Trait> T { .. }` for the crate defining "
"`Trait` would eliminate even more."
msgstr ""

#: src/0445-extension-trait-conventions.md:123
msgid ""
"However, there will always be _some_ use of extension traits, and we need to "
"stabilize the 1.0 libraries prior to these language features landing. So "
"this is the proposed convention for now, and in the future it may be "
"possible to deprecate some of the resulting traits."
msgstr ""

#: src/0445-extension-trait-conventions.md:128
msgid "Alternatives"
msgstr "替代方案"

#: src/0445-extension-trait-conventions.md:130
msgid ""
"It seems clear that we need _some_ convention here. Other possible suffixes "
"would be `Util` or `Methods`, but `Ext` is both shorter and connects to the "
"name of the pattern."
msgstr ""

#: src/0445-extension-trait-conventions.md:134
msgid "Drawbacks"
msgstr ""

#: src/0445-extension-trait-conventions.md:136
msgid ""
"In general, extension traits tend to require additional imports -- "
"especially painful when dealing with object safety. However, this is more to "
"do with the language as it stands today than with the conventions in this "
"RFC."
msgstr ""

#: src/0445-extension-trait-conventions.md:141
msgid ""
"Libraries are already starting to export their own `prelude` module "
"containing extension traits among other things, which by convention is glob "
"imported."
msgstr ""

#: src/0445-extension-trait-conventions.md:145
msgid ""
"In the long run, we should add a general \"prelude\" facility for external "
"libraries that makes it possible to _globally_ import a small set of names "
"from the crate. Some early investigations of such a feature are already "
"under way, but are outside the scope of this RFC."
msgstr ""
