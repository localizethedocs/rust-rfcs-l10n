msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:44Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/2025-nested-method-calls.md:1
msgid "Feature Name: nested_method_call"
msgstr ""

#: src/2025-nested-method-calls.md:2
msgid "Start Date: 2017-06-06"
msgstr ""

#: src/2025-nested-method-calls.md:3
msgid ""
"RFC PR: [rust-lang/rfcs#2025](https://github.com/rust-lang/rfcs/pull/2025)"
msgstr ""

#: src/2025-nested-method-calls.md:4
msgid ""
"Rust Issue: [rust-lang/rust#44100](https://github.com/rust-lang/rust/"
"issues/44100)"
msgstr ""

#: src/2025-nested-method-calls.md:6
msgid "Summary"
msgstr "摘要"

#: src/2025-nested-method-calls.md:9
msgid ""
"Enable \"nested method calls\" where the outer call is an `&mut self` "
"borrow, such as `vec.push(vec.len())` (where `vec: Vec<usize>`). This is "
"done by extending MIR with the concept of a **two-phase borrow**; in this "
"model, select `&mut` borrows are modified so that they begin with a "
"\"reservation\" phase and can later be \"activated\" into a full mutable "
"borrow. During the reservation phase, reads and shared borrows of the "
"borrowed data are permitted (but not mutation), as long as they are confined "
"to the reservation period. Once the mutable borrow is activated, it acts "
"like an ordinary mutable borrow."
msgstr ""

#: src/2025-nested-method-calls.md:19
msgid ""
"Two-phase borrows in this RFC are only used when desugaring method calls; "
"this is intended as a conservative step. In the future, if desired, the "
"scheme could be extended to other syntactic forms, or else subsumed as part "
"of non-lexical lifetimes or some other generalization of the lifetime system."
msgstr ""

#: src/2025-nested-method-calls.md:25
msgid "Motivation"
msgstr "動機"

#: src/2025-nested-method-calls.md:28
msgid ""
"The overriding goal here is that we want to accept nested method calls where "
"the outer call is an `&mut self` method, like `vec.push(vec.len())`. This is "
"a common limitation that beginners stumble over and find confusing and which "
"experienced users have as a persistent annoyance. This makes it a natural "
"target to eliminate as part of the [2017 Roadmap](https://github.com/rust-"
"lang/rfcs/blob/master/text/1774-roadmap-2017.md)."
msgstr ""

#: src/2025-nested-method-calls.md:37
msgid ""
"This problem has been extensively discussed on the internals discussion "
"board (e.g., [1](https://internals.rust-lang.org/t/accepting-nested-method-"
"calls-with-an-mut-self-receiver/4588), [2](https://internals.rust-lang.org/t/"
"blog-post-nested-method-calls-via-two-phase-borrowing/4886)), and a number "
"of different approaches to solving it have been proposed. This RFC itself is "
"intended to represent a \"maximally minimal\" approach, in the sense that it "
"tries to avoid making larger changes to the set of Rust code that will be "
"accepted, and instead focuses precisely on the method-call form. It is "
"compatible with the various alternatives, and tries to leave room for future "
"expansion in a variety of directions. See the Alternatives section for more "
"details."
msgstr ""

#: src/2025-nested-method-calls.md:50
msgid "Why do we get an error in the first place?"
msgstr ""

#: src/2025-nested-method-calls.md:52
msgid ""
"You may wonder why this code isn't accepted in the first place. To see why, "
"consider what the (somewhat simplified[^simp]) resulting MIR looks like:"
msgstr ""

#: src/2025-nested-method-calls.md:55
msgid ""
"This MIR is mildly simplified; the real MIR has multiple basic blocks to "
"account for the possibility of panics."
msgstr ""

#: src/2025-nested-method-calls.md:58 src/2025-nested-method-calls.md:150
#: src/2025-nested-method-calls.md:706
msgid "/* 0 */"
msgstr ""

#: src/2025-nested-method-calls.md:58
msgid ""
"// <-- mutable borrow starts here\n"
"/* 1 */"
msgstr ""

#: src/2025-nested-method-calls.md:59
msgid ""
"// <-- shared borrow overlaps here\n"
"/* 2 */"
msgstr ""

#: src/2025-nested-method-calls.md:60 src/2025-nested-method-calls.md:152
msgid "/* 3 */"
msgstr ""

#: src/2025-nested-method-calls.md:61
msgid ""
"// <-- shared borrow ends here\n"
"/* 3 */"
msgstr ""

#: src/2025-nested-method-calls.md:62
msgid "/* 5 */"
msgstr ""

#: src/2025-nested-method-calls.md:63
msgid "// <-- mutable borrow ends here\n"
msgstr ""

#: src/2025-nested-method-calls.md:66
msgid ""
"As you can see, we first take a mutable reference to `vec` for `tmp0`. This "
"\"locks\" `vec` from being accessed in any other way until after the call to "
"`Vec::push()`, but then we try to access it again when calling `vec.len()`. "
"Hence the error."
msgstr ""

#: src/2025-nested-method-calls.md:71
msgid ""
"(In this MIR, I've included the `EndRegion` annotations that the current MIR "
"borrowck relies on. In most examples, I will elide them unless they are "
"needed to make a point. Also, in the future, when we move to NLL, those "
"statements will not be present, and regions will be inferred based solely on "
"where the references are _used_, but the general idea remains the same.)"
msgstr ""

#: src/2025-nested-method-calls.md:78
msgid ""
"When you see the code desugared in that way, it should not surprise you that "
"there is in fact a real danger here for code to crash if we just \"turned "
"off\" this check (if we even could do such a thing). For example, consider "
"this rather artificial Rust program:"
msgstr ""

#: src/2025-nested-method-calls.md:84 src/2025-nested-method-calls.md:167
msgid "\"Hello, \""
msgstr ""

#: src/2025-nested-method-calls.md:85 src/2025-nested-method-calls.md:168
msgid "\"foo\""
msgstr ""

#: src/2025-nested-method-calls.md:86 src/2025-nested-method-calls.md:102
#: src/2025-nested-method-calls.md:169
msgid "\"World!\""
msgstr ""

#: src/2025-nested-method-calls.md:86 src/2025-nested-method-calls.md:169
msgid "//              ^^^^^^^^^ sneaky attempt to mutate `v`\n"
msgstr ""

#: src/2025-nested-method-calls.md:90
msgid "This last line, if desugared into MIR, looks something like this;"
msgstr ""

#: src/2025-nested-method-calls.md:93 src/2025-nested-method-calls.md:178
msgid "// First evaluate `v[0]` to get a `&mut String`:\n"
msgstr ""

#: src/2025-nested-method-calls.md:97 src/2025-nested-method-calls.md:182
msgid "// Next, evaluate `{ v.push(s); \"World!\" }` block:\n"
msgstr ""

#: src/2025-nested-method-calls.md:103
msgid "// Finally, invoke `push_str`:\n"
msgstr ""

#: src/2025-nested-method-calls.md:108
msgid ""
"The danger here lies in the fact that we evaluate `v[0]` into a reference "
"first, but this reference could well be invalidated by the call to `Vec::"
"push()` that occurs later on (which may resize the vector and hence change "
"the address of its elements). The Rust type system naturally prevents this, "
"however, because the first line (`tmp0 = &mut v`) borrows `v`, and that "
"borrow lasts until the final call to `push_str()`."
msgstr ""

#: src/2025-nested-method-calls.md:116
msgid ""
"In fact, even when the receiver is just a local variable (e.g., `vec."
"push(vec.len())`) we have to be wary. We wouldn't want it to be possible to "
"give ownership of the receiver away in one of the arguments: `vec."
"push({ send_to_another_thread(vec); ... })`. That should still be an error "
"of course."
msgstr ""

#: src/2025-nested-method-calls.md:122
msgid ""
"(Naturally, these complex arguments that are blocks look really artificial, "
"but keep in mind that most of the time when this occurs in practice, the "
"argument is a method or fn call, and that could in principle have arbitrary "
"side-effects.)"
msgstr ""

#: src/2025-nested-method-calls.md:127
msgid "Introducing reservations"
msgstr ""

#: src/2025-nested-method-calls.md:129
msgid ""
"This RFC proposes extending MIR with the concept of a **two-phase borrow**. "
"These borrows are a variant of mutable borrows where the value starts out as "
"**reserved** and only becomes mutably borrowed when the resulting reference "
"is first used (which is called **activating** the borrow). During the "
"reservation phase before a mutable borrow is activated, it acts exactly like "
"a shared borrow -- hence the borrowed value can still be read."
msgstr ""

#: src/2025-nested-method-calls.md:137
msgid ""
"As discussed earlier, this RFC itself only introduces these two-phase "
"borrows in a limited way. Specifically, we extend the MIR with a new kind of "
"borrow (written `mut2`, for two-phase), and we generate those new kinds of "
"borrows when lowering method calls."
msgstr ""

#: src/2025-nested-method-calls.md:142
msgid ""
"To understand how two-phased borrows help, let's revisit our two examples. "
"We'll start with the motivating example, `vec.push(vec.len())`. When this "
"expression is desugared, the resulting reference is stored into a temporary, "
"`tmp0`.  Therefore, until `tmp0` is referenced again, `vec` is only "
"considered **reserved**:"
msgstr ""

#: src/2025-nested-method-calls.md:150
msgid ""
"// reservation of `vec` starts here\n"
"/* 1 */"
msgstr ""

#: src/2025-nested-method-calls.md:151
msgid "/* 2 */"
msgstr ""

#: src/2025-nested-method-calls.md:153
msgid "// first use of `tmp0`, upgrade is here\n"
msgstr ""

#: src/2025-nested-method-calls.md:156
msgid ""
"The first use of `tmp0` is on line 3, and hence the mutable borrow begins "
"then, and lasts until the end of the borrow region. Crucially, lines 1 and 2 "
"(which did a shared borrow of `vec`) took place during the reservation "
"period, and hence no error results. This is because a reservation is "
"equivalent to a shared borrow, and multiple shared borrows are allowed."
msgstr ""

#: src/2025-nested-method-calls.md:163
msgid ""
"Next, let's consider the sneaky example, where the argument attempts to "
"mutate the vector that is being used in the receiver:"
msgstr ""

#: src/2025-nested-method-calls.md:173
msgid ""
"In this case, if we examine the resulting MIR, we can see that the borrow of "
"`v` is almost **immediately** used, as part of the `IndexMut` operation:"
msgstr ""

#: src/2025-nested-method-calls.md:180
msgid "// tmp0 used here!\n"
msgstr ""

#: src/2025-nested-method-calls.md:184
msgid "// <-- Error! mutable borrow of `v` is active.\n"
msgstr ""

#: src/2025-nested-method-calls.md:185
msgid "// see above\n"
msgstr ""

#: src/2025-nested-method-calls.md:188
msgid ""
"This implies that the mutable borrow will be active later on, when `v` is "
"borrowed again during the arguments, and hence an error is still reported."
msgstr ""

#: src/2025-nested-method-calls.md:192
msgid ""
"Note that this same treatment will also rule out some \"harmless\" examples, "
"such as this one:"
msgstr ""

#: src/2025-nested-method-calls.md:196 src/2025-nested-method-calls.md:514
msgid "\"{}\""
msgstr ""

#: src/2025-nested-method-calls.md:199
msgid ""
"This might seem analogous to example 1, but in this case the mutable borrow "
"of `v` is \"activated\" by the indexing, and hence `v` is considered mutably "
"borrowed when `v.len()` is called, not reserved, which results in an error."
msgstr ""

#: src/2025-nested-method-calls.md:204
msgid "Detailed design"
msgstr "詳細設計"

#: src/2025-nested-method-calls.md:207
msgid "New MIR form for two-phase borrows"
msgstr ""

#: src/2025-nested-method-calls.md:209
msgid ""
"Currently, the MIR rvalue for borrows has one of three forms (these are "
"internal syntax only, naturally, since MIR doesn't have a defined written "
"representation)"
msgstr ""

#: src/2025-nested-method-calls.md:217
msgid ""
"In either case, the rvalue returns a reference with lvalue `'a` that refers "
"to the address of `lvalue` (an `lvalue` is a path that leads to memory). "
"This can be either a shared, mutable, or unique reference (unique references "
"are an internal concept that appears only in MIR; they are used when "
"desugaring closures, but there is no direct equivalent in Rust surface "
"syntax)."
msgstr ""

#: src/2025-nested-method-calls.md:224
msgid ""
"This RFC proposes adding a third form: `&'a mut2 <lvalue>`. Like `&unique` "
"borrows, this would be used by the compiler when desugaring and would not "
"have a direct user representation for the time being. For most purposes, an "
"`&mut2` borrow would act precisely the same as an `&mut` borrow; the borrow "
"checker however would treat it differently, as described below."
msgstr ""

#: src/2025-nested-method-calls.md:231
msgid "When are two-phase borrows used"
msgstr ""

#: src/2025-nested-method-calls.md:233
msgid ""
"Two-phase borrows would be used in the specific case of desugaring a call to "
"an `&mut self` method. Currently, in the initially generated MIR, calls to "
"such methods _always_ have a \"auto-mut-ref\" inserted (this is because `vec."
"push()`, where `vec: &mut Vec<i32>`, is considered a _borrow_ of `vec`, not "
"a move). This \"auto-mut-ref\" will be changed from an `&mut` to an `&mut2`."
msgstr ""

#: src/2025-nested-method-calls.md:240
msgid "Integrating reserved borrows into the borrow checker"
msgstr ""

#: src/2025-nested-method-calls.md:242
msgid "Existing MIR borrowck algorithm"
msgstr ""

#: src/2025-nested-method-calls.md:244
msgid ""
"The proposed fix for this problem is described in terms of a MIR-based "
"borrowck (which is coming soon). The basic structure of the existing borrow "
"checker, transposed onto MIR, is as follows:"
msgstr ""

#: src/2025-nested-method-calls.md:248
msgid "Every borrow in MIR always has the same form:"
msgstr ""

#: src/2025-nested-method-calls.md:249
msgid "`lv1 = &'r lv2` or `lv1 = &'r mut lv2`, where:"
msgstr ""

#: src/2025-nested-method-calls.md:250
msgid "`lv1` and `lv2` are MIR lvalues (path naming a memory location)"
msgstr ""

#: src/2025-nested-method-calls.md:251
msgid "`'r` is the duration of the borrow"
msgstr ""

#: src/2025-nested-method-calls.md:252
msgid ""
"Let each borrow be named by its position `P`, which has the form `BB/n`, "
"where `BB` is the basic block containing the borrow statement and `n` is the "
"index within that basic block."
msgstr ""

#: src/2025-nested-method-calls.md:255
msgid ""
"The borrow at position `P` is then considered **live** for all points "
"reachable from `P` without passing through the end of the region `'r`."
msgstr ""

#: src/2025-nested-method-calls.md:258
msgid ""
"The full set of borrows live at a given point can be readily computed using "
"a standard data-flow analysis."
msgstr ""

#: src/2025-nested-method-calls.md:260
msgid "For each **write** to an lvalue `lv_w` at point `P`:"
msgstr ""

#: src/2025-nested-method-calls.md:261
msgid ""
"A **write** is either a mutable borrow `&mut lv_w` or an assignment `lv_w "
"= ...`"
msgstr ""

#: src/2025-nested-method-calls.md:262
msgid ""
"It is an error if there is any borrow (mutable or shared) of some path "
"`lv_b` that is **live** at `P` where `lv_b` may overlap `lv_w`"
msgstr ""

#: src/2025-nested-method-calls.md:264
msgid "For each **read** from an lvalue `lv_r` at point `P`:"
msgstr ""

#: src/2025-nested-method-calls.md:265
msgid "A **read** is any use of `lv_r` as an operand."
msgstr ""

#: src/2025-nested-method-calls.md:266
msgid ""
"It is an error if there is any mutable borrow of some path `lv_b` that is "
"**live** at `P` where `lv_b` may overlap `lv_r`"
msgstr ""

#: src/2025-nested-method-calls.md:269
msgid "Proposed change"
msgstr ""

#: src/2025-nested-method-calls.md:271
msgid ""
"When the borrow checker encounters a `mut2` borrow, it will handle it in a "
"slightly different way. Because of the limited places where `mut2` borrows "
"are generated, we know that they will only ever be encountered in a "
"statement that assigns them to a MIR temporary:"
msgstr ""

#: src/2025-nested-method-calls.md:280
msgid ""
"In that case, the path `lv` would initially be considered **reserved**. The "
"temporary `tmp` will only be used once, as an argument to the actual call: "
"at that point, the path `lv` will be considered **mutably borrowed**."
msgstr ""

#: src/2025-nested-method-calls.md:285
msgid ""
"In terms of the safety checks, reservations act just as a shared borrow "
"does. Therefore, a write to `lv` at point `P` is illegal if there is any "
"active borrow **or** in-scope reservation of `lv` at the point `P`. "
"Similarly, a read from `lv` at point `P` is legal if there exists a "
"reservation (but not with a mutable borrow)."
msgstr ""

#: src/2025-nested-method-calls.md:291
msgid ""
"There is one new check required. At the point `Q` where a mutable borrow is "
"activated, we must check that there are no active borrows or reservations in "
"scope (other than the reservation being upgraded). Otherwise, a test such as "
"this might pass:"
msgstr ""

#: src/2025-nested-method-calls.md:305
msgid "When desugared into MIR, this would look something like:"
msgstr ""

#: src/2025-nested-method-calls.md:307
msgid ""
"```\n"
"tmp0 = &'a mut2 v;   // reservation begins\n"
"tmp1 = &'b v;       // shared borrow begins; allowed, because `v` is "
"reserved\n"
"p = foo(tmp1);\n"
"Vec::push(tmp0, 3); // mutable borrow activated\n"
"EndRegion('a);      // mutable borrow ends\n"
"tmp2 = *p;          // shared borrow still valid!\n"
"use(tmp2) \n"
"EndRegion('b);\n"
"```"
msgstr ""

#: src/2025-nested-method-calls.md:318
msgid ""
"Note that, here, we created a borrow of `v[0]` _before_ we called `Vec::"
"push()`, and we continue to use it afterwards. This should not be accepted, "
"but it could be without this additional check at the activation point. In "
"particular, at the time that the shared borrow _starts_, `v` is reserved; "
"the mutable borrow of `v` is activated later, but still within the scope of "
"the shared borrow. (In today's borrow checker, this cannot happen, so we "
"only check at the start of a borrow whether other borrows are in scope.)"
msgstr ""

#: src/2025-nested-method-calls.md:327
msgid "How We Teach This"
msgstr ""

#: src/2025-nested-method-calls.md:330
msgid ""
"For the most part, because this change is so targeted, it seems that "
"discussion of how it works is out of scope for introductory texts such as "
"The Rust Programming Language or Rust By Example. In particular, the idea "
"simply makes code that seems intuitively like it _should_ work (e.g., `vec."
"push(vec.len())`) work."
msgstr ""

#: src/2025-nested-method-calls.md:336
msgid ""
"However, there are a few related topics which likely _might_ make sense to "
"cover at some point in works like this:"
msgstr ""

#: src/2025-nested-method-calls.md:339
msgid ""
"People will likely first encounter surprises when they attempt more "
"complicated method calls that are not covered by this proposal, such as the "
"`v[0].push_str(&format!(\"{}\", v.len()));` example. In that case, a simple "
"desugaring can be used to show why the compiler rejects this code -- in "
"particular, a comparison with the erroneous examples may be helpful. A keen "
"observer may note the contrast with `vec.push(vec.len())`, but such an "
"observer can be referred to the reference. =)"
msgstr ""

#: src/2025-nested-method-calls.md:347
msgid ""
"One interesting point that came up in discussing this example is that many "
"people expect that `vec.push(vec.len())` would be desugared as follows:"
msgstr ""

#: src/2025-nested-method-calls.md:356
msgid ""
"In particular, note that `vec`, in this desugaring, is not assigned to a "
"temporary.  This is in fact not how the language works (as discussed in more "
"detail under the Alternatives section); instead, `vec` is treated like any "
"other argument. It is evaluated to a temporary, and autorefs etc are "
"applied. It may be worth covering this sort of example when doing an in-"
"depth explanation of how method desugaring works."
msgstr ""

#: src/2025-nested-method-calls.md:364
msgid ""
"Coverage of these rules seems most appropriate for the Rust reference, as "
"part of detailed general coverage on how MIR desugaring and the borrow "
"checker work. At the moment, no such coverage exists, but this would be a "
"logical part of it. In that context, explaining it in a similar fashion to "
"how the RFC presents the change seems appropriate."
msgstr ""

#: src/2025-nested-method-calls.md:370
msgid "Drawbacks"
msgstr ""

#: src/2025-nested-method-calls.md:373
msgid ""
"The obvious downside of this proposal is that it is narrowly targeted at the "
"method call form. This means that \"manual desugarings\" of method calls "
"will not necessarily work, particularly if the user faithfully follows what "
"the compiler does. There are a number of reasons to think this will be not "
"be a very big deal in practice:"
msgstr ""

#: src/2025-nested-method-calls.md:379
msgid ""
"There is rarely a desire to do manual desugaring of method calls anyway."
msgstr ""

#: src/2025-nested-method-calls.md:380
msgid ""
"In practice, when a desugaring _is_ needed, people have a lot of latitude to "
"adjust the ordering of statements and so forth, and hence they can achieve "
"the effect that they need (in fact, every time that you are forced to "
"rewrite an instance of the `vec.push(vec.len())` pattern to save `vec.len()` "
"into a temporary, you are doing a partial desugaring of this kind)."
msgstr ""

#: src/2025-nested-method-calls.md:386
msgid ""
"**Truly** faithful desugarings are rare in any case. As discussed in the How "
"We Teach This section, many people overlook the role of autoref and the "
"precise evaluation order. Fewer still will get the precise lifetime of "
"temporaries correctly or other details. This is not a big deal."
msgstr ""

#: src/2025-nested-method-calls.md:392
msgid ""
"Nonetheless, this change slightly widens the gap between the surface "
"language and the underlying \"desugared\" view that MIR takes, and in "
"general that is to be avoided. The Alternatives section discuses some "
"possible future extensions that could be used to remove that gap."
msgstr ""

#: src/2025-nested-method-calls.md:397
msgid "Alternatives"
msgstr "替代方案"

#: src/2025-nested-method-calls.md:400
msgid ""
"As discussed earlier, a number of major alternative designs have been put "
"forward to address nested method calls. This proposal is intended to be "
"forwards compatible with all of them, but to adopt none of them in "
"particular. We cover now each alternative and explain why we did not want to "
"adopt it in this RFC."
msgstr ""

#: src/2025-nested-method-calls.md:406
msgid "Modifying the desugaring to evaluate receiver after arguments"
msgstr ""

#: src/2025-nested-method-calls.md:408
msgid ""
"One option is to modify the desugaring for method calls. Currently, a call "
"like `a.foo(b..z)` is always desugared into something like:"
msgstr ""

#: src/2025-nested-method-calls.md:411 src/2025-nested-method-calls.md:419
msgid "process `a` and apply any autoref etc, resulting in `tmp0`"
msgstr ""

#: src/2025-nested-method-calls.md:412 src/2025-nested-method-calls.md:418
msgid "evaluate `b..z` to a temporary, resulting in `tmp1..tmpN`"
msgstr ""

#: src/2025-nested-method-calls.md:413 src/2025-nested-method-calls.md:420
msgid "invoke `foo(tmp0..tmpN)`"
msgstr ""

#: src/2025-nested-method-calls.md:415
msgid ""
"However, we could say that, under some set of circumstances, we will "
"evaluate `a` later:"
msgstr ""

#: src/2025-nested-method-calls.md:422
msgid ""
"Due to backwards compatibility constraints, there are some limits to how "
"often we could do this reordering. For example, we clearly cannot change the "
"desugaring of complex, side-effecting expressions like `a().foo(b())`. In "
"fact, even simple expressions like `a.foo(b)` might be a breaking change, if "
"the method is declared as `fn(self)` ([play link](https://is.gd/yz3zFq)):"
msgstr ""

#: src/2025-nested-method-calls.md:441
msgid "// returns 3\n"
msgstr ""

#: src/2025-nested-method-calls.md:444
msgid ""
"In effect, the goal would be to come up with some rules that limit the cases "
"under consideration to cases that would currently result in an error. One "
"proposed set of rules might be:"
msgstr ""

#: src/2025-nested-method-calls.md:448
msgid "the invoked method `foo()` is an `&mut self` method"
msgstr ""

#: src/2025-nested-method-calls.md:449
msgid "the receiver is simply a reference to a local variable `a`"
msgstr ""

#: src/2025-nested-method-calls.md:451
msgid ""
"This would cause, for example, `vec.push(vec.len())` to use the new "
"ordering, and hence to be accepted. However, `v[0].push(...)` would not use "
"the new ordering."
msgstr ""

#: src/2025-nested-method-calls.md:455
msgid ""
"This option strikes many as being simpler than the one proposed here. It is "
"perhaps simpler to explain, especially, since it doesn't introduce any new "
"concepts -- the borrow checker works as it ever did, and we already have to "
"do desugaring _somehow_, we're just doing it differently in this case. And "
"in particular we're only affecting cases where autoref -- a non-trivial "
"desugaring -- applies."
msgstr ""

#: src/2025-nested-method-calls.md:462
msgid ""
"However, this option can also result in some surprises of its own. For "
"example, consider a twist on the previous example, where the method `foo` is "
"declared as `&mut self` instead:"
msgstr ""

#: src/2025-nested-method-calls.md:478
msgid "// returns 4\n"
msgstr ""

#: src/2025-nested-method-calls.md:481
msgid ""
"Currently, this code will not compile. Under the proposal, however, it would "
"compile, because (1) the method is `&mut self` and (2) the receiver is a "
"simple variable reference `a`. Interestingly, now that we changed the method "
"to `&mut self`, we can suddenly see the side-effects of evaluating the "
"argument."
msgstr ""

#: src/2025-nested-method-calls.md:487
msgid ""
"On balance, it seems better to this author to have the borrow checker "
"analysis be more complex than the desugaring and execution order."
msgstr ""

#: src/2025-nested-method-calls.md:490
msgid "Permit more things during the \"restricted\" period"
msgstr ""

#: src/2025-nested-method-calls.md:492
msgid ""
"The current notion of a 'restricted' borrow is identical to a shared borrow. "
"However, we could in principle permit _more_ things during the restricted "
"period -- basically we could permit anything that does not invalidate the "
"reference we created. In that case, we might fruitfully enable two-phased "
"borrows for shared references as well. In practice, this means that we could "
"permit writes to the borrowed content (which are forbidden by this "
"proposal). An example of code that would work as a result is the following:"
msgstr ""

#: src/2025-nested-method-calls.md:502
msgid ""
"// pretend you could define an inherent method on integers\n"
"// for a second, just to keep code snippet simple\n"
msgstr ""

#: src/2025-nested-method-calls.md:507
msgid "// returns new value\n"
msgstr ""

#: src/2025-nested-method-calls.md:513
msgid "// what result do you expect from this?\n"
msgstr ""

#: src/2025-nested-method-calls.md:518
msgid ""
"The call to `x.increment(x.increment(1))` would thus desugar to the "
"following MIR:"
msgstr ""

#: src/2025-nested-method-calls.md:520
msgid ""
"```\n"
"tmp0 = &mut2 x;\n"
"tmp1 = &mut2 x;\n"
"tmp2 = 1;\n"
"tmp3 = i32::increment(tmp1, tmp2); // activates tmp1\n"
"i32::increment(tmp0, tmp3); // activates tmp0\n"
"```"
msgstr ""

#: src/2025-nested-method-calls.md:528
msgid ""
"Under the existing proposal, this is illegal, because `x` is considered "
"\"reserved\" when `tmp1` is created, and an `&mut2` borrow is not permitted "
"when the lvalue being borrowed has been reserved. If we made restrictions "
"more permissive, we might accept this code; it would output `2`."
msgstr ""

#: src/2025-nested-method-calls.md:534
msgid "We opted against this variation for several reasons:"
msgstr ""

#: src/2025-nested-method-calls.md:536
msgid ""
"It makes the borrow checker more complex by introducing not only two-phase "
"borrows, but a new set of restrictions that must be worked out in detail. "
"The current RFC leverages the existing category of shared borrows."
msgstr ""

#: src/2025-nested-method-calls.md:540
msgid ""
"The main gain here is the ability to intersperse two mutable calls (as in "
"the example), or to have an outer shared borrow with an inner mutable "
"borrow. In general, this implies that there is some careful ordering of "
"mutation going on here: in particular, the outer method call will observe "
"the state changes made by the inner calls. This feels like a case where it "
"is _helpful_ to have the user pull the two calls apart, so that their "
"relative side-effects are clearly visible."
msgstr ""

#: src/2025-nested-method-calls.md:549
msgid "Of course, it would be possible to loosen the rules in the future."
msgstr ""

#: src/2025-nested-method-calls.md:551
msgid "A broader user of two-phase borrows"
msgstr ""

#: src/2025-nested-method-calls.md:553
msgid ""
"The initial proposal for two-phased borrows (made in \\[this blog "
"post\\]\\[\\]) was more expansive. In particular, it aimed to convert **all "
"mutable borrows** into two-phase borrows at the MIR level.  Given the way "
"that MIR is generated, this meant that users would be able to observe these "
"two phases in some cases. For example, the following code would have type-"
"checked, whereas it would not today or under this RFC:"
msgstr ""

#: src/2025-nested-method-calls.md:564
msgid "// `vec` is reserved\n"
msgstr ""

#: src/2025-nested-method-calls.md:565
msgid "// shared borrow of vec; ok\n"
msgstr ""

#: src/2025-nested-method-calls.md:566
msgid "// mutable borrow of `vec` is activated\n"
msgstr ""

#: src/2025-nested-method-calls.md:569
msgid ""
"The aim here was specifically to support the desugared form of a method call."
msgstr ""

#: src/2025-nested-method-calls.md:572
msgid ""
"The current RFC backs down from this more aggressive posture. Treating all "
"mutable borrows as potentially deferred would make them something that "
"everyday users would encounter, and we didn't feel satisfied with the "
"\"mental model\" that resulted. In particular, because of how MIR is "
"generated, deferred borrows would be almost immediately activated in most "
"scenarios.  They would only work when a borrow was _immediately_ assigned "
"into a variable as part of a `let` declaration. This means, for example, "
"that these two bits of code would have been treated differently:"
msgstr ""

#: src/2025-nested-method-calls.md:583
msgid "// reserved\n"
msgstr ""

#: src/2025-nested-method-calls.md:584
msgid "// versus:\n"
msgstr ""

#: src/2025-nested-method-calls.md:588
msgid "// immediately activated\n"
msgstr ""

#: src/2025-nested-method-calls.md:591
msgid ""
"The reason for this distinction cannot be explained except by examining the "
"desugarings into MIR; if you do so, you will see that the second case "
"introduces an intermediate temporary:"
msgstr ""

#: src/2025-nested-method-calls.md:594
msgid ""
"```\n"
"tmp0 = &mut vec; // reservation starts\n"
"x = tmp0; // borrow is activated\n"
"```"
msgstr ""

#: src/2025-nested-method-calls.md:599
msgid ""
"The root of the problem is that the current RFC is proposing an analysis "
"that is not done on **types** but rather on MIR variables and points in the "
"control-flow graph. This means that (for example) whether a borrow is "
"activated is affected by \"no-ops\" like `let x = y` (which would be "
"considered a use of `y`)."
msgstr ""

#: src/2025-nested-method-calls.md:605
msgid ""
"Therefore, introducing two-phased borrows **outside** of method-call "
"desugaring form doesn't feel like the right approach. (But, if they are "
"limited to method-call desugaring, as this RFC proposes, then they are a "
"simple and effective mechanism without broader impact.)"
msgstr ""

#: src/2025-nested-method-calls.md:610
msgid "Borrowing for the future"
msgstr ""

#: src/2025-nested-method-calls.md:612
msgid ""
"One of the initial proposals for how to think about nested method calls was "
"in terms of \"borrowing for the future\". Currently, whenever you have a "
"borrow, the resulting reference is \"immediately usable\". That is, the "
"lifetime of the reference must include the point of the borrow. Borrowing "
"for the future proposes to loosen that rule, allowing a borrow to result in "
"a reference that can't be _immediately_ used, but can only be used at some "
"future point. In the meantime, the path that was borrowed must be considered "
"to be _reserved_ (in roughly the same sense as this RFC uses it), in order "
"to ensure that the reference is not invalidated."
msgstr ""

#: src/2025-nested-method-calls.md:623
msgid ""
"To see how this might work, consider the naively desugared version of `vec."
"push(vec.len())`, but with explicit labels for the lifetime of every little "
"part (and also for the lifetime of a borrow):"
msgstr ""

#: src/2025-nested-method-calls.md:639
msgid ""
"Here you can see that the borrow `v = &'invoke mut vec` is borrowing `vec` "
"for a lifetime (`'invoke`) that has not yet started -- but which will start "
"in the future. This is basically saying, \"make a reference that we will "
"give to this function, but we won't use in the meantime\"."
msgstr ""

#: src/2025-nested-method-calls.md:644
msgid ""
"Since the reference `v` is not in active use yet, we can use looser "
"restrictions.  We still need to consider the path `vec` to be \"reserved\", "
"so that `v` doesn't get evaluated. The idea is that we are evaluating the "
"path to a pointer right then and there, so we need to be sure that this "
"pointer remains valid. We wouldn't want people to send `vec` to another "
"thread or something."
msgstr ""

#: src/2025-nested-method-calls.md:651
msgid ""
"It seems plausible that these rules could be integrated into the notion of "
"non-lexical lifetimes. At present, the [non-lexical lifetimes proposal]"
"(http://smallcultfollowing.com/babysteps/blog/2017/02/21/non-lexical-"
"lifetimes-using-liveness-and-location/) still includes the rule that borrows "
"must be immediately active (in particular, at each point P where a variable "
"is live, all of the regions in its type must include P). But this could be "
"changed to a rule that says that the regions must either include P or be a "
"future region of the kind shown here. Clearly, the details will need to be "
"worked out, but this would then present a more cohesive model that we could "
"teach to users (in short, when you make a reference, the span of the code "
"where the reference is in active use is restricted, and the code leading up "
"to that span treats the value as having been shared)."
msgstr ""

#: src/2025-nested-method-calls.md:666
msgid "Ref2"
msgstr ""

#: src/2025-nested-method-calls.md:668
msgid ""
"In the internals thread, arielb1 had \\[an interesting proposal\\]\\[ref2\\] "
"that they called \"two-phase lifetimes\". The goal was precisely to take the "
"\"two-phase\" concept but incorporate it into lifetime inference, rather "
"than handling it in borrow checking as I present here. The idea was to "
"define a type `RefMut<'r, 'w, T>` (original `Ref2Φ<'immut, 'mutbl, T>`) "
"which stands in for a kind of \"richer\" `&mut` type (originally, `&T` was "
"unified as well, but that introduces complications because `&T` types are "
"`Copy`, so I'm leaving that out). In particular, `RefMut` has two lifetimes, "
"not just one:"
msgstr ""

#: src/2025-nested-method-calls.md:678
msgid ""
"`'r` is the \"read\" lifetime. It includes every point where the reference "
"may later be used."
msgstr ""

#: src/2025-nested-method-calls.md:680
msgid ""
"`'w` is a subset of `'r` (that is, `'r: 'w`) which indicates the \"write\" "
"lifetime. This includes those points where the reference is actively being "
"written."
msgstr ""

#: src/2025-nested-method-calls.md:683
msgid ""
"We can then conservatively translate a `&'a mut T` type into `RefMut<'a, 'a, "
"T>` -- that is, we can use `'a` for both of the two lifetimes. This is what "
"we would do for any `&mut` type that appears in a struct declaration or fn "
"interface. But for `&mut T` types within a fn body, we can infer the two "
"lifetimes somewhat separately: the `'r` lifetime is computed just as I "
"described in my [NLL post](http://smallcultfollowing.com/babysteps/"
"blog/2017/02/21/non-lexical-lifetimes-using-liveness-and-location/). But the "
"`'w` lifetime only needs to include those points where a write occurs. The "
"borrow check would then guarantee that the `'w` regions of every `&mut` "
"borrow is disjoint from the `'r` regions of every other borrow (and from "
"shared borrows)."
msgstr ""

#: src/2025-nested-method-calls.md:694
msgid ""
"This proposal has a lot of potential applications, but each of them "
"introduces some complications, and would require singificant further "
"thought. Let's cover them in more detail."
msgstr ""

#: src/2025-nested-method-calls.md:698
msgid "Discontinuous borrows"
msgstr ""

#: src/2025-nested-method-calls.md:700
msgid ""
"This proposal accepts more programs than the one I outlined. In particular, "
"it accepts the example with interleaved reads and writes that we saw "
"earlier. Let me give that example again, but annotation the regions more "
"explicitly:"
msgstr ""

#: src/2025-nested-method-calls.md:706
msgid "/* 1 */"
msgstr ""

#: src/2025-nested-method-calls.md:707
msgid ""
"//                    ^^^^^  ^^^^^\n"
"//                     'r     'w\n"
"/* 2 */"
msgstr ""

#: src/2025-nested-method-calls.md:710
msgid ""
"// just in 'r\n"
"/* 3 */"
msgstr ""

#: src/2025-nested-method-calls.md:711
msgid ""
"// must be in 'w\n"
"/* 4 */"
msgstr ""

#: src/2025-nested-method-calls.md:712
msgid ""
"// just in 'r\n"
"/* 5 */"
msgstr ""

#: src/2025-nested-method-calls.md:713
msgid "// must be in 'w\n"
msgstr ""

#: src/2025-nested-method-calls.md:716
msgid ""
"As you can see here, we would infer the write region to be just the two "
"points 3 and 5. This is precisely those portions of the CFG where writes are "
"happening -- and not the gaps in between, where reads are permitted."
msgstr ""

#: src/2025-nested-method-calls.md:721
msgid ""
"As you might have surmised, these sorts of \"discontinuous\" borrows "
"represent a kind of \"step up\" in the complexity of the system. If it were "
"vital to accept examples with interleaved writes like the previous one, then "
"this wouldn't bother me (NLL also represents such a step, for example, but "
"it seems clearly worth it). But given that the example is artificial and not "
"a pattern I have ever seen arise in \"real life\", it seems like we should "
"try to avoid growing the underlying complexity of the system if we can."
msgstr ""

#: src/2025-nested-method-calls.md:730
msgid ""
"To see what I mean about a \"step up\" in complexity, consider how we would "
"integrate this proposal into lifetime inference. The current rules treat all "
"regions equally, but this proposal seems to imply that regions have "
"\"roles\".  For example, the `'r` region captures the \"liveness\" "
"constraints that I described in the original NLL proposal. Meanwhile the "
"`'w` region captures \"activity\"."
msgstr ""

#: src/2025-nested-method-calls.md:737
msgid ""
"(Since we would always convert a `&'a mut T` type into `RefMut<'a, 'a, T>`, "
"all regions in struct parameters would adopt the more conservative "
"\"liveness\" role to start. This is good because we wouldn't want to start "
"allowing \"holes\" in the lifetimes that unsafe code is relying on to "
"prevent access from the outside. It would however be possible for type "
"inference to use a `RefMut<'r, 'w ,T>` type as the value for a type "
"parameter; I don't yet see a way for that to cause any surprises, but "
"perhaps it can if you consider specialization and other non-parametric "
"features.)"
msgstr ""

#: src/2025-nested-method-calls.md:747
msgid ""
"Another example of where this \"complexity step\" surfaces came from [Ralf "
"Jung](https://www.ralfj.de/blog/). As you may know, Ralf is working on a "
"formalization of Rust as part of the [RustBelt project](http://plv.mpi-sws."
"org/rustbelt/) (if you're interested, there is video available of a [great "
"introduction to this work](https://air.mozilla.org/rust-paris-"
"meetup-35-2017-01-19/) which Ralf gave at the Rust Paris meetup). In any "
"case, their model is a kind of generalization of Rust, in that it can accept "
"a lot of programs that standard Rust cannot (it is intended to be used for "
"assigning types to unsafe code as well as safe code). The two-phase borrow "
"proposal that I describe here should be able to fit into that system in a "
"fairly straightforward way. But if we adopted discontinuous regions, that "
"would require making Ralf's system more expressive. This is not necessarily "
"an argument against doing it, but it does show that it makes the Rust system "
"qualitatively more complex to reason about."
msgstr ""

#: src/2025-nested-method-calls.md:766
msgid ""
"If all this talk of \"steps in complexity\" seems abstract, I think that the "
"most immediate way it will surface is when we try to **teach**. Supporting "
"discontinuous borrows just makes it that much harder to craft small examples "
"that show how borrowing works. It will make the system feel more mysterious, "
"since the underlying rules are indeed more complex and thus harder to "
"\"intuit\" on your own. Getting these details right is a significant design "
"challenge outside the scope of this RFC."
msgstr ""

#: src/2025-nested-method-calls.md:775
msgid "Downgrading mutable to shared"
msgstr ""

#: src/2025-nested-method-calls.md:777
msgid ""
"Another goal of the proposal was to (perhaps someday) support the "
"\"downgrade-mut-to-shared\" pattern, in which a function takes in a mutable "
"reference but returns a shared reference:"
msgstr ""

#: src/2025-nested-method-calls.md:788
msgid ""
"In the case of this function, we do indeed require a mutable borrow of "
"`self` to start -- since we update `self.data` -- but once `get_something()` "
"returns, a simple shared borrow would suffice (as is the case for the pseudo-"
"code above). It is conceivable that such a scenario could be handled by "
"giving `&mut self` a \"write\" lifetime that is confined to the call itself, "
"but a bigger \"read\" lifetime."
msgstr ""

#: src/2025-nested-method-calls.md:795
msgid ""
"However, there are other cases (that exist in active use today) of functions "
"that take an `&mut self` and return an `&T` where it would _not_ be safe to "
"treat `self` as shared after the function returns. For example, one could "
"easily wrap the existing `Mutex::get_mut` function to have a signature like "
"this; `get_mut()` works by taking an `&mut` reference and giving access to "
"the interior of the mutex **without locking it**. This is only possible "
"because `get_mut()` can assume that `self` will remain **mutably** borrowed "
"until you are done using that data.  See [this post on the internals thread]"
"(https://internals.rust-lang.org/t/blog-post-nested-method-calls-via-two-"
"phase-borrowing/4886/33?u=nikomatsakis) for more details."
msgstr ""

#: src/2025-nested-method-calls.md:807
msgid ""
"Therefore, it seems that some form of user annotation would be required to "
"enable this pattern. This implies that the two lifetimes of the `Ref2` type "
"would have to be exposed to end-users, or other annotations are needed. Just "
"as with discontinuous borrows, designing such a system is a significant "
"design challenge outside the scope of this RFC."
msgstr ""

#: src/2025-nested-method-calls.md:814
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/2025-nested-method-calls.md:817
msgid "None as yet.. R"
msgstr ""
