msgid ""
msgstr ""
"Project-Id-Version: The Rust RFC Book\n"
"POT-Creation-Date: 2025-12-22T09:04:42Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/0240-unsafe-api-location.md:1
msgid "Start Date: 2014-10-07"
msgstr ""

#: src/0240-unsafe-api-location.md:2
msgid ""
"RFC PR: [rust-lang/rfcs#240](https://github.com/rust-lang/rfcs/pull/240)"
msgstr ""

#: src/0240-unsafe-api-location.md:3
msgid ""
"Rust Issue: [rust-lang/rust#17863](https://github.com/rust-lang/rust/"
"issues/17863)"
msgstr ""

#: src/0240-unsafe-api-location.md:5
msgid "Summary"
msgstr "摘要"

#: src/0240-unsafe-api-location.md:7
msgid ""
"This is a _conventions RFC_ for settling the location of `unsafe` APIs "
"relative to the types they work with, as well as the use of `raw` submodules."
msgstr ""

#: src/0240-unsafe-api-location.md:10
msgid "The brief summary is:"
msgstr ""

#: src/0240-unsafe-api-location.md:12
msgid ""
"Unsafe APIs should be made into methods or static functions in the same "
"cases that safe APIs would be."
msgstr ""

#: src/0240-unsafe-api-location.md:15
msgid ""
"`raw` submodules should be used only to _define_ explicit low-level "
"representations."
msgstr ""

#: src/0240-unsafe-api-location.md:18
msgid "Motivation"
msgstr "動機"

#: src/0240-unsafe-api-location.md:20
msgid ""
"Many data structures provide unsafe APIs either for avoiding checks or "
"working directly with their (otherwise private) representation. For example, "
"`string` provides:"
msgstr ""

#: src/0240-unsafe-api-location.md:24
msgid ""
"An `as_mut_vec` method on `String` that provides a `Vec<u8>` view of the "
"string.  This method makes it easy to work with the byte-based "
"representation of the string, but thereby also allows violation of the utf8 "
"guarantee."
msgstr ""

#: src/0240-unsafe-api-location.md:28
msgid ""
"A `raw` submodule with a number of free functions, like `from_parts`, that "
"constructs a `String` instances from a raw-pointer-based representation, a "
"`from_utf8` variant that does not actually check for utf8 validity, and so "
"on. The unifying theme is that all of these functions avoid checking some "
"key invariant."
msgstr ""

#: src/0240-unsafe-api-location.md:34
msgid ""
"The problem is that currently, there is no clear/consistent guideline about "
"which of these APIs should live as methods/static functions associated with "
"a type, and which should live in a `raw` submodule. Both forms appear "
"throughout the standard library."
msgstr ""

#: src/0240-unsafe-api-location.md:39
msgid "Detailed design"
msgstr "詳細設計"

#: src/0240-unsafe-api-location.md:41
msgid "The proposed convention is:"
msgstr ""

#: src/0240-unsafe-api-location.md:43
msgid ""
"When an unsafe function/method is clearly \"about\" a certain type (as a way "
"of constructing, destructuring, or modifying values of that type), it should "
"be a method or static function on that type. This is the same as the "
"convention for placement of safe functions/methods. So functions like "
"`string::raw::from_parts` would become static functions on `String`."
msgstr ""

#: src/0240-unsafe-api-location.md:49
msgid ""
"`raw` submodules should only be used to _define_ low-level types/"
"representations (and methods/functions on them). Methods for converting to/"
"from such low-level types should be available directly on the high-level "
"types. Examples: `core::raw`, `sync::raw`."
msgstr ""

#: src/0240-unsafe-api-location.md:54
msgid "The benefits are:"
msgstr ""

#: src/0240-unsafe-api-location.md:56
msgid ""
"_Ergonomics_. You can gain easy access to unsafe APIs merely by having a "
"value of the type (or, for static functions, importing the type)."
msgstr ""

#: src/0240-unsafe-api-location.md:59
msgid ""
"_Consistency and simplicity_. The rules for placement of unsafe APIs are the "
"same as those for safe APIs."
msgstr ""

#: src/0240-unsafe-api-location.md:62
msgid ""
"The perspective here is that marking APIs `unsafe` is enough to deter their "
"use in ordinary situations; they don't need to be further distinguished by "
"placement into a separate module."
msgstr ""

#: src/0240-unsafe-api-location.md:66
msgid ""
"There are also some naming conventions to go along with unsafe static "
"functions and methods:"
msgstr ""

#: src/0240-unsafe-api-location.md:69
msgid ""
"When an unsafe function/method is an unchecked variant of an otherwise safe "
"API, it should be marked using an `_unchecked` suffix."
msgstr ""

#: src/0240-unsafe-api-location.md:72
msgid ""
"For example, the `String` module should provide both `from_utf8` and "
"`from_utf8_unchecked` constructors, where the latter does not actually check "
"the utf8 encoding.  The `string::raw::slice_bytes` and `string::raw::"
"slice_unchecked` functions should be merged into a single `slice_unchecked` "
"method on strings that checks neither bounds nor utf8 boundaries."
msgstr ""

#: src/0240-unsafe-api-location.md:79
msgid ""
"When an unsafe function/method produces or consumes a low-level "
"representation of a data structure, the API should use `raw` in its name. "
"Specifically, `from_raw_parts` is the typical name used for constructing a "
"value from e.g. a pointer-based representation."
msgstr ""

#: src/0240-unsafe-api-location.md:84
msgid ""
"Otherwise, _consider_ using a name that suggests _why_ the API is unsafe. In "
"some cases, like `String::as_mut_vec`, other stronger conventions apply, and "
"the `unsafe` qualifier on the signature (together with API documentation) is "
"enough."
msgstr ""

#: src/0240-unsafe-api-location.md:89
msgid ""
"The unsafe methods and static functions for a given type should be placed in "
"their own `impl` block, at the end of the module defining the type; this "
"will ensure that they are grouped together in rustdoc. (Thanks @lilyball for "
"the suggestion.)"
msgstr ""

#: src/0240-unsafe-api-location.md:94
msgid "Drawbacks"
msgstr ""

#: src/0240-unsafe-api-location.md:96
msgid ""
"One potential drawback of these conventions is that the documentation for a "
"module will be cluttered with rarely-used `unsafe` APIs, whereas the `raw` "
"submodule approach neatly groups these APIs.  But rustdoc could easily be "
"changed to either hide or separate out `unsafe` APIs by default, and in the "
"meantime the `impl` block grouping should help."
msgstr ""

#: src/0240-unsafe-api-location.md:102
msgid ""
"More specifically, the convention of placing unsafe constructors in `raw` "
"makes them very easy to find. But the usual `from_` convention, together "
"with the naming conventions suggested above, should make it fairly easy to "
"discover such constructors even when they're supplied directly as static "
"functions."
msgstr ""

#: src/0240-unsafe-api-location.md:107
msgid ""
"More generally, these conventions give `unsafe` APIs more equal status with "
"safe APIs. Whether this is a _drawback_ depends on your philosophy about the "
"status of unsafe programming. But on a technical level, the key point is "
"that the APIs are marked `unsafe`, so users still have to opt-in to using "
"them. _Ed note: from my perspective, low-level/unsafe programming is "
"important to support, and there is no reason to penalize its ergonomics "
"given that it's opt-in anyway._"
msgstr ""

#: src/0240-unsafe-api-location.md:114
msgid "Alternatives"
msgstr "替代方案"

#: src/0240-unsafe-api-location.md:116
msgid "There are a few alternatives:"
msgstr ""

#: src/0240-unsafe-api-location.md:118
msgid ""
"Rather than providing unsafe APIs directly as methods/static functions, they "
"could be grouped into a single extension trait. For example, the `String` "
"type could be accompanied by a `StringRaw` extension trait providing APIs "
"for working with raw string representations. This would allow a clear "
"grouping of unsafe APIs, while still providing them as methods/static "
"functions and allowing them to easily be imported with e.g. `use std::"
"string::StringRaw`. On the other hand, it still further penalizes the raw "
"APIs (beyond marking them `unsafe`), and given that rustdoc could easily "
"provide API grouping, it's unclear exactly what the benefit is."
msgstr ""

#: src/0240-unsafe-api-location.md:128
msgid ""
"([Suggested by @lilyball](https://github.com/rust-lang/rfcs/"
"pull/240#issuecomment-55635468)):"
msgstr ""

#: src/0240-unsafe-api-location.md:130
msgid ""
"Use `raw` for functions that construct a value of the type without checking "
"for one or more invariants."
msgstr ""

#: src/0240-unsafe-api-location.md:133
msgid ""
"The advantage is that it's easy to find such invariant-ignoring functions. "
"The disadvantage is that their ergonomics is worsened, since they much be "
"separately imported or referenced through a lengthy path:"
msgstr ""

#: src/0240-unsafe-api-location.md:138
msgid "// Compare the ergonomics:\n"
msgstr ""

#: src/0240-unsafe-api-location.md:143
msgid ""
"Another suggestion by @lilyball is to keep the basic structure of `raw` "
"submodules, but use associated types to improve the ergonomics. Details (and "
"discussions of pros/cons) are in [this comment](https://github.com/rust-lang/"
"rfcs/pull/240/files#r17572875)."
msgstr ""

#: src/0240-unsafe-api-location.md:148
msgid ""
"Use `raw` submodules to group together _all_ manipulation of low-level "
"representations. No module in `std` currently does this; existing modules "
"provide some free functions in `raw`, and some unsafe methods, without a "
"clear driving principle. The ergonomics of moving _everything_ into free "
"functions in a `raw` submodule are quite poor."
msgstr ""

#: src/0240-unsafe-api-location.md:154
msgid "Unresolved questions"
msgstr "未解決的問題"

#: src/0240-unsafe-api-location.md:156
msgid ""
"The `core::raw` module provides structs with public representations "
"equivalent to several built-in and library types (boxes, closures, slices, "
"etc.). It's not clear whether the name of this module, or the location of "
"its contents, should change as a result of this RFC. The module is a special "
"case, because not all of the types it deals with even have corresponding "
"modules/type declarations -- so it probably suffices to leave decisions "
"about it to the API stabilization process."
msgstr ""
